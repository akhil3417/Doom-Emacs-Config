#+title: Review
#+author: Akhil Pratap Singh
#+date: 2022-09-22

#+STARTUP: fold
#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :tangle packages.el :comments link
#+property: header-args :tangle no :results silent :eval no-export
#+caption: Banner
#+latex_class: chameleon
#+html_content_class: chameleon
#+html_head: <link rel='stylesheet' type='text/css' href='static/index.css' />
#+html_head: <link rel='shortcut icon' type='image/png' href='https://raw.githubusercontent.com/eccentric-j/doom-icon/master/cute-doom/src/doom.iconset/icon_32x32.png'>
**** (sub|super)script characters
Annoying having to gate these, so let's fix that

#+begin_src emacs-lisp
(setq org-export-with-sub-superscripts '{})
#+end_src

* DONE Eaf  Core
CLOSED: [2022-04-15 Fri 11:42]
** eaf confv2
#+begin_src emacs-lisp :tangle no

;; Don't forget to run M-x eaf-install-dependencies
(use-package! eaf
  ;; :unless gv/is-termux
  :bind (("C-c W" . gv/bm))
  ;; :demand t
  ;; Set to "/usr/share/emacs/site-lisp/eaf" if installed from AUR
  :load-path "~/.emacs.d/site-lisp/emacs-application-framework/"
  :init
  (use-package! epc      :defer t :ensure t)
  (use-package! ctable   :defer t :ensure t)
  (use-package! deferred :defer t :ensure t)
  (use-package! s        :defer t :ensure t)
  ;; (setq browse-url-browser-function 'eaf-open-browser)
  :config
  (defun slurp (f)
    (with-temp-buffer
      (insert-file-contents f)
      (buffer-substring-no-properties
       (point-min)
       (point-max))))
  (defun gv/bm ()
    (interactive)
    (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/app/browser/")
    (require 'eaf-browser)

    (let ((selected (completing-read
                     "Select URL: " (split-string
                                     (slurp "~/.config/bookmarks") "\n" t))))
      (let ((url (car (split-string
                       selected
                       " " t))))
        (if (string-match-p "\\http.*\\'" url)
            ;; Open selected url
            (eaf-open-browser url)
          ;; Search entered text
          (eaf-search-it selected)))))
  (setq eaf-browser-continue-where-left-off t)
  (setq eaf-browser-dnefault-search-engine "duckduckgo")
  (setq eaf-browser-enable-adblocker "true")
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (dolist (keys '("i" "h" "j" "k" "l"
  ;;              "d" "f" "x" ","
  ;;              "-" "." "0" "1"
  ;;              "2" "=" "B" "F"
  ;;              "G" "H" "I" "J"
  ;;              "K" "L" "P" "T"
  ;;              "Y" "c" "d" "e"
  ;;              "f" "g" "m" "n"
  ;;              "o" "p" "r" "t"
  ;;              "u" "v" "x" "y"
  ;;              (eaf-bind-key nil key eaf-browser-keybinding))))
  )
#+end_src

#+RESULTS:
: gv/bm

** eaf config
#+begin_src emacs-lisp :tangle no

(add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
(use-package! eaf
  :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
  :custom
  (setq eaf-browser-continue-where-left-off t)
  (setq eaf-browser-enable-adblocker t)
  (setq browse-url-browser-function 'eaf-open-browser)
(setq eaf-browser-translate-language "es")
(setq eaf-browser-continue-where-left-off t)
(setq eaf-browser-download-path "~/Downloads/eaf/")
(setq eaf-mindmap-dark-mode "follow") ; default option
(setq eaf-browser-dark-mode "force")
(setq eaf-terminal-dark-mode nil)
(setq eaf-pdf-dark-mode "ignore") ; see below
(setq eaf-browser-default-search-engine "duckduckgo")
(setq eaf-music-play-order "random")
(setq eaf-browser-blank-page-url "https://duckduckgo.com")
(setq eaf-browser-default-search-engine "duckduckgo")
  :config
  (defalias 'browse-web #'eaf-open-browser))
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
;; (setq eaf-browser-aria2-proxy-host "127.0.0.1")
;; (setq eaf-browser-aria2-proxy-port "9888")
;; sudo systemctl start privoxy
;; (setq eaf-browser-remember-history nil)
;; (setq eaf-browser-default-zoom 1.25)
;; (setq eaf-browser-enable-plugin nil)
;; (setq eaf-browser-enable-javascript nil)
;; (setq eaf-camera-save-path "new/path/")
(defcustom eaf-music-default-file nil "~/Music/"
  :type 'file)
(defun eaf-org-open-file (file &optional link)
  "An wrapper function on `eaf-open'."
  (eaf-open file))

;; use `emacs-application-framework' to open PDF file: link
(add-to-list 'org-file-apps '("\\.pdf\\'" . eaf-org-open-file))


#+end_src

#+RESULTS:
: ((\.pdf\' . eaf-org-open-file) (remote . emacs) (auto-mode . emacs) (directory . emacs) (\.mm\' . default) (\.x?html?\' . default) (\.pdf\' . default))
** load eaf apps
#+begin_src emacs-lisp :tangle no

 (require 'eaf-pdf-viewer)
 (require 'eaf-browser)
 (require 'eaf-rss-reader)
 (require 'eaf-markdown-previewer)
 (require 'eaf-airshare)
 (require 'eaf-file-sender)
 (require 'eaf-jupyter)
 (require 'eaf-browser)
 (require 'eaf-terminal)
 (require 'eaf-mindmap)
 (require 'eaf-system-monitor)
 (require 'eaf-camera)
 (require 'eaf-org-previewer)
 (require 'eaf-org)
 (require 'eaf-image-viewer)
 ;; (require 'eaf-mermaid)
 ;; (require 'eaf-demo)
 ;; (require 'eaf-video-player)
 ;; (require 'eaf-vue-demo)
 ;; (require 'eaf-music-player)
 ;; (require 'eaf-file-browser)
 ;; (require 'eaf-netease-cloud-music)
 ;; (require 'eaf-file-manager)
 ;; (require 'eaf-evil)

#+end_src

#+RESULTS:
: eaf-image-viewer

** eaf evil

 I usually don't use it as it causes issues with doom keybinds

#+begin_src emacs-lisp :tangle no
(require 'eaf-evil)

(define-key key-translation-map (kbd "SPC")
    (lambda (prompt)
      (if (derived-mode-p 'eaf-mode)
          (pcase eaf--buffer-app-name
            ("browser" (if  (string= (eaf-call-sync "call_function" eaf--buffer-id "is_focus") "True")
                           (kbd "SPC")
                         (kbd eaf-evil-leader-key)))
            ("pdf-viewer" (kbd eaf-evil-leader-key))
            ("image-viewer" (kbd eaf-evil-leader-key))
            (_  (kbd "SPC")))
        (kbd "SPC"))))

#+end_src

#+RESULTS:
| lambda | (prompt) | (if (derived-mode-p 'eaf-mode) (pcase eaf--buffer-app-name (browser (if (string= (eaf-call-sync call_function eaf--buffer-id is_focus) True) (kbd SPC) (kbd eaf-evil-leader-key))) (pdf-viewer (kbd eaf-evil-leader-key)) (image-viewer (kbd eaf-evil-leader-key)) (_ (kbd SPC))) (kbd SPC)) |

** Bufler

#+begin_src emacs-lisp
(use-package! bufler
  ;; :disabled
  :ensure nil
  ;; :straight t
  :bind (("C-c d" . bufler-switch-buffer)
         ("C-c w" . bufler-workspace-frame-set))
  :config
  (evil-collection-define-key 'normal 'bufler-list-mode-map
    (kbd "RET")   'bufler-list-buffer-switch
    (kbd "M-RET") 'bufler-list-buffer-peek
    (kbd "C-d") 'bufler-list-buffer-kill)

  (setf bufler-groups
        (bufler-defgroups
          ;; Subgroup collecting all named workspaces.
          (group (auto-workspace))
          ;; Subgroup collecting buffers in a projectile project.
          (group (auto-projectile))
          ;; Grouping browser windows
          (group
           (group-or "Browsers"
                     (name-match "Vimb" (rx bos "vimb"))
                     (name-match "qutebrowser" (rx bos "Qutebrowser"))
                     (name-match "F# " (rx bos "Qutebrowser"))
                     (name-match "firefoxdeveloperedition" (rx bos "firefoxdeveloperedition"))
                     (name-match "Chromium" (rx bos "Chromium"))))
          (group
           (group-or "Chat"
                     (mode-match "Telega" (rx bos "telega-"))))
          (group
           ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
           (group-or "Help/Info"
                     (mode-match "*Help*" (rx bos (or "help-" "helpful-")))
                     ;; (mode-match "*Helpful*" (rx bos "helpful-"))
                     (mode-match "*Info*" (rx bos "info-"))))
          (group
           ;; Subgroup collecting all special buffers (i.e. ones that are not
           ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
           ;; through to other groups, so they end up grouped with their project buffers).
           (group-and "*Special*"
                      (name-match "**Special**"
                                  (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace" "Pinentry") "*"))
                      (lambda (buffer)
                        (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                             buffer)
                                    (funcall (mode-match "Dired" (rx bos "dired"))
                                             buffer)
                                    (funcall (auto-file) buffer))
                          "*Special*"))))
          ;; Group remaining buffers by major mode.
          (auto-mode))))
#+end_src

#+RESULTS:
: bufler-workspace-frame-set

** Window configuration

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

*** Window rules and basic tweaks (window.el)
**** desc
The =display-buffer-alist= is intended as a rule-set for controlling the
placement of windows.  This is mostly needed for ancillary buffers, such
as shells, compilation output, and the like.  The objective is to create
a more intuitive workflow where targeted buffer groups or types are
always shown at a given location, on the premise that predictability
improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
GNU Emacs Lisp Reference Manual (evaluate =(elisp) Displaying Buffers=).
Information can also be found at all times via =C-h f display-buffer= and,
for my particular settings, with =C-h f display-buffer-in-side-window=.

With regard to the key bindings you will find here, most combinations
are complementary to the standard ones, such as =C-x 1= being aliased as
=s-1=, =C-x o= turning into =s-o= and the like.  They *do not replace* the
defaults: they just provide more convenient access to their
corresponding functions.  Some involve the Super key, in accordance with
the norms described in the relevant [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][note on the matter]].  Concerning the
=balance-windows-area= I find that it is less intrusive than the original
=balance-windows= normally bound to the same =C-x +=.  Lastly, the
=resize-window-repeat-map= is for repeatable key chords that work with the
=repeat-mode= for Emacs28 (read my description of what it is and how to
set it up: [[#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0][Repeatable key chords (repeat-mode)]]).

Make sure to also review the other window-related keys in those
sections:

+ [[#h:6b4f7792-6ccd-45d5-b262-01d200639072][Window history (winner-mode)]].
+ [[#h:230d96c8-a955-4b82-844d-9de9a1b7c531][Directional window motions (windmove)]].

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch my [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07).

**** code
#+begin_src emacs-lisp :tangle no
;;; Window rules and basic tweaks (window.el)
(use-package! window
  :config
  (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\**prot-elfeed-bongo-queue.*"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -2))
          ("\\*\\(prot-elfeed-mpv-output\\|world-clock\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -1))
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*"    ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*keycast\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (window-width . 0.25)
           (side . right)
           (slot . -1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; bottom side window
          ("\\*Org Select\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; ("\\*\\(Embark\\)?.*Completions.*"
          ;;  (display-buffer-reuse-mode-window display-buffer-at-bottom)
          ;;  (window-parameters . ((no-other-window . t))))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom))
          ;; below current window
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected))
          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.2))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x <down>") #'next-buffer)
    (define-key map (kbd "C-x <up>") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'
  (let ((map resize-window-repeat-map))
    (define-key map ">" #'enlarge-window-horizontally)
    (define-key map "<" #'shrink-window-horizontally)))
#+end_src

#+RESULTS:
: t

*** Tabs for window layouts (tab-bar.el and prot-tab.el)
**** desc
Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register).

Starting with Emacs 28, the =tab-bar= can re-use indicators from the mode
line.  With a bit of tweaking (and dirty hacks---but, hey, they work!)
we can hide all mode lines and replace them with a single status bar
that spans the length of the frame (just like the Tmux status line, if
you have ever used that).  I was aware of this possibility for a long
time, as I keep track of developments in emacs.git, but I never actually
tinkered with the available options...  Until Philip Kaludercic
published the article [[http://ruzkuku.com/texts/emacs-global.html][Emacs 28 has a global mode line]] (2021-07-29) which
inspired me to finally start experimenting.

As of this writing (2021-07-30), upstream Emacs only covers the part of
the mode line that shows the current time and the like (technically the
=global-mode-string=).  So my =prot-tab.el= library, which is reproduced
after the following package configurations, implements some more
indicators that I want to use.

The minor mode which takes care of this new "status line" concept is
=prot-tab-status-line=.  Check the code to notice the dirty hacks I
alluded to.

In the past, I was using a command which would merely toggle the display
of the =tab-bar= (=prot-tab-bar-toggle=), but now that I can finally avoid
the duplication of information and keep things cleaner, I think I am not
going back to the paradigm where each window has its own mode line.

To learn about the key bindings that the =tab-bar= uses, type its prefix
key =C-x t= and follow it up with =C-h= (read [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

Finally, now that =tab-bar-history-mode= is a de facto replacement for
=winner-mode=.  Like Winner, it stores a history of window layouts.
Unlike Winner, it keeps histories that are specific to each tab.  The
problem with Winner is that when we switch between tabs, it continues to
retain a linear history, so when we try to undo in one tab, we
effectively get the state of the previous one.  As such, my two commands
=prot-tab-winner-undo= and =prot-tab-winner-redo= provide thin wrappers
around the two modes.  If tabs are present, then we use the history for
them, else we fall back to Winner.

Here are my settings, followed by the entirety of =prot-tab.el=.

**** code
#+begin_src emacs-lisp :tangle no
;;; Tabs for window layouts (tab-bar.el and prot-tab.el)
(use-package! tab-bar
  :config
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice nil)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
 (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-current)

  (tab-bar-mode -1)                     ; see `prot-tab-status-line'

  ;; Same concept as `winner-mode'.  See the `prot-tab-winner-undo' and
  ;; its counterpart.
  (tab-bar-history-mode 1))

(load "prot-tab")
(use-package! prot-tab
  :config
  (setq prot-tab-tab-select-num-threshold 3)
  (setq tab-bar-format                    ; Emacs 28
        '(prot-tab-format-space-single
          prot-tab-format-mule-info
          prot-tab-format-modified
          tab-bar-format-tabs-groups
          prot-tab-format-space-double
          prot-tab-format-position
          prot-tab-format-space-double
          prot-tab-format-vc
          prot-tab-format-space-double
          prot-tab-format-modes         ; FIXME 2021-07-30: Make it work with `minions'.
          tab-bar-format-align-right
          prot-tab-format-misc-info
          prot-tab-format-space-double
          tab-bar-format-global
          prot-tab-format-space-single))

  (add-hook 'after-init-hook #'prot-tab-status-line)

  (let ((map global-map))
    (define-key map (kbd "C-x <right>") #'prot-tab-winner-redo)
    (define-key map (kbd "C-x <left>") #'prot-tab-winner-undo)
    (define-key map (kbd "<f8>") #'prot-tab-status-line) ; unopinionated alternative: `prot-tab-bar-toggle'
    (define-key map (kbd "C-x t t") #'prot-tab-select-tab-dwim)))

;; ;; This is only included as a reference.
;; (prot-emacs-builtin-package 'tab-line
;;   (global-tab-line-mode -1))
#+end_src

#+RESULTS:
: t

The =prot-tab.el= code, which is in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]:

#+include: prot-lisp/prot-tab.el src emacs-lisp :tangle no

** DONE Shackle
CLOSED: [2022-04-05 Tue 19:20]
Shackle is an easy way to customise the display rules for windows rather than messing up with display-buffer-alist.

#+begin_src emacs-lisp :tangle no
(use-package! shackle
  :custom
  ((shackle-rules
    (let ((repls "\\*\\(cider-repl\\|sly-mrepl\\|ielm\\)")
          (godot "\\*godot - .*\\*")
          (vcs   "\\*\\(Flymake\\|Package-Lint\\|vc-\\(git\\|got\\) :\\).*")
          (elfeed "\\*elfeed-entry\\*")
          (vmd    "\\*vmd console .*"))
      `((compilation-mode :noselect t
                          :align above
                          :size 0.2)
        ("*Async Shell Command*" :ignore t)
        (,repls :regexp t
                :align below
                :size 0.3)
        (,godot :regexp t
                :align t
                :size 0.3)
        (occur-mode :select t
                    :align right
                    :size 0.3)
        (diff-mode :select t)
        (help-mode :select t
                   :align left
                   :size 0.3)
        (,vcs :regexp t
              :align above
              :size 0.15
              :select t)
        (,elfeed :regexp t
                 :align t
                 :select t
                 :size 0.75)
        (,vmd :regexp t
              :align below
              :select t
              :size 0.3))))
   (shackle-default-rule nil ; '(:inhibit-window-quit t)
                         ))
  :config (shackle-mode))
#+end_src

#+RESULTS:
: t

** Outline mode, outline minor mode, and extras (prot-outline.el)
*** desc
The =outline.el= library defines a major mode (=outline-mode=) that is
similar to =org-mode= in that it consists of headings which can be
expanded or contracted individually or as a group (actually Outline
predates Org).  The major mode is meant to work with plain text files,
or be leveraged by other packages that need to have some structure and
the accompanying benefits of outline folding.  In practice, however, I
never found a dedicated use for it that would justify it over the more
featureful Org.

Where =outline.el= truly shines, in my experience, is in the minor mode it
defines (=outline-minor-mode=), which provides the familiar structured,
heading-folding facilities in other major modes, like =emacs-lisp-mode= or
any arbitrary mode, like =diff-mode= and the =diary=.

Also read:

+ [[#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9][Calendar and Diary (and prot-diary.el)]].
+ [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]].

With some careful tweaks you can continue to work on your code while
also benefitting from a more effective means of organising and reviewing
what you have.

In practice, to make an outline for Elisp buffers, you need to start a
comment line /without leading spaces/ and make it at least three comment
delimiters long (=;;;=) followed by a space and then the text of the
heading, such as =;;; Code:=.  That is considered a heading level 1.
Every extra delimiter will increase heading levels accordingly.  The
buffer-local variable =outline-regexp= determines what constitutes a
heading for this purpose.

Now on to my custom library, =prot-outline.el= which builds on those
concepts:

+ Provide several new commands and minor extras for working with
  outlines.

+ Define a =prot-outline-minor-mode-safe= command that checks whether the
  current buffer's major mode is not a member of a blocklist.  The idea
  is to not run =outline-minor-mode= with major modes that already provide
  its functionality: =org-mode=, =outline-mode=, =markdown-mode=.

Watch my [[https://protesilaos.com/codelog/2020-07-20-emacs-outline-imenu/][video demo of outline-minor-mode and imenu]] (2020-07-20), though
note that it was recorded long before I wrote =prot-outline.el=.  In
particular, older versions of my code would establish bindings for
=imenu.el=.  This was done via bespoke entry and exit hooks and was
intended to complement the standard Imenu headings with those of the
Outline.  This is no longer needed because =consult-outline= does exactly
that ([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).

A quick reminder of why this matters: you can navigate the outline using
minibuffer completion, which is my favourite way to browse a file.  You
can, in the same spirit, use Embark to produce a buffer with the
completion candidates, i.e. the headings, or a subset you have narrowed
to, and navigate therefrom.  It really is an efficient workflow:
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

*** code
#+begin_src emacs-lisp :tangle no
;;; Outline mode, outline minor mode, and extras (prot-outline.el)
(use-package! outline
  :config
  (setq outline-minor-mode-highlight 'override) ; emacs28
  (setq outline-minor-mode-cycle t)             ; emacs28
  (let ((map outline-minor-mode-map))
    ;; ;; NOTE 2021-07-25: Those two are already defined (emacs28).
    ;; (define-key map (kbd "TAB") #'outline-cycle)
    ;; (define-key map (kbd "<backtab>") #'outline-cycle-buffer) ; S-TAB
    (define-key map (kbd "C-c C-n") #'outline-next-visible-heading) ;;def
    (define-key map (kbd "C-c C-p") #'outline-previous-visible-heading) ;;def
    (define-key map (kbd "C-c C-f") #'outline-forward-same-level) ;;]h
    (define-key map (kbd "C-c C-b") #'outline-backward-same-level) ;;[h
    (define-key map (kbd "C-c C-a") #'outline-show-all)
    (define-key map (kbd "C-c C-o") #'outline-hide-other)
    (define-key map (kbd "C-c C-u") #'outline-up-heading))) ;;def
(load "prot-outline")
(use-package! prot-outline
  :config
  (let ((map outline-minor-mode-map))
    (define-key map (kbd "C-c C-v") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "M-<down>") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "C-c M-v") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "M-<up>") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "C-x n s") #'prot-outline-narrow-to-subtree))
  (define-key global-map (kbd "<f10>") #'prot-outline-minor-mode-safe))
#+end_src

#+RESULTS:
: t
* from sasha chua
#+begin_src emacs-lisp

(defun my-goto-random-char ()
  (interactive)
  (goto-char (random (point-max))))
#+end_src
#+CAPTION: yeah well
[[file:/home/shiva/Screenshots/maim-region-20220928-104859.png]]

#+RESULTS:
: my-goto-random-char
#+begin_src emacs-lisp
(defvar my-screenshot-directory "~/Screenshots")
(defun my-org-insert-screenshot (file &optional note)
  (interactive (list
                (if current-prefix-arg
                    (expand-file-name
                     (consult--read
                      (reverse (directory-files my-screenshot-directory nil "\\.png$"))
                      :sort nil
                      :require-match t
                      :category 'file
                      :state (lambda (candidate state)
                               (when candidate
                                 (with-current-buffer (find-file-noselect (expand-file-name candidate my-screenshot-directory))
                                   (display-buffer (current-buffer))))))
                     my-screenshot-directory)
                  (my-latest-file my-screenshot-directory))))
  (save-window-excursion
    (with-current-buffer (find-file-noselect file) (display-buffer (current-buffer)))
    (insert "#+CAPTION: " (or note (read-string "Caption: "))))
  (save-excursion (insert "\n" (org-link-make-string (concat "file:" file)) "\n")))
(defun my-copy-last-screenshot-to-file (new-filename)
  (interactive (list (read-file-name (format "Copy %s to: " (file-name-nondirectory (my-latest-file my-screenshot-directory))))))
  (copy-file (my-latest-file my-screenshot-directory) new-filename))

(defun my-copy-last-screenshot-and-insert-into-org (new-filename caption)
  (interactive (list (read-file-name (format "Copy %s to: " (file-name-nondirectory (my-latest-file my-screenshot-directory))))
                     (read-string "Caption: ")))
  (copy-file (my-latest-file my-screenshot-directory) new-filename t)
  (insert "#+CAPTION: " caption "\n"
          (org-link-make-string (concat "file:" (file-relative-name new-filename))) "\n"))
(defun my-latest-file (path &optional filter)
  "Return the newest file in PATH. Optionally filter by FILTER."
  (car (sort (seq-remove #'file-directory-p (directory-files path 'full filter t)) #'file-newer-than-file-p)))
(defun my-ledger-change-account (account)
  (interactive (list (ledger-read-account-with-prompt (concat (ledger-xact-payee) ": "))))
  (beginning-of-line)
  (re-search-forward ledger-account-name-or-directive-regex)
  (replace-match (concat "  " account "  ") t t))
#+end_src


#+begin_src emacs-lisp

;; Based on https://www.reddit.com/r/emacs/comments/l4v1ux/one_of_the_most_useful_small_lisp_functions_in_my-


(defun my-toggle-or-create (buffer-name buffer-create-fn &optional switch-cont)
  (interactive)
  (let ((target-buf (get-buffer buffer-name)))
    (prin1 target-buf)
    (cond
     ((equal (current-buffer) target-buf) (switch-to-buffer nil))
     (target-buf
      (switch-to-buffer target-buf)
      (if switch-cont (funcall switch-cont)))
     (t (funcall buffer-create-fn)
        (if switch-cont (funcall switch-cont))))))

(defun make-toggle-function (buffer-name buffer-create-fn &optional switch-cont)
  "Makes a toggle-function to have raise-or-create behaviour.

Creates a toggle-function that executes BUFFER-CREATE-FN if a
buffer named BUFFER-NAME doesn't exist, switches to the buffer
named BUFFER-NAME if it exists, and switches to the previous
buffer if we are currently visiting buffer BUFFER-NAME.

The SWITCH-CONT argument is a function which, if given, is called
after the buffer has been created or switched to.  This allows
running further actions that setup the state of the buffer or
modify it."
  (lambda ()
    (interactive)
    (let ((target-buf (get-buffer buffer-name)))
     (if target-buf
	 (if (eq (current-buffer) target-buf)
	     (progn
	       (message "switching to other buffer")
	       (switch-to-buffer nil))
	     (progn
	       (message "switching back...")
	       (switch-to-buffer buffer-name)
	       (when switch-cont (funcall switch-cont))))
       (message "creating buffer...")
       (funcall buffer-create-fn)
       (when switch-cont (funcall switch-cont))))))


#+end_src

#+RESULTS:
: make-toggle-function

#+begin_src emacs-lisp
;; (global-set-key (kbd "")
(global-set-key (kbd "C-a")
  (make-toggle-function "*eshell*"
      (lambda () (progn (eshell)
		   (end-of-buffer)))
      (lambda () (progn (eshell/cd (default-directory))
		   (end-of-buffer)))))


#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (let ((target-buf (get-buffer buffer-name))) (if target-buf (if (eq (current-buffer) target-buf) (progn (message switching to other buffer) (switch-to-buffer nil)) (progn (message switching back...) (switch-to-buffer buffer-name) (when switch-cont (funcall switch-cont)))) (message creating buffer...) (funcall buffer-create-fn) (when switch-cont (funcall switch-cont)))) |

#+begin_src emacs-lisp
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
     This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+end_src

#+RESULTS:
: xah-toggle-margin-right

#+begin_src emacs-lisp
(defun my-org-contacts-template-email (&optional return-value)
  "Try to return the contact email for a template.
         If not found return RETURN-VALUE or something that would ask the user."
  (eval-when-compile (require 'gnus-art nil t))
  (eval-when-compile (require 'org-contacts nil t))
  (or (cadr (if (gnus-alive-p)
                (gnus-with-article-headers
                  (mail-extract-address-components
                   (or (mail-fetch-field "Reply-To") (mail-fetch-field "From") "")))))
      return-value
      (concat "%^{" org-contacts-email-property "}p")))

#+end_src

#+RESULTS:
: my-org-contacts-template-email

* IRC


=circe= is a client for IRC in Emacs (hey, isn't that a nice project
name+acronym), and a greek enchantress who turned humans into animals.

Let's use the former to chat to +recluses+ discerning individuals online.

[[xkcd:1782]]

Before we start seeing and sending messages, we need to authenticate with our
IRC servers. The circe manual provided a snippet for putting some of the auth
details in =.authinfo.gpg= --- but I think we should go further than that: have
the entire server info in our authinfo.

First, a reasonable format by which we can specify:
+ server
+ port
+ SASL username
+ SASL password
+ channels to join

We can have these stored like so
#+begin_src authinfo
machine chat.freenode.net login USERNAME password PASSWORD port PORT for irc channels emacs,org-mode
#+end_src

The ~for irc~ bit is used so we can uniquely identify all IRC auth info. By
omitting the =#= in channel names we can have a list of channels comma-separated
(no space!) which the secrets API will return as a single string.

#+name: irc-authinfo-reader
#+begin_src emacs-lisp :tangle no
(defun auth-server-pass (server)
  (if-let ((secret (plist-get (car (auth-source-search :host server)) :secret)))
      (if (functionp secret)
          (funcall secret) secret)
    (error "Could not fetch password for host %s" server)))

(defun register-irc-auths ()
  (require 'circe)
  (require 'dash)
  (let ((accounts (-filter (lambda (a) (string= "irc" (plist-get a :for)))
                           (auth-source-search :require '(:for) :max 10))))
    (appendq! circe-network-options
              (mapcar (lambda (entry)
                        (let* ((host (plist-get entry :host))
                               (label (or (plist-get entry :label) host))
                               (_ports (mapcar #'string-to-number
                                               (s-split "," (plist-get entry :port))))
                               (port (if (= 1 (length _ports)) (car _ports) _ports))
                               (user (plist-get entry :user))
                               (nick (or (plist-get entry :nick) user))
                               (channels (mapcar (lambda (c) (concat "#" c))
                                                 (s-split "," (plist-get entry :channels)))))
                          `(,label
                            :host ,host :port ,port :nick ,nick
                            :sasl-username ,user :sasl-password auth-server-pass
                            :channels ,channels)))
                      accounts))))
#+end_src

We'll just call src_elisp{(register-irc-auths)} on a hook when we start Circe
up.

Now we're ready to go, let's actually wire-up Circe, with one or two
configuration tweaks.
#+begin_src emacs-lisp :noweb no-export
(after! circe
  (setq-default circe-use-tls t)
  (setq circe-notifications-alert-icon "/usr/share/icons/breeze/actions/24/network-connect.svg"
        lui-logging-directory (expand-file-name "irc" doom-etc-dir)
        lui-logging-file-format "{buffer}/%Y/%m-%d.txt"
        circe-format-self-say "{nick:+13s} ┃ {body}")

  (custom-set-faces!
    '(circe-my-message-face :weight unspecified))

  (enable-lui-logging-globally)
  (enable-circe-display-images)

  <<org-emph-to-irc>>

  <<circe-emojis>>
  <<circe-emoji-alists>>

  (defun named-circe-prompt ()
    (lui-set-prompt
     (concat (propertize (format "%13s > " (circe-nick))
                         'face 'circe-prompt-face)
             "")))
  (add-hook 'circe-chat-mode-hook #'named-circe-prompt)

  (appendq! all-the-icons-mode-icon-alist
            '((circe-channel-mode all-the-icons-material "message" :face all-the-icons-lblue)
              (circe-server-mode all-the-icons-material "chat_bubble_outline" :face all-the-icons-purple))))

<<irc-authinfo-reader>>

(add-transient-hook! #'=irc (register-irc-auths))
#+end_src

** Org-style emphasis

Let's do our *bold*, /italic/, and _underline_ in org-syntax, using IRC control characters.
#+name: org-emph-to-irc
#+begin_src emacs-lisp
(defun lui-org-to-irc ()
  "Examine a buffer with simple org-mode formatting, and converts the empasis:
,*bold*, /italic/, and _underline_ to IRC semi-standard escape codes.
=code= is converted to inverse (highlighted) text."
  (goto-char (point-min))
  (while (re-search-forward "\\_<\\(?1:[*/_=]\\)\\(?2:[^[:space:]]\\(?:.*?[^[:space:]]\\)?\\)\\1\\_>" nil t)
    (replace-match
     (concat (pcase (match-string 1)
               ("*" "")
               ("/" "")
               ("_" "")
               ("=" ""))
             (match-string 2)
             "") nil nil)))

(add-hook 'lui-pre-input-hook #'lui-org-to-irc)
#+end_src

** Emojis

Let's setup Circe to use some emojis
#+name: circe-emojis
#+begin_src emacs-lisp :tangle no
(defun lui-ascii-to-emoji ()
  (goto-char (point-min))
  (while (re-search-forward "\\( \\)?::?\\([^[:space:]:]+\\):\\( \\)?" nil t)
    (replace-match
     (concat
      (match-string 1)
      (or (cdr (assoc (match-string 2) lui-emojis-alist))
          (concat ":" (match-string 2) ":"))
      (match-string 3))
     nil nil)))

(defun lui-emoticon-to-emoji ()
  (dolist (emoticon lui-emoticons-alist)
    (goto-char (point-min))
    (while (re-search-forward (concat " " (car emoticon) "\\( \\)?") nil t)
      (replace-match (concat " "
                             (cdr (assoc (cdr emoticon) lui-emojis-alist))
                             (match-string 1))))))

(define-minor-mode lui-emojify
  "Replace :emojis: and ;) emoticons with unicode emoji chars."
  :global t
  :init-value t
  (if lui-emojify
      (add-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)
    (remove-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)))
#+end_src

Now, some actual emojis to use.
#+name: circe-emoji-alists
#+begin_src emacs-lisp :tangle no
(defvar lui-emojis-alist
  '(("grinning"                      . "😀")
    ("smiley"                        . "😃")
    ("smile"                         . "😄")
    ("grin"                          . "😁")
    ("laughing"                      . "😆")
    ("sweat_smile"                   . "😅")
    ("joy"                           . "😂")
    ("rofl"                          . "🤣")
    ("relaxed"                       . "☺️")
    ("blush"                         . "😊")
    ("innocent"                      . "😇")
    ("slight_smile"                  . "🙂")
    ("upside_down"                   . "🙃")
    ("wink"                          . "😉")
    ("relieved"                      . "😌")
    ("heart_eyes"                    . "😍")
    ("yum"                           . "😋")
    ("stuck_out_tongue"              . "😛")
    ("stuck_out_tongue_closed_eyes"  . "😝")
    ("stuck_out_tongue_wink"         . "😜")
    ("zanzy"                         . "🤪")
    ("raised_eyebrow"                . "🤨")
    ("monocle"                       . "🧐")
    ("nerd"                          . "🤓")
    ("cool"                          . "😎")
    ("star_struck"                   . "🤩")
    ("party"                         . "🥳")
    ("smirk"                         . "😏")
    ("unamused"                      . "😒")
    ("disapointed"                   . "😞")
    ("pensive"                       . "😔")
    ("worried"                       . "😟")
    ("confused"                      . "😕")
    ("slight_frown"                  . "🙁")
    ("frown"                         . "☹️")
    ("persevere"                     . "😣")
    ("confounded"                    . "😖")
    ("tired"                         . "😫")
    ("weary"                         . "😩")
    ("pleading"                      . "🥺")
    ("tear"                          . "😢")
    ("cry"                           . "😢")
    ("sob"                           . "😭")
    ("triumph"                       . "😤")
    ("angry"                         . "😠")
    ("rage"                          . "😡")
    ("exploding_head"                . "🤯")
    ("flushed"                       . "😳")
    ("hot"                           . "🥵")
    ("cold"                          . "🥶")
    ("scream"                        . "😱")
    ("fearful"                       . "😨")
    ("disapointed"                   . "😰")
    ("relieved"                      . "😥")
    ("sweat"                         . "😓")
    ("thinking"                      . "🤔")
    ("shush"                         . "🤫")
    ("liar"                          . "🤥")
    ("blank_face"                    . "😶")
    ("neutral"                       . "😐")
    ("expressionless"                . "😑")
    ("grimace"                       . "😬")
    ("rolling_eyes"                  . "🙄")
    ("hushed"                        . "😯")
    ("frowning"                      . "😦")
    ("anguished"                     . "😧")
    ("wow"                           . "😮")
    ("astonished"                    . "😲")
    ("sleeping"                      . "😴")
    ("drooling"                      . "🤤")
    ("sleepy"                        . "😪")
    ("dizzy"                         . "😵")
    ("zipper_mouth"                  . "🤐")
    ("woozy"                         . "🥴")
    ("sick"                          . "🤢")
    ("vomiting"                      . "🤮")
    ("sneeze"                        . "🤧")
    ("mask"                          . "😷")
    ("bandaged_head"                 . "🤕")
    ("money_face"                    . "🤑")
    ("cowboy"                        . "🤠")
    ("imp"                           . "😈")
    ("ghost"                         . "👻")
    ("alien"                         . "👽")
    ("robot"                         . "🤖")
    ("clap"                          . "👏")
    ("thumpup"                       . "👍")
    ("+1"                            . "👍")
    ("thumbdown"                     . "👎")
    ("-1"                            . "👎")
    ("ok"                            . "👌")
    ("pinch"                         . "🤏")
    ("left"                          . "👈")
    ("right"                         . "👉")
    ("down"                          . "👇")
    ("wave"                          . "👋")
    ("pray"                          . "🙏")
    ("eyes"                          . "👀")
    ("brain"                         . "🧠")
    ("facepalm"                      . "🤦")
    ("tada"                          . "🎉")
    ("fire"                          . "🔥")
    ("flying_money"                  . "💸")
    ("lighbulb"                      . "💡")
    ("heart"                         . "❤️")
    ("sparkling_heart"               . "💖")
    ("heartbreak"                    . "💔")
    ("100"                           . "💯")))

(defvar lui-emoticons-alist
  '((":)"   . "slight_smile")
    (";)"   . "wink")
    (":D"   . "smile")
    ("=D"   . "grin")
    ("xD"   . "laughing")
    (";("   . "joy")
    (":P"   . "stuck_out_tongue")
    (";D"   . "stuck_out_tongue_wink")
    ("xP"   . "stuck_out_tongue_closed_eyes")
    (":("   . "slight_frown")
    (";("   . "cry")
    (";'("  . "sob")
    (">:("  . "angry")
    (">>:(" . "rage")
    (":o"   . "wow")
    (":O"   . "astonished")
    (":/"   . "confused")
    (":-/"  . "thinking")
    (":|"   . "neutral")
    (":-|"  . "expressionless")))
#+end_src
* EVA

Emacs Virtual assistant
#+begin_src emacs-lisp :tangle packages.el

(package! eva
    :recipe (:host github :repo "meedstrom/eva"
           :files (:defaults "assets" "renv" "*.R" "*.gnuplot")))

#+end_src
#+begin_src emacs-lisp :tangle no

(use-package! eva
:init
(setq ess-history-file "~/self/data/.Rhistory")
(setq ess-ask-for-ess-directory nil)
  (setq eva-ai-name "HAL"
        eva-user-name "Akhil"
        eva-user-birthday "1999-01-02"
        eva-user-short-title "Dude"
        eva-fallback-to-emacs-idle t)
      (setq eva--idle-secs-fn #'eva--idle-secs-gnome)
  (setq eva-idle-log-path         "~/self/data/idle.tsv")
  (setq eva-buffer-focus-log-path "~/self/data/buffer-focus.tsv")
  (setq eva-buffer-info-path      "~/self/data/buffer-info.tsv")
  (setq eva-main-ledger-path      "~/self/data/l.ledger")
  (setq eva-main-datetree-path    "~/org/notes/diary.org")
  :config
  (setq org-journal-dir "~/org/journal/")
    (setq org-journal-date-prefix "#+TITLE: "
        org-journal-file-format "%Y-%m-%d.org"
        org-journal-date-format "%A, %d %B %Y")
    (require 'eva-builtin)
  (require 'eva-activity)
    (add-hook 'eva-after-load-vars-hook #'eva-check-dangling-clock)
  (add-hook 'eva-after-load-vars-hook #'eva-check-org-variables)
   (setq eva-items
        (list
         (eva-item-create :fn #'eva-greet
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-query-mood
                          :dataset "~/self/data/mood.tsv"
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-query-activity
                          :dataset "~/self/data/activities.tsv"
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-present-diary
                          :max-successes-per-day 1)

         (eva-item-create :fn #'eva-query-weight
                          :dataset "~/self/data/weight.tsv"
                          :max-entries-per-day 1)

         (eva-item-create :fn #'eva-plot-weight
                          :max-entries-per-day 1)

         (eva-item-create :fn #'eva-query-sleep
                          :dataset "~/self/data/sleep.tsv"
                          :min-hours-wait 5
                          :lookup-posted-time t)

         (eva-item-create :fn #'eva-present-ledger-report)

         (eva-item-create :fn #'eva-present-org-agenda)

         (eva-item-create :fn #'eva-query-ingredients
                          :dataset "~/self/data/ingredients.tsv"
                          :min-hours-wait 5)

         (eva-item-create :fn #'eva-query-cold-shower
                          :dataset "~/self/data/cold.tsv"
                          :max-entries-per-day 1)

         ;; you can inline define the functions too
         (eva-item-create
          :fn (eva-defun my-bye ()
                (message (eva-emit "All done for now."))
                (bury-buffer (eva-buffer-chat)))
          :min-hours-wait 0)))
        (transient-replace-suffix 'eva-dispatch '(0)
    '["General actions"
      ("q" "Quit" bury-buffer)
      ("l" "View Ledger report" eva-present-ledger-report)
      ("f" "View Ledger file" eva-present-ledger-file)
      ("a" "View Org agenda" org-agenda-list)])

  (define-key eva-chat-mode-map (kbd "l") #'eva-present-ledger-report)
  (define-key eva-chat-mode-map (kbd "a") #'org-agenda-list)

  ;; Activities
  (setq eva-activity-list
        (list (eva-activity-create :name "sleep"
                                   :cost-false-pos 3
                                   :cost-false-neg 3)

              (eva-activity-create :name "studying"
                                   :cost-false-pos 8
                                   :cost-false-neg 8)

              (eva-activity-create :name "coding"
                                   :cost-false-pos 5
                                   :cost-false-neg 5)

              (eva-activity-create :name "working"
                                   :cost-false-pos 5
                                   :cost-false-neg 5)
              (eva-activity-create :name "unknown"
                                   :cost-false-pos 0
                                   :cost-false-neg 0)))
  (eva-mode))
#+end_src

* Davivil ivy mode
#+begin_src emacs-lisp :tangle no
;; Better Completions with Ivy
;; I currently use Ivy, Counsel, and Swiper to navigate around files, buffers, and projects super quickly. Here are some workflow notes on how to best use Ivy:

;; While in an Ivy minibuffer, you can search within the current results by using S-Space.
;; To quickly jump to an item in the minibuffer, use C-' to get Avy line jump keys.
;; To see actions for the selected minibuffer item, use M-o and then press the action's key.
;; Super useful: Use C-c C-o to open ivy-occur to open the search results in a separate buffer. From there you can click any item to perform the ivy action.

(use-package! ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-f" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-r" . ivy-reverse-i-search-kill))
  ;; :init
  ;; (ivy-mode 1)
  :config
  (defun my/ivy-switch-buffer-by-prefix (prefix)
    "Use ivy to select a buffer prefixed by PREFIX#."
    (minibuffer-with-setup-hook
        (lambda ()
          (insert (concat "^" prefix "# ")))
      (ivy-switch-buffer)))
  (defun my/ivy-switch-buffer-firefox ()
    "Use ivy to select a Firefox window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "F"))
  (defun my/ivy-switch-buffer-urxvt ()
    "Use ivy to select an URXVT window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "u"))
  (defun my/ivy-switch-buffer-detached-command ()
    "Use ivy to select a compilation buffer."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "d")))

  ;; (setcdr (assoc t ivy-format-functions-alist) #'ivy-format-function-line)
  ;; ;; (ivy-mode 1)
  ;; (setq ivy-use-virtual-buffers t)
  ;; (setq ivy-wrap t)
  ;; (setq ivy-count-format "(%d/%d) ")
  ;; (setq enable-recursive-minibuffers t)

  ;; ;; Use different regex strategies per completion command
  ;; (push '(completion-at-point . ivy--regex-fuzzy) ivy-re-builders-alist) ;; This doesn't seem to work...
  ;; (push '(swiper . ivy--regex-ignore-order) ivy-re-builders-alist)
  ;; (push '(counsel-M-x . ivy--regex-ignore-order) ivy-re-builders-alist)

  ;; Set minibuffer height for different commands
  ;; (setf (alist-get 'counsel-projectile-ag ivy-height-alist) 15)
  ;; (setf (alist-get 'counsel-projectile-rg ivy-height-alist) 15)
  ;; (setf (alist-get 'swiper ivy-height-alist) 15)
  ;; (setf (alist-get 'counsel-switch-buffer ivy-height-alist) 7))

  ;; (setf (alist-get '+default/search-emacsd ivy-height-alist) 7)
  ;; (setf (alist-get '+vertico/project-search-from-cwd ivy-height-alist) 7))
;; (use-package! ivy-hydra
;;   :defer t
;;   :after hydra)

;; (use-package! ivy-rich
;;   :init
;;   ;; (ivy-rich-mode 1)
;;   :after counsel
;;   :config
;;   (setq ivy-format-function #'ivy-format-function-line)
;;   (setq ivy-rich-display-transformers-list
;;         (plist-put ivy-rich-display-transformers-list
;;                    'ivy-switch-buffer
;;                    '(:columns
;;                      ((ivy-rich-candidate (:width 40))
;;                       (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
;;                       (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
;;                       (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
;;                       (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
;;                      :predicate
;;                      (lambda (cand)
;;                        (if-let ((buffer (get-buffer cand)))
;;                            ;; Don't mess with EXWM buffers
;;                            (with-current-buffer buffer
;;                              (not (derived-mode-p 'exwm-mode)))))))))

(use-package! counsel
  :demand t
  ;; :bind (("M-x" . counsel-M-x)
  ;;        ("C-c a" . counsel-ibuffer)
  ;;        ("C-x C-f" . counsel-find-file)
         ;; ("C-M-j" . counsel-switch-buffer)
         ;; ("C-c l" . counsel-imenu)
         ;; :map minibuffer-local-map
         ;; ("C-c r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (setq ivy-initial-inputs-alist nil) ;; Don't start searches with ^

  (defun my/counsel-find-file-no-tramp (&optional initial-input initial-directory)
    (interactive)
    (if (string-prefix-p "/ssh:" default-directory)
        (counsel-find-file "" "~/")
      (counsel-find-file initial-input initial-directory)))
  ;; Pending https://github.com/abo-abo/swiper/pull/2844/
  (defun counsel--esh-dir-history-action-cd (pair)
    "Change the current working directory to the selection.
This function is the default action for `counsel-esh-dir-history'
and changes the working directory in Eshell to the selected
candidate which must be provided as the `car' of PAIR."
    (eshell/cd (car pair)))
  (defun counsel--esh-dir-history-action-edit (pair)
    "Insert the selection to the Eshell buffer prefixed by \"cd \".
This function is an action for `counsel-esh-dir-history' to
insert the selected directory (provided as the `car' of PAIR) to
the Eshell buffer prefixed by \"cd \", allowing the caller to
modify parts of the directory before switching to it."
    (insert (format "cd %s" (car pair))))
  (defun counsel-esh-dir-history ()
    "Use Ivy to browse Eshell's directory stack."
    (interactive)
    (require 'em-dirs)
    (defvar eshell-last-dir-ring)
    (ivy-read "Directory to change to: " (ivy-history-contents eshell-last-dir-ring)
              :keymap ivy-reverse-i-search-map
              :action #'counsel--esh-dir-history-action-cd
              :caller #'counsel-esh-dir-history))
  (ivy-set-actions
   'counsel-esh-dir-history
   '(("e" counsel--esh-dir-history-action-edit "edit")))
  (defun counsel-fzf-action (x)
    (with-ivy-window
      (let ((default-directory counsel--fzf-dir))
        (find-file-other-window x)))
    (other-window -1))
  :custom
  (counsel-yank-pop-separator "\n-------------------\n")
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
(use-package! swiper
  :bind (("C-s" . isearch-forward)
         ("C-M-s" . swiper-thing-at-point)))
;; (use-package! flx  ;; Improves sorting for fuzzy-matched results
;;   :after ivy
;;   :defer t
;;   :init
;;   (setq ivy-flx-limit 10000))

;; (use-package! wgrep)

;; (use-package! ivy-posframe
;;   ;; :disabled
;;   :custom
;;   (ivy-posframe-width      115)
;;   (ivy-posframe-min-width  115)
;;   (ivy-posframe-height     10)
;;   (ivy-posframe-min-height 10)
;;   :config
;;   (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
;;   (setq ivy-posframe-parameters '((parent-frame . nil)
;;                                   (left-fringe . 8)
;;                                   (right-fringe . 8)))
;;   (ivy-posframe-mode nil))

;; (use-package! prescient
;;   :after counsel
;;   :config
;;   (prescient-persist-mode 1))

;; (use-package! ivy-prescient
;;   :after prescient
;;   :config
;;   (ivy-prescient-mode 1))

;; (dw/leader-key-def
;;   "r"   '(ivy-resume :which-key "ivy resume")
;;   "f"   '(:ignore t :which-key "files")
;;   "ff"  '(counsel-find-file :which-key "open file")
;;   "C-f" 'counsel-find-file
;;   "fr"  '(counsel-recentf :which-key "recent files")
;;   "fR"  '(revert-buffer :which-key "revert file")
;;   "fj"  '(counsel-file-jump :which-key "jump to file"))
#+end_src

#+RESULTS:
: swiper-thing-at-point

* vertico posframe
#+begin_src emacs-lisp :tangle packages.el
(package! vertico-posframe
    :recipe (:host github :repo "tumashu/vertico-posframe"
       :files ("vertico-posframe.el")))
#+end_src
#+begin_src emacs-lisp
(use-package! vertico-posframe
  :config
  (defun ct/vertico-posframe-get-size ()
    "Override of `vertico-posframe-get-size'"
    (let ((width (round (* (frame-width) 0.8))))
      (list
       :height vertico-posframe-height
       :width (min (or vertico-posframe-max-width
                       999999)
                   (or vertico-posframe-min-width
                       width))
       :min-height (or vertico-posframe-min-height
                       (let ((height (+ vertico-count 1)))
                         (min height (or vertico-posframe-height height))))
       :min-width (or vertico-posframe-min-width
                      vertico-posframe-max-width
                      width))))
  (defun ct/posframe-poshandler-frame-center-eyelevel (info)
    "Posframe position handler to put the posframe at eye level,
horizontally centered. Top position is fixed to avoid jittering
when filtering.

INFO can be found in docstring of `posframe-show'."
    (cons (- (/ (plist-get info :parent-frame-width) 2)
             (/ (plist-get info :posframe-width) 2))
          (- (/ (plist-get info :parent-frame-height) 4)
             (/ vertico-posframe-min-height 2))))

  (setq vertico-posframe-parameters '((left-fringe . 20)
                                      (right-fringe . 20))
        vertico-posframe-border-width 4
        vertico-posframe-min-height 3
        vertico-posframe-max-width 130  ;; Don't go too wide on ultrawide monitors
        vertico-posframe-poshandler #'ct/posframe-poshandler-frame-center-eyelevel
        vertico-posframe-size-function #'ct/vertico-posframe-get-size)
  :init
  (vertico-posframe-mode 1))
#+end_src

#+RESULTS:
: t

* Holidays
  :PROPERTIES:
  :CATEGORY: Holiday
  :END:
%%(org-calendar-holiday)   ; special function for holiday names

* Birthdays
  :PROPERTIES:
  :CATEGORY: Ann
  :END:
%%(org-anniversary 2022  10 17) Arthur Dent is %d years old
%%(org-anniversary 1869 10  2) Mahatma Gandhi would be %d years old

* [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][Dynamic and fast agenda]]
#+begin_src emacs-lisp :tangle no
(add-to-list 'org-tags-exclude-from-inheritance "project")
(defun vulpea-project-p ()
  "Return non-nil if current buffer has any todo entry.

TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks."
  (seq-find                                 ; (3)
   (lambda (type)
     (eq type 'todo))
   (org-element-map                         ; (2)
       (org-element-parse-buffer 'headline) ; (1)
       'headline
     (lambda (h)
       (org-element-property :todo-type h)))))

(defun vulpea-project-update-tag ()
    "Update PROJECT tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-project-p)
              (setq tags (cons "project" tags))
            (setq tags (remove "project" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

(defun vulpea-buffer-p ()
  "Return non-nil if the currently visited buffer is a note."
  (and buffer-file-name
       (string-prefix-p
        (expand-file-name (file-name-as-directory org-roam-directory))
        (file-name-directory buffer-file-name))))

(defun vulpea-project-files ()
    "Return a list of note files containing 'project' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
        :from tags
        :left-join nodes
        :on (= tags:node-id nodes:id)
        :where (like tag (quote "%\"project\"%"))]))))

(defun vulpea-agenda-files-update (&rest _)
  "Update the value of `org-agenda-files'."
  (setq org-agenda-files (vulpea-project-files)))

(add-hook 'find-file-hook #'vulpea-project-update-tag)
(add-hook 'before-save-hook #'vulpea-project-update-tag)

(advice-add 'org-agenda :before #'vulpea-agenda-files-update)
(advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
#+end_src

#+RESULTS:

* org mode
** REVIEW Org fonts
- State "REVIEW"     from "HOLD"       [2022-10-16 Sun 13:23]
- State "HOLD"       from "READY"      [2022-10-16 Sun 13:22]
Distrotube  have created an interactive function for each color scheme (M-x dt/org-colors-*).  These functions will set appropriate colors and font attributes for org-level fonts and the org-table font.
#+begin_src emacs-lisp :tangle no

(defun dt/org-colors-doom-one ()
  "Enable Doom One colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#51afef" ultra-bold)
         (org-level-2 1.6 "#c678dd" extra-bold)
         (org-level-3 1.5 "#98be65" bold)
         (org-level-4 1.4 "#da8548" semi-bold)
         (org-level-5 1.3 "#5699af" normal)
         (org-level-6 1.2 "#a9a1e1" normal)
         (org-level-7 1.1 "#46d9ff" normal)
         (org-level-8 1.0 "#ff6c6b" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-dracula ()
  "Enable Dracula colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#8be9fd" ultra-bold)
         (org-level-2 1.6 "#bd93f9" extra-bold)
         (org-level-3 1.5 "#50fa7b" bold)
         (org-level-4 1.4 "#ff79c6" semi-bold)
         (org-level-5 1.3 "#9aedfe" normal)
         (org-level-6 1.2 "#caa9fa" normal)
         (org-level-7 1.1 "#5af78e" normal)
         (org-level-8 1.0 "#ff92d0" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-gruvbox-dark ()
  "Enable Gruvbox Dark colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#458588" ultra-bold)
         (org-level-2 1.6 "#b16286" extra-bold)
         (org-level-3 1.5 "#98971a" bold)
         (org-level-4 1.4 "#fb4934" semi-bold)
         (org-level-5 1.3 "#83a598" normal)
         (org-level-6 1.2 "#d3869b" normal)
         (org-level-7 1.1 "#d79921" normal)
         (org-level-8 1.0 "#8ec07c" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-monokai-pro ()
  "Enable Monokai Pro colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#78dce8" ultra-bold)
         (org-level-2 1.6 "#ab9df2" extra-bold)
         (org-level-3 1.5 "#a9dc76" bold)
         (org-level-4 1.4 "#fc9867" semi-bold)
         (org-level-5 1.3 "#ff6188" normal)
         (org-level-6 1.2 "#ffd866" normal)
         (org-level-7 1.1 "#78dce8" normal)
         (org-level-8 1.0 "#ab9df2" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-nord ()
  "Enable Nord colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#81a1c1" ultra-bold)
         (org-level-2 1.6 "#b48ead" extra-bold)
         (org-level-3 1.5 "#a3be8c" bold)
         (org-level-4 1.4 "#ebcb8b" semi-bold)
         (org-level-5 1.3 "#bf616a" normal)
         (org-level-6 1.2 "#88c0d0" normal)
         (org-level-7 1.1 "#81a1c1" normal)
         (org-level-8 1.0 "#b48ead" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-oceanic-next ()
  "Enable Oceanic Next colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#6699cc" ultra-bold)
         (org-level-2 1.6 "#c594c5" extra-bold)
         (org-level-3 1.5 "#99c794" bold)
         (org-level-4 1.4 "#fac863" semi-bold)
         (org-level-5 1.3 "#5fb3b3" normal)
         (org-level-6 1.2 "#ec5f67" normal)
         (org-level-7 1.1 "#6699cc" normal)
         (org-level-8 1.0 "#c594c5" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-palenight ()
  "Enable Palenight colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#82aaff" ultra-bold)
         (org-level-2 1.6 "#c792ea" extra-bold)
         (org-level-3 1.5 "#c3e88d" bold)
         (org-level-4 1.4 "#ffcb6b" semi-bold)
         (org-level-5 1.3 "#a3f7ff" normal)
         (org-level-6 1.2 "#e1acff" normal)
         (org-level-7 1.1 "#f07178" normal)
         (org-level-8 1.0 "#ddffa7" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-solarized-dark ()
  "Enable Solarized Dark colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#268bd2" ultra-bold)
         (org-level-2 1.6 "#d33682" extra-bold)
         (org-level-3 1.5 "#859900" bold)
         (org-level-4 1.4 "#b58900" semi-bold)
         (org-level-5 1.3 "#cb4b16" normal)
         (org-level-6 1.2 "#6c71c4" normal)
         (org-level-7 1.1 "#2aa198" normal)
         (org-level-8 1.0 "#657b83" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-solarized-light ()
  "Enable Solarized Light colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#268bd2" ultra-bold)
         (org-level-2 1.6 "#d33682" extra-bold)
         (org-level-3 1.5 "#859900" bold)
         (org-level-4 1.4 "#b58900" semi-bold)
         (org-level-5 1.3 "#cb4b16" normal)
         (org-level-6 1.2 "#6c71c4" normal)
         (org-level-7 1.1 "#2aa198" normal)
         (org-level-8 1.0 "#657b83" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-tomorrow-night ()
  "Enable Tomorrow Night colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#81a2be" ultra-bold)
         (org-level-2 1.6 "#b294bb" extra-bold)
         (org-level-3 1.5 "#b5bd68" bold)
         (org-level-4 1.4 "#e6c547" semi-bold)
         (org-level-5 1.3 "#cc6666" normal)
         (org-level-6 1.2 "#70c0ba" normal)
         (org-level-7 1.1 "#b77ee0" normal)
         (org-level-8 1.0 "#9ec400" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

;; Load our desired dt/org-colors-* theme on startup
(dt/org-colors-doom-one)

#+end_src

#+RESULTS:

** org mode
*** LaTeX Export

**** Compiling

By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
(setq org-latex-pdf-process '("LC_ALL=en_US.UTF-8 latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

**** Nicer checkboxes

We'll assume that thanks to the clever preamble the various custom =\checkbox...=
commands below are defined.

#+begin_src emacs-lisp
(defun +org-export-latex-fancy-item-checkboxes (text backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string
     "\\\\item\\[{$\\\\\\(\\w+\\)$}\\]"
     (lambda (fullmatch)
       (concat "\\\\item[" (pcase (substring fullmatch 9 -3) ; content of capture group
                             ("square"   "\\\\checkboxUnchecked")
                             ("boxminus" "\\\\checkboxTransitive")
                             ("boxtimes" "\\\\checkboxChecked")
                             (_ (substring fullmatch 9 -3))) "]"))
     text)))

(add-to-list 'org-export-filter-item-functions
             '+org-export-latex-fancy-item-checkboxes)
#+end_src

**** Class templates

I really like the KOMA bundle. It provides a set of mechanisms to tweak document
styling which is both easy to use, and quite comprehensive.
For example, I rather like section numbers in the margin, which can be
accomplished with
#+name: latex-hanging-secnum
#+begin_src LaTeX
\renewcommand\sectionformat{\llap{\thesection\autodot\enskip}}
\renewcommand\subsectionformat{\llap{\thesubsection\autodot\enskip}}
\renewcommand\subsubsectionformat{\llap{\thesubsubsection\autodot\enskip}}
#+end_src

It can also be nice to have big =\chapter=​s.
#+name: latex-big-chapter
#+begin_src LaTeX
\RedeclareSectionCommand[afterindent=false, beforeskip=0pt, afterskip=0pt, innerskip=0pt]{chapter}
\setkomafont{chapter}{\normalfont\Huge}
\renewcommand*{\chapterheadstartvskip}{\vspace*{0\baselineskip}}
\renewcommand*{\chapterheadendvskip}{\vspace*{0\baselineskip}}
\renewcommand*{\chapterformat}{%
  \fontsize{60}{30}\selectfont\rlap{\hspace{6pt}\thechapter}}
\renewcommand*\chapterlinesformat[3]{%
  \parbox[b]{\dimexpr\textwidth-0.5em\relax}{%
    \raggedleft{{\large\scshape\bfseries\chapapp}\vspace{-0.5ex}\par\Huge#3}}%
    \hfill\makebox[0pt][l]{#2}}
#+end_src

Now let's just sprinkle some KOMA all over the Org LaTeX classes.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(after! ox-latex
  (let* ((article-sections '(("\\section{%s}" . "\\section*{%s}")
                             ("\\subsection{%s}" . "\\subsection*{%s}")
                             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                             ("\\paragraph{%s}" . "\\paragraph*{%s}")
                             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
         (book-sections (append '(("\\chapter{%s}" . "\\chapter*{%s}"))
                                article-sections))
         (hanging-secnum-preamble <<grab("latex-hanging-secnum")>>)
         (big-chap-preamble <<grab("latex-big-chapter">>))
    (setcdr (assoc "article" org-latex-classes)
            `(,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
              ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("report" ,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("book" ,(concat "\\documentclass[twoside=false]{scrbook}"
                                   big-chap-preamble hanging-secnum-preamble)
                   ,@book-sections))
    (add-to-list 'org-latex-classes
                 `("blank" "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc-article" "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc" "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@book-sections))))

(setq org-latex-tables-booktabs t
      org-latex-hyperref-template
      <<grab("latex-fancy-hyperref")>>
      org-latex-reference-command "\\cref{%s}")
#+end_src


The =hyperref= setup needs to be handled separately however.
#+name: latex-fancy-hyperref
#+begin_src LaTeX
\providecolor{url}{HTML}{0077bb}
\providecolor{link}{HTML}{882255}
\providecolor{cite}{HTML}{999933}
\hypersetup{
  pdfauthor={%a},
  pdftitle={%t},
  pdfkeywords={%k},
  pdfsubject={%d},
  pdfcreator={%c},
  pdflang={%L},
  breaklinks=true,
  colorlinks=true,
  linkcolor=link,
  urlcolor=url,
  citecolor=cite
}
\urlstyle{same}
%% hide links styles in toc
\NewCommandCopy{\oldtoc}{\tableofcontents}
\renewcommand{\tableofcontents}{\begingroup\hypersetup{hidelinks}\oldtoc\endgroup}
#+end_src

**** A cleverer preamble
***** Use case

We often want particular snippets of LaTeX in our documents preambles.
It's a pain to have to work out / remember them every time.
For example, I almost always want to include the snippet below.

#+name: org-latex-embed-files-preamble
#+begin_src LaTeX
\usepackage[main,include]{embedall}
\IfFileExists{./\jobname.org}{\embedfile[desc=The original file]{\jobname.org}}{}
#+end_src

We could have every package we could possibly need in every one of
~org-latex-classes~, but that's /horribly/ inefficient and I don't want to think
about maintaining that.

Instead we can provide some granularity by splitting up the features we want,
and then take the experience to a whole new level by implementing a system to
automatically detect which features are desired and generating a preamble that
provides these features.

***** Conditional Content

Let's consider content we want in particular situations.

Captions could do with a bit of tweaking such that
+ You can easily have multiple captions
+ Links to figures take you to the /top/ of the figure (not the bottom)
+ Caption labels could do with being emphasised slightly more
+ Multiline captions should run ragged-right, but only when then span more than
  one line

#+name: org-latex-caption-preamble
#+begin_src LaTeX
\usepackage{subcaption}
\usepackage[hypcap=true]{caption}
\setkomafont{caption}{\sffamily\small}
\setkomafont{captionlabel}{\upshape\bfseries}
\captionsetup{justification=raggedright,singlelinecheck=true}
\usepackage{capt-of} % required by Org
#+end_src

The default checkboxes look rather ugly, so let's provide some prettier alternatives.

#+name: org-latex-checkbox-preamble
#+begin_src LaTeX
\newcommand{\checkboxUnchecked}{$\square$}
\newcommand{\checkboxTransitive}{\rlap{\raisebox{-0.1ex}{\hspace{0.35ex}\Large\textbf -}}$\square$}
\newcommand{\checkboxChecked}{\rlap{\raisebox{0.2ex}{\hspace{0.35ex}\scriptsize \ding{52}}}$\square$}
#+end_src

It's nice to have "message blocks", things like info/warning/error/success.
A LaTeX macro should make them trivial to create.

#+name: org-latex-box-preamble
#+begin_src LaTeX
\ExplSyntaxOn
\NewCoffin\Content
\NewCoffin\SideRule
\NewDocumentCommand{\defsimplebox}{O{\ding{117}} O{0.36em} m m m}{%
  % #1 ding, #2 ding offset, #3 name, #4 colour, #5 default label
  \definecolor{#3}{HTML}{#4}
  \NewDocumentEnvironment{#3}{ O{#5} }
  {
    \vcoffin_set:Nnw \Content { \linewidth }
    \noindent \ignorespaces
    \par\vspace{-0.7\baselineskip}%
    \textcolor{#3}{#1}~\textcolor{#3}{\textbf{##1}}%
    \vspace{-0.8\baselineskip}
    \begin{addmargin}[1em]{1em}
    }
    {
    \end{addmargin}
    \vspace{-0.5\baselineskip}
    \vcoffin_set_end:
    \SetHorizontalCoffin\SideRule{\color{#3}\rule{1pt}{\CoffinTotalHeight\Content}}
    \JoinCoffins*\Content[l,t]\SideRule[l,t](#2,-0.7em)
    \noindent\TypesetCoffin\Content
    \vspace*{\CoffinTotalHeight\Content}\bigskip
    \vspace{-2\baselineskip}
  }
}
\ExplSyntaxOff
#+end_src

Lastly, we will pass this content into some global variables we for ease of
access.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(defvar org-latex-embed-files-preamble
  <<grab("org-latex-embed-files-preamble")>>
  "Preamble that embeds files within the pdf.")

(defvar org-latex-caption-preamble
  <<grab("org-latex-caption-preamble")>>
  "Preamble that improves captions.")

(defvar org-latex-checkbox-preamble
  <<grab("org-latex-checkbox-preamble")>>
  "Preamble that improves checkboxes.")

(defvar org-latex-box-preamble
  <<grab("org-latex-box-preamble")>>
  "Preamble that provides a macro for custom boxes.")
#+end_src

In the "universal preamble", we already embed the source =.org= file, but it would
be nice to embed all the tangled files. This is fairly easy to accomplish by
mapping each tangled file to a form which embeds the file if it exists.
Considering we're going this far, why not add a dedicated =#+emded= keyword, so we
can embed whatever we want.

#+begin_src emacs-lisp
(defun org-latex-embed-extra-files ()
  "Return a string that uses embedfile to embed all tangled files."
  (mapconcat
   (lambda (file-desc)
     (format "\\IfFileExists{%1$s}{\\embedfile[desc=%2$s]{%1$s}}{}"
             (thread-last (car file-desc)
                          (replace-regexp-in-string "\\\\" "\\\\\\\\")
                          (replace-regexp-in-string "~" "\\\\string~"))
             (cdr file-desc)))
   (append
    (let (tangle-fspecs) ; All files being tangled to.
      (org-element-cache-map
       (lambda (src)
         (when (and (not (org-in-commented-heading-p nil src))
                    (not (org-in-archived-heading-p nil src)))
           (when-let ((params (org-babel-parse-header-arguments
                               (org-element-property :parameters src) t))
                      (lang (org-element-property :language src))
                      (tangle-value
                       (pcase (alist-get :tangle params)
                         ((and (pred stringp) (pred (string-match-p "^(.*)$")) expr)
                          (eval (read expr)))
                         (val val)))
                      (tangle-file
                       (pcase tangle-value
                         ((or "no" (guard (member (alist-get :export-embed params) '("no" "nil"))))
                          nil)
                         ("yes"
                          (file-name-with-extension
                           (file-name-nondirectory (buffer-file-name))
                           (or (alist-get lang org-babel-tangle-lang-exts nil nil #'equal)
                               lang)))
                         (val val))))
             (unless (assoc tangle-file tangle-fspecs)
               (push
                (cons tangle-file (format "Tangled %s file" lang))
                tangle-fspecs)))))
       :granularity 'element
       :restrict-elements '(src-block))
      (nreverse tangle-fspecs))
    (let (extra-files)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\+embed:" nil t)
          (let* ((file-desc (split-string (org-element-property :value (org-element-at-point)) " :desc\\(?:ription\\)? ")))
            (push (cons (car file-desc) (or (cdr file-desc) "Extra file")) extra-files))))
      (nreverse extra-files)))
   "\n"))
#+end_src

Now all tangled files will be embedded, and we can embed arbitrary files like
so:
#+begin_src org
,#+embed: some-file :description flavour text about the file
#+end_src

This currently won't complete or anything like that, as we haven't told Org that
it's a keyword yet. It's also LaTeX-specific, so maybe it should be changed to
=#+latex_embed= or something like that.

***** Content-feature-preamble association

Initially this idea was implemented with an alist that associated a construct
that would search the current Org file for an indication that some feature was
needed, with a LaTeX snippet to be inserted in the preamble which would provide
that feature.
This is all well and good when there is a bijection between detected features
and the LaTeX code needed to support those features, but in many cases this
relation is not injective.

To better model the reality of the situation, I add an extra layer to this
process where each detected feature gives a list of required "feature flags".
Simply be merging the lists of feature flags we no longer have to require
injectivity to avoid LaTeX duplication. Then the extra layer forms a bijection
between there feature flags and a specification which can be used to implement
the feature.

This model also provides a number of nice secondary benefits, such as a simple
implementation of feature dependency.

#+begin_src dot :file misc/org-latex-clever-preamble.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" width="1.3" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [color="#aaaaaa" penwidth="1.2"]
    rankdir=LR

    node[group=a,color="#2ec27e"]
    "file:*.svg"
    "file:*.jpeg"
    "file:*.png"
    "#+caption"
    "xkcd:*"
    node[group=b,color="#f5c211"]
    "svg"
    "image"
    "caption"
    node[group=c,color="#813d9c"]
    "(TeX) svg"
    "(TeX) graphicx"
    "(TeX) caption"

    "file:*.svg" -> "svg" -> "(TeX) svg"
    "file:*.jpeg" -> "image" -> "(TeX) graphicx"
    "file:*.png" -> "image"
    "(TeX) svg":s -> "(TeX) graphicx":n [constraint=false]
    "#+caption" -> "caption" -> "(TeX) caption"
    "xkcd:*" -> "image"
    "xkcd:*" -> "caption"
}
#+end_src

#+caption: Association between Org features, feature flags, and LaTeX snippets required.
#+attr_html: :class invertible :alt DAG showing how Org features flow through to LaTeX :style max-width:min(24em,100%)
#+attr_latex: :width 0.6\linewidth
[[file:misc/org-latex-clever-preamble.svg]]

First we will implement the feature detection component of this model. I'd like
this to be able to use as much state information as possible, so the feature
tests should be very versatile.

#+begin_src emacs-lisp
(defvar org-latex-embed-files t
  "Embed the source .org, .tex, and any tangled files.")
(defvar org-latex-use-microtype t
  "Use the microtype pakage.")
(defvar org-latex-italic-quotes t
  "Make \"quote\" environments italic.")
(defvar org-latex-par-sep t
  "Vertically seperate paragraphs, and remove indentation.")

(pushnew!
 org-export-conditional-features
 '("\\\\(\\|\\\\\\[\\|\\\\begin{\\(?:math\\|displaymath\\|equation\\|align\\|flalign\\|multiline\\|gather\\)[a-z]*\\*?}" . maths)
 '("cref:\\|\\cref{\\|\\[\\[[^\\]+\n?[^\\]\\]\\]" . cleveref)
 '("[;\\\\]?\\b[A-Z][A-Z]+s?[^A-Za-z]" . acronym)
 '("[\u2500-\u259F]" . box-drawing)
 '("\\+[^ ].*[^ ]\\+\\|_[^ ].*[^ ]_\\|\\\\uu?line\\|\\\\uwave\\|\\\\sout\\|\\\\xout\\|\\\\dashuline\\|\\dotuline\\|\\markoverwith" . underline)
 '(":float wrap" . float-wrap)
 '(":float sideways" . rotate)
 '("^[ \t]*#\\+caption:\\|\\\\caption" . caption)
 '("\\[\\[xkcd:" . (image caption))
 '(org-latex-use-microtype . microtype)
 (cons (lambda (_info) (and org-latex-italic-quotes "^[ \t]*#\\+begin_quote\\|\\\\begin{quote}")) 'italic-quotes)
 '(org-latex-par-sep . par-sep)
 '(org-latex-embed-files . embed-files)
 (cons (lambda (_info) (and org-latex-embed-files "^[ \t]*#\\+embed\\|^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC")) 'embed-tangled)
 '("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\|[A-Za-z]+[.)]\\) \\[[ -X]\\]" . checkbox)
 '("^[ \t]*#\\+begin_warning\\|\\\\begin{warning}" . box-warning)
 '("^[ \t]*#\\+begin_info\\|\\\\begin{info}"       . box-info)
 '("^[ \t]*#\\+begin_notes\\|\\\\begin{notes}"     . box-notes)
 '("^[ \t]*#\\+begin_success\\|\\\\begin{success}" . box-success)
 '("^[ \t]*#\\+begin_error\\|\\\\begin{error}"     . box-error))
#+end_src

Then we provide a way to generate the preamble that provides those features.
In addition to the features named in ~org-latex-conditional-features~ we'll also
create /meta-features/, which can be required by other features (with =:requires=),
or be active by default (=:eager t=). For further control I some features may only
be used when certain other features are active (with =:when=), and masked by other
features (with =:prevents=). I will use the convention of starting meta-features
with =.=, and =:eager= features with =!= to make their nature more readily apparent.

Another consideration in LaTeX is load order, which matters in some cases.
Beyond that, it's nice to have some sort of sensible ordering. For this I'll
introduce an =:order= keyword. Using this I'll arrange snippets as follows.

+ =-2= Embed files setup
+ =-1= Extra file embedding
+ =0= Typography
  - =0= Fonts themselves
  - =0.1= Typographic tweaks (=microtype=)
  - =0.2= Maths setup
  - =0.3= Maths font
  - =0.4= Extra text shaping (~\acr~)
  - =0.5-0.9= Miscellaneous text modifications, trying to put shorter snippets first
+ =1= (/default/)
+ =2= Tables and figures
+ =3= Miscellaneous short content
+ =4= Fancy boxes

#+begin_src emacs-lisp
(pushnew!
 org-latex-feature-implementations
 '(image         :snippet "\\usepackage{graphicx}" :order 2)
 '(svg           :snippet "\\usepackage[inkscapelatex=false]{svg}" :order 2)
 '(table         :snippet "\\usepackage{longtable}\n\\usepackage{booktabs}" :order 2)
 '(maths         :snippet org-latex-maths-preamble :order 0.2)
 '(cleveref      :snippet "\\usepackage[capitalize]{cleveref}" :order 1) ; after bmc-maths
 '(float-wrap    :snippet "\\usepackage{wrapfig}" :order 2)
 '(rotate        :snippet "\\usepackage{rotating}" :order 2)
 '(caption       :snippet org-latex-caption-preamble :order 2.1)
 '(microtype     :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}\n" :order 0.1)
 '(embed-files   :snippet org-latex-embed-files-preamble :order -2)
 `(embed-tangled :requires embed-files :snippet ,(lambda (_info) (concat (org-latex-embed-extra-files) "\n")) :order -1)
 '(acronym       :snippet "\\newcommand{\\acr}[1]{\\protect\\textls*[110]{\\scshape #1}}\n\\newcommand{\\acrs}{\\protect\\scalebox{.91}[.84]{\\hspace{0.15ex}s}}" :order 0.4)
 '(box-drawing   :snippet "\\usepackage{pmboxdraw}" :order 0.05)
 '(italic-quotes :snippet "\\renewcommand{\\quote}{\\list{}{\\rightmargin\\leftmargin}\\item\\relax\\em}\n" :order 0.5)
 '(par-sep       :snippet "\\setlength{\\parskip}{\\baselineskip}\n\\setlength{\\parindent}{0pt}\n" :order 0.5)
 '(.pifont       :snippet "\\usepackage{pifont}")
 '(.xcoffins     :snippet "\\usepackage{xcoffins}")
 `(checkbox      :requires .pifont :order 3
   :snippet ,(lambda (_info)
               (concat (unless (memq 'maths features)
                         "\\usepackage{amssymb} % provides \\square")
                       org-latex-checkbox-preamble)))
 '(.fancy-box    :requires (.pifont .xcoffins) :snippet org-latex-box-preamble :order 3.9)
 '(box-warning   :requires .fancy-box :snippet "\\defsimplebox{warning}{e66100}{Warning}" :order 4)
 '(box-info      :requires .fancy-box :snippet "\\defsimplebox{info}{3584e4}{Information}" :order 4)
 '(box-notes     :requires .fancy-box :snippet "\\defsimplebox{notes}{26a269}{Notes}" :order 4)
 '(box-success   :requires .fancy-box :snippet "\\defsimplebox{success}{26a269}{\\vspace{-\\baselineskip}}" :order 4)
 '(box-error     :requires .fancy-box :snippet "\\defsimplebox{error}{c01c28}{Important}" :order 4))
#+end_src

***** Reduce default packages

Thanks to our additions, we can remove a few packages from
~org-latex-default-packages-alist~.

There are also some obsolete entries in the default value, specifically
+ =grffile='s capabilities are built into the current version of =graphicx=
+ =textcomp='s functionality has been included in LaTeX's core for a while now

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t ("pdflatex"))
        ("T1" "fontenc" t ("pdflatex"))
        ("" "xcolor" nil) ; Generally useful
        ("" "hyperref" nil)))
#+end_src

**** Font collections

Using the lovely conditional preamble, I'll define a number of font collections
that can be used for LaTeX exports. Who knows, maybe I'll use it with other
export formats too at some point.

To start with I'll create a default state variable and register =fontset= as part
of =#+options=.

#+begin_src emacs-lisp
(defvar org-latex-default-fontset 'alegreya
  "Fontset from `org-latex-fontsets' to use by default.
As cm (computer modern) is TeX's default, that causes nothing
to be added to the document.

If \"nil\" no custom fonts will ever be used.")

(eval '(cl-pushnew '(:latex-font-set nil "fontset" org-latex-default-fontset)
                   (org-export-backend-options (org-export-get-backend 'latex))))
#+end_src

Then a function is needed to generate a LaTeX snippet which applies the fontset. It
would be nice if this could be done for individual styles and use different
styles as the main document font. If the individual typefaces for a fontset are
defined individually as
src_elisp{:serif}, src_elisp{:sans}, src_elisp{:mono}, and src_elisp{:maths}.
I can use those to generate LaTeX for subsets of the full fontset. Then, if I
don't let any fontset names have =-= in them, I can use =-sans= and =-mono= as
suffixes that specify the document font to use.

#+begin_src emacs-lisp
(defun org-latex-fontset-entry ()
  "Get the fontset spec of the current file.
Has format \"name\" or \"name-style\" where 'name' is one of
the cars in `org-latex-fontsets'."
  (let ((fontset-spec
         (symbol-name
          (or (car (delq nil
                         (mapcar
                          (lambda (opt-line)
                            (plist-get (org-export--parse-option-keyword opt-line 'latex)
                                       :latex-font-set))
                          (cdar (org-collect-keywords '("OPTIONS"))))))
              org-latex-default-fontset))))
    (cons (intern (car (split-string fontset-spec "-")))
          (when (cadr (split-string fontset-spec "-"))
            (intern (concat ":" (cadr (split-string fontset-spec "-"))))))))

(defun org-latex-fontset (&rest desired-styles)
  "Generate a LaTeX preamble snippet which applies the current fontset for DESIRED-STYLES."
  (let* ((fontset-spec (org-latex-fontset-entry))
         (fontset (alist-get (car fontset-spec) org-latex-fontsets)))
    (if fontset
        (concat
         (mapconcat
          (lambda (style)
            (when (plist-get fontset style)
              (concat (plist-get fontset style) "\n")))
          desired-styles
          "")
         (when (memq (cdr fontset-spec) desired-styles)
           (pcase (cdr fontset-spec)
             (:serif "\\renewcommand{\\familydefault}{\\rmdefault}\n")
             (:sans "\\renewcommand{\\familydefault}{\\sfdefault}\n")
             (:mono "\\renewcommand{\\familydefault}{\\ttdefault}\n"))))
      (error "Font-set %s is not provided in org-latex-fontsets" (car fontset-spec)))))
#+end_src

Now that all the functionality has been implemented, we should hook it into our
preamble generation.

#+begin_src emacs-lisp
(add-to-list 'org-export-conditional-features '(org-latex-default-fontset . custom-font) t)
(add-to-list 'org-latex-feature-implementations (list 'custom-font :snippet (lambda (_info) (org-latex-fontset :serif :sans :mono)) :order 0) t)
(add-to-list 'org-latex-feature-implementations (list '.custom-maths-font :eager t :when '(custom-font maths) :snippet (lambda (_info) (org-latex-fontset :maths)) :order 0.3) t)
#+end_src

Finally, we just need to add some fonts.

#+begin_src emacs-lisp
(defvar org-latex-fontsets
  '((cm nil) ; computer modern
    (## nil) ; no font set
    (alegreya
     :serif "\\usepackage[osf]{Alegreya}"
     :sans "\\usepackage{AlegreyaSans}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (biolinum
     :serif "\\usepackage[osf]{libertineRoman}"
     :sans "\\usepackage[sfdefault,osf]{biolinum}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[libertine,varvw]{newtxmath}")
    (fira
     :sans "\\usepackage[sfdefault,scale=0.85]{FiraSans}"
     :mono "\\usepackage[scale=0.80]{FiraMono}"
     :maths "\\usepackage{newtxsf} % change to firamath in future?")
    (kp
     :serif "\\usepackage{kpfonts}")
    (newpx
     :serif "\\usepackage{newpxtext}"
     :sans "\\usepackage{gillius}"
     :mono "\\usepackage[scale=0.9]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (noto
     :serif "\\usepackage[osf]{noto-serif}"
     :sans "\\usepackage[osf]{noto-sans}"
     :mono "\\usepackage[scale=0.96]{noto-mono}"
     :maths "\\usepackage{notomath}")
    (plex
     :serif "\\usepackage{plex-serif}"
     :sans "\\usepackage{plex-sans}"
     :mono "\\usepackage[scale=0.95]{plex-mono}"
     :maths "\\usepackage{newtxmath}") ; may be plex-based in future
    (source
     :serif "\\usepackage[osf,semibold]{sourceserifpro}"
     :sans "\\usepackage[osf,semibold]{sourcesanspro}"
     :mono "\\usepackage[scale=0.92]{sourcecodepro}"
     :maths "\\usepackage{newtxmath}") ; may be sourceserifpro-based in future
    (times
     :serif "\\usepackage{newtxtext}"
     :maths "\\usepackage{newtxmath}"))
  "Alist of fontset specifications.
Each car is the name of the fontset (which cannot include \"-\").

Each cdr is a plist with (optional) keys :serif, :sans, :mono, and :maths.
A key's value is a LaTeX snippet which loads such a font.")
#+end_src

When we're using Alegreya we can apply a lovely little tweak to =tabular= which
(locally) changes the figures used to lining fixed-width.

#+begin_src emacs-lisp
(add-to-list 'org-export-conditional-features (list (lambda (_info) (string= (car (org-latex-fontset-entry)) "alegreya")) 'alegreya-typeface))
(add-to-list 'org-latex-feature-implementations '(alegreya-typeface) t)
(add-to-list 'org-latex-feature-implementations'(.alegreya-tabular-figures :eager t :when (alegreya-typeface table) :order 0.5 :snippet "
\\makeatletter
% tabular lining figures in tables
\\renewcommand{\\tabular}{\\AlegreyaTLF\\let\\@halignto\\@empty\\@tabular}
\\makeatother\n") t)
#+end_src

Due to Alegreya's metrics, the =\LaTeX= symbol doesn't quite look right. We
can correct for this by redefining it with subtlety shifted kerning.

#+begin_src emacs-lisp
(add-to-list 'org-export-conditional-features '("LaTeX" . latex-symbol))
(add-to-list 'org-latex-feature-implementations '(latex-symbol :when alegreya-typeface :order 0.5 :snippet "
\\makeatletter
% Kerning around the A needs adjusting
\\DeclareRobustCommand{\\LaTeX}{L\\kern-.24em%
        {\\sbox\\z@ T%
         \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts
                              \\fontsize\\sf@size\\z@
                              \\math@fontsfalse\\selectfont
                              A}%
                        \\vss}%
        }%
        \\kern-.10em%
        \\TeX}
\\makeatother\n") t)
#+end_src

**** Maths notation conveniences
:PROPERTIES:
:header-args:LaTeX: :noweb-ref latex-maths-conveniences
:END:

Maths has a way of popping up relentlessly. I think this says something both
about me and the subject itself. While the LaTeX set of commands is quite
reasonable, we can make a few common bits of notation a tad more convenient.

***** Packages

First, there are a few useful packages we want to use.

#+begin_src LaTeX
%% Maths-related packages
% More maths environments, commands, and symbols.
\usepackage{amsmath, amssymb}
% Slanted fractions with \sfrac{a}{b}, in text and maths.
\usepackage{xfrac}
% Visually cancel expressions with \cancel{value} and \cancelto{expression}{value}
\usepackage[makeroom]{cancel}
% Improvements on amsmath and utilities for mathematical typesetting
\usepackage{mathtools}
#+end_src

***** Custom delimiters

Next up we want to make the various types of rounding-related and absolute value
delimitors accessible as commands.

#+begin_src LaTeX
% Deliminators
\DeclarePairedDelimiter{\abs}{\lvert}{\rvert}
\DeclarePairedDelimiter{\norm}{\lVert}{\rVert}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}
\DeclarePairedDelimiter{\round}{\lfloor}{\rceil}
#+end_src

***** Number sets

Then we have the various common number sets, it would be nice to have a
convenient way of typing them and optionally giving them powers. It's fairly
easy to support both =\XX= and =\XX[n]=.

#+begin_src LaTeX
\newcommand{\RR}[1][]{\ensuremath{\ifstrempty{#1}{\mathbb{R}}{\mathbb{R}^{#1}}}} % Real numbers
\newcommand{\NN}[1][]{\ensuremath{\ifstrempty{#1}{\mathbb{N}}{\mathbb{N}^{#1}}}} % Natural numbers
\newcommand{\ZZ}[1][]{\ensuremath{\ifstrempty{#1}{\mathbb{Z}}{\mathbb{Z}^{#1}}}} % Integer numbers
\newcommand{\QQ}[1][]{\ensuremath{\ifstrempty{#1}{\mathbb{Q}}{\mathbb{Q}^{#1}}}} % Rational numbers
\newcommand{\CC}[1][]{\ensuremath{\ifstrempty{#1}{\mathbb{C}}{\mathbb{C}^{#1}}}} % Complex numbers
#+end_src

***** Derivatives

Derivatives are actually a bit of a pain to typeset, it would be nice to have a
=\dv= command that supports:
+ =\dv{x}= for the derivative with respect to =x=
+ =\dv{f}{x}= for the derivative of =f= with respect to =x=
+ =\dv[2]{f}{x}= for the second order derivative of =f= with respect to =x=

Similarly, it would be nice to have a partial derivate counterpart =\pdv= which behaves
the same way.

#+begin_src LaTeX
% Easy derivatives
\ProvideDocumentCommand\dv{o m g}{%
  \ensuremath{%
    \IfValueTF{#3}{%
      \IfNoValueTF{#1}{%
        \frac{\dd #2}{\dd #3}%
      }{\frac{\dd^{#1} #2}{\dd #3^{#1}}%
      }}{%
      \IfNoValueTF{#1}{%
        \frac{\dd}{\dd #2}%
      }{\frac{\dd^{#1}}{\dd #2^{#1}}}}}}
% Easy partial derivatives
\ProvideDocumentCommand\pdv{o m g}{%
  \ensuremath{%
    \IfValueTF{#3}{%
      \IfNoValueTF{#1}{%
        \frac{\partial #2}{\partial #3}%
      }{\frac{\partial^{#1} #2}{\partial #3^{#1}}%
      }}{%
      \IfNoValueTF{#1}{%
        \frac{\partial}{\partial #2}%
      }{\frac{\partial^{#1}}{\partial #2^{#1}}}}}}
#+end_src

***** Common operators

The default set of operators could benefit from a bit of expansion.

#+begin_src LaTeX
% Laplacian
\DeclareMathOperator{\Lap}{\mathcal{L}}

% Statistics
\DeclareMathOperator{\Var}{Var} % varience
\DeclareMathOperator{\Cov}{Cov} % covarience
\newcommand{\EE}{\ensuremath{\mathbb{E}}} % expected value
\DeclareMathOperator{\E}{E} % expected value
#+end_src

***** Slanted inequalities

As a matter of personal taste, I prefer the slanted less/greater than or equal
to operators, and would like to use them by default.

#+begin_src LaTeX
% I prefer the slanted \leq/\geq
\let\barleq\leq % Save them in case they're every wanted
\let\bargeq\geq
\renewcommand{\leq}{\leqslant}
\renewcommand{\geq}{\geqslant}
#+end_src

***** Alignment of matrix columns

By default, everything in a matrix is centred, which I actually find often
undesirable. It would be much nicer to take the alignment as an optional
argument of the environment, and default to right-alignment.

#+begin_src LaTeX
% Redefine the matrix environment to allow for alignment
% via an optional argument, and use r as the default.
\makeatletter
\renewcommand*\env@matrix[1][r]{\hskip -\arraycolsep%
    \let\@ifnextchar\new@ifnextchar
    \array{*\c@MaxMatrixCols #1}}
\makeatother
#+end_src

***** Slanted derivative "d"

Determining an appropriate styling for a derivative "d" (e.g. "dx") is
surprisingly hard, as the "d" is neither:
+ An operator (which are typeset as upright roman)
+ A variable (which are typet as italic roman)

The ISO 80000-2 standard (2009) specifies that it should be upright, however (a)
it is still not an operator, (b) not used in any maths book I've seen, and (c)
doesn't look very good. I'm not entirely comfortable with the variable styling
either though, so perhaps something else is in order?

After trying a few different options, I rather like the idea of using a /slanted
roman "d"/. This stylistically works for me, while being just distinct enough
from other faces. As long as we are creating a PDF, we can apply a transform
that slants a "d".

#+begin_src LaTeX
% Slanted roman "d" for derivatives
\ifnum\pdfoutput<1 % DVI
  \newcommand{\slantedromand}{d} % fallback
\else % PDF
  \newsavebox\diffdbox{}
  \newcommand{\slantedromand}{{\mathpalette\makesl{d}}}
  \newcommand{\makesl}[2]{%
    \begingroup
    \sbox{\diffdbox}{$\mathsurround=0pt#1\mathrm{#2}$}%
    \pdfsave%
    \pdfsetmatrix{1 0 0.2 1}%
    \rlap{\usebox{\diffdbox}}%
    \pdfrestore%
    \hskip\wd\diffdbox%
    \endgroup}
\fi
#+end_src

Now there's the matter of /placing/ the "d", or rather adjusting the space around
it. After much fiddling, I've ended up with the following.

#+begin_src LaTeX
% Derivative d^n, nicely spaced
\makeatletter
\newcommand{\dd}[1][]{\mathop{}\!%
  \expandafter\ifx\expandafter&\detokenize{#1}&% \ifstrempty from etoolbox
    \slantedromand\@ifnextchar^{\hspace{0.2ex}}{\hspace{0.1ex}}
  \else
    \slantedromand\hspace{0.2ex}^{#1}
  \fi}
\makeatother
#+end_src

**** Cover page

To make a nice cover page, a simple method that comes to mind is just redefining
=\maketitle=. To get precise control over the positioning we'll use the =tikz=
package, and then add in the Tikz libraries =calc= and =shapes.geometric= to make
some nice decorations for the background.

I'll start off by setting up the required additions to the preamble.
This will accomplish the following:
+ Load the required packages
+ Redefine =\maketitle=
+ Draw an Org icon with Tikz to use in the cover page (it's a little easter egg)
+ Start a new page after the table of contents by redefining =\tableofcontents=

#+name: latex-cover-page
#+begin_src LaTeX
\usepackage{tikz}
\usetikzlibrary{shapes.geometric}
\usetikzlibrary{calc}

\newsavebox\orgicon
\begin{lrbox}{\orgicon}
  \begin{tikzpicture}[y=0.80pt, x=0.80pt, inner sep=0pt, outer sep=0pt]
    \path[fill=black!6] (16.15,24.00) .. controls (15.58,24.00) and (13.99,20.69) .. (12.77,18.06)arc(215.55:180.20:2.19) .. controls (12.33,19.91) and (11.27,19.09) .. (11.43,18.05) .. controls (11.36,18.09) and (10.17,17.83) .. (10.17,17.82) .. controls (9.94,18.75) and (9.37,19.44) .. (9.02,18.39) .. controls (8.32,16.72) and (8.14,15.40) .. (9.13,13.80) .. controls (8.22,9.74) and (2.18,7.75) .. (2.81,4.47) .. controls (2.99,4.47) and (4.45,0.99) .. (9.15,2.41) .. controls (14.71,3.99) and (17.77,0.30) .. (18.13,0.04) .. controls (18.65,-0.49) and (16.78,4.61) .. (12.83,6.90) .. controls (10.49,8.18) and (11.96,10.38) .. (12.12,11.15) .. controls (12.12,11.15) and (14.00,9.84) .. (15.36,11.85) .. controls (16.58,11.53) and (17.40,12.07) .. (18.46,11.69) .. controls (19.10,11.41) and (21.79,11.58) .. (20.79,13.08) .. controls (20.79,13.08) and (21.71,13.90) .. (21.80,13.99) .. controls (21.97,14.75) and (21.59,14.91) .. (21.47,15.12) .. controls (21.44,15.60) and (21.04,15.79) .. (20.55,15.44) .. controls (19.45,15.64) and (18.36,15.55) .. (17.83,15.59) .. controls (16.65,15.76) and (15.67,16.38) .. (15.67,16.38) .. controls (15.40,17.19) and (14.82,17.01) .. (14.09,17.32) .. controls (14.70,18.69) and (14.76,19.32) .. (15.50,21.32) .. controls (15.76,22.37) and (16.54,24.00) .. (16.15,24.00) -- cycle(7.83,16.74) .. controls (6.83,15.71) and (5.72,15.70) .. (4.05,15.42) .. controls (2.75,15.19) and (0.39,12.97) .. (0.02,10.68) .. controls (-0.02,10.07) and (-0.06,8.50) .. (0.45,7.18) .. controls (0.94,6.05) and (1.27,5.45) .. (2.29,4.85) .. controls (1.41,8.02) and (7.59,10.18) .. (8.55,13.80) -- (8.55,13.80) .. controls (7.73,15.00) and (7.80,15.64) .. (7.83,16.74) -- cycle;
  \end{tikzpicture}
\end{lrbox}

\makeatletter
\g@addto@macro\tableofcontents{\clearpage}
\renewcommand\maketitle{
  \thispagestyle{empty}
  \hyphenpenalty=10000 % hyphens look bad in titles
  \renewcommand{\baselinestretch}{1.1}
  \NewCommandCopy{\oldtoday}{\today}
  \renewcommand{\today}{\LARGE\number\year\\\large%
    \ifcase \month \or Jan\or Feb\or Mar\or Apr\or May \or Jun\or Jul\or Aug\or Sep\or Oct\or Nov\or Dec\fi
    ~\number\day}
  \begin{tikzpicture}[remember picture,overlay]
    %% Background Polygons %%
    \foreach \i in {2.5,...,22} % bottom left
    {\node[rounded corners,black!3.5,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.west)+(2.5,-4.2)$) {} ;}
    \foreach \i in {0.5,...,22} % top left
    {\node[rounded corners,black!5,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {} ;}
    \node[rounded corners,fill=black!4,regular polygon,regular polygon sides=6, minimum size=5.5 cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {};
    \foreach \i in {0.5,...,24} % top right
    {\node[rounded corners,black!2,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {} ;}
    \node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2.5 cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {};
    \foreach \i in {21,...,3} % bottom right
    {\node[black!3,rounded corners,draw,regular polygon,regular polygon sides=6, minimum size=\i cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {} ;}
    \node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2 cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {};
    \node[align=center, scale=1.4] at ($(current page.south east)+(-1.5,0.75)$) {\usebox\orgicon};
    %% Text %%
    \node[left, align=right, black, text width=0.8\paperwidth, minimum height=3cm, rounded corners,font=\Huge\bfseries] at ($(current page.north east)+(-2,-8.5)$)
    {\@title};
    \node[left, align=right, black, text width=0.8\paperwidth, minimum height=2cm, rounded corners, font=\Large] at ($(current page.north east)+(-2,-11.8)$)
    {\scshape \@author};
    \renewcommand{\baselinestretch}{0.75}
    \node[align=center,rounded corners,fill=black!3,text=black,regular polygon,regular polygon sides=6, minimum size=2.5 cm,inner sep=0, font=\Large\bfseries ] at ($(current page.west)+(2.5,-4.2)$)
    {\@date};
  \end{tikzpicture}
  \let\today\oldtoday
  \clearpage}
\makeatother
#+end_src

Now we've got a nice cover page to work with, we just need to use it every now
and then. Adding this to =#+options= feels most appropriate.
Let's have the =coverpage= option accept =auto= as a value and then decide whether
or not a cover page should be used based on the word count --- I'll have this be
the global default. Then we just want to insert a LaTeX snippet tweak the
subtitle format to use the cover page.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(defvar org-latex-cover-page 'auto
  "When t, use a cover page by default.
When auto, use a cover page when the document's wordcount exceeds
`org-latex-cover-page-wordcount-threshold'.

Set with #+option: coverpage:{yes,auto,no} in org buffers.")
(defvar org-latex-cover-page-wordcount-threshold 5000
  "Document word count at which a cover page will be used automatically.
This condition is applied when cover page option is set to auto.")
(defvar org-latex-subtitle-coverpage-format "\\\\\\bigskip\n\\LARGE\\mdseries\\itshape\\color{black!80} %s\\par"
  "Variant of `org-latex-subtitle-format' to use with the cover page.")
(defvar org-latex-cover-page-maketitle
  <<grab("latex-cover-page")>>
  "LaTeX preamble snippet that sets \\maketitle to produce a cover page.")

(eval '(cl-pushnew '(:latex-cover-page nil "coverpage" org-latex-cover-page)
                   (org-export-backend-options (org-export-get-backend 'latex))))

(defun org-latex-cover-page-p ()
  "Whether a cover page should be used when exporting this Org file."
  (pcase (or (car
              (delq nil
                    (mapcar
                     (lambda (opt-line)
                       (plist-get (org-export--parse-option-keyword opt-line 'latex) :latex-cover-page))
                     (cdar (org-collect-keywords '("OPTIONS"))))))
             org-latex-cover-page)
    ((or 't 'yes) t)
    ('auto (when (> (count-words (point-min) (point-max)) org-latex-cover-page-wordcount-threshold) t))
    (_ nil)))

(defadvice! org-latex-set-coverpage-subtitle-format-a (contents info)
  "Set the subtitle format when a cover page is being used."
  :before #'org-latex-template
  (when (org-latex-cover-page-p)
    (setf info (plist-put info :latex-subtitle-format org-latex-subtitle-coverpage-format))))

(add-to-list 'org-latex-feature-implementations '(cover-page :snippet org-latex-cover-page-maketitle :order 9) t)
(add-to-list 'org-export-conditional-features (cons (lambda (_info) (org-latex-cover-page-p)) 'cover-page) t)
#+end_src

**** Condensed lists

LaTeX is generally pretty good by default, but it's /really/ generous with how
much space it puts between list items by default. I'm generally not a fan.

Thankfully this is easy to correct with a small snippet:
#+name: latex-condense-lists
#+begin_src LaTeX
\newcommand{\setuplistspacing}{\setlength{\itemsep}{-0.5ex}\setlength{\parskip}{1.5ex}\setlength{\parsep}{0pt}}
\let\olditem\itemize\renewcommand{\itemize}{\olditem\setuplistspacing}
\let\oldenum\enumerate\renewcommand{\enumerate}{\oldenum\setuplistspacing}
\let\olddesc\description\renewcommand{\description}{\olddesc\setuplistspacing}
#+end_src

Then we can just hook this in with our clever preamble.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(defvar org-latex-condense-lists t
  "Reduce the space between list items.")
(defvar org-latex-condensed-lists
  <<grab("latex-condense-lists")>>
  "LaTeX preamble snippet that reduces the space between list items.")

(add-to-list 'org-export-conditional-features (cons (lambda (_info) (and org-latex-condense-lists "^[ \t]*[-+]\\|^[ \t]*[1Aa][.)] ")) 'condensed-lists) t)
(add-to-list 'org-latex-feature-implementations '(condensed-lists :snippet org-latex-condensed-lists :order 0.7) t)
#+end_src

**** Pretty code blocks

We could just use minted for syntax highlighting --- however, we can do better!
The =engrave-faces= package lets us use Emacs' font-lock for syntax highlighting,
exporting that as LaTeX commands.

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! engrave-faces :recipe (:local-repo "lisp/engrave-faces"))
#+end_src

#+begin_src emacs-lisp
(use-package! engrave-faces-latex
  :after ox-latex)
#+end_src

Using this as in LaTeX exports is now as easy as

#+begin_src emacs-lisp
(setq org-latex-listings 'engraved)
#+end_src

One little annoyance with this is the interaction between microtype and =Verbatim=
environments. Protrusion is not desirable here. Thankfully, we can patch the
=Verbatim= environment to turn off protrusion locally.

#+begin_src emacs-lisp
(add-to-list
 'org-latex-feature-implementations
 '(.no-protrusion-in-code
   :snippet "\\ifcsname Code\\endcsname\n  \\let\\oldcode\\Code\\renewcommand{\\Code}{\\microtypesetup{protrusion=false}\\oldcode}\n\\fi"
   :when microtype
   :eager t
   :order 98.5) t)
#+end_src

At some point it would be nice to make the box colours easily customisable. At
the moment it's fairly easy to change the syntax highlighting colours with
src_elisp{(setq engrave-faces-preset-styles (engrave-faces-generate-preset))},
but perhaps a toggle which specifies whether to use the default values, the
current theme, or any named theme could be a good idea. It should also possible
to set the box background dynamically to match. The named theme could work by
looking for a style definition with a certain name in a cache dir, and then
switching to that theme and producing (and saving) the style definition if it
doesn't exist.

Now let's have the example block be styled similarly.

#+begin_src emacs-lisp
(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
  "Like `org-latex-example-block', but supporting an engraved backend"
  :around #'org-latex-example-block
  (let ((output-block (funcall orig-fn example-block contents info)))
    (if (eq 'engraved (plist-get info :latex-listings))
        (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
      output-block)))
#+end_src

In addition to the vastly superior visual output, this should also be much
faster to compile for code-heavy documents (like this config).

Performing a little benchmark with this document, I find that this is indeed the
case.

| LaTeX syntax highlighting backend | Compile time | Overhead | Overhead ratio |
|-----------------------------------+--------------+----------+----------------|
| verbatim                          | 12 s         | 0        |            0.0 |
| lstlistings                       | 15 s         | 3 s      |            0.2 |
| Engrave                           | 34 s         | 22 s     |            1.8 |
| Pygments (Minted)                 | 184 s        | 172 s    |           14.3 |
#+TBLFM: $3=$2-@2$2::$4=$3 / @2$2;%.1f

Treating the verbatim (no syntax highlighting) result as a baseline; this
rudimentary test suggest that =engrave-faces= is around eight times faster than
=pygments=, and takes three times as long as no syntax highlighting (verbatim).

**** Julia code blocks

Julia code has fantastic support for unicode! The downside is that =pdflatex= is
/still/ a pain to use with unicode symbols. The solution --- =lualatex=. Now we just
need to make it automatic

#+begin_src emacs-lisp
(defadvice! org-latex-pick-compiler (_contents info)
  :before #'org-latex-template
  :before #'org-beamer-template
  (when (and (memq 'code (plist-get info :features))
             (memq 'julia-code (plist-get info :features))
             (save-excursion
               (goto-char (point-min))
               (re-search-forward "[^\x00-\x7F\u200b]" nil t)))
    (setf info (plist-put
                (if (member #'+org-latex-replace-non-ascii-chars (plist-get info :filter-final-output))
                    (plist-put info :filter-final-output
                               (delq #'+org-latex-replace-non-ascii-chars (plist-get info :filter-final-output)))
                  info)
                :latex-compiler "lualatex"))))
#+end_src

Then a font with unicode support must be used. JuliaMono is the obvious choice,
and we can use it with the =fontspec= package. In future it may be nice to set
this just as a fallback font (when it isn't a pain to do so).

#+name: julia-mono-fontspec
#+begin_src LaTeX
\ifcsname directlua\endcsname
  \usepackage{fontspec}
  \newfontfamily\JuliaMono{JuliaMono-Regular.ttf}[Path=/usr/share/fonts/truetype/, Extension=.ttf]
  \newfontface\JuliaMonoRegular{JuliaMono-Regular}
  \setmonofont{JuliaMonoRegular}[Contextuals=Alternate, Scale=MatchLowercase]
\fi
#+end_src

Now all that remains is to hook this into the preamble generation.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(defvar org-latex-julia-mono-fontspec
  <<grab("julia-mono-fontspec")>>
  "LaTeX preamble snippet that sets LuaLaTeX's fontspec to use Julia Mono.")

(add-to-list 'org-latex-feature-implementations '(julia-code :when code :snippet org-latex-julia-mono-fontspec :order 0) t)
(add-to-list 'org-export-conditional-features '("^[ \t]*#\\+begin_src julia\\|^[ \t]*#\\+BEGIN_SRC julia\\|src_julia" . julia-code) t)

(add-to-list 'org-latex-feature-implementations '(.microtype-lualatex :eager t :when (microtype julia-code) :prevents microtype :order 0.1 :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,factor=2000]{microtype}\n"))
(add-to-list 'org-latex-feature-implementations (list '.custom-font-no-mono :eager t :prevents 'custom-font :order 0 :snippet (lambda (_info) (org-latex-fontset :serif :sans))) t)
#+end_src

**** Emojis

#+call: confpkg("ox-latex-emoji", after="ox-latex", prefix="")

It would be nice to actually include emojis where used.
Thanks to =emojify=, we have a folder of emoji images just sitting and waiting to
be used 🙂.

First up, we want to detect when emojis are actually present. Manually
constructing a regex for this would be a huge pain with the way the codepoints
are scattered around, but thanks to ~char-script-table~ we don't have to!

#+begin_src emacs-lisp
(defvar org-latex-emoji--rx
  (let (emojis)
    (map-char-table
     (lambda (char set)
       (when (eq set 'emoji)
         (push (copy-tree char) emojis)))
     char-script-table)
    (rx-to-string `(any ,@emojis)))
  "A regexp to find all emoji-script characters.")
#+end_src

Once we've found an Emoji, we would like to include it in LaTeX. We'll set up
the infrastructure for this with the help of two packages
+ =accsupp=, to provide the copy-paste text overlay
+ =transparent=, to provide invisible text to enable text copying at the image

With these packages we can insert an emoji image at the point and then place
some invisible text on-top of it that copies as the emoji codepoint.

Unfortunately though, =accsupp= doesn't seem to accept five digit hexadecimal
codepoints at this point in time, instead we need to convert to UTF-16 surrogate
pairs, so we'll give our =\DeclareEmoji= command two arguments: one for the
non-surrogate form required by =\DeclareUnicodeCharacter=, and another for the
surrogate form required by =\BeginAccSupp=.

#+name: latex-emoji-preamble
#+begin_src LaTeX
\usepackage{accsupp}
\usepackage{transparent}
\newsavebox\emojibox

\NewDocumentCommand\DeclareEmoji{m m}{% UTF-8 codepoint, UTF-16 codepoint
  \DeclareUnicodeCharacter{#1}{%
    \sbox\emojibox{\raisebox{OFFSET}{%
        \includegraphics[height=HEIGHT]{EMOJI-FOLDER/#1}}}%
    \usebox\emojibox
    \llap{%
      \resizebox{\wd\emojibox}{\height}{%
        \BeginAccSupp{method=hex,unicode,ActualText=#2}%
        \texttransparent{0}{X}%
        \EndAccSupp{}}}}}
#+end_src

Once we know that there are emojis present we can add a bit of preamble to the
buffer to make insertion easier.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(defconst org-latex-emoji-base-dir
  (expand-file-name "emojis/" doom-cache-dir)
  "Directory where emojis should be saved and look for.")

(defvar org-latex-emoji-sets
  '(("twemoji" :url "https://github.com/twitter/twemoji/archive/refs/tags/v14.0.2.zip"
     :folder "twemoji-14.0.2/assets/svg" :height "1.8ex" :offset "-0.3ex")
    ("twemoji-bw" :url "https://github.com/youdly/twemoji-color-font/archive/refs/heads/v11-release.zip"
     :folder "twemoji-color-font-11-release/assets/builds/svg-bw" :height "1.8ex" :offset "-0.3ex")
    ("openmoji" :url "https://github.com/hfg-gmuend/openmoji/releases/latest/download/openmoji-svg-color.zip"
     :height "2.2ex" :offset "-0.45ex")
    ("openmoji-bw" :url "https://github.com/hfg-gmuend/openmoji/releases/latest/download/openmoji-svg-black.zip"
     :height "2.2ex" :offset "-0.45ex")
    ("emojione" :url "https://github.com/joypixels/emojione/archive/refs/tags/v2.2.7.zip"
     :folder "emojione-2.2.7/assets/svg") ; Warning, poor coverage
    ("noto" :url "https://github.com/googlefonts/noto-emoji/archive/refs/tags/v2.038.zip"
     :folder "noto-emoji-2.038/svg" :file-regexp "^emoji_u\\([0-9a-f_]+\\)"
     :height "2.0ex" :offset "-0.3ex"))
  "An alist of plistst of emoji sets.
Specified with the minimal form:
  (\"SET-NAME\" :url \"URL\")
The following optional parameters are supported:
  :folder (defaults to \"\")
  The folder within the archive where the emojis exist.
  :file-regexp (defaults to nil)
  Pattern with the emoji code point as the first capture group.
  :height (defaults to \"1.8ex\")
  Height of the emojis to be used.
  :offset (defaults to \"-0.3ex\")
  Baseline offset of the emojis.")

(defconst org-latex-emoji-keyword
  "LATEX_EMOJI_SET"
  "Keyword used to set the emoji set from `org-latex-emoji-sets'.")

(defvar org-latex-emoji-preamble <<grab("latex-emoji-preamble")>>
  "LaTeX preamble snippet that will allow for emojis to be declared.
Contains the string \"EMOJI-FOLDER\" which should be replaced with
the path to the emoji folder.")

(defun org-latex-emoji-utf16 (char)
  "Return the pair of UTF-16 surrogates that represent CHAR."
  (list
   (+ #xD7C0 (ash char -10))
   (+ #xDC00 (logand char #x03FF))))

(defun org-latex-emoji-declaration (char)
  "Construct the LaTeX command declaring CHAR as an emoji."
  (format "\\DeclareEmoji{%X}{%s} %% %s"
          char
          (if (< char #xFFFF)
              (format "%X" char)
            (apply #'format "%X%X" (org-latex-emoji-utf16 char)))
          (capitalize (get-char-code-property char 'name))))

(defun org-latex-emoji-fill-preamble (emoji-folder &optional height offset svg-p)
  "Fill in `org-latex-emoji-preamble' with EMOJI-FOLDER, HEIGHT, and OFFSET.
If SVG-P is set \"includegraphics\" will be replaced with \"includesvg\"."
  (let* (case-fold-search
         (filled-preamble
          (replace-regexp-in-string
           "HEIGHT"
           (or height "1.8ex")
           (replace-regexp-in-string
            "OFFSET"
            (or offset "-0.3ex")
            (replace-regexp-in-string
             "EMOJI-FOLDER"
             (directory-file-name
              (if (getenv "HOME")
                  (replace-regexp-in-string
                   (regexp-quote (getenv "HOME"))
                   "\\string~"
                   emoji-folder t t)
                emoji-folder))
             org-latex-emoji-preamble t t)
            t t)
           t t)))
    (if svg-p
        (replace-regexp-in-string
         "includegraphics" "includesvg"
         filled-preamble t t)
      filled-preamble)))

(defun org-latex-emoji-setup (&optional info)
  "Construct a preamble snippet to set up emojis based on INFO."
  (let* ((emoji-set
          (or (org-element-map
                  (plist-get info :parse-tree)
                  'keyword
                (lambda (keyword)
                  (and (string= (org-element-property :key keyword)
                                org-latex-emoji-keyword)
                       (org-element-property :value keyword)))
                info t)
              (caar org-latex-emoji-sets)))
         (emoji-spec (cdr (assoc emoji-set org-latex-emoji-sets)))
         (emoji-folder
          (expand-file-name emoji-set org-latex-emoji-base-dir))
         (emoji-svg-only
          (and (file-exists-p emoji-folder)
               (not (cl-some
                     (lambda (path)
                       (not (string= (file-name-extension path) "svg")))
                     (directory-files emoji-folder nil "\\....$"))))))
    (cond
     ((not emoji-spec)
      (error "Emoji set `%s' is unknown. Try one of: %s" emoji-set
             (string-join (mapcar #'car org-latex-emoji-sets) ", ")))
     ((not (file-exists-p emoji-folder))
      (if (and (not noninteractive)
               (yes-or-no-p (format "Emoji set `%s' is not installed, would you like to install it?" emoji-set)))
          (org-latex-emoji-install
           emoji-set
           (or (executable-find "cairosvg") (executable-find "inkscape")))
        (error "Emoji set `%s' is not installed" emoji-set))))
    (concat
     (org-latex-emoji-fill-preamble
      emoji-folder (plist-get emoji-spec :height)
      (plist-get emoji-spec :offset) emoji-svg-only)
     "\n\n"
     (mapconcat
      #'org-latex-emoji-declaration
      (let (unicode-cars)
        (save-excursion
          (goto-char (point-min))
          (while (re-search-forward org-latex-emoji--rx nil t)
            (push (aref (match-string 0) 0) unicode-cars)))
        (cl-delete-duplicates unicode-cars))
      "\n")
     "\n")))

(add-to-list 'org-export-conditional-features
             (cons (lambda (_info)
                     (save-excursion
                       (goto-char (point-min))
                       (re-search-forward org-latex-emoji--rx nil t)))
                   'emoji)
             t)

(add-to-list 'org-latex-feature-implementations
             (list 'emoji :requires 'image :snippet #'org-latex-emoji-setup :order 3))
#+end_src

Unfortunately this isn't a global solution, as LuaLaTeX doesn't have
=\DeclareUnicodeCharacter=. However, we can fix this with a hack for the one case
when we know it will be used.

#+begin_src emacs-lisp
(add-to-list 'org-latex-feature-implementations
             '(.emoji-lualatex-hack
               :when (emoji julia-code) ; LuaLaTeX is used with julia-code.
               :eager t
               :snippet
               "\
\\usepackage{newunicodechar}
\\newcommand{\\DeclareUnicodeCharacter}[2]{%
    \\begingroup\\lccode`|=\\string\"#1\\relax
    \\lowercase{\\endgroup\\newunicodechar{|}}{#2}}"
               :order 2.9))
#+end_src

This works fairly nicely, there's just one little QOL upgrade that we can
perform. =emojify= downloads the ~72x72~ versions of Twemoji, however SVG versions
are also produced. We could use ~inkscape~ to convert those to PDFs, which would
likely be best for including.

This works fairly nicely, but it would be good to use =.pdf= forms whenever
possible. We can use =texdef= to check the file extension priority list.

#+begin_src shell :tangle no :exports both :results output verbatim :wrap example
texdef -t pdflatex -p graphicx Gin@extensions
#+end_src

#+RESULTS:
#+begin_example
\Gin@extensions:
macro:->.pdf,.png,.jpg,.mps,.jpeg,.jbig2,.jb2,.PDF,.PNG,.JPG,.JPEG,.JBIG2,.JB2,.eps
#+end_example

Fantastic! We can see that =.pdf= actually comes first in the priority list.
Now we just need to fetch and convert the emoji images.

#+begin_src emacs-lisp
(defun org-latex-emoji-install (set &optional convert)
  "Dowload, convert, and install emojis for use with LaTeX."
  (interactive
   (list (completing-read "Emoji set to install: "
                          (mapcar
                           (lambda (set-spec)
                             (if (file-exists-p (expand-file-name (car set-spec) org-latex-emoji-base-dir))
                                 (propertize (car set-spec) 'face 'font-lock-doc-face)
                               (car set-spec)))
                           org-latex-emoji-sets)
                          nil t)
         (if (or (executable-find "cairosvg") (executable-find "inkscape"))
             (yes-or-no-p "Would you like to create .pdf forms of the Emojis (strongly recommended)?")
           (message "Install `cairosvg' (recommended) or `inkscape' to convert to PDF forms")
           nil)))
  (let ((emoji-folder (expand-file-name set org-latex-emoji-base-dir)))
    (when (or (not (file-exists-p emoji-folder))
              (and (not noninteractive)
                   (yes-or-no-p "Emoji folder already present, would you like to re-download?")
                   (progn (delete-directory emoji-folder) t)))
      (let* ((spec (cdr (assoc set org-latex-emoji-sets)))
             (dir (org-latex-emoji-install--download set (plist-get spec :url)))
             (svg-dir (expand-file-name (or (plist-get spec :folder) "") dir)))
        (org-latex-emoji-install--install
         set svg-dir (plist-get spec :file-regexp))))
    (when convert
      (org-latex-emoji-install--convert (file-name-as-directory emoji-folder))))
  (message "Emojis set `%s' installed." set))

(defun org-latex-emoji-install--download (name url)
  "Download the emoji archive URL for the set NAME."
  (let* ((dest-folder (make-temp-file (format "%s-" name) t)))
    (message "Downloading %s..." name)
    (let ((default-directory dest-folder))
      (call-process "curl" nil nil nil "-sL" url "--output" "emojis.zip")
      (message "Unzipping")
      (call-process "unzip" nil nil nil "emojis.zip")
      dest-folder)))

(defun org-latex-emoji-install--install (name dir &optional filename-regexp)
  "Install the emoji files in DIR to the NAME set folder.
If a FILENAME-REGEXP, only files matching this regexp will be moved,
and they will be renamed to the first capture group of the regexp."
  (message "Installing %s emojis into emoji directory" name)
  (let ((images (append (directory-files dir t ".*.svg")
                        (directory-files dir t ".*.pdf")))
        (emoji-dir (file-name-as-directory
                    (expand-file-name name org-latex-emoji-base-dir))))
    (unless (file-exists-p emoji-dir)
      (make-directory emoji-dir t))
    (mapc
     (lambda (image)
       (if filename-regexp
           (when (string-match filename-regexp (file-name-nondirectory image))
             (rename-file image
                          (expand-file-name
                           (file-name-with-extension
                            (upcase (match-string 1 (file-name-nondirectory image)))
                            (file-name-extension image))
                           emoji-dir)
                          t))
         (rename-file image
                      (expand-file-name
                       (file-name-with-extension
                        (upcase (file-name-nondirectory image))
                        (file-name-extension image))
                       emoji-dir)
                      t)))
     images)
    (message "%d emojis installed" (length images))))

(defun org-latex-emoji-install--convert (dir)
  "Convert all .svg files in DIR to .pdf forms.
Uses cairosvg if possible, falling back to inkscape."
  (let ((default-directory dir))
    (if (executable-find "cairosvg") ; cairo's PDFs are ~10% smaller
        (let* ((images (directory-files dir nil ".*.svg"))
               (num-images (length images))
               (index 0)
               (max-threads (1- (string-to-number (shell-command-to-string "nproc"))))
               (threads 0))
          (while (< index num-images)
            (setf threads (1+ threads))
            (let (message-log-max)
              (message "Converting emoji %d/%d (%s)" (1+ index) num-images (nth index images)))
            (make-process :name "cairosvg"
                          :command (list "cairosvg" (nth index images) "-o" (concat (file-name-sans-extension (nth index images)) ".pdf"))
                          :sentinel (lambda (proc msg)
                                      (when (memq (process-status proc) '(exit signal))
                                        (setf threads (1- threads)))))
            (setq index (1+ index))
            (while (> threads max-threads)
              (sleep-for 0.01)))
          (while (> threads 0)
            (sleep-for 0.01)))
      (message "Cairosvg not found. Proceeding with inkscape as a fallback.")
      (shell-command "inkscape --batch-process --export-type='pdf' *.svg"))
    (message "Finished conversion!")))
#+end_src

**** Remove non-ascii chars

When using ~pdflatex~, almost non-ascii characters are generally problematic, and
don't appear in the pdf. It's preferable to see that there was /some/ character
which wasn't displayed as opposed to nothing.

We check every non-ascii character to make sure it's not a character encoded by
the =inputenc= packages when loaded with the =utf8= option. We'll also allow
box-drawing characters since they can be mostly supported with =pmboxdraw=.
Finally, we see if we have our own LaTeX conversion we can apply and if there is
none we replace the non-ascii char with =¿=.

No to make sure we only remove characters that can't be displayed, we check
=/usr/share/texmf/tex/latex/base/utf8enc.dfu=.

We just need to make sure this is appended to the list of filter functions,
since we want to let emoji processing occur first.

#+begin_src emacs-lisp
(defvar +org-pdflatex-inputenc-encoded-chars
  "[[:ascii:]\u00A0-\u01F0\u0218-\u021BȲȳȷˆˇ˜˘˙˛˝\u0400-\u04FFḂḃẞ\u200B\u200C\u2010-\u201E†‡•…‰‱‹›※‽⁄⁎⁒₡₤₦₩₫€₱℃№℗℞℠™Ω℧℮←↑→↓〈〉␢␣◦◯♪⟨⟩Ḡḡ\uFB00-\uFB06\u2500-\u259F]")

(defun +org-latex-replace-non-ascii-chars (text backend info)
  "Replace non-ascii chars with \\char\"XYZ forms."
  (when (and (org-export-derived-backend-p backend 'latex)
             (string= (plist-get info :latex-compiler) "pdflatex"))
    (let (case-replace)
      (replace-regexp-in-string "[^[:ascii:]]"
                                (lambda (nonascii)
                                  (if (or (string-match-p +org-pdflatex-inputenc-encoded-chars nonascii)
                                          (string-match-p org-latex-emoji--rx nonascii))
                                      nonascii
                                    (or (cdr (assoc nonascii +org-latex-non-ascii-char-substitutions))
                                        "¿")))
                                text))))

(add-to-list 'org-export-filter-plain-text-functions #'+org-latex-replace-non-ascii-chars t)
#+end_src

Now, there are some symbols that aren't included in =inputenc=, but we should be
able to handle anyway. For them we define a table of LaTeX translations

#+name: latex-non-ascii-char-substitutions
| Character | LaTeX |
|-----------+-------|
| ɑ          | \(\alpha\)  |
| β          | \(\beta\)  |
| γ          | \(\gamma\)  |
| δ          | \(\delta\)  |
| ε          | \(\epsilon\)  |
| ϵ          | \(\varepsilon\)  |
| ζ          | \(\zeta\)  |
| η          | \(\eta\)  |
| θ          | \(\theta\)  |
| ϑ         | \(\vartheta\) |
| ι          | \(\iota\)  |
| κ          | \(\kappa\)  |
| λ         | \(\lambda\) |
| μ         | \(\mu\) |
| ν          | \(\nu\)  |
| ξ          | \(\xi\)  |
| π         | \(\pi\) |
| ϖ         | \(\varpi\) |
| ρ          | \(\rho\)  |
| ϱ          | \(\varrho\)  |
| σ          | \(\sigma\)  |
| ς          | \(\varsigma\)  |
| τ          | \(\tau\)  |
| υ          | \(\upsilon\)  |
| ϕ         | \(\phi\) |
| φ         | \(\varphi\) |
| ψ         | \(\psi\) |
| ω         | \(\omega\) |
| Γ          | \(\Gamma\)  |
| Δ         | \(\Delta\) |
| Θ         | \(\Theta\) |
| Λ          | \(\Lambda\)  |
| Ξ         | \(\Xi\) |
| Π         | \(\Pi\) |
| Σ          | \(\Sigma\)  |
| Υ          | \(\Upsilon\)  |
| Φ         | \(\Phi\) |
| Ψ         | \(\Psi\) |
| Ω         | \(\Omega\) |
| א         | \(\aleph\)  |
| ב          | \(\beth\)  |
| ד          | \(\daleth\)  |
| ג          | \(\gimel\)  |

#+name: gen-latex-non-ascii-char-substitutions
#+begin_src emacs-lisp :noweb-ref none :var latex-non-ascii-char-substitutions=latex-non-ascii-char-substitutions
(replace-regexp-in-string
 " '((" "\n   '(("
 (replace-regexp-in-string
  ") (" ")\n     ("
  (prin1-to-string
   `(defvar +org-latex-non-ascii-char-substitutions
      ',(mapcar
         (lambda (entry)
           (cons (car entry) (replace-regexp-in-string "\\\\" "\\\\\\\\" (cadr entry))))
         latex-non-ascii-char-substitutions)))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<gen-latex-non-ascii-char-substitutions()>>
#+end_src

**** Normal spaces after abbreviations

In LaTeX inter-word and sentence spaces are typically of different widths. This
can be an issue when using abbreviations i.e. e.g. etc. et al..
This can be corrected by forcing a normal space with src_LaTeX{\ }.
When exporting Org documents, we can add a filter to check for common
abbreviations and make the space normal.

#+begin_src emacs-lisp
(defvar +org-latex-abbreviations
  '(;; Latin
    "cf." "e.g." "etc." "et al." "i.e." "v." "vs." "viz." "n.b."
    ;; Corperate
    "inc." "govt." "ltd." "pty." "dept."
    ;; Temporal
    "est." "c."
    ;; Honorifics
    "Prof." "Dr." "Mr." "Mrs." "Ms." "Miss." "Sr." "Jr."
    ;; Components of a work
    "ed." "vol." "sec." "chap." "pt." "pp." "op." "no."
    ;; Common usage
    "approx." "misc." "min." "max.")
  "A list of abbreviations that should be spaced correctly when exporting to LaTeX.")

(defun +org-latex-correct-latin-abbreviation-spaces (text backend _info)
  "Normalise spaces after Latin abbreviations."
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string (rx (group (or line-start space)
                                         (regexp (regexp-opt-group +org-latex-abbreviations)))
                                  (or line-end space))
                              "\\1\\\\ "
                              text)))

(add-to-list 'org-export-filter-paragraph-functions #'+org-latex-correct-latin-abbreviation-spaces t)
#+end_src

**** Extra special strings

LaTeX already recognises =---= and =--= as em/en-dashes, =\-= as a shy hyphen, and the
conversion of =...= to =\ldots{}= is hardcoded into ~org-latex-plain-text~ (unlike
~org-html-plain-text~).

I'd quite like to also recognise =->= and =<-=, so let's set come up with some advice.

#+begin_src emacs-lisp
(defvar org-latex-extra-special-string-regexps
  '(("<->" . "\\\\(\\\\leftrightarrow{}\\\\)")
    ("->" . "\\\\textrightarrow{}")
    ("<-" . "\\\\textleftarrow{}")))

(defun org-latex-convert-extra-special-strings (string)
  "Convert special characters in STRING to LaTeX."
  (dolist (a org-latex-extra-special-string-regexps string)
    (let ((re (car a))
          (rpl (cdr a)))
      (setq string (replace-regexp-in-string re rpl string t)))))

(defadvice! org-latex-plain-text-extra-special-a (orig-fn text info)
  "Make `org-latex-plain-text' handle some extra special strings."
  :around #'org-latex-plain-text
  (let ((output (funcall orig-fn text info)))
    (when (plist-get info :with-special-strings)
      (setq output (org-latex-convert-extra-special-strings output)))
    output))
#+end_src

**** Chameleon --- aka. match theme

#+call: confpkg("!Pkg ox-chameleon")

Once I had the idea of having the look of the LaTeX document produced match the
current Emacs theme, I was enraptured. The result is the pseudo-class ~chameleon~,
which I have implemented in the package =ox-chameleon=.

#+begin_src emacs-lisp :tangle packages.el
(package! ox-chameleon :recipe (:local-repo "lisp/ox-chameleon"))
#+end_src

#+begin_src emacs-lisp
(use-package! ox-chameleon
  :after ox)
#+end_src

**** Make verbatim different to code

Since have just gone to so much effort above let's make the most of it by making
=verbatim= use ~verb~ instead of ~protectedtexttt~ (default).

This gives the same advantages as mentioned in the [[*Make verbatim different to code][HTML export section]].

#+begin_src emacs-lisp
(setq org-latex-text-markup-alist
      '((bold . "\\textbf{%s}")
        (code . protectedtexttt)
        (italic . "\\emph{%s}")
        (strike-through . "\\sout{%s}")
        (underline . "\\uline{%s}")
        (verbatim . verb)))
#+end_src

**** Check for required packages

For how I've setup Org's LaTeX export, the following packages are needed:
#+name: org-latex-required-packages-list
| Package    | Description                                           |
|------------+-------------------------------------------------------|
| adjustbox  | Adjust general LaTeX material in like includegraphics |
| amsmath    | A near-essential maths package                        |
| booktabs   | Nice horizontal lines in tables                       |
| cancel     | Cancel terms in equations                             |
| capt-of    | Captions outside floats                               |
| caption    | Finer control over captions                           |
| cleveref   | Easy cross-referencing                                |
| embedall   | Embed files in the document                           |
| float      | Floating environments                                 |
| fontenc    | Font encodings                                        |
| fvextra    | Enhanced verbatim environments                        |
| graphicx   | An extended graphics package                          |
| hanging    | Used by oc-csl                                        |
| hyperref   | Links                                                 |
| inputenc   | Input file encodings                                  |
| longtable  | Multi-page tables                                     |
| mathalpha  | Set extended math alphabet fonts                      |
| mathtools  | Typesetting tools for maths                           |
| microtype  | Microtypography                                       |
| pdfx       | Create pdf/a- and pdf/x- compatible documents         |
| pifont     | A collection of symbols                               |
| preview    | Needed for AUCTeX and ob-latex                        |
| scrbase    | KOMA classes and more                                 |
| siunitx    | Proper unit support                                   |
| soul       | Strikethrough and underline, flexibly                 |
| subcaption | Form subfigures and subcaptions                       |
| svg        | Insert SVG images                                     |
| tikz       | Generally handy, as a dependancy and for graphics     |
| tcolorbox  | Nice boxes for code                                   |
| textcomp   | Font encodings                                        |
| xcolor     | Colours                                               |
| xparse     | Extended command/env definition forms                 |
| xcoffins   | Manipulate coffins (boxes) for typesetting            |

Then for the various fontsets:
#+name: org-latex-font-packages-list
+ Alegreya
+ arev
+ biolinum
+ FiraMono
+ FiraSans
+ fourier
+ gillius
+ kpfonts
+ libertine
+ newpxmath
+ newpxtext
+ newtxmath
+ newtxtext
+ newtxsf
+ noto
+ plex-mono
+ plex-sans
+ plex-serif
+ sourcecodepro
+ sourcesanspro
+ sourceserifpro

We can write a function which will check for each of these packages with
=kpsewhich=, and then if any of them are missing we'll inject some advice into the
generated config that gets a list of missing packages and warns us every time we
export to a PDF.

#+name: org-missing-latex-packages
#+begin_src emacs-lisp :noweb-ref none :var org-latex-required-packages-list=org-latex-required-packages-list[,0] :var org-latex-font-packages-list=org-latex-font-packages-list
(setq org-required-latex-packages
      (append org-latex-required-packages-list
              org-latex-font-packages-list))

(defun check-for-latex-packages (packages)
  (delq nil (mapcar (lambda (package)
                      (unless
                          (= 0 (call-process "kpsewhich" nil nil nil (concat package ".sty")))
                        package))
                    packages)))

(if-let ((missing-pkgs (check-for-latex-packages org-required-latex-packages)))
    (concat
     (pp-to-string `(setq org-required-latex-packages ',org-required-latex-packages))
     (message ";; Detected missing LaTeX packages: %s\n" (mapconcat #'identity missing-pkgs ", "))
     (pp-to-string
      '(defun check-for-latex-packages (packages)
         (delq nil (mapcar (lambda (package)
                             (unless
                                 (= 0 (call-process "kpsewhich" nil nil nil (concat package ".sty")))
                               package))
                           packages))))
     (pp-to-string
      '(defun +org-warn-about-missing-latex-packages (&rest _)
         (message "Checking for missing LaTeX packages...")
         (sleep-for 0.4)
         (if-let (missing-pkgs (check-for-latex-packages org-required-latex-packages))
             (message "%s You are missing the following LaTeX packages: %s."
                      (propertize "Warning!" 'face '(bold warning))
                      (mapconcat (lambda (pkg) (propertize pkg 'face 'font-lock-variable-name-face))
                                 missing-pkgs
                                 ", "))
           (message "%s You have all the required LaTeX packages. Run %s to make this message go away."
                    (propertize "Success!" 'face '(bold success))
                    (propertize "doom sync" 'face 'font-lock-keyword-face))
           (advice-remove 'org-latex-export-to-pdf #'+org-warn-about-missing-latex-packages))
         (sleep-for 1)))
     (pp-to-string
      '(advice-add 'org-latex-export-to-pdf :before #'+org-warn-about-missing-latex-packages)))
  ";; No missing LaTeX packags detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<org-missing-latex-packages()>>
#+end_src

*** Beamer Export


It's nice to use a different theme
#+begin_src emacs-lisp
(setq org-beamer-theme "[progressbar=foot]metropolis")
#+end_src

When using metropolis though, we want to make a few tweaks:
#+name: beamer-metropolis-tweaks
#+begin_src LaTeX
\NewCommandCopy{\moldusetheme}{\usetheme}
\renewcommand*{\usetheme}[2][]{\moldusetheme[#1]{#2}
  \setbeamertemplate{items}{$\bullet$}
  \setbeamerfont{block title}{size=\normalsize, series=\bfseries\parbox{0pt}{\rule{0pt}{4ex}}}}

\makeatletter
\newcommand{\setmetropolislinewidth}{
  \setlength{\metropolis@progressinheadfoot@linewidth}{1.2px}}
\makeatother

\usepackage{etoolbox}
\AtEndPreamble{\setmetropolislinewidth}
#+end_src

Now let's just apply this along with some extra beamer tweaks.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(defun org-beamer-p (info)
  (eq 'beamer (and (plist-get info :back-end)
                   (org-export-backend-name (plist-get info :back-end)))))

(add-to-list 'org-export-conditional-features
             '(org-beamer-p . beamer) t)
(add-to-list 'org-latex-feature-implementations
             '(beamer :requires .missing-koma :prevents (italic-quotes condensed-lists)) t)
(add-to-list 'org-latex-feature-implementations
             '(.missing-koma :snippet "\\usepackage{scrextend}" :order 2) t)

(defvar org-beamer-metropolis-tweaks
  <<grab("beamer-metropolis-tweaks")>>
  "LaTeX preamble snippet that tweaks the Beamer metropolis theme styling.")

(add-to-list 'org-export-conditional-features
             (cons (lambda (info)
                     (and (org-beamer-p info)
                          (string-match-p "metropolis$" org-beamer-theme)))
                   'beamer-metropolis)
             t)
(add-to-list 'org-latex-feature-implementations
             '(beamer-metropolis :requires beamer :snippet org-beamer-metropolis-tweaks :order 3) t)
#+end_src

And I think that it's natural to divide a presentation into sections, e.g.
Introduction, Overview... so let's set bump up the headline level that becomes a
frame from ~1~ to ~2~.
#+begin_src emacs-lisp
(setq org-beamer-frame-level 2)
#+end_src


* [[https://www.gonsie.com/blorg/org-highlight.html][Highlighting in Org-Mode]]
:PROPERTIES:
:ID:       2b786d93-643e-48d6-b4fc-18331e8e9821
:END:

June 09, 2019

I use org-mode to take a lot of notes and I frequently want to highlight some terms that I'm defining or a key sentence. Overall, I want two things:

1. I would like to add some markup syntax which will highlight a word or phrase, using ‘:' to mark the start and end of the phrase (similar to bold or italic markup).
2. When I export this markup through HTML (or markdown) it the markup should get converted to the HTML5 =<mark>= tag.

*** Extending Org Syntax
   :PROPERTIES:
   :CUSTOM_ID: extending-org-syntax
   :END:
Extending the org syntax isn't the most straightforward. At first, I tried to modify the =org-emphasis-alist= variable, but that didn't seem to work. Instead, I was able to extend =org-font-lock= with an extra regex.

#+begin_example
(defun org-add-my-extra-markup ()
  "Add highlight emphasis."
  (add-to-list 'org-font-lock-extra-keywords
               '("[^\\w]\\(:\\[^\n\r\t]+:\\)[^\\w]"
                 (1 '(face highlight invisible nil)))))

(add-hook 'org-font-lock-set-keywords-hook #'org-add-my-extra-markup)
#+end_example

The elisp regular expression isn't the easiest to understand, but this is what it matches:

| Regex      | Explanation                                                             |
|------------+-------------------------------------------------------------------------|
| =[^\\w]=     | something that's not a word                                             |
| =\\(=        | start of a capture group (not matching)                                 |
| =:=          | a colon                                                                 |
| =[^\n\r\t]+= | a string of 1 or more characters that doesn't contain new-lines or tabs |
| =:=          | a colon                                                                 |
| =\\)=        | end of the capture group (not matching)                                 |
| =[^\\w]=     | something that's not a word                                             |

The start-and-end matching of something that's not a word means that colons in the middle of a URL are not matched and that the highlighted text can be followed by punctuation. The parenthesis create a capture group, which is used later to define what has the highlight face. Here is a diagram to try and explain the different pieces:

#+begin_example
'("[^\\w]\\(:\\[^\n\r\t]+:\\)[^\\w]" (1 '(face highlight invisible nil)))
  |      '--capture group---'      |  |  '--face definition-----------'
  '--regular expression to match---'  '--capture group number
#+end_example

*** Exporting HTML
   :PROPERTIES:
   :CUSTOM_ID: exporting-html
   :END:
The next step is to extend the org-exporter. This is easily done and a working example is even provided by [[https://orgmode.org/manual/Advanced-Export-Configuration.html#Advanced-Export-Configuration][export engine manual]]. I simply create a filter for any backend built on top of html (which should include my markdown and jekyll-md exporters).

#+begin_example
(defun my-html-mark-tag (text backend info)
  "Transcode :blah: into <mark>blah</mark> in body text."
  (when (org-export-derived-backend-p backend 'html)
    (let ((text (replace-regexp-in-string "[^\\w]\\(:\\)[^\n\t\r]+\\(:\\)[^\\w]" "<mark>"  text nil nil 1 nil)))
      (replace-regexp-in-string "[^\\w]\\(<mark>\\)[^\n\t\r]+\\(:\\)[^\\w]" "</mark>" text nil nil 2 nil))))

(add-to-list 'org-export-filter-plain-text-fucntions 'my-html-mark-tag)
#+end_example

I add this to my =org-config.el= file and success!

*** Alternatives
   :PROPERTIES:
   :CUSTOM_ID: alternatives
   :END:
Of course, org-mode already ships with some built-in highlighting functionality; namely, the syntax for defining a description list (which is a native HTML concept). The following org formatting can be used to create a description list:

#+begin_src org
- Emacs :: an extensible ,customizable, free/libre text editor
- Org mode :: keeping notes, maintaining TODO lists, planning projects, and authoring documents with a fast and effective plain-text system
#+end_src

Which becomes the following HTML:

#+begin_example
<dl>
<dt>Emacs</dt><dd>an extensible ,customizable, free/libre text editor</dd>
<dt>Org mode</dt><dd>keeping notes, maintaining TODO lists, planning projects, and authoring documents with a fast and effective plain-text system</dd>
</dl>
#+end_example

While this is a common use-case for highlighting, I don't always want my highlights to be in a list.

*** Final Example
   :PROPERTIES:
   :CUSTOM_ID: final-example
   :END:
Here is a very brief example of a highlighted phrase which was exported properly. I can also use this method to highlight a longer sentence, such as: Should I implement this highlighting syntax and export functionality into Orgmode itself?



* Email settings

Once you delve into the technical details, email is hard as it consists
of arcane specs and protocols.  Combined with Emacs' open-endedness as
well as the wealth of free software command-line programs on offer,
there are seemingly infinite ways to set things up.  The toolset for my
current setup consists of the following:

+ The external =mbsync= program to periodically synchronise my remote
  email server and my local mail directories.  This allows me to keep a
  copy of my correspondence, while it removes the burden of updating
  mail sources from the client.  The latter benefit is particularly
  important to avoid slowing down Emacs.

+ The Notmuch package which includes the CLI program and the Emacs
  library that implements a Mail User Agent.  Notmuch is a mail indexer
  that can search through the database using a strictly tags-only
  workflow.  I was using Gnus in the past (between early 2020 and May
  2021), but ultimately decided to upgrade my workflow by going with the
  more flexible approach of Notmuch (I had also used Mu4e before, which
  is closer in spirit to Notmuch and is a good choice overall---in the
  source code of my dotfiles, from where you can find this document,
  there is the =prot-mu4e-deprecated-conf.el= file in case you need it;
  same for =prot-gnus-deprecated-conf.org=).

+ The built-in capabilities to compose and send email.

+ Other extensions to integrate email composition with encryption tools,
  Dired, Org, contact-completion (EBDB)...

*This is a mega section that encompasses all of the aforementioned.*
Please study it carefully.

*** Client-agnostic email settings (and prot-mail.el)
:PROPERTIES:
:CUSTOM_ID: h:a82766be-daab-4925-b23a-1c5ffd47e599
:END:

Before configuring any mail user agent, we need to establish the
absolute essentials: who we are, where our authentication credentials
are stored, and whether encryption is to be supported.  We must also
define how message composition should work.  This is what the following
configurations are about.

+ The =mail-user-agent= and =message-mail-user-agent= concern the default
  email composition buffer, called with =C-x m= or any other facility that
  falls back to the =compose-mail= function.  The default is =message-mode=.

  - When notmuch is in use, it will insert a special "Fcc" header whose
    task is to copy the outgoing message to the appropriate maildir path
    (this part is done in [[#h:a196812e-1644-4536-84ba-687366867def][the Notmuch section]]).

+ The value of =message-citation-line-format= is expanded into something
  like /"On 2020-02-19, 13:54 +0200, NAME <EMAIL> wrote:"/.  To learn
  about all the date-related specifiers, it is better to read the
  documentation with =M-x describe-variable RET format-time-string RET=.

+ The =mm-encode= and =mml-sec= are meant to come into effect when
  encrypting and signing an outgoing message, such as with =C-c C-m C-e=
  (=mml-secure-message-sign-encrypt=).  The optional guided key selection
  will ask for confirmation on who to encrypt to.  It presents a list
  with the available keys.  Items are marked with =m= and then the mail
  can be sent with the standard commands (e.g. =C-c C-c=).  I used that
  setup for a while, but ultimately decided that the extra steps did not
  make any difference to my workflow, as I always double-check before
  sending out an email.

+ The =gnus-dired= library can be used independently of Gnus (and should
  thus be refactored as "message-dired.el" or something).  It provides
  glue code that integrates Dired buffers with message composition, so
  that one can attach either the file at point or the marked ones with
  =C-c C-m C-a= (=gnus-dired-attach=).

#+begin_src emacs-lisp :tangle no
;;; Client-agnostic email settings (and prot-mail.el)
(prot-emacs-builtin-package 'auth-source
  (setq auth-sources '("~/.authinfo.gpg"))
  (setq user-full-name "Protesilaos Stavrou")
  (setq user-mail-address "public@protesilaos.com"))

(prot-emacs-builtin-package 'mm-encode
  (setq mm-encrypt-option nil) ; use 'guided if you need more control
  (setq mm-sign-option nil))   ; same

(prot-emacs-builtin-package 'mml-sec
  (setq mml-secure-openpgp-encrypt-to-self t)
  (setq mml-secure-openpgp-sign-with-sender t)
  (setq mml-secure-smime-encrypt-to-self t)
  (setq mml-secure-smime-sign-with-sender t))

(prot-emacs-builtin-package 'message
  (setq mail-user-agent 'message-user-agent)
  (setq mail-header-separator (purecopy "*****"))
  (setq message-elide-ellipsis ">\n> [... %l lines elided]\n>\n>") ; NOTE 2021-07-13: experimental
  (setq compose-mail-user-agent-warnings nil)
  (setq message-mail-user-agent t)      ; use `mail-user-agent'
  (setq mail-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-citation-line-format "On %Y-%m-%d, %R %z, %f wrote:\n")
  (setq message-citation-line-function
        'message-insert-formatted-citation-line)
  (setq message-confirm-send nil)
  (setq message-kill-buffer-on-exit t)
  (setq message-wide-reply-confirm-recipients t)
  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

  (add-hook 'message-setup-hook #'message-sort-headers))

(prot-emacs-builtin-package 'gnus-dired ; does not require `gnus'
  (add-hook 'dired-mode-hook #'gnus-dired-mode))

(prot-emacs-builtin-package 'prot-mail
  ;; NOTE 2021-05-14: This is a generic indicator for new mail in the
  ;; maildir.  As I now use notmuch (see relevant section in this
  ;; document) I have an alternative approach in prot-notmuch.el.
  (setq prot-mail-maildir-path-regexp "~/.mail/*/Inbox/new/") ; shell regexp
  (setq prot-mail-mode-line-indicator-commands
        '(notmuch-refresh-this-buffer))
  ;; mode line indicator with the number of new mails
  (prot-mail-mail-indicator -1))
#+end_src

**** Sample of authinfo.gpg
:PROPERTIES:
:CUSTOM_ID: h:8d0bd754-8a31-431b-b112-f541cc0144ac
:END:

Below is a sample with the contents of my =authinfo.gpg=.  This is read,
inter alia, by =notmuch= and =smtpmail= to be able to both fetch and send
messages from the given account.  By default, one can use a generic
=authinfo= file though I consider that reckless: I strongly encourage you
to *encrypt this file* if you add your login credentials there.  Do it
from inside =dired= with =: e= while the point is over the file.  Emacs can
decrypt all encrypted files automatically.

#+begin_example
machine prv port 993 login MAIL password SECRET
machine inf port 993 login MAIL password SECRET
machine pub port 993 login MAIL password SECRET

machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
#+end_example

Refer to your email provider's documentation in order to determine the
port number and server address you need to use for sending and receiving
messages.  The =MAIL= is either your email address or some username for
logging into the account.

Note that the terms I use above for =prv=, =inf=, and =pub= are just arbitrary
names for the given =MAIL= and =SECRET= combination.  This allows me to
reference each name in the various package configurations in this
document, and share them publicly without worrying about leaking
sensitive data.

Which brings us to the point of actually retrieving those values.  The
=prot-mail-auth-get-field= is designed to return a field from the authinfo
file (this function is defined in my =prot-mail.el=, which is reproduced
at the end of [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).  You
will find this function used elsewhere in this document.  For example,
to get the username and password for host =inf= we do:

#+begin_example emacs-lisp :tangle no
(prot-mail-auth-get-field "inf" :user)   ; login name
(prot-mail-auth-get-field "inf" :secret) ; password
#+end_example

**** .mbsyncrc
:PROPERTIES:
:CUSTOM_ID: h:88a605b8-d5b5-486f-87c9-0c80b423ae36
:END:

I already noted in the introduction to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]] that my emails are
synced locally using the =mbsync= executable.  This program is part of a
package that, depending on your operating system, is called "isync".
Read the [[https://wiki.archlinux.org/index.php/Isync][Arch Wiki entry on mbsync]].

My =~/.mbsyncrc= is furnished below.  Note that the =awk= call reads from
the =~/.authinfo.gpg= (see [[#h:8d0bd754-8a31-431b-b112-f541cc0144ac][Sample of authinfo.gpg]]).

*** Notmuch (mail indexer and mail user agent (MUA))
:PROPERTIES:
:CUSTOM_ID: h:a196812e-1644-4536-84ba-687366867def
:END:

Also watch the video of what you are about to read in the following
paragraphs: [[https://protesilaos.com/codelog/2021-05-15-emacs-notmuch/][Demo of the Emacs front-end to Notmuch]] (2021-05-15).


At its core, Notmuch is a command-line program that maintains an index
of a maildir directory structure and is capable to search through it
using a tag-based method.  Notmuch is both minimalist and powerful:

1. its clearly delimited role as a mail indexer allows it to be used in
   a variety of setups that involve different tools on how to handle
   email traffic;

2. while its tag-centric design lifts the inherent restrictions of
   complex filesystem paths on where a file must be stored, as messages
   can be grouped together dynamically depending on the search criteria.

In terms of overall setup, I use Notmuch together with =mbsync= to
synchronise my maildir with the IMAP server (consult my [[#h:88a605b8-d5b5-486f-87c9-0c80b423ae36][.mbsyncrc]]).
While I send messages with Emacs' own facility which relies on the
=sendmail= program (refer to [[#h:2d793cf8-83f5-4830-b73d-78385d9b96dd][Sending email (SMTP)]]).  The latter may change
in the future, as I weigh the pros and cons of programs like =msmtp=,
though this is low on my list of priorities.  As for the actual
composition of emails, it is done by Emacs' =message.el= library
([[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

Tagging is integral to the Notmuch experience, because it allows you to
cope with evolving circumstances.  It is best to consider this by means
of an example.  Suppose that you are working on some project: (1) there
is an email in your private account from a close friend that contains
valuable information but which is part of an otherwise long thread that
is not pertinent in its entirety to the task at hand, (2) there is
another message from a mailing list you do not actively participate in
and this message lives in your "throwaway" account that you use only for
mailing lists and the like, and (3) there is yet another mail from some
client or employer that is specific to the project and which is kept in
your designated "professional" inbox.  Lets say that those correspond to
"private@example.tld", "lists@example.tld", "work@example.tld".  In a
folder-based approach, it is hard to combine those otherwise unrelated
files.  Whereas with tags, say, =+project=, we can get everything into
focus with a simple search for =tag:project=.

While we will be using the Emacs interface to Notmuch, it is important
to spend some time reading the man pages for the CLI tools.  Some
examples for searching:

#+begin_example
$ notmuch search from:prot*
$ notmuch search from:protesilaos tag:todo
$ notmuch search from:protesilaos or from:socrates
$ notmuch search 'from:"/(info|public)@protesilaos.com/"'
$ notmuch search 'from:"/(info|public)@protesilaos.com/"' date:yesterday..today
$ notmuch search '(from:"*@protesilaos.com*" not to:"*@protesilaos.com*")' date:today
$ notmuch search from:"*@protesilaos.com*" date:today..08:00
$ notmuch search body:recrudescence
$ notmuch search path:inf/Inbox/** date:2021-05
#+end_example

There is no need to develop expertise in that syntax at the outset.
Just learn the basics and let the rest grow organically through regular
usage.  Though do read the man pages as they include important
information such as what "stemming" is and how it affects your search
results.

Now let's focus on the Emacs side of things, starting with the
"notmuch-hello" buffer (it runs =notmuch-hello-mode=).  What exactly shows
up here depends on =notmuch-hello-sections=.  I like to keep it clean.  At
any rate, from here we can switch to results from saved searches or
tags, or perform a new search:

+ Type =j= to invoke =notmuch-jump-search=: it will produce a prompt for a
  key binding that corresponds to one of your saved searches (controlled
  by the variable =notmuch-saved-searches=).

+ With =t= for =notmuch-search-by-tag= you get minibuffer completion against
  all known tags.

+ Hit =s= to call =notmuch-search= which lets you type a query such as one
  of the aforementioned examples.  In the "notmuch-hello" buffer I keep
  a list of recent searches, which can be helpful to re-use at a later
  point, though we can always benefit from minibuffer history
  navigation, such as =M-n= and =M-p= while at the =notmuch-search= prompt.

+ Same principle for =z= (=notmuch-tree=) only it differs from the above
  search in the overall presentation where it visualises each thread
  using indentation and arrows to show what belongs where.  It also
  reduces the subject line to the first entry in each thread, making it
  easier to follow the results.

All of those will put you in a buffer that runs =notmuch-search-mode=.  As
always, you should use =C-h m= (=describe-mode=) to learn about everything
related to the current major mode (as well as all active minor modes).

To further limit the results to an arbitrary list of search criteria,
use =l= (=notmuch-search-filter=) and then supply whatever terms are needed.
Or use =t=, which is here bound to =notmuch-search-filter-by-tag= to filter
directly by tag using completion.  For example, I can start from the
"notmuch-hello" buffer with =notmuch-search-by-tag=, select "todo", and
then use =l= or =t= to further narrow to, say, a "replied" tag or
=date:today=.

Filtering of search results is the best way to narrow the list to
relevant matches.  You can try supplying just a search term without any
keywords and you are likely to get what you are looking for.  For
example, I was in a search that included results from the emacs-devel
and bug-gnu-emacs mailing lists and had several unread threads, though I
only wanted to read about "group-function".  So I just hit =l=
(=notmuch-search-filter=) and then typed in that query.  Same principle if
you wish to exclude something, such as with =not tag:flag=.

The Notmuch presentation is compact when it comes to longer threads as
it reduces them to a single line.  We can still get a sense of context
by viewing the total count of messages in the thread: this is controlled
by the variable =notmuch-search-result-format=.  While I like this as a
default, there are cases where we need to visualise the email exchanges:
=notmuch-tree-from-unthreaded-current-query= can do just that and is bound
to =Z= in =notmuch-search-mode-map=.  A similar variant is =U= for
=notmuch-unthreaded-from-search-current-query=, as it expands the view
without adding the tree indicators and without de-duplicating subject
lines across the threads.  Go back to the standard search view with =S=
(=notmuch-search-from-tree-current-query=).

All those changes in presentation happen in new buffers: you do not lose
anything, unless you explicitly kill those buffers.  For the sake of
convenience, Notmuch provides the =notmuch-bury-or-kill-this-buffer=
command, bound to =q= in all those views.  Read its doc string to know
when it kills and when it buries the buffer.  Of course, you may always
use commands like =previous-buffer= as well as minibuffer completion and
=M-x ibuffer= or whatever else you normally use.  The point is that you
can easily switch views to get the job done.

Speaking of multiple buffers, Notmuch provides two commands to refresh
those: (i) =notmuch-refresh-this-buffer=, which is bound by default to the
usual =g= key as well as ===, and (ii) =notmuch-refresh-all-buffers= which is
assigned to =M-g=.  My =prot-notmuch-refresh-buffer= is a wrapper of those
two and is mapped to =g=: when called with a =C-u= prefix argument, it
refreshes all buffers, else it operates on the current one.  There is
also =G= (=notmuch-poll-and-refresh-this-buffer=) which runs =notmuch new=
externally and then refreshes the buffer---personally I don't need this
as mbsync automatically does that every few minutes.

To read a thread, hit =RET= (=notmuch-search-show-thread=) with point over
it in any those search/tree views.  That puts you in =notmuch-show-mode=
(did I tell you about =C-h m=?).  Notmuch organises all messages in the
thread as headings, where the first line with the summary of the message
uses a special face (a background colour, though that depends on the
theme).  With point over the heading's line =RET= expands or contracts the
body of the message.  The =n= and =p= keys move between expanded messages in
the thread, while =N= and =P= always go to the next and previous items,
respectively.  An Imenu index is also available, so you can jump to any
heading using minibuffer completion (with =M-x imenu= or some third-party
extension like the =consult-imenu= that I use).

When you compose an email, such as by replying with =r= or =R=, you are
taken to a buffer that leverages functionality provided by the built-in
=message.el=.  As always, run =C-h m= to get a sense of how things work and
what commands you may call: =C-c C-c= dispatches the email, =C-c C-a=
prompts for an attachment, =C-c C-m C-e= encrypts and signs, =C-c C-m C-a=
from a Dired buffer attaches the file at point or any marked ones (refer
to [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

For searching to be productive, we must apply tags in accordance with a
defined method of organising our workflow (more about my approach
further below).  Too many over-specialised or poorly considered tags
will likely make things more difficult, while too few will probably
prevent you from finding what you need.  How you go about it is up to
you.  Notmuch is just a tool: don't believe in the hype of magical
exominds or second brains that do the work on your behalf---maximise the
potential of the one mind you have and the rest will follow from there.

Tag addition or removal is denoted by a plus or minus prefix to the name
of the tag.  The =k= binding exists in all relevant mode maps: it offers a
shortcut to the "keys" (tags) that can be used to mark a give entry.
That command will prompt for a choice among =notmuch-tagging-keys=.  For
example =k d= will do =+del -inbox=, based on what I currently have.  Invert
the meaning of those terms by prefixing the command with a =C-u= argument.

To freely tag all items in the current view (search, tree, show) use =*=.
That gives you a completion prompt where multiple terms can be supplied,
each delimited by a space (internally this is =completing-read-multiple=
and the space is governed by a let-bound =crm-separator=).  Combine that
with the aforementioned methods for limiting the view to a given subset
for maximum effect.

Other ways to perform tagging operations involve the =+= and =-= keys.  They
also use =completing-read-multiple=.  What those commands offer, beside
the minibuffer interface, is the ability to operate on the entries
encompassed by the active region, where point and mark delimit the lines
to be affected.  There are cases where marking a region is faster than
narrowing the view with new search criteria, so use whatever makes sense
at the moment.

Remember the governing principle of Notmuch: it does not touch your
mail.  All those tags are specific to the Notmuch database (with the
exception of some basic tags that are understood by the IMAP server and
can be optionally affected by Notmuch ([[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] has the
=synchronize_flags=true= directive).

As Notmuch is not a traditional mail client, it has neither opinions nor
capabilities on how one handles their maildir.  It does not move files
around nor does it have its own deletion and anti-spam mechanisms.  It
is up to the user to provide those.  While this may seem needlessly
limited at first, it is consistent with the precise function that
Notmuch performs in the broader email toolkit.  To actually delete mail,
we can tag it accordingly (e.g. "del") and then run this command either
manually or from a script with some cron job or systemd timer:

#+begin_example
notmuch search --output=files --format=text0 tag:del | xargs -r0 rm
#+end_example

I actually prefer the manual method: mark items with =+del= and perform
their removal from the disk whenever it is expedient.  This has the
upside of offering me the chance to review the messages, in case I have
mislabelled some item: I have deleted legitimate mail before, so it is
not a bad idea to be extra careful.

I have no pressing need to define commands for moving my mail files
between different directories: I did not do that even while I was using
Gnus.  Though I might eventually do it just for the sake of
completeness.  As such, consider the following package configurations a
work-in-progress, though they already offer all I need to get things
done.

With regard to the use of tags for day-to-day usage, I like to employ
the =tag:inbox and tag:unread= search as well as =tag:inbox= for practically
everything that is unsorted or of general interest.  Then I have
specialised tags like "list" for mailing lists which should not belong
in the inbox and "todo" for messages that require some further action
(those can always be complemented by other tags for greater precision
such as =+list +emacs=).  To keep things in check, a "post-new" script
outside the Emacs setup performs initial tagging on new mail.  For
example, my sent messages are marked as =-unread= while new mailing list
traffic goes to its right place with tags like =-inbox +list= (refer to
the sections on [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] and [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).  Those that
I manually mark as =+todo= can optionally be combined with =org-capture= to
record a task that may appear in the Org agenda: call the =org-capture=
command while viewing such a message and Org will create a direct link
back to it: the glue code is found in [[#h:a7580136-cf32-44e8-81f6-590dbdd7f8f9][the section on ol-notmuch.el]] while
my =org-capture-templates= and their =org-capture-templates-contexts= are
defined in [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]]).

Unlike most Emacs packages, I install =notmuch= from my distro's repos.
This is because (i) the CLI program is independent of Emacs, and (ii)
=notmuch.el= is bundled up together with the command-line tool because the
two are developed by the same group of people.  All good!  There is also
this note in =M-x find-library RET notmuch RET=:

#+begin_quote
Note for MELPA users (and others tracking the development version
of notmuch-emacs):

This emacs package needs a fairly closely matched version of the
notmuch program. If you use the MELPA version of notmuch.el (as
opposed to MELPA stable), you should be prepared to track the
master development branch (i.e. build from git) for the notmuch
program as well. Upgrading notmuch-emacs too far beyond the notmuch
program can CAUSE YOUR EMAIL TO STOP WORKING.

TL;DR: notmuch-emacs from MELPA and notmuch from distro packages is
NOT SUPPORTED.
#+end_quote

Finally, my =prot-notmuch.el= contains various commands and some minor
stylistic extras including a mode line indicator that shows a count of
all items matching the search terms =tag:unread and tag:inbox= (can be
configured by the variable =prot-notmuch-mode-line-search-args=).

#+begin_src emacs-lisp :tangle no
;;; Notmuch (mail indexer and mail user agent (MUA))
;; I install notmuch from the distro's repos because the CLI program is
;; not dependent on Emacs.  Though the package also includes notmuch.el
;; which is what we use here (they are maintained by the same people).
(add-to-list 'load-path "/usr/share/emacs/site-lisp/")
(prot-emacs-builtin-package 'notmuch

;;; Account settings
  (setq notmuch-identities
        (let ((identities))
          (dolist (m `(,(prot-mail-auth-get-field "prv" :user)
                       ,(prot-mail-auth-get-field "inf" :user)
                       ,(prot-mail-auth-get-field "pub" :user)))
            (push (format "%s <%s>" user-full-name m) identities))
          identities))
  (setq notmuch-fcc-dirs
        `((,(prot-mail-auth-get-field "prv" :user) . "prv/Sent")
          (,(prot-mail-auth-get-field "inf" :user) . "inf/Sent")
          (,(prot-mail-auth-get-field "pub" :user) . "pub/Sent")))

;;; General UI
  (setq notmuch-show-logo nil)
  (setq notmuch-column-control t)
  (setq notmuch-hello-auto-refresh t)
  (setq notmuch-hello-recent-searches-max 20)
  (setq notmuch-hello-thousands-separator "")
  ;; ;; See my variant of it in `prot-notmuch' below.
  ;; (setq notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (setq notmuch-show-all-tags-list nil)

;;; Search
  (setq notmuch-search-oldest-first nil)
  (setq notmuch-search-result-format
        '(("date" . "%12s  ")
          ("count" . "%-7s  ")
          ("authors" . "%-20s  ")
          ("subject" . "%-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-tree-result-format
        '(("date" . "%12s  ")
          ("authors" . "%-20s  ")
          ((("tree" . "%s")
            ("subject" . "%s"))
           . " %-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-search-line-faces
        '(("unread" . notmuch-search-unread-face)
          ("flag" . notmuch-search-flagged-face)))
  (setq notmuch-show-empty-saved-searches t)
  (setq notmuch-saved-searches
        `(( :name "inbox"
            :query "tag:inbox"
            :sort-order newest-first
            :key ,(kbd "i"))
          ( :name "unread (inbox)"
            :query "tag:unread and tag:inbox"
            :sort-order newest-first
            :key ,(kbd "u"))
          ( :name "unread all"
            :query "tag:unread not tag:archived"
            :sort-order newest-first
            :key ,(kbd "U"))
          ( :name "references"
            :query "tag:ref not tag:archived"
            :sort-order newest-first
            :key ,(kbd "r"))
          ( :name "todo"
            :query "tag:todo not tag:archived"
            :sort-order newest-first
            :key ,(kbd "t"))
          ( :name "mailing lists"
            :query "tag:list not tag:archived"
            :sort-order newest-first
            :key ,(kbd "m"))
          ;; Emacs
          ( :name "emacs-devel"
            :query "(from:emacs-devel@gnu.org or to:emacs-devel@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e d"))
          ( :name "emacs-orgmode"
            :query "(from:emacs-orgmode@gnu.org or to:emacs-orgmode@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e o"))
          ( :name "emacs-bugs"
            :query "'to:\"/*@debbugs.gnu.org*/\"' not tag:archived"
            :sort-order newest-first :key ,(kbd "e b"))
          ( :name "emacs-humanities"
            :query "(from:emacs-humanities@gnu.org or to:emacs-humanities@gnu.org) not tag:archived"
            :sort-order newest-first :key ,(kbd "e h"))
          ( :name "emacs-elpher"
            :query "(from:~michel-slm/elpher@lists.sr.ht or to:~michel-slm/elpher@lists.sr.ht) not tag:archived"
            :sort-order newest-first :key ,(kbd "e e"))
          ;; CLI tools
          ( :name "notmuch"
            :query "(from:notmuch@notmuchmail.org or to:notmuch@notmuchmail.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "cn"))))

;;; Tags
  (setq notmuch-archive-tags '("-inbox" "+archived"))
  (setq notmuch-message-replied-tags '("+replied"))
  (setq notmuch-message-forwarded-tags '("+forwarded"))
  (setq notmuch-show-mark-read-tags '("-unread"))
  (setq notmuch-draft-tags '("+draft"))
  (setq notmuch-draft-folder "drafts")
  (setq notmuch-draft-save-plaintext 'ask)
  ;; ;; NOTE 2021-06-18: See an updated version in the `prot-notmuch'
  ;; ;; section below.
  ;; (setq notmuch-tagging-keys
  ;;       `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
  ;;         (,(kbd "c") ("+archived" "-inbox" "-list" "-todo" "-ref" "-unread") "Complete and archive")
  ;;         (,(kbd "d") ("+del" "-inbox" "-archived" "-unread") "Mark for deletion")
  ;;         (,(kbd "f") ("+flag" "-unread") "Flag as important")
  ;;         ;; (,(kbd "r") notmuch-show-mark-read-tags "Mark as read")
  ;;         (,(kbd "r") ("+ref" "-unread") "Reference for the future")
  ;;         (,(kbd "s") ("+spam" "+del" "-inbox" "-unread") "Mark as spam")
  ;;         (,(kbd "t") ("+todo" "-unread") "To-do")
  ;;         (,(kbd "u") ("+unread") "Mark as unread")))
  (setq notmuch-tag-formats
        '(("unread" (propertize tag 'face 'notmuch-tag-unread))
          ("flag" (propertize tag 'face 'notmuch-tag-flagged))))
  (setq notmuch-tag-deleted-formats
        '(("unread" (notmuch-apply-face bare-tag `notmuch-tag-deleted))
          (".*" (notmuch-apply-face tag `notmuch-tag-deleted))))

;;; Email composition
  (setq notmuch-mua-compose-in 'current-window)
  (setq notmuch-mua-hidden-headers nil) ; TODO 2021-05-12: Review hidden headers
  (setq notmuch-address-command nil)    ; FIXME 2021-05-13: Make it work with EBDB
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-mua-cite-function 'message-cite-original-without-signature)
  (setq notmuch-mua-reply-insert-header-p-function 'notmuch-show-reply-insert-header-p-never)
  (setq notmuch-mua-user-agent-function #'notmuch-mua-user-agent-full)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-crypto-process-mime t)
  (setq notmuch-crypto-get-keys-asynchronously t)
  (setq notmuch-mua-attachment-regexp   ; see `notmuch-mua-send-hook'
        (concat "\\b\\(attache\?ment\\|attached\\|attach\\|"
                "pi[èe]ce\s+jointe?\\|"
                "συνημμ[εέ]νο\\|επισυν[αά]πτω\\)\\b"))

;;; Reading messages
  (setq notmuch-show-relative-dates t)
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-show-indent-messages-width 0)
  (setq notmuch-show-indent-multipart nil)
  (setq notmuch-show-part-button-default-action 'notmuch-show-save-part)
  (setq notmuch-show-text/html-blocked-images ".") ; block everything
  (setq notmuch-wash-citation-lines-prefix 6)
  (setq notmuch-wash-citation-lines-suffix 6)
  (setq notmuch-wash-wrap-lines-length 100)
  (setq notmuch-unthreaded-show-out nil)
  (setq notmuch-message-headers '("To" "Cc" "Subject" "Date"))
  (setq notmuch-message-headers-visible t)

;;; Hooks and key bindings
  (add-hook 'notmuch-mua-send-hook #'notmuch-mua-attachment-check)
  (remove-hook 'notmuch-show-hook #'notmuch-show-turn-on-visual-line-mode)
  (add-hook 'notmuch-show-hook (lambda () (setq-local header-line-format nil)))

  (let ((map global-map))
    (define-key map (kbd "C-c m") #'notmuch)
    (define-key map (kbd "C-x m") #'notmuch-mua-new-mail)) ; override `compose-mail'
  (define-key notmuch-search-mode-map (kbd "/") #'notmuch-search-filter) ; alias for l
  (define-key notmuch-hello-mode-map (kbd "C-<tab>") nil))

(prot-emacs-builtin-package 'prot-notmuch
  ;; Those are for the actions that are available after pressing 'k'
  ;; (`notmuch-tag-jump').  For direct actions, refer to the key
  ;; bindings below.
  (setq notmuch-tagging-keys
        `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
          (,(kbd "c") prot-notmuch-mark-complete-tags "Complete and archive")
          (,(kbd "d") prot-notmuch-mark-delete-tags "Mark for deletion")
          (,(kbd "f") prot-notmuch-mark-flag-tags "Flag as important")
          (,(kbd "s") prot-notmuch-mark-spam-tags "Mark as spam")
          (,(kbd "t") prot-notmuch-mark-todo-tags "To-do")
          (,(kbd "x") prot-notmuch-mark-reference-tags "Reference for the future")
          (,(kbd "r") ("-unread") "Mark as read")
          (,(kbd "u") ("+unread") "Mark as unread")))

  (setq prot-notmuch-search-field-width 100)
  (setq notmuch-hello-sections '(prot-notmuch-hello-insert-saved-searches
                                 ;; prot-notmuch-hello-insert-recent-searches
                                 ))

  (add-to-list 'notmuch-tag-formats
               '("encrypted" (propertize tag 'face 'prot-notmuch-encrypted-tag)))
  (add-to-list 'notmuch-tag-formats
               '("sent" (propertize tag 'face 'prot-notmuch-sent-tag)))
  (add-to-list 'notmuch-tag-formats
               '("ref" (propertize tag 'face 'prot-notmuch-ref-tag)))
  (add-to-list 'notmuch-tag-formats
               '("todo" (propertize tag 'face 'prot-notmuch-todo-tag)))
  (add-to-list 'notmuch-tag-formats
               '("spam" (propertize tag 'face 'prot-notmuch-spam-tag)))

  ;; NOTE 2021-05-14: I have an alternative method of finding new mail
  ;; in a maildir tree by using the find command.  It is somewhat
  ;; simplistic, though it worked just fine: see prot-mail.el.  I prefer
  ;; this implementation instead, as it leverages notmuch and so I can
  ;; pass arbitrary search terms to it.
  (setq prot-notmuch-mode-line-count-args "tag:unread and tag:inbox")
  (setq prot-notmuch-mode-line-indicator-commands
        '(notmuch notmuch-refresh-this-buffer))
  ;; Mode line indicator with the number of new mails.
  (prot-notmuch-mail-indicator 1)

  (add-hook 'notmuch-hello-mode-hook #'prot-notmuch-widget-field-face-remap)

  (let ((map notmuch-search-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-search-archive-thread)
    (define-key map (kbd "D") #'prot-notmuch-search-delete-thread)
    (define-key map (kbd "T") #'prot-notmuch-search-todo-thread)
    (define-key map (kbd "X") #'prot-notmuch-search-reference-thread)
    (define-key map (kbd "C") #'prot-notmuch-search-complete-thread)
    (define-key map (kbd "S") #'prot-notmuch-search-spam-thread)
    (define-key map (kbd "g") #'prot-notmuch-refresh-buffer))
  (let ((map notmuch-show-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-show-archive-message-then-next-or-next-thread)
    (define-key map (kbd "D") #'prot-notmuch-show-delete-message)
    (define-key map (kbd "T") #'prot-notmuch-show-todo-message)
    (define-key map (kbd "X") #'prot-notmuch-show-reference-message)
    (define-key map (kbd "C") #'prot-notmuch-show-complete-message)
    (define-key map (kbd "S") #'prot-notmuch-show-spam-message)))
#+end_src


**** .notmuch-config
:PROPERTIES:
:CUSTOM_ID: h:79803e19-1150-49a6-a3df-1cffe3d0cbc5
:END:

What follows is my =~/.notmuch-config=.  The =tags=new= configuration is
what enables the use of initial tagging, as explained in the upstream
documentation (basically you want to tag some mail right after a
=notmuch new= such as, for example, to remove mailist list messages from
the inbox---see [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].


**** notmuch post-new rules
:PROPERTIES:
:CUSTOM_ID: h:70d60d41-cb63-4950-bbd9-9157c4d186dc
:END:

And here are the rules that apply after running =notmuch new=.  Its file
system path is =$maildir/.notmuch/hooks/post-new= where =$maildir= is the
database path specified in =.notmuch-config= (see [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]]).
Remember that this file needs to be an executable.

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].


**** Org+Notmuch integration (ol-notmuch.el)
:PROPERTIES:
:CUSTOM_ID: h:a7580136-cf32-44e8-81f6-590dbdd7f8f9
:END:

The =ol-notmuch.el= is part of the =org-contrib= package which can be found
in the NonGNU ELPA (that archive is configured out-of-the-box for
Emacs28, same as with GNU ELPA).  However, that package contains
approximately one zillion things I do not need, so I prefer to copy the
file here and handle it on its own.

#+begin_src emacs-lisp :tangle no
;;; ol-notmuch.el --- Links to notmuch messages

;; Copyright (C) 2010-2014  Matthieu Lemerre

;; Author: Matthieu Lemerre <racin@free.fr>
;; Keywords: outlines, hypermedia, calendar, wp
;; Homepage: https://orgmode.org

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This file implements links to notmuch messages and "searches". A
;; search is a query to be performed by notmuch; it is the equivalent
;; to folders in other mail clients. Similarly, mails are referred to
;; by a query, so both a link can refer to several mails.

;; Links have one the following form
;; notmuch:<search terms>
;; notmuch-search:<search terms>.

;; The first form open the queries in notmuch-show mode, whereas the
;; second link open it in notmuch-search mode. Note that queries are
;; performed at the time the link is opened, and the result may be
;; different from when the link was stored.

;;; Code:

(require 'ol)

;; customisable notmuch open functions
(defcustom org-notmuch-open-function
  'org-notmuch-follow-link
  "Function used to follow notmuch links.

Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(defcustom org-notmuch-search-open-function
  'org-notmuch-search-follow-link
  "Function used to follow notmuch-search links.
Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(make-obsolete-variable 'org-notmuch-search-open-function nil "9.3")



;; Install the link type
(org-link-set-parameters "notmuch"
			 :follow #'org-notmuch-open
			 :store #'org-notmuch-store-link)

(defun org-notmuch-store-link ()
  "Store a link to a notmuch search or message."
  (when (memq major-mode '(notmuch-show-mode notmuch-tree-mode))
    (let* ((message-id (notmuch-show-get-message-id t))
	   (subject (notmuch-show-get-subject))
	   (to (notmuch-show-get-to))
	   (from (notmuch-show-get-from))
	   (date (org-trim (notmuch-show-get-date)))
	   desc link)
      (org-link-store-props :type "notmuch" :from from :to to :date date
       			    :subject subject :message-id message-id)
      (setq desc (org-link-email-description))
      (setq link (concat "notmuch:id:" message-id))
      (org-link-add-props :link link :description desc)
      link)))

(defun org-notmuch-open (path _)
  "Follow a notmuch message link specified by PATH."
  (funcall org-notmuch-open-function path))

(defun org-notmuch-follow-link (search)
  "Follow a notmuch link to SEARCH.

Can link to more than one message, if so all matching messages are shown."
  (require 'notmuch)
  (notmuch-show search))



(org-link-set-parameters "notmuch-search"
			 :follow #'org-notmuch-search-open
			 :store #'org-notmuch-search-store-link)

(defun org-notmuch-search-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-search-mode)
    (let ((link (concat "notmuch-search:" notmuch-search-query-string))
	  (desc (concat "Notmuch search: " notmuch-search-query-string)))
      (org-link-store-props :type "notmuch-search"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-search-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-search-follow-link path))

(defun org-notmuch-search-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-search mode."
  (require 'notmuch)
  (notmuch-search search))



(org-link-set-parameters "notmuch-tree"
			 :follow #'org-notmuch-tree-open
			 :store #'org-notmuch-tree-store-link)

(defun org-notmuch-tree-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-tree-mode)
    (let ((link (concat "notmuch-tree:" (notmuch-tree-get-query)))
	  (desc (concat "Notmuch tree: " (notmuch-tree-get-query))))
      (org-link-store-props :type "notmuch-tree"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-tree-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-tree-follow-link path))

(defun org-notmuch-tree-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-tree mode."
  (require 'notmuch)
  (notmuch-tree search))

(provide 'ol-notmuch)

;;; ol-notmuch.el ends here
#+end_src


#+begin_src emacs-lisp :tangle no
(require 'ol-notmuch)
#+end_src

*** Sending email (SMTP)
:PROPERTIES:
:CUSTOM_ID: h:2d793cf8-83f5-4830-b73d-78385d9b96dd
:END:

These are the base settings for the SMTP functionality.  Passwords and
other critical information are stored in =~/.authinfo.gpg=, as
demonstrated in [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][the base email settings]].  What follows is just a
mirroring of the contents of that file.

#+begin_src emacs-lisp :tangle no
;;; Sending email (SMTP)
(prot-emacs-builtin-package 'smtpmail
  (setq smtpmail-default-smtp-server "mail.gandi.net")
  (setq smtpmail-smtp-server "mail.gandi.net")
  (setq smtpmail-stream-type 'ssl)
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-queue-mail nil))

(prot-emacs-builtin-package 'sendmail
  (setq send-mail-function 'smtpmail-send-it))
#+end_src

*** EBDB (mail contacts)
:PROPERTIES:
:CUSTOM_ID: h:d386e14b-dcf7-46a2-851f-867cd84c6cae
:END:

EBDB is a contacts' manager by Eric Abrahamsen that integrates with Mail
User Agents inside of Emacs.  I used to use it as part of my Gnus setup
but as of 2021-05-13 my plan is to make it work with Notmuch as I have
switched to it ([[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]]).

What I need from it is to perform the task of storing every address that
I exchange messages with.  When I send someone a message, their email
should be saved automatically.  While if I merely read an item, say, on
the emacs-devel mailing list, I prefer to only update existing records
else do nothing.

One could set everything to automatically update in all contexts, though
I find that such an approach will either create too many false positives
that will distract you from the immediate task of handling your
correspondence, or they will simply contribute to the creation of a
database that contains a lot of largely useless information.  Save only
what matters---ignore the rest.

While "ignore the rest" can mean to simply pass it over in silence, EBBD
actually provides a mechanism to permanently exclude individual
addresses or domain names from ever being recorded.  Those are stored in
the file specified by the variable =ebdb-permanent-ignores-file=: you can
edit it manually, adding one address per line with no attached name or
angled brackets, or a domain name that starts with the =@= sign.  No
regexp notation is accepted.  For example:

#+begin_example
@debbugs.gnu.org
help-debbugs@gnu.org
@reply.github.com
#+end_example

EBDB binds some common commands to the semicolon (=;=) prefix key inside
Gnus' summary and article buffers.  For example, =; := will update all
records that are found in the message at point, while =; s= will scan
(called "snarf") the body of the message for names and email addresses
in an attempt to create records of any findings.  As always, append =C-h=
to the prefix key to get help about all key bindings that complete the
sequence and what commands they call.

The =ebdb-mua-pop-up= controls whether a window with relevant contact
information should be displayed automatically.  Perhaps it is good to
have some extra feedback on what we know or what has been collected thus
far, though I prefer not to see anything by default (it can still be
displayed with the various commands under the =;= prefix key).  Its
informative nature aside, this window can be used to further edit
entries.  With point over a field, type =e= to edit it or =C-k= to remove it
(I bind =D= to delete).  The latter command behaves differently when the
point is before the record's main field, typically the name, where it
will prompt to delete the whole entry altogether.  For more about that
specific major mode and its associated buffers, use =C-h m= (which invokes
=describe-mode=).

To view all of your contacts, or just those matching a pattern (or
string), use =M-x ebdb=, which will prompt for a search.  Input an empty
query if you prefer to view everything in the database.  While in the
=*EBDB*= buffer, you gain access to commands for operating on the records.
Same principle as with the aforementioned =ebdb-mua-pop-up=: =c= to create a
new entry, =e= to edit the field at point, =i= to insert a new datum to the
current record, =C-k= (or my preferred =D=) to delete...  Again, =C-h m= is
your friend.

Apart from gathering data and operating on it, EBDB can auto-complete
email addresses in the message composition buffer: hit TAB in a "To:",
"Cc:" or equivalent header and then use the completion framework's
interaction model to retrieve what you want.

Finally, note that this package is fairly comprehensive as it defines
lots of options and commands: make sure to read its official manual.

#+begin_src emacs-lisp :tangle no
;;; EBDB (mail contacts)
(prot-emacs-elpa-package 'ebdb
  (require 'ebdb-message)
  (require 'ebdb-notmuch) ; FIXME 2021-05-13: does not activate the corfu-mode UI
  (setq ebdb-sources (locate-user-emacs-file "ebdb"))
  (setq ebdb-permanent-ignores-file (locate-user-emacs-file "ebdb-permanent-ignores"))

  (setq ebdb-mua-pop-up nil)
  (setq ebdb-default-window-size 0.25)
  (setq ebdb-mua-default-formatter ebdb-default-multiline-formatter)

  (setq ebdb-mua-auto-update-p 'existing)
  (setq ebdb-mua-reader-update-p 'existing)
  (setq ebdb-mua-sender-update-p 'create)
  (setq ebdb-message-auto-update-p 'create)

  (setq ebdb-message-try-all-headers t)
  (setq ebdb-message-headers
        '((sender "From" "Resent-From" "Reply-To" "Sender")
          (recipients "Resent-To" "Resent-Cc" "Resent-CC" "To" "Cc" "CC" "Bcc" "BCC")))
  (setq ebdb-message-all-addresses t)

  (setq ebdb-complete-mail 'capf)
  (setq ebdb-mail-avoid-redundancy t)
  (setq ebdb-completion-display-record nil)
  (setq ebdb-complete-mail-allow-cycling nil)

  (setq ebdb-record-self "ace719a4-61f8-4bee-a1ca-2f07e2292305")
  (setq ebdb-user-name-address-re 'self) ; match the above
  (setq ebdb-save-on-exit t)

  (with-eval-after-load 'prot-mail ; check my `prot-mail.el'
    (add-hook 'message-setup-hook #'prot-mail-ebdb-message-setup))

  (let ((map ebdb-mode-map))
    (define-key map (kbd "D") #'ebdb-delete-field-or-record)
    (define-key map (kbd "M") #'ebdb-mail) ; disables `ebdb-mail-each'
    (define-key map (kbd "m") #'ebdb-toggle-record-mark)
    (define-key map (kbd "t") #'ebdb-toggle-all-record-marks)
    (define-key map (kbd "T") #'ebdb-toggle-records-format) ; disables `ebdb-toggle-all-records-format'
    (define-key map (kbd "U") #'ebdb-unmark-all-records)))
#+end_src

* some notes

add org -> packages -> extra funcionalty in teco config on hold

turn off org cdlatex for performance

compare html export from original

vertico postframe

fix flycheck org
