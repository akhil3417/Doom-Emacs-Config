#+title: Review
#+author: Akhil Pratap Singh
#+date: 2022-09-22

** Very large files

The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.

#+begin_src emacs-lisp :tangle packages.el
(package! vlf :recipe (:host github :repo "emacs-straight/vlf" :files ("*.el"))
  :pin "cacdb359f8c37c6e7e4c7937462b632d22462130")
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write
  vlf-search vlf-occur vlf-follow vlf-ediff vlf
  :commands vlf vlf-mode
  :init
  <<vlf-largefile-prompt>>
  :config
  (advice-remove 'abort-if-file-too-large #'ad-Advice-abort-if-file-too-large)
  <<vlf-linenum-offset>>)
#+end_src

#+RESULTS:

Now, there are one or two tweaks worth applying to VLF. For starters, it goes to
the liberty of advising ~abort-if-file-too-large~, and in doing so removes the
option of opening files literally. I think that's a bit much, so we can remove
the advice and instead override ~files--ask-user-about-large-file~ (the more
appropriate function, I think) as a simpler approach, just sacrificing the
original behaviour with src_elisp{(setq vlf-application 'always)} (which I can't
imagine using anyway).

#+name: vlf-largefile-prompt
#+begin_src emacs-lisp :tangle no
(defadvice! +files--ask-about-large-file-vlf (size op-type filename offer-raw)
  "Like `files--ask-user-about-large-file', but with support for `vlf'."
  :override #'files--ask-user-about-large-file
  (if (eq vlf-application 'dont-ask)
      (progn (vlf filename) (error ""))
    (let ((prompt (format "File %s is large (%s), really %s?"
                          (file-name-nondirectory filename)
                          (funcall byte-count-to-string-function size) op-type)))
      (if (not offer-raw)
          (if (y-or-n-p prompt) nil 'abort)
        (let ((choice
               (car
                (read-multiple-choice
                 prompt '((?y "yes")
                          (?n "no")
                          (?l "literally")
                          (?v "vlf"))
                 (files--ask-user-about-large-file-help-text
                  op-type (funcall byte-count-to-string-function size))))))
          (cond ((eq choice ?y) nil)
                ((eq choice ?l) 'raw)
                ((eq choice ?v)
                 (vlf filename)
                 (error ""))
                (t 'abort)))))))
#+end_src

#+RESULTS: vlf-largefile-prompt

As you go from one chunk fetched by VLF to the next, the displayed line number
of the first line /in each chunk/ is unchanged. I think it's reasonable to hope
for an /overall/ line number, and by tracking chunk's cumulative line numbers we
can implement this behaviour fairly easily.

#+name: vlf-linenum-offset
#+begin_src emacs-lisp :tangle no
(defvar-local +vlf-cumulative-linenum '((0 . 0))
  "An alist keeping track of the cumulative line number.")

(defun +vlf-update-linum ()
  "Update the line number offset."
  (let ((linenum-offset (alist-get vlf-start-pos +vlf-cumulative-linenum)))
    (setq display-line-numbers-offset (or linenum-offset 0))
    (when (and linenum-offset (not (assq vlf-end-pos +vlf-cumulative-linenum)))
      (push (cons vlf-end-pos (+ linenum-offset
                                 (count-lines (point-min) (point-max))))
            +vlf-cumulative-linenum))))

(add-hook 'vlf-after-chunk-update-hook #'+vlf-log-poses-a)

;; Since this only works with absolute line numbers, let's make sure we use them.
gadd-hook! 'vlf-mode-hook (setq-local display-line-numbers t)
#+end_src

The other thing that doesn't work too well with VLF is searching with anything
other than =M-x occur=. This is because trying to go to the next match at the end
of a chunk usually wraps the point to the beginning of the chunk, instead of
moving to the next chunk.

#+begin_src emacs-lisp :tangle no
(defun +vlf-next-chunk-or-start ()
  (if (= vlf-file-size vlf-end-pos)
      (vlf-jump-to-chunk 1)
    (vlf-next-batch 1))
  (goto-char (point-min)))

(defun +vlf-last-chunk-or-end ()
  (if (= 0 vlf-start-pos)
      (vlf-end-of-file)
    (vlf-prev-batch 1))
  (goto-char (point-max)))

(defun +vlf-isearch-wrap ()
  (if isearch-forward
      (+vlf-next-chunk-or-start)
    (+vlf-last-chunk-or-end)))

(add-hook! 'vlf-mode-hook (setq-local isearch-wrap-function #'+vlf-isearch-wrap))
#+end_src

#+RESULTS:

Unfortunately, since evil-search doesn't have an analogue to
~isearch-wrap-function~, we can't easily add support to it.

* DONE Eaf  Core
CLOSED: [2022-04-15 Fri 11:42]
** eaf confv2
#+begin_src emacs-lisp :tangle no

;; Don't forget to run M-x eaf-install-dependencies
(use-package! eaf
  ;; :unless gv/is-termux
  :bind (("C-c W" . gv/bm))
  ;; :demand t
  ;; Set to "/usr/share/emacs/site-lisp/eaf" if installed from AUR
  :load-path "~/.emacs.d/site-lisp/emacs-application-framework/"
  :init
  (use-package! epc      :defer t :ensure t)
  (use-package! ctable   :defer t :ensure t)
  (use-package! deferred :defer t :ensure t)
  (use-package! s        :defer t :ensure t)
  ;; (setq browse-url-browser-function 'eaf-open-browser)
  :config
  (defun slurp (f)
    (with-temp-buffer
      (insert-file-contents f)
      (buffer-substring-no-properties
       (point-min)
       (point-max))))
  (defun gv/bm ()
    (interactive)
    (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/app/browser/")
    (require 'eaf-browser)

    (let ((selected (completing-read
                     "Select URL: " (split-string
                                     (slurp "~/.config/bookmarks") "\n" t))))
      (let ((url (car (split-string
                       selected
                       " " t))))
        (if (string-match-p "\\http.*\\'" url)
            ;; Open selected url
            (eaf-open-browser url)
          ;; Search entered text
          (eaf-search-it selected)))))
  (setq eaf-browser-continue-where-left-off t)
  (setq eaf-browser-dnefault-search-engine "duckduckgo")
  (setq eaf-browser-enable-adblocker "true")
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (dolist (keys '("i" "h" "j" "k" "l"
  ;;              "d" "f" "x" ","
  ;;              "-" "." "0" "1"
  ;;              "2" "=" "B" "F"
  ;;              "G" "H" "I" "J"
  ;;              "K" "L" "P" "T"
  ;;              "Y" "c" "d" "e"
  ;;              "f" "g" "m" "n"
  ;;              "o" "p" "r" "t"
  ;;              "u" "v" "x" "y"
  ;;              (eaf-bind-key nil key eaf-browser-keybinding))))
  )
#+end_src

#+RESULTS:
: gv/bm

** eaf config
#+begin_src emacs-lisp :tangle no

(add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
(use-package! eaf
  :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
  :custom
  (setq eaf-browser-continue-where-left-off t)
  (setq eaf-browser-enable-adblocker t)
  (setq browse-url-browser-function 'eaf-open-browser)
(setq eaf-browser-translate-language "es")
(setq eaf-browser-continue-where-left-off t)
(setq eaf-browser-download-path "~/Downloads/eaf/")
(setq eaf-mindmap-dark-mode "follow") ; default option
(setq eaf-browser-dark-mode "force")
(setq eaf-terminal-dark-mode nil)
(setq eaf-pdf-dark-mode "ignore") ; see below
(setq eaf-browser-default-search-engine "duckduckgo")
(setq eaf-music-play-order "random")
(setq eaf-browser-blank-page-url "https://duckduckgo.com")
(setq eaf-browser-default-search-engine "duckduckgo")
  :config
  (defalias 'browse-web #'eaf-open-browser))
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
;; (setq eaf-browser-aria2-proxy-host "127.0.0.1")
;; (setq eaf-browser-aria2-proxy-port "9888")
;; sudo systemctl start privoxy
;; (setq eaf-browser-remember-history nil)
;; (setq eaf-browser-default-zoom 1.25)
;; (setq eaf-browser-enable-plugin nil)
;; (setq eaf-browser-enable-javascript nil)
;; (setq eaf-camera-save-path "new/path/")
(defcustom eaf-music-default-file nil "~/Music/"
  :type 'file)
(defun eaf-org-open-file (file &optional link)
  "An wrapper function on `eaf-open'."
  (eaf-open file))

;; use `emacs-application-framework' to open PDF file: link
(add-to-list 'org-file-apps '("\\.pdf\\'" . eaf-org-open-file))


#+end_src

#+RESULTS:
: ((\.pdf\' . eaf-org-open-file) (remote . emacs) (auto-mode . emacs) (directory . emacs) (\.mm\' . default) (\.x?html?\' . default) (\.pdf\' . default))
** load eaf apps
#+begin_src emacs-lisp :tangle no

 (require 'eaf-pdf-viewer)
 (require 'eaf-browser)
 (require 'eaf-rss-reader)
 (require 'eaf-markdown-previewer)
 (require 'eaf-airshare)
 (require 'eaf-file-sender)
 (require 'eaf-jupyter)
 (require 'eaf-browser)
 (require 'eaf-terminal)
 (require 'eaf-mindmap)
 (require 'eaf-system-monitor)
 (require 'eaf-camera)
 (require 'eaf-org-previewer)
 (require 'eaf-org)
 (require 'eaf-image-viewer)
 ;; (require 'eaf-mermaid)
 ;; (require 'eaf-demo)
 ;; (require 'eaf-video-player)
 ;; (require 'eaf-vue-demo)
 ;; (require 'eaf-music-player)
 ;; (require 'eaf-file-browser)
 ;; (require 'eaf-netease-cloud-music)
 ;; (require 'eaf-file-manager)
 ;; (require 'eaf-evil)

#+end_src

#+RESULTS:
: eaf-image-viewer

** eaf evil

 I usually don't use it as it causes issues with doom keybinds

#+begin_src emacs-lisp :tangle no
(require 'eaf-evil)

(define-key key-translation-map (kbd "SPC")
    (lambda (prompt)
      (if (derived-mode-p 'eaf-mode)
          (pcase eaf--buffer-app-name
            ("browser" (if  (string= (eaf-call-sync "call_function" eaf--buffer-id "is_focus") "True")
                           (kbd "SPC")
                         (kbd eaf-evil-leader-key)))
            ("pdf-viewer" (kbd eaf-evil-leader-key))
            ("image-viewer" (kbd eaf-evil-leader-key))
            (_  (kbd "SPC")))
        (kbd "SPC"))))

#+end_src

#+RESULTS:
| lambda | (prompt) | (if (derived-mode-p 'eaf-mode) (pcase eaf--buffer-app-name (browser (if (string= (eaf-call-sync call_function eaf--buffer-id is_focus) True) (kbd SPC) (kbd eaf-evil-leader-key))) (pdf-viewer (kbd eaf-evil-leader-key)) (image-viewer (kbd eaf-evil-leader-key)) (_ (kbd SPC))) (kbd SPC)) |
