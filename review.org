#+title: Review
#+author: Akhil Pratap Singh
#+date: 2022-09-22

#+property: header-args:emacs-lisp :tangle yes :comments link
#+property: header-args:elisp :tangle packages.el :comments link
#+property: header-args :tangle no :results silent :eval no-export
#+caption: Banner
#+latex_class: chameleon
#+html_content_class: chameleon
#+html_head: <link rel='stylesheet' type='text/css' href='static/index.css' />
#+html_head: <link rel='shortcut icon' type='image/png' href='https://raw.githubusercontent.com/eccentric-j/doom-icon/master/cute-doom/src/doom.iconset/icon_32x32.png'>
**** LaTeX
A necessary evil. I hate it, it hates me, but it makes my PDF documents look nice.

***** Preambles
Various preamble setups to improve the overall look of several items

#+begin_src emacs-lisp
(defvar org-latex-caption-preamble "
\\usepackage{subcaption}
\\usepackage[hypcap=true]{caption}
\\setkomafont{caption}{\\sffamily\\small}
\\setkomafont{captionlabel}{\\upshape\\bfseries}
\\captionsetup{justification=raggedright,singlelinecheck=true}
\\usepackage{capt-of} % required by Org
"
  "Preamble that improves captions.")

(defvar org-latex-checkbox-preamble "
\\newcommand{\\checkboxUnchecked}{$\\square$}
\\newcommand{\\checkboxTransitive}{\\rlap{\\raisebox{-0.1ex}{\\hspace{0.35ex}\\Large\\textbf -}}$\\square$}
\\newcommand{\\checkboxChecked}{\\rlap{\\raisebox{0.2ex}{\\hspace{0.35ex}\\scriptsize \\ding{52}}}$\\square$}
"
  "Preamble that improves checkboxes.")

(defvar org-latex-box-preamble "
% args = #1 Name, #2 Colour, #3 Ding, #4 Label
\\newcommand{\\defsimplebox}[4]{%
  \\definecolor{#1}{HTML}{#2}
  \\newenvironment{#1}[1][]
  {%
    \\par\\vspace{-0.7\\baselineskip}%
    \\textcolor{#1}{#3} \\textcolor{#1}{\\textbf{\\def\\temp{##1}\\ifx\\temp\\empty#4\\else##1\\fi}}%
    \\vspace{-0.8\\baselineskip}
    \\begin{addmargin}[1em]{1em}
  }{%
    \\end{addmargin}
    \\vspace{-0.5\\baselineskip}
  }%
}
"
  "Preamble that provides a macro for custom boxes.")
#+end_src

***** Conditional features
Don't always need everything in LaTeX, so only add it what we need when we need it.

#+begin_src emacs-lisp
(defvar org-latex-italic-quotes t
  "Make \"quote\" environments italic.")
(defvar org-latex-par-sep t
  "Vertically seperate paragraphs, and remove indentation.")

(defvar org-latex-conditional-features
  '(("\\[\\[\\(?:file\\|https?\\):\\(?:[^]]\\|\\\\\\]\\)+?\\.\\(?:eps\\|pdf\\|png\\|jpeg\\|jpg\\|jbig2\\)\\]\\]" . image)
    ("\\[\\[\\(?:file\\|https?\\):\\(?:[^]]+?\\|\\\\\\]\\)\\.svg\\]\\]\\|\\\\includesvg" . svg)
    ("^[ \t]*|" . table)
    ("cref:\\|\\cref{\\|\\[\\[[^\\]]+\\]\\]" . cleveref)
    ("[;\\\\]?\\b[A-Z][A-Z]+s?[^A-Za-z]" . acronym)
    ("\\+[^ ].*[^ ]\\+\\|_[^ ].*[^ ]_\\|\\\\uu?line\\|\\\\uwave\\|\\\\sout\\|\\\\xout\\|\\\\dashuline\\|\\dotuline\\|\\markoverwith" . underline)
    (":float wrap" . float-wrap)
    (":float sideways" . rotate)
    ("^[ \t]*#\\+caption:\\|\\\\caption" . caption)
    ("\\[\\[xkcd:" . (image caption))
    ((and org-latex-italic-quotes "^[ \t]*#\\+begin_quote\\|\\\\begin{quote}") . italic-quotes)
    (org-latex-par-sep . par-sep)
    ("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\|[A-Za-z]+[.)]\\) \\[[ -X]\\]" . checkbox)
    ("^[ \t]*#\\+begin_warning\\|\\\\begin{warning}" . box-warning)
    ("^[ \t]*#\\+begin_info\\|\\\\begin{info}"       . box-info)
    ("^[ \t]*#\\+begin_success\\|\\\\begin{success}" . box-success)
    ("^[ \t]*#\\+begin_error\\|\\\\begin{error}"     . box-error))
  "Org feature tests and associated LaTeX feature flags.

Alist where the car is a test for the presense of the feature,
and the cdr is either a single feature symbol or list of feature symbols.

When a string, it is used as a regex search in the buffer.
The feature is registered as present when there is a match.

The car can also be a
- symbol, the value of which is fetched
- function, which is called with info as an argument
- list, which is `eval'uated

If the symbol, function, or list produces a string: that is used as a regex
search in the buffer. Otherwise any non-nil return value will indicate the
existance of the feature.")

(defvar org-latex-feature-implementations
  '((image         :snippet "\\usepackage{graphicx}" :order 2)
    (svg           :snippet "\\usepackage{svg}" :order 2)
    (table         :snippet "\\usepackage{longtable}\n\\usepackage{booktabs}" :order 2)
    (cleveref      :snippet "\\usepackage[capitalize]{cleveref}" :order 1)
    (underline     :snippet "\\usepackage[normalem]{ulem}" :order 0.5)
    (float-wrap    :snippet "\\usepackage{wrapfig}" :order 2)
    (rotate        :snippet "\\usepackage{rotating}" :order 2)
    (caption       :snippet org-latex-caption-preamble :order 2.1)
    (acronym       :snippet "\\newcommand{\\acr}[1]{\\protect\\textls*[110]{\\scshape #1}}\n\\newcommand{\\acrs}{\\protect\\scalebox{.91}[.84]{\\hspace{0.15ex}s}}" :order 0.4)
    (italic-quotes :snippet "\\renewcommand{\\quote}{\\list{}{\\rightmargin\\leftmargin}\\item\\relax\\em}\n" :order 0.5)
    (par-sep       :snippet "\\setlength{\\parskip}{\\baselineskip}\n\\setlength{\\parindent}{0pt}\n" :order 0.5)
    (.pifont       :snippet "\\usepackage{pifont}")
    (checkbox      :requires .pifont :order 3
                   :snippet (concat (unless (memq 'maths features)
                                      "\\usepackage{amssymb} % provides \\square")
                                    org-latex-checkbox-preamble))
    (.fancy-box    :requires .pifont    :snippet org-latex-box-preamble :order 3.9)
    (box-warning   :requires .fancy-box :snippet "\\defsimplebox{warning}{e66100}{\\ding{68}}{Warning}" :order 4)
    (box-info      :requires .fancy-box :snippet "\\defsimplebox{info}{3584e4}{\\ding{68}}{Information}" :order 4)
    (box-success   :requires .fancy-box :snippet "\\defsimplebox{success}{26a269}{\\ding{68}}{\\vspace{-\\baselineskip}}" :order 4)
    (box-error     :requires .fancy-box :snippet "\\defsimplebox{error}{c01c28}{\\ding{68}}{Important}" :order 4))
  "LaTeX features and details required to implement them.

List where the car is the feature symbol, and the rest forms a plist with the
following keys:
- :snippet, which may be either
  - a string which should be included in the preamble
  - a symbol, the value of which is included in the preamble
  - a function, which is evaluated with the list of feature flags as its
    single argument. The result of which is included in the preamble
  - a list, which is passed to `eval', with a list of feature flags available
    as \"features\"

- :requires, a feature or list of features that must be available
- :when, a feature or list of features that when all available should cause this
    to be automatically enabled.
- :prevents, a feature or list of features that should be masked
- :order, for when ordering is important. Lower values appear first.
    The default is 0.

Features that start with ! will be eagerly loaded, i.e. without being detected.")
#+end_src

First, we need to detect which features we actually need

#+begin_src emacs-lisp
(defun org-latex-detect-features (&optional buffer info)
  "List features from `org-latex-conditional-features' detected in BUFFER."
  (let ((case-fold-search nil))
    (with-current-buffer (or buffer (current-buffer))
      (delete-dups
       (mapcan (lambda (construct-feature)
                 (when (let ((out (pcase (car construct-feature)
                                    ((pred stringp) (car construct-feature))
                                    ((pred functionp) (funcall (car construct-feature) info))
                                    ((pred listp) (eval (car construct-feature)))
                                    ((pred symbolp) (symbol-value (car construct-feature)))
                                    (_ (user-error "org-latex-conditional-features key %s unable to be used" (car construct-feature))))))
                         (if (stringp out)
                             (save-excursion
                               (goto-char (point-min))
                               (re-search-forward out nil t))
                           out))
                   (if (listp (cdr construct-feature)) (cdr construct-feature) (list (cdr construct-feature)))))
               org-latex-conditional-features)))))
#+end_src

Then we need to expand them and sort them according to the above definitions

#+begin_src emacs-lisp
(defun org-latex-expand-features (features)
  "For each feature in FEATURES process :requires, :when, and :prevents keywords and sort according to :order."
  (dolist (feature features)
    (unless (assoc feature org-latex-feature-implementations)
      (error "Feature %s not provided in org-latex-feature-implementations" feature)))
  (setq current features)
  (while current
    (when-let ((requirements (plist-get (cdr (assq (car current) org-latex-feature-implementations)) :requires)))
      (setcdr current (if (listp requirements)
                          (append requirements (cdr current))
                        (cons requirements (cdr current)))))
    (setq current (cdr current)))
  (dolist (potential-feature
           (append features (delq nil (mapcar (lambda (feat)
                                                (when (plist-get (cdr feat) :eager)
                                                  (car feat)))
                                              org-latex-feature-implementations))))
    (when-let ((prerequisites (plist-get (cdr (assoc potential-feature org-latex-feature-implementations)) :when)))
      (setf features (if (if (listp prerequisites)
                             (cl-every (lambda (preq) (memq preq features)) prerequisites)
                           (memq prerequisites features))
                         (append (list potential-feature) features)
                       (delq potential-feature features)))))
  (dolist (feature features)
    (when-let ((prevents (plist-get (cdr (assoc feature org-latex-feature-implementations)) :prevents)))
      (setf features (cl-set-difference features (if (listp prevents) prevents (list prevents))))))
  (sort (delete-dups features)
        (lambda (feat1 feat2)
          (if (< (or (plist-get (cdr (assoc feat1 org-latex-feature-implementations)) :order) 1)
                 (or (plist-get (cdr (assoc feat2 org-latex-feature-implementations)) :order) 1))
              t nil))))
#+end_src

Finally, we can create the preamble to be inserted

#+begin_src emacs-lisp
(defun org-latex-generate-features-preamble (features)
  "Generate the LaTeX preamble content required to provide FEATURES.
This is done according to `org-latex-feature-implementations'"
  (let ((expanded-features (org-latex-expand-features features)))
    (concat
     (format "\n%% features: %s\n" expanded-features)
     (mapconcat (lambda (feature)
                  (when-let ((snippet (plist-get (cdr (assoc feature org-latex-feature-implementations)) :snippet)))
                    (concat
                     (pcase snippet
                       ((pred stringp) snippet)
                       ((pred functionp) (funcall snippet features))
                       ((pred listp) (eval `(let ((features ',features)) (,@snippet))))
                       ((pred symbolp) (symbol-value snippet))
                       (_ (user-error "org-latex-feature-implementations :snippet value %s unable to be used" snippet)))
                     "\n")))
                expanded-features
                "")
     "% end features\n")))
#+end_src

Last step, some advice to hook in all of the above to work

#+begin_src emacs-lisp
(defvar info--tmp nil)

(defadvice! org-latex-save-info (info &optional t_ s_)
  :before #'org-latex-make-preamble
  (setq info--tmp info))

(defadvice! org-splice-latex-header-and-generated-preamble-a (orig-fn tpl def-pkg pkg snippets-p &optional extra)
  "Dynamically insert preamble content based on `org-latex-conditional-preambles'."
  :around #'org-splice-latex-header
  (let ((header (funcall orig-fn tpl def-pkg pkg snippets-p extra)))
    (if snippets-p header
      (concat header
              (org-latex-generate-features-preamble (org-latex-detect-features nil info--tmp))
              "\n"))))
#+end_src

***** Tectonic
Tectonic is the hot new thing, which also means I can get rid of my tex installation.

#+begin_src emacs-lisp
(setq-default org-latex-pdf-process '("tectonic -Z shell-escape --outdir=%o %f"))
#+end_src

***** TODO Classes
Simple base header shared by all defines classes

#+name: base-template
#+begin_src latex
\\documentclass[10pt]{scrartcl}
[PACKAGES]
[DEFAULT-PACKAGES]
[EXTRA]
\\setmainfont[Ligatures=TeX]{Overpass}
\\setmonofont[Ligatures=TeX]{Iosevka Nerd Font Mono}
#+end_src

#+name: chameleon-template
#+begin_src latex :noweb yes
% Using chameleon
<<base-template>>
#+end_src

#+name: work-template
#+begin_src latex :noweb yes
% Using work
<<base-template>>
\\usepackage{fontawesome5}
\\usepackage{tcolorbox}
\\usepackage{fancyhdr}
\\usepackage{lastpage}
\\pagestyle{fancy}
\\fancyhead{}
\\fancyhead[RO, LE]{}
#+end_src

Now for some class setup (likely to change over time)

#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (add-to-list 'org-latex-classes
               '("chameleon" "
<<chameleon-template>>
"
                 ("\\section{%s}" . "\\section*{%s}")
                 ("\\subsection{%s}" . "\\subsection*{%s}")
                 ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                 ("\\paragraph{%s}" . "\\paragraph*{%s}")
                 ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))
#+end_src

And some saner default for them

#+begin_src emacs-lisp
(after! ox-latex
  (setq org-latex-default-class "chameleon"
        org-latex-tables-booktabs t
        org-latex-hyperref-template "\\colorlet{greenyblue}{blue!70!green}
\\colorlet{blueygreen}{blue!40!green}
\\providecolor{link}{named}{greenyblue}
\\providecolor{cite}{named}{blueygreen}
\\hypersetup{
  pdfauthor={%a},
  pdftitle={%t},
  pdfkeywords={%k},
  pdfsubject={%d},
  pdfcreator={%c},
  pdflang={%L},
  breaklinks=true,
  colorlinks=true,
  linkcolor=,
  urlcolor=link,
  citecolor=cite\n}
\\urlstyle{same}
"
        org-latex-reference-command "\\cref{%s}"))
#+end_src

***** Packages
Add some packages (also very likely to change)

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      `(("AUTO" "inputenc" t ("pdflatex"))
        ("T1" "fontenc" t ("pdflatex"))
        ("" "fontspec" t)
        ("" "xcolor" nil)
        ("" "hyperref" nil)))
#+end_src

***** Pretty code blocks
Teco is the goto for this, so basically just ripping off him.

#+begin_src elisp
(package! engrave-faces
  :recipe (:host github :repo "tecosaur/engrave-faces"))
#+end_src

#+begin_src emacs-lisp
(use-package! engrave-faces-latex
  :after ox-latex
  :config
  (setq org-latex-listings 'engraved))
#+end_src

#+begin_src emacs-lisp
(use-package! engrave-faces-html
  :after ox-html
  :config
  (setq org-latex-listings 'engraved))
#+end_src

#+begin_src emacs-lisp
(defvar-local org-export-has-code-p nil)

(defadvice! org-export-expect-no-code (&rest _)
  :before #'org-export-as
  (setq org-export-has-code-p nil))

(defadvice! org-export-register-code (&rest _)
  :after #'org-latex-src-block
  :after #'org-latex-inline-src-block-engraved
  (setq org-export-has-code-p t))

(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
  "Like `org-latex-example-block', but supporting an engraved backend"
  :around #'org-latex-example-block
  (let ((output-block (funcall orig-fn example-block contents info)))
    (if (eq 'engraved (plist-get info :latex-listings))
        (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
      output-block)))
#+end_src

***** ox-chameleon
Chameleons are cool, not having to touches faces is cooler (not the COVID kind)

#+begin_src elisp
(package! ox-chameleon
  :recipe (:host github :repo "tecosaur/ox-chameleon"))
#+end_src

#+begin_src emacs-lisp
(use-package! ox-chameleon
  :after ox)
#+end_src

***** Beamer
Starting to look into beamer for creating presentations, seems like we need to +steal+ borrow more config from Tecosaur.

Metropolis is a nice theme, with a tiny adjustment it might be the best.

#+begin_src emacs-lisp
(setq org-beamer-theme "[progressbar=foot]metropolis")
#+end_src

#+begin_src emacs-lisp :noweb yes
(defun org-beamer-p (info)
  (eq 'beamer (and (plist-get info :back-end)
                   (org-export-backend-name (plist-get info :back-end)))))

(add-to-list 'org-latex-conditional-features '(org-beamer-p . beamer) t)
(add-to-list 'org-latex-feature-implementations '(beamer :requires .missing-koma :prevents (italic-quotes condensed-lists)) t)
(add-to-list 'org-latex-feature-implementations '(.missing-koma :snippet "\\usepackage{scrextend}" :order 2) t)
#+end_src

And lastly, a small tweak to improve how sections are divided

#+begin_src emacs-lisp
(setq org-beamer-frame-level 2)
#+end_src

**** (sub|super)script characters
Annoying having to gate these, so let's fix that

#+begin_src emacs-lisp
(setq org-export-with-sub-superscripts '{})
#+end_src

** IRC


=circe= is a client for IRC in Emacs (hey, isn't that a nice project
name+acronym), and a greek enchantress who turned humans into animals.

Let's use the former to chat to +recluses+ discerning individuals online.

[[xkcd:1782]]

Before we start seeing and sending messages, we need to authenticate with our
IRC servers. The circe manual provided a snippet for putting some of the auth
details in =.authinfo.gpg= --- but I think we should go further than that: have
the entire server info in our authinfo.

First, a reasonable format by which we can specify:
+ server
+ port
+ SASL username
+ SASL password
+ channels to join

We can have these stored like so
#+begin_src authinfo
machine chat.freenode.net login USERNAME password PASSWORD port PORT for irc channels emacs,org-mode
#+end_src

The ~for irc~ bit is used so we can uniquely identify all IRC auth info. By
omitting the =#= in channel names we can have a list of channels comma-separated
(no space!) which the secrets API will return as a single string.

#+name: irc-authinfo-reader
#+begin_src emacs-lisp :tangle no
(defun auth-server-pass (server)
  (if-let ((secret (plist-get (car (auth-source-search :host server)) :secret)))
      (if (functionp secret)
          (funcall secret) secret)
    (error "Could not fetch password for host %s" server)))

(defun register-irc-auths ()
  (require 'circe)
  (require 'dash)
  (let ((accounts (-filter (lambda (a) (string= "irc" (plist-get a :for)))
                           (auth-source-search :require '(:for) :max 10))))
    (appendq! circe-network-options
              (mapcar (lambda (entry)
                        (let* ((host (plist-get entry :host))
                               (label (or (plist-get entry :label) host))
                               (_ports (mapcar #'string-to-number
                                               (s-split "," (plist-get entry :port))))
                               (port (if (= 1 (length _ports)) (car _ports) _ports))
                               (user (plist-get entry :user))
                               (nick (or (plist-get entry :nick) user))
                               (channels (mapcar (lambda (c) (concat "#" c))
                                                 (s-split "," (plist-get entry :channels)))))
                          `(,label
                            :host ,host :port ,port :nick ,nick
                            :sasl-username ,user :sasl-password auth-server-pass
                            :channels ,channels)))
                      accounts))))
#+end_src

We'll just call src_elisp{(register-irc-auths)} on a hook when we start Circe
up.

Now we're ready to go, let's actually wire-up Circe, with one or two
configuration tweaks.
#+begin_src emacs-lisp :noweb no-export
(after! circe
  (setq-default circe-use-tls t)
  (setq circe-notifications-alert-icon "/usr/share/icons/breeze/actions/24/network-connect.svg"
        lui-logging-directory (expand-file-name "irc" doom-etc-dir)
        lui-logging-file-format "{buffer}/%Y/%m-%d.txt"
        circe-format-self-say "{nick:+13s} â”ƒ {body}")

  (custom-set-faces!
    '(circe-my-message-face :weight unspecified))

  (enable-lui-logging-globally)
  (enable-circe-display-images)

  <<org-emph-to-irc>>

  <<circe-emojis>>
  <<circe-emoji-alists>>

  (defun named-circe-prompt ()
    (lui-set-prompt
     (concat (propertize (format "%13s > " (circe-nick))
                         'face 'circe-prompt-face)
             "")))
  (add-hook 'circe-chat-mode-hook #'named-circe-prompt)

  (appendq! all-the-icons-mode-icon-alist
            '((circe-channel-mode all-the-icons-material "message" :face all-the-icons-lblue)
              (circe-server-mode all-the-icons-material "chat_bubble_outline" :face all-the-icons-purple))))

<<irc-authinfo-reader>>

(add-transient-hook! #'=irc (register-irc-auths))
#+end_src

*** Org-style emphasis

Let's do our *bold*, /italic/, and _underline_ in org-syntax, using IRC control characters.
#+name: org-emph-to-irc
#+begin_src emacs-lisp
(defun lui-org-to-irc ()
  "Examine a buffer with simple org-mode formatting, and converts the empasis:
,*bold*, /italic/, and _underline_ to IRC semi-standard escape codes.
=code= is converted to inverse (highlighted) text."
  (goto-char (point-min))
  (while (re-search-forward "\\_<\\(?1:[*/_=]\\)\\(?2:[^[:space:]]\\(?:.*?[^[:space:]]\\)?\\)\\1\\_>" nil t)
    (replace-match
     (concat (pcase (match-string 1)
               ("*" "")
               ("/" "")
               ("_" "")
               ("=" ""))
             (match-string 2)
             "") nil nil)))

(add-hook 'lui-pre-input-hook #'lui-org-to-irc)
#+end_src

*** Emojis

Let's setup Circe to use some emojis
#+name: circe-emojis
#+begin_src emacs-lisp :tangle no
(defun lui-ascii-to-emoji ()
  (goto-char (point-min))
  (while (re-search-forward "\\( \\)?::?\\([^[:space:]:]+\\):\\( \\)?" nil t)
    (replace-match
     (concat
      (match-string 1)
      (or (cdr (assoc (match-string 2) lui-emojis-alist))
          (concat ":" (match-string 2) ":"))
      (match-string 3))
     nil nil)))

(defun lui-emoticon-to-emoji ()
  (dolist (emoticon lui-emoticons-alist)
    (goto-char (point-min))
    (while (re-search-forward (concat " " (car emoticon) "\\( \\)?") nil t)
      (replace-match (concat " "
                             (cdr (assoc (cdr emoticon) lui-emojis-alist))
                             (match-string 1))))))

(define-minor-mode lui-emojify
  "Replace :emojis: and ;) emoticons with unicode emoji chars."
  :global t
  :init-value t
  (if lui-emojify
      (add-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)
    (remove-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)))
#+end_src

Now, some actual emojis to use.
#+name: circe-emoji-alists
#+begin_src emacs-lisp :tangle no
(defvar lui-emojis-alist
  '(("grinning"                      . "ðŸ˜€")
    ("smiley"                        . "ðŸ˜ƒ")
    ("smile"                         . "ðŸ˜„")
    ("grin"                          . "ðŸ˜")
    ("laughing"                      . "ðŸ˜†")
    ("sweat_smile"                   . "ðŸ˜…")
    ("joy"                           . "ðŸ˜‚")
    ("rofl"                          . "ðŸ¤£")
    ("relaxed"                       . "â˜ºï¸")
    ("blush"                         . "ðŸ˜Š")
    ("innocent"                      . "ðŸ˜‡")
    ("slight_smile"                  . "ðŸ™‚")
    ("upside_down"                   . "ðŸ™ƒ")
    ("wink"                          . "ðŸ˜‰")
    ("relieved"                      . "ðŸ˜Œ")
    ("heart_eyes"                    . "ðŸ˜")
    ("yum"                           . "ðŸ˜‹")
    ("stuck_out_tongue"              . "ðŸ˜›")
    ("stuck_out_tongue_closed_eyes"  . "ðŸ˜")
    ("stuck_out_tongue_wink"         . "ðŸ˜œ")
    ("zanzy"                         . "ðŸ¤ª")
    ("raised_eyebrow"                . "ðŸ¤¨")
    ("monocle"                       . "ðŸ§")
    ("nerd"                          . "ðŸ¤“")
    ("cool"                          . "ðŸ˜Ž")
    ("star_struck"                   . "ðŸ¤©")
    ("party"                         . "ðŸ¥³")
    ("smirk"                         . "ðŸ˜")
    ("unamused"                      . "ðŸ˜’")
    ("disapointed"                   . "ðŸ˜ž")
    ("pensive"                       . "ðŸ˜”")
    ("worried"                       . "ðŸ˜Ÿ")
    ("confused"                      . "ðŸ˜•")
    ("slight_frown"                  . "ðŸ™")
    ("frown"                         . "â˜¹ï¸")
    ("persevere"                     . "ðŸ˜£")
    ("confounded"                    . "ðŸ˜–")
    ("tired"                         . "ðŸ˜«")
    ("weary"                         . "ðŸ˜©")
    ("pleading"                      . "ðŸ¥º")
    ("tear"                          . "ðŸ˜¢")
    ("cry"                           . "ðŸ˜¢")
    ("sob"                           . "ðŸ˜­")
    ("triumph"                       . "ðŸ˜¤")
    ("angry"                         . "ðŸ˜ ")
    ("rage"                          . "ðŸ˜¡")
    ("exploding_head"                . "ðŸ¤¯")
    ("flushed"                       . "ðŸ˜³")
    ("hot"                           . "ðŸ¥µ")
    ("cold"                          . "ðŸ¥¶")
    ("scream"                        . "ðŸ˜±")
    ("fearful"                       . "ðŸ˜¨")
    ("disapointed"                   . "ðŸ˜°")
    ("relieved"                      . "ðŸ˜¥")
    ("sweat"                         . "ðŸ˜“")
    ("thinking"                      . "ðŸ¤”")
    ("shush"                         . "ðŸ¤«")
    ("liar"                          . "ðŸ¤¥")
    ("blank_face"                    . "ðŸ˜¶")
    ("neutral"                       . "ðŸ˜")
    ("expressionless"                . "ðŸ˜‘")
    ("grimace"                       . "ðŸ˜¬")
    ("rolling_eyes"                  . "ðŸ™„")
    ("hushed"                        . "ðŸ˜¯")
    ("frowning"                      . "ðŸ˜¦")
    ("anguished"                     . "ðŸ˜§")
    ("wow"                           . "ðŸ˜®")
    ("astonished"                    . "ðŸ˜²")
    ("sleeping"                      . "ðŸ˜´")
    ("drooling"                      . "ðŸ¤¤")
    ("sleepy"                        . "ðŸ˜ª")
    ("dizzy"                         . "ðŸ˜µ")
    ("zipper_mouth"                  . "ðŸ¤")
    ("woozy"                         . "ðŸ¥´")
    ("sick"                          . "ðŸ¤¢")
    ("vomiting"                      . "ðŸ¤®")
    ("sneeze"                        . "ðŸ¤§")
    ("mask"                          . "ðŸ˜·")
    ("bandaged_head"                 . "ðŸ¤•")
    ("money_face"                    . "ðŸ¤‘")
    ("cowboy"                        . "ðŸ¤ ")
    ("imp"                           . "ðŸ˜ˆ")
    ("ghost"                         . "ðŸ‘»")
    ("alien"                         . "ðŸ‘½")
    ("robot"                         . "ðŸ¤–")
    ("clap"                          . "ðŸ‘")
    ("thumpup"                       . "ðŸ‘")
    ("+1"                            . "ðŸ‘")
    ("thumbdown"                     . "ðŸ‘Ž")
    ("-1"                            . "ðŸ‘Ž")
    ("ok"                            . "ðŸ‘Œ")
    ("pinch"                         . "ðŸ¤")
    ("left"                          . "ðŸ‘ˆ")
    ("right"                         . "ðŸ‘‰")
    ("down"                          . "ðŸ‘‡")
    ("wave"                          . "ðŸ‘‹")
    ("pray"                          . "ðŸ™")
    ("eyes"                          . "ðŸ‘€")
    ("brain"                         . "ðŸ§ ")
    ("facepalm"                      . "ðŸ¤¦")
    ("tada"                          . "ðŸŽ‰")
    ("fire"                          . "ðŸ”¥")
    ("flying_money"                  . "ðŸ’¸")
    ("lighbulb"                      . "ðŸ’¡")
    ("heart"                         . "â¤ï¸")
    ("sparkling_heart"               . "ðŸ’–")
    ("heartbreak"                    . "ðŸ’”")
    ("100"                           . "ðŸ’¯")))

(defvar lui-emoticons-alist
  '((":)"   . "slight_smile")
    (";)"   . "wink")
    (":D"   . "smile")
    ("=D"   . "grin")
    ("xD"   . "laughing")
    (";("   . "joy")
    (":P"   . "stuck_out_tongue")
    (";D"   . "stuck_out_tongue_wink")
    ("xP"   . "stuck_out_tongue_closed_eyes")
    (":("   . "slight_frown")
    (";("   . "cry")
    (";'("  . "sob")
    (">:("  . "angry")
    (">>:(" . "rage")
    (":o"   . "wow")
    (":O"   . "astonished")
    (":/"   . "confused")
    (":-/"  . "thinking")
    (":|"   . "neutral")
    (":-|"  . "expressionless")))
#+end_src

** Very large files

The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.

#+begin_src emacs-lisp :tangle packages.el
(package! vlf :recipe (:host github :repo "emacs-straight/vlf" :files ("*.el"))
  :pin "cacdb359f8c37c6e7e4c7937462b632d22462130")
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write
  vlf-search vlf-occur vlf-follow vlf-ediff vlf
  :commands vlf vlf-mode
  :init
  <<vlf-largefile-prompt>>
  :config
  (advice-remove 'abort-if-file-too-large #'ad-Advice-abort-if-file-too-large)
  <<vlf-linenum-offset>>)
#+end_src

#+RESULTS:

Now, there are one or two tweaks worth applying to VLF. For starters, it goes to
the liberty of advising ~abort-if-file-too-large~, and in doing so removes the
option of opening files literally. I think that's a bit much, so we can remove
the advice and instead override ~files--ask-user-about-large-file~ (the more
appropriate function, I think) as a simpler approach, just sacrificing the
original behaviour with src_elisp{(setq vlf-application 'always)} (which I can't
imagine using anyway).

#+name: vlf-largefile-prompt
#+begin_src emacs-lisp :tangle no
(defadvice! +files--ask-about-large-file-vlf (size op-type filename offer-raw)
  "Like `files--ask-user-about-large-file', but with support for `vlf'."
  :override #'files--ask-user-about-large-file
  (if (eq vlf-application 'dont-ask)
      (progn (vlf filename) (error ""))
    (let ((prompt (format "File %s is large (%s), really %s?"
                          (file-name-nondirectory filename)
                          (funcall byte-count-to-string-function size) op-type)))
      (if (not offer-raw)
          (if (y-or-n-p prompt) nil 'abort)
        (let ((choice
               (car
                (read-multiple-choice
                 prompt '((?y "yes")
                          (?n "no")
                          (?l "literally")
                          (?v "vlf"))
                 (files--ask-user-about-large-file-help-text
                  op-type (funcall byte-count-to-string-function size))))))
          (cond ((eq choice ?y) nil)
                ((eq choice ?l) 'raw)
                ((eq choice ?v)
                 (vlf filename)
                 (error ""))
                (t 'abort)))))))
#+end_src

#+RESULTS: vlf-largefile-prompt

As you go from one chunk fetched by VLF to the next, the displayed line number
of the first line /in each chunk/ is unchanged. I think it's reasonable to hope
for an /overall/ line number, and by tracking chunk's cumulative line numbers we
can implement this behaviour fairly easily.

#+name: vlf-linenum-offset
#+begin_src emacs-lisp :tangle no
(defvar-local +vlf-cumulative-linenum '((0 . 0))
  "An alist keeping track of the cumulative line number.")

(defun +vlf-update-linum ()
  "Update the line number offset."
  (let ((linenum-offset (alist-get vlf-start-pos +vlf-cumulative-linenum)))
    (setq display-line-numbers-offset (or linenum-offset 0))
    (when (and linenum-offset (not (assq vlf-end-pos +vlf-cumulative-linenum)))
      (push (cons vlf-end-pos (+ linenum-offset
                                 (count-lines (point-min) (point-max))))
            +vlf-cumulative-linenum))))

(add-hook 'vlf-after-chunk-update-hook #'+vlf-log-poses-a)

;; Since this only works with absolute line numbers, let's make sure we use them.
gadd-hook! 'vlf-mode-hook (setq-local display-line-numbers t)
#+end_src

The other thing that doesn't work too well with VLF is searching with anything
other than =M-x occur=. This is because trying to go to the next match at the end
of a chunk usually wraps the point to the beginning of the chunk, instead of
moving to the next chunk.

#+begin_src emacs-lisp :tangle no
(defun +vlf-next-chunk-or-start ()
  (if (= vlf-file-size vlf-end-pos)
      (vlf-jump-to-chunk 1)
    (vlf-next-batch 1))
  (goto-char (point-min)))

(defun +vlf-last-chunk-or-end ()
  (if (= 0 vlf-start-pos)
      (vlf-end-of-file)
    (vlf-prev-batch 1))
  (goto-char (point-max)))

(defun +vlf-isearch-wrap ()
  (if isearch-forward
      (+vlf-next-chunk-or-start)
    (+vlf-last-chunk-or-end)))

(add-hook! 'vlf-mode-hook (setq-local isearch-wrap-function #'+vlf-isearch-wrap))
#+end_src

#+RESULTS:

Unfortunately, since evil-search doesn't have an analogue to
~isearch-wrap-function~, we can't easily add support to it.

* DONE Eaf  Core
CLOSED: [2022-04-15 Fri 11:42]
** eaf confv2
#+begin_src emacs-lisp :tangle no

;; Don't forget to run M-x eaf-install-dependencies
(use-package! eaf
  ;; :unless gv/is-termux
  :bind (("C-c W" . gv/bm))
  ;; :demand t
  ;; Set to "/usr/share/emacs/site-lisp/eaf" if installed from AUR
  :load-path "~/.emacs.d/site-lisp/emacs-application-framework/"
  :init
  (use-package! epc      :defer t :ensure t)
  (use-package! ctable   :defer t :ensure t)
  (use-package! deferred :defer t :ensure t)
  (use-package! s        :defer t :ensure t)
  ;; (setq browse-url-browser-function 'eaf-open-browser)
  :config
  (defun slurp (f)
    (with-temp-buffer
      (insert-file-contents f)
      (buffer-substring-no-properties
       (point-min)
       (point-max))))
  (defun gv/bm ()
    (interactive)
    (add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/app/browser/")
    (require 'eaf-browser)

    (let ((selected (completing-read
                     "Select URL: " (split-string
                                     (slurp "~/.config/bookmarks") "\n" t))))
      (let ((url (car (split-string
                       selected
                       " " t))))
        (if (string-match-p "\\http.*\\'" url)
            ;; Open selected url
            (eaf-open-browser url)
          ;; Search entered text
          (eaf-search-it selected)))))
  (setq eaf-browser-continue-where-left-off t)
  (setq eaf-browser-dnefault-search-engine "duckduckgo")
  (setq eaf-browser-enable-adblocker "true")
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (dolist (keys '("i" "h" "j" "k" "l"
  ;;              "d" "f" "x" ","
  ;;              "-" "." "0" "1"
  ;;              "2" "=" "B" "F"
  ;;              "G" "H" "I" "J"
  ;;              "K" "L" "P" "T"
  ;;              "Y" "c" "d" "e"
  ;;              "f" "g" "m" "n"
  ;;              "o" "p" "r" "t"
  ;;              "u" "v" "x" "y"
  ;;              (eaf-bind-key nil key eaf-browser-keybinding))))
  )
#+end_src

#+RESULTS:
: gv/bm

** eaf config
#+begin_src emacs-lisp :tangle no

(add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
(use-package! eaf
  :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
  :custom
  (setq eaf-browser-continue-where-left-off t)
  (setq eaf-browser-enable-adblocker t)
  (setq browse-url-browser-function 'eaf-open-browser)
(setq eaf-browser-translate-language "es")
(setq eaf-browser-continue-where-left-off t)
(setq eaf-browser-download-path "~/Downloads/eaf/")
(setq eaf-mindmap-dark-mode "follow") ; default option
(setq eaf-browser-dark-mode "force")
(setq eaf-terminal-dark-mode nil)
(setq eaf-pdf-dark-mode "ignore") ; see below
(setq eaf-browser-default-search-engine "duckduckgo")
(setq eaf-music-play-order "random")
(setq eaf-browser-blank-page-url "https://duckduckgo.com")
(setq eaf-browser-default-search-engine "duckduckgo")
  :config
  (defalias 'browse-web #'eaf-open-browser))
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
;; (setq eaf-browser-aria2-proxy-host "127.0.0.1")
;; (setq eaf-browser-aria2-proxy-port "9888")
;; sudo systemctl start privoxy
;; (setq eaf-browser-remember-history nil)
;; (setq eaf-browser-default-zoom 1.25)
;; (setq eaf-browser-enable-plugin nil)
;; (setq eaf-browser-enable-javascript nil)
;; (setq eaf-camera-save-path "new/path/")
(defcustom eaf-music-default-file nil "~/Music/"
  :type 'file)
(defun eaf-org-open-file (file &optional link)
  "An wrapper function on `eaf-open'."
  (eaf-open file))

;; use `emacs-application-framework' to open PDF file: link
(add-to-list 'org-file-apps '("\\.pdf\\'" . eaf-org-open-file))


#+end_src

#+RESULTS:
: ((\.pdf\' . eaf-org-open-file) (remote . emacs) (auto-mode . emacs) (directory . emacs) (\.mm\' . default) (\.x?html?\' . default) (\.pdf\' . default))
** load eaf apps
#+begin_src emacs-lisp :tangle no

 (require 'eaf-pdf-viewer)
 (require 'eaf-browser)
 (require 'eaf-rss-reader)
 (require 'eaf-markdown-previewer)
 (require 'eaf-airshare)
 (require 'eaf-file-sender)
 (require 'eaf-jupyter)
 (require 'eaf-browser)
 (require 'eaf-terminal)
 (require 'eaf-mindmap)
 (require 'eaf-system-monitor)
 (require 'eaf-camera)
 (require 'eaf-org-previewer)
 (require 'eaf-org)
 (require 'eaf-image-viewer)
 ;; (require 'eaf-mermaid)
 ;; (require 'eaf-demo)
 ;; (require 'eaf-video-player)
 ;; (require 'eaf-vue-demo)
 ;; (require 'eaf-music-player)
 ;; (require 'eaf-file-browser)
 ;; (require 'eaf-netease-cloud-music)
 ;; (require 'eaf-file-manager)
 ;; (require 'eaf-evil)

#+end_src

#+RESULTS:
: eaf-image-viewer

** eaf evil

 I usually don't use it as it causes issues with doom keybinds

#+begin_src emacs-lisp :tangle no
(require 'eaf-evil)

(define-key key-translation-map (kbd "SPC")
    (lambda (prompt)
      (if (derived-mode-p 'eaf-mode)
          (pcase eaf--buffer-app-name
            ("browser" (if  (string= (eaf-call-sync "call_function" eaf--buffer-id "is_focus") "True")
                           (kbd "SPC")
                         (kbd eaf-evil-leader-key)))
            ("pdf-viewer" (kbd eaf-evil-leader-key))
            ("image-viewer" (kbd eaf-evil-leader-key))
            (_  (kbd "SPC")))
        (kbd "SPC"))))

#+end_src

#+RESULTS:
| lambda | (prompt) | (if (derived-mode-p 'eaf-mode) (pcase eaf--buffer-app-name (browser (if (string= (eaf-call-sync call_function eaf--buffer-id is_focus) True) (kbd SPC) (kbd eaf-evil-leader-key))) (pdf-viewer (kbd eaf-evil-leader-key)) (image-viewer (kbd eaf-evil-leader-key)) (_ (kbd SPC))) (kbd SPC)) |

** Bufler

#+begin_src emacs-lisp
(use-package! bufler
  ;; :disabled
  :ensure nil
  ;; :straight t
  :bind (("C-c d" . bufler-switch-buffer)
         ("C-c w" . bufler-workspace-frame-set))
  :config
  (evil-collection-define-key 'normal 'bufler-list-mode-map
    (kbd "RET")   'bufler-list-buffer-switch
    (kbd "M-RET") 'bufler-list-buffer-peek
    (kbd "C-d") 'bufler-list-buffer-kill)

  (setf bufler-groups
        (bufler-defgroups
          ;; Subgroup collecting all named workspaces.
          (group (auto-workspace))
          ;; Subgroup collecting buffers in a projectile project.
          (group (auto-projectile))
          ;; Grouping browser windows
          (group
           (group-or "Browsers"
                     (name-match "Vimb" (rx bos "vimb"))
                     (name-match "qutebrowser" (rx bos "Qutebrowser"))
                     (name-match "F# " (rx bos "Qutebrowser"))
                     (name-match "firefoxdeveloperedition" (rx bos "firefoxdeveloperedition"))
                     (name-match "Chromium" (rx bos "Chromium"))))
          (group
           (group-or "Chat"
                     (mode-match "Telega" (rx bos "telega-"))))
          (group
           ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
           (group-or "Help/Info"
                     (mode-match "*Help*" (rx bos (or "help-" "helpful-")))
                     ;; (mode-match "*Helpful*" (rx bos "helpful-"))
                     (mode-match "*Info*" (rx bos "info-"))))
          (group
           ;; Subgroup collecting all special buffers (i.e. ones that are not
           ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
           ;; through to other groups, so they end up grouped with their project buffers).
           (group-and "*Special*"
                      (name-match "**Special**"
                                  (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace" "Pinentry") "*"))
                      (lambda (buffer)
                        (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                             buffer)
                                    (funcall (mode-match "Dired" (rx bos "dired"))
                                             buffer)
                                    (funcall (auto-file) buffer))
                          "*Special*"))))
          ;; Group remaining buffers by major mode.
          (auto-mode))))
#+end_src

#+RESULTS:
: bufler-workspace-frame-set

** Window configuration

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

*** Window rules and basic tweaks (window.el)
**** desc
The =display-buffer-alist= is intended as a rule-set for controlling the
placement of windows.  This is mostly needed for ancillary buffers, such
as shells, compilation output, and the like.  The objective is to create
a more intuitive workflow where targeted buffer groups or types are
always shown at a given location, on the premise that predictability
improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
GNU Emacs Lisp Reference Manual (evaluate =(elisp) Displaying Buffers=).
Information can also be found at all times via =C-h f display-buffer= and,
for my particular settings, with =C-h f display-buffer-in-side-window=.

With regard to the key bindings you will find here, most combinations
are complementary to the standard ones, such as =C-x 1= being aliased as
=s-1=, =C-x o= turning into =s-o= and the like.  They *do not replace* the
defaults: they just provide more convenient access to their
corresponding functions.  Some involve the Super key, in accordance with
the norms described in the relevant [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][note on the matter]].  Concerning the
=balance-windows-area= I find that it is less intrusive than the original
=balance-windows= normally bound to the same =C-x +=.  Lastly, the
=resize-window-repeat-map= is for repeatable key chords that work with the
=repeat-mode= for Emacs28 (read my description of what it is and how to
set it up: [[#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0][Repeatable key chords (repeat-mode)]]).

Make sure to also review the other window-related keys in those
sections:

+ [[#h:6b4f7792-6ccd-45d5-b262-01d200639072][Window history (winner-mode)]].
+ [[#h:230d96c8-a955-4b82-844d-9de9a1b7c531][Directional window motions (windmove)]].

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch my [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07).

**** code
#+begin_src emacs-lisp :tangle no
;;; Window rules and basic tweaks (window.el)
(use-package! window
  :config
  (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\**prot-elfeed-bongo-queue.*"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -2))
          ("\\*\\(prot-elfeed-mpv-output\\|world-clock\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -1))
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*"    ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*keycast\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (window-width . 0.25)
           (side . right)
           (slot . -1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; bottom side window
          ("\\*Org Select\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; ("\\*\\(Embark\\)?.*Completions.*"
          ;;  (display-buffer-reuse-mode-window display-buffer-at-bottom)
          ;;  (window-parameters . ((no-other-window . t))))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom))
          ;; below current window
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected))
          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.2))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x <down>") #'next-buffer)
    (define-key map (kbd "C-x <up>") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'
  (let ((map resize-window-repeat-map))
    (define-key map ">" #'enlarge-window-horizontally)
    (define-key map "<" #'shrink-window-horizontally)))
#+end_src

#+RESULTS:
: t

*** Tabs for window layouts (tab-bar.el and prot-tab.el)
**** desc
Starting with version 27.1, Emacs has built-in support for two distinct
concepts of "tabs":

1. Work spaces that contain windows in any given layout.
2. A list of buffers presented as buttons at the top of the window.

The former, represented by the =tab-bar= library, is best understood as
the equivalent of "virtual desktops", as these are used in most desktop
environments or window managers.

The latter, implemented in =tab-line=, is the same as the tabs you are
used to in web browsers.  Each buffer is assigned to a single tab.
Clicking on the tab takes you to the corresponding buffer.

I do not need the =tab-line= as I find such tabs to be inefficient at
scale.  Finding a buffer through search mechanisms is generally faster:
it does not matter whether you have ten or a hundred buffers on the list
(unless, of course, they all have similar names in which case you are in
trouble either way---do not forget to check my [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer settings]]).

On the other hand, the work spaces (=tab-bar=) are very useful for
organising the various applications that are running inside of Emacs.
You can, for example, have your current project on tab (workspace) 1,
your email and news reader on 2, music on 3, and so on.  Of course, this
can also be achieved by using separate frames for each of these, though
I generally prefer working in a single frame (plus you can define a
window configuration or frameset in a register).

Starting with Emacs 28, the =tab-bar= can re-use indicators from the mode
line.  With a bit of tweaking (and dirty hacks---but, hey, they work!)
we can hide all mode lines and replace them with a single status bar
that spans the length of the frame (just like the Tmux status line, if
you have ever used that).  I was aware of this possibility for a long
time, as I keep track of developments in emacs.git, but I never actually
tinkered with the available options...  Until Philip Kaludercic
published the article [[http://ruzkuku.com/texts/emacs-global.html][Emacs 28 has a global mode line]] (2021-07-29) which
inspired me to finally start experimenting.

As of this writing (2021-07-30), upstream Emacs only covers the part of
the mode line that shows the current time and the like (technically the
=global-mode-string=).  So my =prot-tab.el= library, which is reproduced
after the following package configurations, implements some more
indicators that I want to use.

The minor mode which takes care of this new "status line" concept is
=prot-tab-status-line=.  Check the code to notice the dirty hacks I
alluded to.

In the past, I was using a command which would merely toggle the display
of the =tab-bar= (=prot-tab-bar-toggle=), but now that I can finally avoid
the duplication of information and keep things cleaner, I think I am not
going back to the paradigm where each window has its own mode line.

To learn about the key bindings that the =tab-bar= uses, type its prefix
key =C-x t= and follow it up with =C-h= (read [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).

Finally, now that =tab-bar-history-mode= is a de facto replacement for
=winner-mode=.  Like Winner, it stores a history of window layouts.
Unlike Winner, it keeps histories that are specific to each tab.  The
problem with Winner is that when we switch between tabs, it continues to
retain a linear history, so when we try to undo in one tab, we
effectively get the state of the previous one.  As such, my two commands
=prot-tab-winner-undo= and =prot-tab-winner-redo= provide thin wrappers
around the two modes.  If tabs are present, then we use the history for
them, else we fall back to Winner.

Here are my settings, followed by the entirety of =prot-tab.el=.

**** code
#+begin_src emacs-lisp :tangle no
;;; Tabs for window layouts (tab-bar.el and prot-tab.el)
(use-package! tab-bar
  :config
  (setq tab-bar-close-button-show nil)
  (setq tab-bar-close-last-tab-choice nil)
  (setq tab-bar-close-tab-select 'recent)
  (setq tab-bar-new-tab-choice t)
  (setq tab-bar-new-tab-to 'right)
 (setq tab-bar-position nil)
  (setq tab-bar-show nil)
  (setq tab-bar-tab-hints nil)
  (setq tab-bar-tab-name-function 'tab-bar-tab-name-current)

  (tab-bar-mode -1)                     ; see `prot-tab-status-line'

  ;; Same concept as `winner-mode'.  See the `prot-tab-winner-undo' and
  ;; its counterpart.
  (tab-bar-history-mode 1))

(load "prot-tab")
(use-package! prot-tab
  :config
  (setq prot-tab-tab-select-num-threshold 3)
  (setq tab-bar-format                    ; Emacs 28
        '(prot-tab-format-space-single
          prot-tab-format-mule-info
          prot-tab-format-modified
          tab-bar-format-tabs-groups
          prot-tab-format-space-double
          prot-tab-format-position
          prot-tab-format-space-double
          prot-tab-format-vc
          prot-tab-format-space-double
          prot-tab-format-modes         ; FIXME 2021-07-30: Make it work with `minions'.
          tab-bar-format-align-right
          prot-tab-format-misc-info
          prot-tab-format-space-double
          tab-bar-format-global
          prot-tab-format-space-single))

  (add-hook 'after-init-hook #'prot-tab-status-line)

  (let ((map global-map))
    (define-key map (kbd "C-x <right>") #'prot-tab-winner-redo)
    (define-key map (kbd "C-x <left>") #'prot-tab-winner-undo)
    (define-key map (kbd "<f8>") #'prot-tab-status-line) ; unopinionated alternative: `prot-tab-bar-toggle'
    (define-key map (kbd "C-x t t") #'prot-tab-select-tab-dwim)))

;; ;; This is only included as a reference.
;; (prot-emacs-builtin-package 'tab-line
;;   (global-tab-line-mode -1))
#+end_src

#+RESULTS:
: t

The =prot-tab.el= code, which is in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]:

#+include: prot-lisp/prot-tab.el src emacs-lisp :tangle no

** DONE Shackle
CLOSED: [2022-04-05 Tue 19:20]
Shackle is an easy way to customise the display rules for windows rather than messing up with display-buffer-alist.

#+begin_src emacs-lisp :tangle no
(use-package! shackle
  :custom
  ((shackle-rules
    (let ((repls "\\*\\(cider-repl\\|sly-mrepl\\|ielm\\)")
          (godot "\\*godot - .*\\*")
          (vcs   "\\*\\(Flymake\\|Package-Lint\\|vc-\\(git\\|got\\) :\\).*")
          (elfeed "\\*elfeed-entry\\*")
          (vmd    "\\*vmd console .*"))
      `((compilation-mode :noselect t
                          :align above
                          :size 0.2)
        ("*Async Shell Command*" :ignore t)
        (,repls :regexp t
                :align below
                :size 0.3)
        (,godot :regexp t
                :align t
                :size 0.3)
        (occur-mode :select t
                    :align right
                    :size 0.3)
        (diff-mode :select t)
        (help-mode :select t
                   :align left
                   :size 0.3)
        (,vcs :regexp t
              :align above
              :size 0.15
              :select t)
        (,elfeed :regexp t
                 :align t
                 :select t
                 :size 0.75)
        (,vmd :regexp t
              :align below
              :select t
              :size 0.3))))
   (shackle-default-rule nil ; '(:inhibit-window-quit t)
                         ))
  :config (shackle-mode))
#+end_src

#+RESULTS:
: t

** Outline mode, outline minor mode, and extras (prot-outline.el)
*** desc
The =outline.el= library defines a major mode (=outline-mode=) that is
similar to =org-mode= in that it consists of headings which can be
expanded or contracted individually or as a group (actually Outline
predates Org).  The major mode is meant to work with plain text files,
or be leveraged by other packages that need to have some structure and
the accompanying benefits of outline folding.  In practice, however, I
never found a dedicated use for it that would justify it over the more
featureful Org.

Where =outline.el= truly shines, in my experience, is in the minor mode it
defines (=outline-minor-mode=), which provides the familiar structured,
heading-folding facilities in other major modes, like =emacs-lisp-mode= or
any arbitrary mode, like =diff-mode= and the =diary=.

Also read:

+ [[#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9][Calendar and Diary (and prot-diary.el)]].
+ [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]].

With some careful tweaks you can continue to work on your code while
also benefitting from a more effective means of organising and reviewing
what you have.

In practice, to make an outline for Elisp buffers, you need to start a
comment line /without leading spaces/ and make it at least three comment
delimiters long (=;;;=) followed by a space and then the text of the
heading, such as =;;; Code:=.  That is considered a heading level 1.
Every extra delimiter will increase heading levels accordingly.  The
buffer-local variable =outline-regexp= determines what constitutes a
heading for this purpose.

Now on to my custom library, =prot-outline.el= which builds on those
concepts:

+ Provide several new commands and minor extras for working with
  outlines.

+ Define a =prot-outline-minor-mode-safe= command that checks whether the
  current buffer's major mode is not a member of a blocklist.  The idea
  is to not run =outline-minor-mode= with major modes that already provide
  its functionality: =org-mode=, =outline-mode=, =markdown-mode=.

Watch my [[https://protesilaos.com/codelog/2020-07-20-emacs-outline-imenu/][video demo of outline-minor-mode and imenu]] (2020-07-20), though
note that it was recorded long before I wrote =prot-outline.el=.  In
particular, older versions of my code would establish bindings for
=imenu.el=.  This was done via bespoke entry and exit hooks and was
intended to complement the standard Imenu headings with those of the
Outline.  This is no longer needed because =consult-outline= does exactly
that ([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).

A quick reminder of why this matters: you can navigate the outline using
minibuffer completion, which is my favourite way to browse a file.  You
can, in the same spirit, use Embark to produce a buffer with the
completion candidates, i.e. the headings, or a subset you have narrowed
to, and navigate therefrom.  It really is an efficient workflow:
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

*** code
#+begin_src emacs-lisp :tangle no
;;; Outline mode, outline minor mode, and extras (prot-outline.el)
(use-package! outline
  :config
  (setq outline-minor-mode-highlight 'override) ; emacs28
  (setq outline-minor-mode-cycle t)             ; emacs28
  (let ((map outline-minor-mode-map))
    ;; ;; NOTE 2021-07-25: Those two are already defined (emacs28).
    ;; (define-key map (kbd "TAB") #'outline-cycle)
    ;; (define-key map (kbd "<backtab>") #'outline-cycle-buffer) ; S-TAB
    (define-key map (kbd "C-c C-n") #'outline-next-visible-heading) ;;def
    (define-key map (kbd "C-c C-p") #'outline-previous-visible-heading) ;;def
    (define-key map (kbd "C-c C-f") #'outline-forward-same-level) ;;]h
    (define-key map (kbd "C-c C-b") #'outline-backward-same-level) ;;[h
    (define-key map (kbd "C-c C-a") #'outline-show-all)
    (define-key map (kbd "C-c C-o") #'outline-hide-other)
    (define-key map (kbd "C-c C-u") #'outline-up-heading))) ;;def
(load "prot-outline")
(use-package! prot-outline
  :config
  (let ((map outline-minor-mode-map))
    (define-key map (kbd "C-c C-v") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "M-<down>") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "C-c M-v") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "M-<up>") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "C-x n s") #'prot-outline-narrow-to-subtree))
  (define-key global-map (kbd "<f10>") #'prot-outline-minor-mode-safe))
#+end_src

#+RESULTS:
: t
* from sasha chua
#+begin_src emacs-lisp

(defun my-goto-random-char ()
  (interactive)
  (goto-char (random (point-max))))
#+end_src
#+CAPTION: yeah well
[[file:/home/shiva/Screenshots/maim-region-20220928-104859.png]]

#+RESULTS:
: my-goto-random-char
#+begin_src emacs-lisp
(defvar my-screenshot-directory "~/Screenshots")
(defun my-org-insert-screenshot (file &optional note)
  (interactive (list
                (if current-prefix-arg
                    (expand-file-name
                     (consult--read
                      (reverse (directory-files my-screenshot-directory nil "\\.png$"))
                      :sort nil
                      :require-match t
                      :category 'file
                      :state (lambda (candidate state)
                               (when candidate
                                 (with-current-buffer (find-file-noselect (expand-file-name candidate my-screenshot-directory))
                                   (display-buffer (current-buffer))))))
                     my-screenshot-directory)
                  (my-latest-file my-screenshot-directory))))
  (save-window-excursion
    (with-current-buffer (find-file-noselect file) (display-buffer (current-buffer)))
    (insert "#+CAPTION: " (or note (read-string "Caption: "))))
  (save-excursion (insert "\n" (org-link-make-string (concat "file:" file)) "\n")))
(defun my-copy-last-screenshot-to-file (new-filename)
  (interactive (list (read-file-name (format "Copy %s to: " (file-name-nondirectory (my-latest-file my-screenshot-directory))))))
  (copy-file (my-latest-file my-screenshot-directory) new-filename))

(defun my-copy-last-screenshot-and-insert-into-org (new-filename caption)
  (interactive (list (read-file-name (format "Copy %s to: " (file-name-nondirectory (my-latest-file my-screenshot-directory))))
                     (read-string "Caption: ")))
  (copy-file (my-latest-file my-screenshot-directory) new-filename t)
  (insert "#+CAPTION: " caption "\n"
          (org-link-make-string (concat "file:" (file-relative-name new-filename))) "\n"))
(defun my-latest-file (path &optional filter)
  "Return the newest file in PATH. Optionally filter by FILTER."
  (car (sort (seq-remove #'file-directory-p (directory-files path 'full filter t)) #'file-newer-than-file-p)))
(defun my-ledger-change-account (account)
  (interactive (list (ledger-read-account-with-prompt (concat (ledger-xact-payee) ": "))))
  (beginning-of-line)
  (re-search-forward ledger-account-name-or-directive-regex)
  (replace-match (concat "  " account "  ") t t))
#+end_src


#+begin_src emacs-lisp

;; Based on https://www.reddit.com/r/emacs/comments/l4v1ux/one_of_the_most_useful_small_lisp_functions_in_my-


(defun my-toggle-or-create (buffer-name buffer-create-fn &optional switch-cont)
  (interactive)
  (let ((target-buf (get-buffer buffer-name)))
    (prin1 target-buf)
    (cond
     ((equal (current-buffer) target-buf) (switch-to-buffer nil))
     (target-buf
      (switch-to-buffer target-buf)
      (if switch-cont (funcall switch-cont)))
     (t (funcall buffer-create-fn)
        (if switch-cont (funcall switch-cont))))))

(defun make-toggle-function (buffer-name buffer-create-fn &optional switch-cont)
  "Makes a toggle-function to have raise-or-create behaviour.

Creates a toggle-function that executes BUFFER-CREATE-FN if a
buffer named BUFFER-NAME doesn't exist, switches to the buffer
named BUFFER-NAME if it exists, and switches to the previous
buffer if we are currently visiting buffer BUFFER-NAME.

The SWITCH-CONT argument is a function which, if given, is called
after the buffer has been created or switched to.  This allows
running further actions that setup the state of the buffer or
modify it."
  (lambda ()
    (interactive)
    (let ((target-buf (get-buffer buffer-name)))
     (if target-buf
	 (if (eq (current-buffer) target-buf)
	     (progn
	       (message "switching to other buffer")
	       (switch-to-buffer nil))
	     (progn
	       (message "switching back...")
	       (switch-to-buffer buffer-name)
	       (when switch-cont (funcall switch-cont))))
       (message "creating buffer...")
       (funcall buffer-create-fn)
       (when switch-cont (funcall switch-cont))))))


#+end_src

#+RESULTS:
: make-toggle-function

#+begin_src emacs-lisp
;; (global-set-key (kbd "")
(global-set-key (kbd "C-a")
  (make-toggle-function "*eshell*"
      (lambda () (progn (eshell)
		   (end-of-buffer)))
      (lambda () (progn (eshell/cd (default-directory))
		   (end-of-buffer)))))


#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (let ((target-buf (get-buffer buffer-name))) (if target-buf (if (eq (current-buffer) target-buf) (progn (message switching to other buffer) (switch-to-buffer nil)) (progn (message switching back...) (switch-to-buffer buffer-name) (when switch-cont (funcall switch-cont)))) (message creating buffer...) (funcall buffer-create-fn) (when switch-cont (funcall switch-cont)))) |

#+begin_src emacs-lisp
(defun xah-toggle-margin-right ()
  "Toggle the right margin between `fill-column' or window width.
     This command is convenient when reading novel, documentation."
  (interactive)
  (if (eq (cdr (window-margins)) nil)
      (set-window-margins nil 0 (- (window-body-width) fill-column))
    (set-window-margins nil 0 0)))
#+end_src

#+RESULTS:
: xah-toggle-margin-right

#+begin_src emacs-lisp
(defun my-org-contacts-template-email (&optional return-value)
  "Try to return the contact email for a template.
         If not found return RETURN-VALUE or something that would ask the user."
  (eval-when-compile (require 'gnus-art nil t))
  (eval-when-compile (require 'org-contacts nil t))
  (or (cadr (if (gnus-alive-p)
                (gnus-with-article-headers
                  (mail-extract-address-components
                   (or (mail-fetch-field "Reply-To") (mail-fetch-field "From") "")))))
      return-value
      (concat "%^{" org-contacts-email-property "}p")))

#+end_src

#+RESULTS:
: my-org-contacts-template-email

* IRC


=circe= is a client for IRC in Emacs (hey, isn't that a nice project
name+acronym), and a greek enchantress who turned humans into animals.

Let's use the former to chat to +recluses+ discerning individuals online.

[[xkcd:1782]]

Before we start seeing and sending messages, we need to authenticate with our
IRC servers. The circe manual provided a snippet for putting some of the auth
details in =.authinfo.gpg= --- but I think we should go further than that: have
the entire server info in our authinfo.

First, a reasonable format by which we can specify:
+ server
+ port
+ SASL username
+ SASL password
+ channels to join

We can have these stored like so
#+begin_src authinfo
machine chat.freenode.net login USERNAME password PASSWORD port PORT for irc channels emacs,org-mode
#+end_src

The ~for irc~ bit is used so we can uniquely identify all IRC auth info. By
omitting the =#= in channel names we can have a list of channels comma-separated
(no space!) which the secrets API will return as a single string.

#+name: irc-authinfo-reader
#+begin_src emacs-lisp :tangle no
(defun auth-server-pass (server)
  (if-let ((secret (plist-get (car (auth-source-search :host server)) :secret)))
      (if (functionp secret)
          (funcall secret) secret)
    (error "Could not fetch password for host %s" server)))

(defun register-irc-auths ()
  (require 'circe)
  (require 'dash)
  (let ((accounts (-filter (lambda (a) (string= "irc" (plist-get a :for)))
                           (auth-source-search :require '(:for) :max 10))))
    (appendq! circe-network-options
              (mapcar (lambda (entry)
                        (let* ((host (plist-get entry :host))
                               (label (or (plist-get entry :label) host))
                               (_ports (mapcar #'string-to-number
                                               (s-split "," (plist-get entry :port))))
                               (port (if (= 1 (length _ports)) (car _ports) _ports))
                               (user (plist-get entry :user))
                               (nick (or (plist-get entry :nick) user))
                               (channels (mapcar (lambda (c) (concat "#" c))
                                                 (s-split "," (plist-get entry :channels)))))
                          `(,label
                            :host ,host :port ,port :nick ,nick
                            :sasl-username ,user :sasl-password auth-server-pass
                            :channels ,channels)))
                      accounts))))
#+end_src

We'll just call src_elisp{(register-irc-auths)} on a hook when we start Circe
up.

Now we're ready to go, let's actually wire-up Circe, with one or two
configuration tweaks.
#+begin_src emacs-lisp :noweb no-export
(after! circe
  (setq-default circe-use-tls t)
  (setq circe-notifications-alert-icon "/usr/share/icons/breeze/actions/24/network-connect.svg"
        lui-logging-directory (expand-file-name "irc" doom-etc-dir)
        lui-logging-file-format "{buffer}/%Y/%m-%d.txt"
        circe-format-self-say "{nick:+13s} â”ƒ {body}")

  (custom-set-faces!
    '(circe-my-message-face :weight unspecified))

  (enable-lui-logging-globally)
  (enable-circe-display-images)

  <<org-emph-to-irc>>

  <<circe-emojis>>
  <<circe-emoji-alists>>

  (defun named-circe-prompt ()
    (lui-set-prompt
     (concat (propertize (format "%13s > " (circe-nick))
                         'face 'circe-prompt-face)
             "")))
  (add-hook 'circe-chat-mode-hook #'named-circe-prompt)

  (appendq! all-the-icons-mode-icon-alist
            '((circe-channel-mode all-the-icons-material "message" :face all-the-icons-lblue)
              (circe-server-mode all-the-icons-material "chat_bubble_outline" :face all-the-icons-purple))))

<<irc-authinfo-reader>>

(add-transient-hook! #'=irc (register-irc-auths))
#+end_src

** Org-style emphasis

Let's do our *bold*, /italic/, and _underline_ in org-syntax, using IRC control characters.
#+name: org-emph-to-irc
#+begin_src emacs-lisp
(defun lui-org-to-irc ()
  "Examine a buffer with simple org-mode formatting, and converts the empasis:
,*bold*, /italic/, and _underline_ to IRC semi-standard escape codes.
=code= is converted to inverse (highlighted) text."
  (goto-char (point-min))
  (while (re-search-forward "\\_<\\(?1:[*/_=]\\)\\(?2:[^[:space:]]\\(?:.*?[^[:space:]]\\)?\\)\\1\\_>" nil t)
    (replace-match
     (concat (pcase (match-string 1)
               ("*" "")
               ("/" "")
               ("_" "")
               ("=" ""))
             (match-string 2)
             "") nil nil)))

(add-hook 'lui-pre-input-hook #'lui-org-to-irc)
#+end_src

** Emojis

Let's setup Circe to use some emojis
#+name: circe-emojis
#+begin_src emacs-lisp :tangle no
(defun lui-ascii-to-emoji ()
  (goto-char (point-min))
  (while (re-search-forward "\\( \\)?::?\\([^[:space:]:]+\\):\\( \\)?" nil t)
    (replace-match
     (concat
      (match-string 1)
      (or (cdr (assoc (match-string 2) lui-emojis-alist))
          (concat ":" (match-string 2) ":"))
      (match-string 3))
     nil nil)))

(defun lui-emoticon-to-emoji ()
  (dolist (emoticon lui-emoticons-alist)
    (goto-char (point-min))
    (while (re-search-forward (concat " " (car emoticon) "\\( \\)?") nil t)
      (replace-match (concat " "
                             (cdr (assoc (cdr emoticon) lui-emojis-alist))
                             (match-string 1))))))

(define-minor-mode lui-emojify
  "Replace :emojis: and ;) emoticons with unicode emoji chars."
  :global t
  :init-value t
  (if lui-emojify
      (add-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)
    (remove-hook! lui-pre-input #'lui-ascii-to-emoji #'lui-emoticon-to-emoji)))
#+end_src

Now, some actual emojis to use.
#+name: circe-emoji-alists
#+begin_src emacs-lisp :tangle no
(defvar lui-emojis-alist
  '(("grinning"                      . "ðŸ˜€")
    ("smiley"                        . "ðŸ˜ƒ")
    ("smile"                         . "ðŸ˜„")
    ("grin"                          . "ðŸ˜")
    ("laughing"                      . "ðŸ˜†")
    ("sweat_smile"                   . "ðŸ˜…")
    ("joy"                           . "ðŸ˜‚")
    ("rofl"                          . "ðŸ¤£")
    ("relaxed"                       . "â˜ºï¸")
    ("blush"                         . "ðŸ˜Š")
    ("innocent"                      . "ðŸ˜‡")
    ("slight_smile"                  . "ðŸ™‚")
    ("upside_down"                   . "ðŸ™ƒ")
    ("wink"                          . "ðŸ˜‰")
    ("relieved"                      . "ðŸ˜Œ")
    ("heart_eyes"                    . "ðŸ˜")
    ("yum"                           . "ðŸ˜‹")
    ("stuck_out_tongue"              . "ðŸ˜›")
    ("stuck_out_tongue_closed_eyes"  . "ðŸ˜")
    ("stuck_out_tongue_wink"         . "ðŸ˜œ")
    ("zanzy"                         . "ðŸ¤ª")
    ("raised_eyebrow"                . "ðŸ¤¨")
    ("monocle"                       . "ðŸ§")
    ("nerd"                          . "ðŸ¤“")
    ("cool"                          . "ðŸ˜Ž")
    ("star_struck"                   . "ðŸ¤©")
    ("party"                         . "ðŸ¥³")
    ("smirk"                         . "ðŸ˜")
    ("unamused"                      . "ðŸ˜’")
    ("disapointed"                   . "ðŸ˜ž")
    ("pensive"                       . "ðŸ˜”")
    ("worried"                       . "ðŸ˜Ÿ")
    ("confused"                      . "ðŸ˜•")
    ("slight_frown"                  . "ðŸ™")
    ("frown"                         . "â˜¹ï¸")
    ("persevere"                     . "ðŸ˜£")
    ("confounded"                    . "ðŸ˜–")
    ("tired"                         . "ðŸ˜«")
    ("weary"                         . "ðŸ˜©")
    ("pleading"                      . "ðŸ¥º")
    ("tear"                          . "ðŸ˜¢")
    ("cry"                           . "ðŸ˜¢")
    ("sob"                           . "ðŸ˜­")
    ("triumph"                       . "ðŸ˜¤")
    ("angry"                         . "ðŸ˜ ")
    ("rage"                          . "ðŸ˜¡")
    ("exploding_head"                . "ðŸ¤¯")
    ("flushed"                       . "ðŸ˜³")
    ("hot"                           . "ðŸ¥µ")
    ("cold"                          . "ðŸ¥¶")
    ("scream"                        . "ðŸ˜±")
    ("fearful"                       . "ðŸ˜¨")
    ("disapointed"                   . "ðŸ˜°")
    ("relieved"                      . "ðŸ˜¥")
    ("sweat"                         . "ðŸ˜“")
    ("thinking"                      . "ðŸ¤”")
    ("shush"                         . "ðŸ¤«")
    ("liar"                          . "ðŸ¤¥")
    ("blank_face"                    . "ðŸ˜¶")
    ("neutral"                       . "ðŸ˜")
    ("expressionless"                . "ðŸ˜‘")
    ("grimace"                       . "ðŸ˜¬")
    ("rolling_eyes"                  . "ðŸ™„")
    ("hushed"                        . "ðŸ˜¯")
    ("frowning"                      . "ðŸ˜¦")
    ("anguished"                     . "ðŸ˜§")
    ("wow"                           . "ðŸ˜®")
    ("astonished"                    . "ðŸ˜²")
    ("sleeping"                      . "ðŸ˜´")
    ("drooling"                      . "ðŸ¤¤")
    ("sleepy"                        . "ðŸ˜ª")
    ("dizzy"                         . "ðŸ˜µ")
    ("zipper_mouth"                  . "ðŸ¤")
    ("woozy"                         . "ðŸ¥´")
    ("sick"                          . "ðŸ¤¢")
    ("vomiting"                      . "ðŸ¤®")
    ("sneeze"                        . "ðŸ¤§")
    ("mask"                          . "ðŸ˜·")
    ("bandaged_head"                 . "ðŸ¤•")
    ("money_face"                    . "ðŸ¤‘")
    ("cowboy"                        . "ðŸ¤ ")
    ("imp"                           . "ðŸ˜ˆ")
    ("ghost"                         . "ðŸ‘»")
    ("alien"                         . "ðŸ‘½")
    ("robot"                         . "ðŸ¤–")
    ("clap"                          . "ðŸ‘")
    ("thumpup"                       . "ðŸ‘")
    ("+1"                            . "ðŸ‘")
    ("thumbdown"                     . "ðŸ‘Ž")
    ("-1"                            . "ðŸ‘Ž")
    ("ok"                            . "ðŸ‘Œ")
    ("pinch"                         . "ðŸ¤")
    ("left"                          . "ðŸ‘ˆ")
    ("right"                         . "ðŸ‘‰")
    ("down"                          . "ðŸ‘‡")
    ("wave"                          . "ðŸ‘‹")
    ("pray"                          . "ðŸ™")
    ("eyes"                          . "ðŸ‘€")
    ("brain"                         . "ðŸ§ ")
    ("facepalm"                      . "ðŸ¤¦")
    ("tada"                          . "ðŸŽ‰")
    ("fire"                          . "ðŸ”¥")
    ("flying_money"                  . "ðŸ’¸")
    ("lighbulb"                      . "ðŸ’¡")
    ("heart"                         . "â¤ï¸")
    ("sparkling_heart"               . "ðŸ’–")
    ("heartbreak"                    . "ðŸ’”")
    ("100"                           . "ðŸ’¯")))

(defvar lui-emoticons-alist
  '((":)"   . "slight_smile")
    (";)"   . "wink")
    (":D"   . "smile")
    ("=D"   . "grin")
    ("xD"   . "laughing")
    (";("   . "joy")
    (":P"   . "stuck_out_tongue")
    (";D"   . "stuck_out_tongue_wink")
    ("xP"   . "stuck_out_tongue_closed_eyes")
    (":("   . "slight_frown")
    (";("   . "cry")
    (";'("  . "sob")
    (">:("  . "angry")
    (">>:(" . "rage")
    (":o"   . "wow")
    (":O"   . "astonished")
    (":/"   . "confused")
    (":-/"  . "thinking")
    (":|"   . "neutral")
    (":-|"  . "expressionless")))
#+end_src
* *latex
** Class templates

I really like the KOMA bundle. It provides a set of mechanisms to tweak document
styling which is both easy to use, and quite comprehensive.
For example, I rather like section numbers in the margin, which can be
accomplished with
#+name: latex-hanging-secnum
#+begin_src LaTeX
\\renewcommand\\sectionformat{\\llap{\\thesection\\autodot\\enskip}}
\\renewcommand\\subsectionformat{\\llap{\\thesubsection\\autodot\\enskip}}
\\renewcommand\\subsubsectionformat{\\llap{\\thesubsubsection\\autodot\\enskip}}
#+end_src

It can also be nice to have big =\chapter=â€‹s.
#+name: latex-big-chapter
#+begin_src LaTeX
\\RedeclareSectionCommand[afterindent=false, beforeskip=0pt, afterskip=0pt, innerskip=0pt]{chapter}
\\setkomafont{chapter}{\\normalfont\\Huge}
\\renewcommand*{\\chapterheadstartvskip}{\\vspace*{0\\baselineskip}}
\\renewcommand*{\\chapterheadendvskip}{\\vspace*{0\\baselineskip}}
\\renewcommand*{\\chapterformat}{%
  \\fontsize{60}{30}\\selectfont\\rlap{\\hspace{6pt}\\thechapter}}
\\renewcommand*\\chapterlinesformat[3]{%
  \\parbox[b]{\\dimexpr\\textwidth-0.5em\\relax}{%
    \\raggedleft{{\\large\\scshape\\bfseries\\chapapp}\\vspace{-0.5ex}\\par\\Huge#3}}%
    \\hfill\\makebox[0pt][l]{#2}}
#+end_src

Now let's just sprinkle some KOMA all over the Org LaTeX classes.

#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (let* ((article-sections '(("\\section{%s}" . "\\section*{%s}")
                             ("\\subsection{%s}" . "\\subsection*{%s}")
                             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                             ("\\paragraph{%s}" . "\\paragraph*{%s}")
                             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
         (book-sections (append '(("\\chapter{%s}" . "\\chapter*{%s}"))
                                article-sections))
         (hanging-secnum-preamble "
<<latex-hanging-secnum>>
")
         (big-chap-preamble "
<<latex-big-chapter>>
"))
    (setcdr (assoc "article" org-latex-classes)
            `(,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
              ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("report" ,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("book" ,(concat "\\documentclass[twoside=false]{scrbook}"
                                   big-chap-preamble hanging-secnum-preamble)
                   ,@book-sections))
    (add-to-list 'org-latex-classes
                 `("blank" "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc-article" "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc" "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@book-sections))))

(setq org-latex-tables-booktabs t
      org-latex-hyperref-template "
<<latex-fancy-hyperref>>
"
      org-latex-reference-command "\\cref{%s}")
#+end_src


The =hyperref= setup needs to be handled separately however.
#+name: latex-fancy-hyperref
#+begin_src LaTeX
\\providecolor{url}{HTML}{0077bb}
\\providecolor{link}{HTML}{882255}
\\providecolor{cite}{HTML}{999933}
\\hypersetup{
  pdfauthor={%a},
  pdftitle={%t},
  pdfkeywords={%k},
  pdfsubject={%d},
  pdfcreator={%c},
  pdflang={%L},
  breaklinks=true,
  colorlinks=true,
  linkcolor=link,
  urlcolor=url,
  citecolor=cite\n}
\\urlstyle{same}
%% hide links styles in toc
\\NewCommandCopy{\\oldtoc}{\\tableofcontents}
\\renewcommand{\\tableofcontents}{\\begingroup\\hypersetup{hidelinks}\\oldtoc\\endgroup}
#+end_src

** A cleverer preamble
*** Use case

We often want particular snippets of LaTeX in our documents preambles.
It's a pain to have to work out / remember them every time.
For example, I almost always want to include the snippet below.

#+name: org-latex-embed-files-preamble
#+begin_src LaTeX
\\usepackage[main,include]{embedall}
\\IfFileExists{./\\jobname.org}{\\embedfile[desc=The original file]{\\jobname.org}}{}
#+end_src

We could have every package we could possibly need in every one of
~org-latex-classes~, but that's /horribly/ inefficient and I don't want to think
about maintaining that.

Instead we can provide some granularity by splitting up the features we want,
and then take the experience to a whole new level by implementing a system to
automatically detect which features are desired and generating a preamble that
provides these features.

*** Conditional Content

Let's consider content we want in particular situations.

Captions could do with a bit of tweaking such that
+ You can easily have multiple captions
+ Links to figures take you to the /top/ of the figure (not the bottom)
+ Caption labels could do with being emphasised slightly more
+ Multiline captions should run ragged-right, but only when then span more than
  one line

#+name: org-latex-caption-preamble
#+begin_src LaTeX
\\usepackage{subcaption}
\\usepackage[hypcap=true]{caption}
\\setkomafont{caption}{\\sffamily\\small}
\\setkomafont{captionlabel}{\\upshape\\bfseries}
\\captionsetup{justification=raggedright,singlelinecheck=true}
\\usepackage{capt-of} % required by Org
#+end_src

The default checkboxes look rather ugly, so let's provide some prettier alternatives.

#+name: org-latex-checkbox-preamble
#+begin_src LaTeX
\\newcommand{\\checkboxUnchecked}{$\\square$}
\\newcommand{\\checkboxTransitive}{\\rlap{\\raisebox{-0.1ex}{\\hspace{0.35ex}\\Large\\textbf -}}$\\square$}
\\newcommand{\\checkboxChecked}{\\rlap{\\raisebox{0.2ex}{\\hspace{0.35ex}\\scriptsize \\ding{52}}}$\\square$}
#+end_src

It's nice to have "message blocks", things like info/warning/error/success.
A LaTeX macro should make them trivial to create.

#+name: org-latex-box-preamble
#+begin_src LaTeX
\\ExplSyntaxOn
\\NewCoffin\\Content
\\NewCoffin\\SideRule
\\NewDocumentCommand{\\defsimplebox}{O{\\ding{117}} O{0.36em} m m m}{%
  % #1 ding, #2 ding offset, #3 name, #4 colour, #5 default label
  \\definecolor{#3}{HTML}{#4}
  \\NewDocumentEnvironment{#3}{ O{#5} }
  {
    \\vcoffin_set:Nnw \\Content { \\linewidth }
    \\noindent \\ignorespaces
    \\par\\vspace{-0.7\\baselineskip}%
    \\textcolor{#3}{#1}~\\textcolor{#3}{\\textbf{##1}}%
    \\vspace{-0.8\\baselineskip}
    \\begin{addmargin}[1em]{1em}
    }
    {
    \\end{addmargin}
    \\vspace{-0.5\\baselineskip}
    \\vcoffin_set_end:
    \\SetHorizontalCoffin\\SideRule{\\color{#3}\\rule{1pt}{\\CoffinTotalHeight\\Content}}
    \\JoinCoffins*\\Content[l,t]\\SideRule[l,t](#2,-0.7em)
    \\noindent\\TypesetCoffin\\Content
    \\vspace*{\\CoffinTotalHeight\\Content}\\bigskip
    \\vspace{-2\\baselineskip}
  }
}
\\ExplSyntaxOff
#+end_src

Lastly, we will pass this content into some global variables we for ease of
access.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-embed-files-preamble "
<<org-latex-embed-files-preamble>>
"
  "Preamble that embeds files within the pdf.")

(defvar org-latex-caption-preamble "
<<org-latex-caption-preamble>>
"
  "Preamble that improves captions.")

(defvar org-latex-checkbox-preamble "
<<org-latex-checkbox-preamble>>
"
  "Preamble that improves checkboxes.")

(defvar org-latex-box-preamble "
<<org-latex-box-preamble>>
"
  "Preamble that provides a macro for custom boxes.")
#+end_src

In the "universal preamble", we already embed the source =.org= file, but it would
be nice to embed all the tangled files. This is fairly easy to accomplish by
mapping each tangled file to a form which embeds the file if it exists.
Considering we're going this far, why not add a dedicated =#+emded= keyword, so we
can embed whatever we want.

#+begin_src emacs-lisp
(defun org-latex-embed-extra-files ()
  "Return a string that uses embedfile to embed all tangled files."
  (mapconcat
   (lambda (file-desc)
     (format "\\IfFileExists{%1$s}{\\embedfile[desc=%2$s]{%1$s}}{}"
             (thread-last (car file-desc)
               (replace-regexp-in-string "\\\\" "\\\\\\\\")
               (replace-regexp-in-string "~" "\\\\string~"))
             (cdr file-desc)))
   (append
    (mapcar (lambda (f-block)
              (let ((file-lang (cons (or (car f-block) (caddr (cadr f-block))) (caadr f-block))))
                (cons (car file-lang) (format "Tangled %s file" (cdr file-lang)))))
            (org-babel-tangle-collect-blocks)) ; all files being tangled to
    (let (extra-files)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\+embed:" nil t)
          (let* ((file-desc (split-string (org-element-property :value (org-element-at-point)) " :desc\\(?:ription\\)? ")))
            (push (cons (car file-desc) (or (cdr file-desc) "Extra file")) extra-files))))
      (nreverse extra-files)))
   "\n"))
#+end_src

Now all tangled files will be embedded, and we can embed arbitrary files like
so:
#+begin_src org
,#+embed: some-file :description flavour text about the file
#+end_src

This currently won't complete or anything like that, as we haven't told Org that
it's a keyword yet. It's also LaTeX-specific, so maybe it should be changed to
=#+latex_embed= or something like that.

*** Content-feature-preamble association

Initially this idea was implemented with an alist that associated a construct
that would search the current Org file for an indication that some feature was
needed, with a LaTeX snippet to be inserted in the preamble which would provide
that feature.
This is all well and good when there is a bijection between detected features
and the LaTeX code needed to support those features, but in many cases this
relation is not injective.

To better model the reality of the situation, I add an extra layer to this
process where each detected feature gives a list of required "feature flags".
Simply be merging the lists of feature flags we no longer have to require
injectivity to avoid LaTeX duplication. Then the extra layer forms a bijection
between there feature flags and a specification which can be used to implement
the feature.

This model also provides a number of nice secondary benefits, such as a simple
implementation of feature dependency.

#+begin_src dot :file misc/org-latex-clever-preamble.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" width="1.3" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [color="#aaaaaa" penwidth="1.2"]
    rankdir=LR

    node[group=a,color="#2ec27e"]
    "file:*.svg"
    "file:*.jpeg"
    "file:*.png"
    "#+caption"
    "xkcd:*"
    node[group=b,color="#f5c211"]
    "svg"
    "image"
    "caption"
    node[group=c,color="#813d9c"]
    "(TeX) svg"
    "(TeX) graphicx"
    "(TeX) caption"

    "file:*.svg" -> "svg" -> "(TeX) svg"
    "file:*.jpeg" -> "image" -> "(TeX) graphicx"
    "file:*.png" -> "image"
    "(TeX) svg":s -> "(TeX) graphicx":n [constraint=false]
    "#+caption" -> "caption" -> "(TeX) caption"
    "xkcd:*" -> "image"
    "xkcd:*" -> "caption"
}
#+end_src

#+caption: Association between Org features, feature flags, and LaTeX snippets required.
#+attr_html: :class invertible :alt DAG showing how Org features flow through to LaTeX :style max-width:min(24em,100%)
#+attr_latex: :width 0.6\linewidth
[[file:misc/org-latex-clever-preamble.svg]]

First we will implement the feature detection component of this model. I'd like
this to be able to use as much state information as possible, so the feature
tests should be very versatile.

#+begin_src emacs-lisp
(defvar org-latex-embed-files t
  "Embed the source .org, .tex, and any tangled files.")
(defvar org-latex-use-microtype t
  "Use the microtype pakage.")
(defvar org-latex-italic-quotes t
  "Make \"quote\" environments italic.")
(defvar org-latex-par-sep t
  "Vertically seperate paragraphs, and remove indentation.")

(pushnew!
 org-export-conditional-features
 '("\\\\(\\|\\\\\\[\\|\\\\begin{\\(?:math\\|displaymath\\|equation\\|align\\|flalign\\|multiline\\|gather\\)[a-z]*\\*?}" . maths)
 '("cref:\\|\\cref{\\|\\[\\[[^\\]+\n?[^\\]\\]\\]" . cleveref)
 '("[;\\\\]?\\b[A-Z][A-Z]+s?[^A-Za-z]" . acronym)
 '("[\u2500-\u259F]" . box-drawing)
 '("\\+[^ ].*[^ ]\\+\\|_[^ ].*[^ ]_\\|\\\\uu?line\\|\\\\uwave\\|\\\\sout\\|\\\\xout\\|\\\\dashuline\\|\\dotuline\\|\\markoverwith" . underline)
 '(":float wrap" . float-wrap)
 '(":float sideways" . rotate)
 '("^[ \t]*#\\+caption:\\|\\\\caption" . caption)
 '("\\[\\[xkcd:" . (image caption))
 '(org-latex-use-microtype . microtype)
 (cons (lambda (_info) (and org-latex-italic-quotes "^[ \t]*#\\+begin_quote\\|\\\\begin{quote}")) 'italic-quotes)
 '(org-latex-par-sep . par-sep)
 '(org-latex-embed-files . embed-files)
 (cons (lambda (_info) (and org-latex-embed-files "^[ \t]*#\\+embed\\|^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC")) 'embed-tangled)
 '("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\|[A-Za-z]+[.)]\\) \\[[ -X]\\]" . checkbox)
 '("^[ \t]*#\\+begin_warning\\|\\\\begin{warning}" . box-warning)
 '("^[ \t]*#\\+begin_info\\|\\\\begin{info}"       . box-info)
 '("^[ \t]*#\\+begin_notes\\|\\\\begin{notes}"     . box-notes)
 '("^[ \t]*#\\+begin_success\\|\\\\begin{success}" . box-success)
 '("^[ \t]*#\\+begin_error\\|\\\\begin{error}"     . box-error))
#+end_src

Then we provide a way to generate the preamble that provides those features.
In addition to the features named in ~org-latex-conditional-features~ we'll also
create /meta-features/, which can be required by other features (with =:requires=),
or be active by default (=:eager t=). For further control I some features may only
be used when certain other features are active (with =:when=), and masked by other
features (with =:prevents=). I will use the convention of starting meta-features
with =.=, and =:eager= features with =!= to make their nature more readily apparent.

Another consideration in LaTeX is load order, which matters in some cases.
Beyond that, it's nice to have some sort of sensible ordering. For this I'll
introduce an =:order= keyword. Using this I'll arrange snippets as follows.

+ =-2= Embed files setup
+ =-1= Extra file embedding
+ =0= Typography
  - =0= Fonts themselves
  - =0.1= Typographic tweaks (=microtype=)
  - =0.2= Maths setup
  - =0.3= Maths font
  - =0.4= Extra text shaping (~\acr~)
  - =0.5-0.9= Miscellaneous text modifications, trying to put shorter snippets first
+ =1= (/default/)
+ =2= Tables and figures
+ =3= Miscellaneous short content
+ =4= Fancy boxes

#+begin_src emacs-lisp
(pushnew!
 org-latex-feature-implementations
 '(image         :snippet "\\usepackage{graphicx}" :order 2)
 '(svg           :snippet "\\usepackage[inkscapelatex=false]{svg}" :order 2)
 '(maths         :snippet "\\usepackage[nofont]{bmc-maths}" :order 0.2)
 '(table         :snippet "\\usepackage{longtable}\n\\usepackage{booktabs}" :order 2)
 '(cleveref      :snippet "\\usepackage[capitalize]{cleveref}" :order 1) ; after bmc-maths
 '(float-wrap    :snippet "\\usepackage{wrapfig}" :order 2)
 '(rotate        :snippet "\\usepackage{rotating}" :order 2)
 '(caption       :snippet org-latex-caption-preamble :order 2.1)
 '(microtype     :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}\n" :order 0.1)
 '(embed-files   :snippet org-latex-embed-files-preamble :order -2)
 `(embed-tangled :requires embed-files :snippet ,(lambda (_info) (concat (org-latex-embed-extra-files) "\n")) :order -1)
 '(acronym       :snippet "\\newcommand{\\acr}[1]{\\protect\\textls*[110]{\\scshape #1}}\n\\newcommand{\\acrs}{\\protect\\scalebox{.91}[.84]{\\hspace{0.15ex}s}}" :order 0.4)
 '(box-drawing   :snippet "\\usepackage{pmboxdraw}" :order 0.05)
 '(italic-quotes :snippet "\\renewcommand{\\quote}{\\list{}{\\rightmargin\\leftmargin}\\item\\relax\\em}\n" :order 0.5)
 '(par-sep       :snippet "\\setlength{\\parskip}{\\baselineskip}\n\\setlength{\\parindent}{0pt}\n" :order 0.5)
 '(.pifont       :snippet "\\usepackage{pifont}")
 '(.xcoffins     :snippet "\\usepackage{xcoffins}")
 `(checkbox      :requires .pifont :order 3
   :snippet ,(lambda (_info)
               (concat (unless (memq 'maths features)
                         "\\usepackage{amssymb} % provides \\square")
                       org-latex-checkbox-preamble)))
 '(.fancy-box    :requires (.pifont .xcoffins) :snippet org-latex-box-preamble :order 3.9)
 '(box-warning   :requires .fancy-box :snippet "\\defsimplebox{warning}{e66100}{Warning}" :order 4)
 '(box-info      :requires .fancy-box :snippet "\\defsimplebox{info}{3584e4}{Information}" :order 4)
 '(box-notes     :requires .fancy-box :snippet "\\defsimplebox{notes}{26a269}{Notes}" :order 4)
 '(box-success   :requires .fancy-box :snippet "\\defsimplebox{success}{26a269}{\\vspace{-\\baselineskip}}" :order 4)
 '(box-error     :requires .fancy-box :snippet "\\defsimplebox{error}{c01c28}{Important}" :order 4))
#+end_src

*** Reduce default packages

Thanks to our additions, we can remove a few packages from
~org-latex-default-packages-alist~.

There are also some obsolete entries in the default value, specifically
+ =grffile='s capabilities are built into the current version of =graphicx=
+ =textcomp='s functionality has been included in LaTeX's core for a while now

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t ("pdflatex"))
        ("T1" "fontenc" t ("pdflatex"))
        ("" "xcolor" nil) ; Generally useful
        ("" "hyperref" nil)))
#+end_src

* LaTeX Export

** Compiling

By default Org uses ~pdflatex~ \times 3 + ~bibtex~. This simply won't do in our
modern world. ~latexmk~ + ~biber~ (which is used automatically with ~latexmk~) is a
simply superior combination.

#+begin_src emacs-lisp
;; org-latex-compilers = ("pdflatex" "xelatex" "lualatex"), which are the possible values for %latex
(setq org-latex-pdf-process '("LC_ALL=en_US.UTF-8 latexmk -f -pdf -%latex -shell-escape -interaction=nonstopmode -output-directory=%o %f"))
#+end_src

While ~org-latex-pdf-process~ does support a function, and we could use that
instead, this would no longer use the log buffer --- it's a bit blind, you give
it the file name and expect it to do its thing.

The default values of ~org-latex-compilers~ is given in commented form to see how
~org-latex-pdf-process~ works with them.

While the ~-%latex~ above is slightly hacky (~-pdflatex~ expects to be given a
value) it allows us to leave ~org-latex-compilers~ unmodified.
This is nice in case I open an org file that uses =#+LATEX_COMPILER= for example,
it should still work.

** Class templates

I really like the KOMA bundle. It provides a set of mechanisms to tweak document
styling which is both easy to use, and quite comprehensive.
For example, I rather like section numbers in the margin, which can be
accomplished with
#+name: latex-hanging-secnum
#+begin_src LaTeX
\\renewcommand\\sectionformat{\\llap{\\thesection\\autodot\\enskip}}
\\renewcommand\\subsectionformat{\\llap{\\thesubsection\\autodot\\enskip}}
\\renewcommand\\subsubsectionformat{\\llap{\\thesubsubsection\\autodot\\enskip}}
#+end_src

It can also be nice to have big =\chapter=â€‹s.
#+name: latex-big-chapter
#+begin_src LaTeX
\\RedeclareSectionCommand[afterindent=false, beforeskip=0pt, afterskip=0pt, innerskip=0pt]{chapter}
\\setkomafont{chapter}{\\normalfont\\Huge}
\\renewcommand*{\\chapterheadstartvskip}{\\vspace*{0\\baselineskip}}
\\renewcommand*{\\chapterheadendvskip}{\\vspace*{0\\baselineskip}}
\\renewcommand*{\\chapterformat}{%
  \\fontsize{60}{30}\\selectfont\\rlap{\\hspace{6pt}\\thechapter}}
\\renewcommand*\\chapterlinesformat[3]{%
  \\parbox[b]{\\dimexpr\\textwidth-0.5em\\relax}{%
    \\raggedleft{{\\large\\scshape\\bfseries\\chapapp}\\vspace{-0.5ex}\\par\\Huge#3}}%
    \\hfill\\makebox[0pt][l]{#2}}
#+end_src

Now let's just sprinkle some KOMA all over the Org LaTeX classes.

#+begin_src emacs-lisp :noweb no-export
(after! ox-latex
  (let* ((article-sections '(("\\section{%s}" . "\\section*{%s}")
                             ("\\subsection{%s}" . "\\subsection*{%s}")
                             ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
                             ("\\paragraph{%s}" . "\\paragraph*{%s}")
                             ("\\subparagraph{%s}" . "\\subparagraph*{%s}")))
         (book-sections (append '(("\\chapter{%s}" . "\\chapter*{%s}"))
                                article-sections))
         (hanging-secnum-preamble "
<<latex-hanging-secnum>>
")
         (big-chap-preamble "
<<latex-big-chapter>>
"))
    (setcdr (assoc "article" org-latex-classes)
            `(,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
              ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("report" ,(concat "\\documentclass{scrartcl}" hanging-secnum-preamble)
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("book" ,(concat "\\documentclass[twoside=false]{scrbook}"
                                   big-chap-preamble hanging-secnum-preamble)
                   ,@book-sections))
    (add-to-list 'org-latex-classes
                 `("blank" "[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc-article" "\\documentclass[article,code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@article-sections))
    (add-to-list 'org-latex-classes
                 `("bmc" "\\documentclass[code,maths]{bmc}\n[NO-DEFAULT-PACKAGES]\n[NO-PACKAGES]\n[EXTRA]"
                   ,@book-sections))))

(setq org-latex-tables-booktabs t
      org-latex-hyperref-template "
<<latex-fancy-hyperref>>
"
      org-latex-reference-command "\\cref{%s}")
#+end_src


The =hyperref= setup needs to be handled separately however.
#+name: latex-fancy-hyperref
#+begin_src LaTeX
\\providecolor{url}{HTML}{0077bb}
\\providecolor{link}{HTML}{882255}
\\providecolor{cite}{HTML}{999933}
\\hypersetup{
  pdfauthor={%a},
  pdftitle={%t},
  pdfkeywords={%k},
  pdfsubject={%d},
  pdfcreator={%c},
  pdflang={%L},
  breaklinks=true,
  colorlinks=true,
  linkcolor=link,
  urlcolor=url,
  citecolor=cite\n}
\\urlstyle{same}
%% hide links styles in toc
\\NewCommandCopy{\\oldtoc}{\\tableofcontents}
\\renewcommand{\\tableofcontents}{\\begingroup\\hypersetup{hidelinks}\\oldtoc\\endgroup}
#+end_src

** A cleverer preamble
*** Use case

We often want particular snippets of LaTeX in our documents preambles.
It's a pain to have to work out / remember them every time.
For example, I almost always want to include the snippet below.

#+name: org-latex-embed-files-preamble
#+begin_src LaTeX
\\usepackage[main,include]{embedall}
\\IfFileExists{./\\jobname.org}{\\embedfile[desc=The original file]{\\jobname.org}}{}
#+end_src

We could have every package we could possibly need in every one of
~org-latex-classes~, but that's /horribly/ inefficient and I don't want to think
about maintaining that.

Instead we can provide some granularity by splitting up the features we want,
and then take the experience to a whole new level by implementing a system to
automatically detect which features are desired and generating a preamble that
provides these features.

*** Conditional Content

Let's consider content we want in particular situations.

Captions could do with a bit of tweaking such that
+ You can easily have multiple captions
+ Links to figures take you to the /top/ of the figure (not the bottom)
+ Caption labels could do with being emphasised slightly more
+ Multiline captions should run ragged-right, but only when then span more than
  one line

#+name: org-latex-caption-preamble
#+begin_src LaTeX
\\usepackage{subcaption}
\\usepackage[hypcap=true]{caption}
\\setkomafont{caption}{\\sffamily\\small}
\\setkomafont{captionlabel}{\\upshape\\bfseries}
\\captionsetup{justification=raggedright,singlelinecheck=true}
\\usepackage{capt-of} % required by Org
#+end_src

The default checkboxes look rather ugly, so let's provide some prettier alternatives.

#+name: org-latex-checkbox-preamble
#+begin_src LaTeX
\\newcommand{\\checkboxUnchecked}{$\\square$}
\\newcommand{\\checkboxTransitive}{\\rlap{\\raisebox{-0.1ex}{\\hspace{0.35ex}\\Large\\textbf -}}$\\square$}
\\newcommand{\\checkboxChecked}{\\rlap{\\raisebox{0.2ex}{\\hspace{0.35ex}\\scriptsize \\ding{52}}}$\\square$}
#+end_src

It's nice to have "message blocks", things like info/warning/error/success.
A LaTeX macro should make them trivial to create.

#+name: org-latex-box-preamble
#+begin_src LaTeX
\\ExplSyntaxOn
\\NewCoffin\\Content
\\NewCoffin\\SideRule
\\NewDocumentCommand{\\defsimplebox}{O{\\ding{117}} O{0.36em} m m m}{%
  % #1 ding, #2 ding offset, #3 name, #4 colour, #5 default label
  \\definecolor{#3}{HTML}{#4}
  \\NewDocumentEnvironment{#3}{ O{#5} }
  {
    \\vcoffin_set:Nnw \\Content { \\linewidth }
    \\noindent \\ignorespaces
    \\par\\vspace{-0.7\\baselineskip}%
    \\textcolor{#3}{#1}~\\textcolor{#3}{\\textbf{##1}}%
    \\vspace{-0.8\\baselineskip}
    \\begin{addmargin}[1em]{1em}
    }
    {
    \\end{addmargin}
    \\vspace{-0.5\\baselineskip}
    \\vcoffin_set_end:
    \\SetHorizontalCoffin\\SideRule{\\color{#3}\\rule{1pt}{\\CoffinTotalHeight\\Content}}
    \\JoinCoffins*\\Content[l,t]\\SideRule[l,t](#2,-0.7em)
    \\noindent\\TypesetCoffin\\Content
    \\vspace*{\\CoffinTotalHeight\\Content}\\bigskip
    \\vspace{-2\\baselineskip}
  }
}
\\ExplSyntaxOff
#+end_src

Lastly, we will pass this content into some global variables we for ease of
access.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-embed-files-preamble "
<<org-latex-embed-files-preamble>>
"
  "Preamble that embeds files within the pdf.")

(defvar org-latex-caption-preamble "
<<org-latex-caption-preamble>>
"
  "Preamble that improves captions.")

(defvar org-latex-checkbox-preamble "
<<org-latex-checkbox-preamble>>
"
  "Preamble that improves checkboxes.")

(defvar org-latex-box-preamble "
<<org-latex-box-preamble>>
"
  "Preamble that provides a macro for custom boxes.")
#+end_src

In the "universal preamble", we already embed the source =.org= file, but it would
be nice to embed all the tangled files. This is fairly easy to accomplish by
mapping each tangled file to a form which embeds the file if it exists.
Considering we're going this far, why not add a dedicated =#+emded= keyword, so we
can embed whatever we want.

#+begin_src emacs-lisp
(defun org-latex-embed-extra-files ()
  "Return a string that uses embedfile to embed all tangled files."
  (mapconcat
   (lambda (file-desc)
     (format "\\IfFileExists{%1$s}{\\embedfile[desc=%2$s]{%1$s}}{}"
             (thread-last (car file-desc)
               (replace-regexp-in-string "\\\\" "\\\\\\\\")
               (replace-regexp-in-string "~" "\\\\string~"))
             (cdr file-desc)))
   (append
    (mapcar (lambda (f-block)
              (let ((file-lang (cons (or (car f-block) (caddr (cadr f-block))) (caadr f-block))))
                (cons (car file-lang) (format "Tangled %s file" (cdr file-lang)))))
            (org-babel-tangle-collect-blocks)) ; all files being tangled to
    (let (extra-files)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward "^[ \t]*#\\+embed:" nil t)
          (let* ((file-desc (split-string (org-element-property :value (org-element-at-point)) " :desc\\(?:ription\\)? ")))
            (push (cons (car file-desc) (or (cdr file-desc) "Extra file")) extra-files))))
      (nreverse extra-files)))
   "\n"))
#+end_src

Now all tangled files will be embedded, and we can embed arbitrary files like
so:
#+begin_src org
,#+embed: some-file :description flavour text about the file
#+end_src

This currently won't complete or anything like that, as we haven't told Org that
it's a keyword yet. It's also LaTeX-specific, so maybe it should be changed to
=#+latex_embed= or something like that.

*** Content-feature-preamble association

Initially this idea was implemented with an alist that associated a construct
that would search the current Org file for an indication that some feature was
needed, with a LaTeX snippet to be inserted in the preamble which would provide
that feature.
This is all well and good when there is a bijection between detected features
and the LaTeX code needed to support those features, but in many cases this
relation is not injective.

To better model the reality of the situation, I add an extra layer to this
process where each detected feature gives a list of required "feature flags".
Simply be merging the lists of feature flags we no longer have to require
injectivity to avoid LaTeX duplication. Then the extra layer forms a bijection
between there feature flags and a specification which can be used to implement
the feature.

This model also provides a number of nice secondary benefits, such as a simple
implementation of feature dependency.

#+begin_src dot :file misc/org-latex-clever-preamble.svg :exports none
digraph {
    graph [bgcolor="transparent"];
    node  [shape="underline" penwidth="2" width="1.3" style="rounded,filled" fillcolor="#efefef" color="#c9c9c9" fontcolor="#000000" fontname="overpass"];
    edge  [color="#aaaaaa" penwidth="1.2"]
    rankdir=LR

    node[group=a,color="#2ec27e"]
    "file:*.svg"
    "file:*.jpeg"
    "file:*.png"
    "#+caption"
    "xkcd:*"
    node[group=b,color="#f5c211"]
    "svg"
    "image"
    "caption"
    node[group=c,color="#813d9c"]
    "(TeX) svg"
    "(TeX) graphicx"
    "(TeX) caption"

    "file:*.svg" -> "svg" -> "(TeX) svg"
    "file:*.jpeg" -> "image" -> "(TeX) graphicx"
    "file:*.png" -> "image"
    "(TeX) svg":s -> "(TeX) graphicx":n [constraint=false]
    "#+caption" -> "caption" -> "(TeX) caption"
    "xkcd:*" -> "image"
    "xkcd:*" -> "caption"
}
#+end_src

#+caption: Association between Org features, feature flags, and LaTeX snippets required.
#+attr_html: :class invertible :alt DAG showing how Org features flow through to LaTeX :style max-width:min(24em,100%)
#+attr_latex: :width 0.6\linewidth
[[file:misc/org-latex-clever-preamble.svg]]

First we will implement the feature detection component of this model. I'd like
this to be able to use as much state information as possible, so the feature
tests should be very versatile.

#+begin_src emacs-lisp
(defvar org-latex-embed-files t
  "Embed the source .org, .tex, and any tangled files.")
(defvar org-latex-use-microtype t
  "Use the microtype pakage.")
(defvar org-latex-italic-quotes t
  "Make \"quote\" environments italic.")
(defvar org-latex-par-sep t
  "Vertically seperate paragraphs, and remove indentation.")

(pushnew!
 org-export-conditional-features
 '("\\\\(\\|\\\\\\[\\|\\\\begin{\\(?:math\\|displaymath\\|equation\\|align\\|flalign\\|multiline\\|gather\\)[a-z]*\\*?}" . maths)
 '("cref:\\|\\cref{\\|\\[\\[[^\\]+\n?[^\\]\\]\\]" . cleveref)
 '("[;\\\\]?\\b[A-Z][A-Z]+s?[^A-Za-z]" . acronym)
 '("[\u2500-\u259F]" . box-drawing)
 '("\\+[^ ].*[^ ]\\+\\|_[^ ].*[^ ]_\\|\\\\uu?line\\|\\\\uwave\\|\\\\sout\\|\\\\xout\\|\\\\dashuline\\|\\dotuline\\|\\markoverwith" . underline)
 '(":float wrap" . float-wrap)
 '(":float sideways" . rotate)
 '("^[ \t]*#\\+caption:\\|\\\\caption" . caption)
 '("\\[\\[xkcd:" . (image caption))
 '(org-latex-use-microtype . microtype)
 (cons (lambda (_info) (and org-latex-italic-quotes "^[ \t]*#\\+begin_quote\\|\\\\begin{quote}")) 'italic-quotes)
 '(org-latex-par-sep . par-sep)
 '(org-latex-embed-files . embed-files)
 (cons (lambda (_info) (and org-latex-embed-files "^[ \t]*#\\+embed\\|^[ \t]*#\\+begin_src\\|^[ \t]*#\\+BEGIN_SRC")) 'embed-tangled)
 '("^[ \t]*\\(?:[-+*]\\|[0-9]+[.)]\\|[A-Za-z]+[.)]\\) \\[[ -X]\\]" . checkbox)
 '("^[ \t]*#\\+begin_warning\\|\\\\begin{warning}" . box-warning)
 '("^[ \t]*#\\+begin_info\\|\\\\begin{info}"       . box-info)
 '("^[ \t]*#\\+begin_notes\\|\\\\begin{notes}"     . box-notes)
 '("^[ \t]*#\\+begin_success\\|\\\\begin{success}" . box-success)
 '("^[ \t]*#\\+begin_error\\|\\\\begin{error}"     . box-error))
#+end_src

Then we provide a way to generate the preamble that provides those features.
In addition to the features named in ~org-latex-conditional-features~ we'll also
create /meta-features/, which can be required by other features (with =:requires=),
or be active by default (=:eager t=). For further control I some features may only
be used when certain other features are active (with =:when=), and masked by other
features (with =:prevents=). I will use the convention of starting meta-features
with =.=, and =:eager= features with =!= to make their nature more readily apparent.

Another consideration in LaTeX is load order, which matters in some cases.
Beyond that, it's nice to have some sort of sensible ordering. For this I'll
introduce an =:order= keyword. Using this I'll arrange snippets as follows.

+ =-2= Embed files setup
+ =-1= Extra file embedding
+ =0= Typography
  - =0= Fonts themselves
  - =0.1= Typographic tweaks (=microtype=)
  - =0.2= Maths setup
  - =0.3= Maths font
  - =0.4= Extra text shaping (~\acr~)
  - =0.5-0.9= Miscellaneous text modifications, trying to put shorter snippets first
+ =1= (/default/)
+ =2= Tables and figures
+ =3= Miscellaneous short content
+ =4= Fancy boxes

#+begin_src emacs-lisp
(pushnew!
 org-latex-feature-implementations
 '(image         :snippet "\\usepackage{graphicx}" :order 2)
 '(svg           :snippet "\\usepackage[inkscapelatex=false]{svg}" :order 2)
 '(maths         :snippet "\\usepackage[nofont]{bmc-maths}" :order 0.2)
 '(table         :snippet "\\usepackage{longtable}\n\\usepackage{booktabs}" :order 2)
 '(cleveref      :snippet "\\usepackage[capitalize]{cleveref}" :order 1) ; after bmc-maths
 '(float-wrap    :snippet "\\usepackage{wrapfig}" :order 2)
 '(rotate        :snippet "\\usepackage{rotating}" :order 2)
 '(caption       :snippet org-latex-caption-preamble :order 2.1)
 '(microtype     :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}\n" :order 0.1)
 '(embed-files   :snippet org-latex-embed-files-preamble :order -2)
 `(embed-tangled :requires embed-files :snippet ,(lambda (_info) (concat (org-latex-embed-extra-files) "\n")) :order -1)
 '(acronym       :snippet "\\newcommand{\\acr}[1]{\\protect\\textls*[110]{\\scshape #1}}\n\\newcommand{\\acrs}{\\protect\\scalebox{.91}[.84]{\\hspace{0.15ex}s}}" :order 0.4)
 '(box-drawing   :snippet "\\usepackage{pmboxdraw}" :order 0.05)
 '(italic-quotes :snippet "\\renewcommand{\\quote}{\\list{}{\\rightmargin\\leftmargin}\\item\\relax\\em}\n" :order 0.5)
 '(par-sep       :snippet "\\setlength{\\parskip}{\\baselineskip}\n\\setlength{\\parindent}{0pt}\n" :order 0.5)
 '(.pifont       :snippet "\\usepackage{pifont}")
 '(.xcoffins     :snippet "\\usepackage{xcoffins}")
 `(checkbox      :requires .pifont :order 3
   :snippet ,(lambda (_info)
               (concat (unless (memq 'maths features)
                         "\\usepackage{amssymb} % provides \\square")
                       org-latex-checkbox-preamble)))
 '(.fancy-box    :requires (.pifont .xcoffins) :snippet org-latex-box-preamble :order 3.9)
 '(box-warning   :requires .fancy-box :snippet "\\defsimplebox{warning}{e66100}{Warning}" :order 4)
 '(box-info      :requires .fancy-box :snippet "\\defsimplebox{info}{3584e4}{Information}" :order 4)
 '(box-notes     :requires .fancy-box :snippet "\\defsimplebox{notes}{26a269}{Notes}" :order 4)
 '(box-success   :requires .fancy-box :snippet "\\defsimplebox{success}{26a269}{\\vspace{-\\baselineskip}}" :order 4)
 '(box-error     :requires .fancy-box :snippet "\\defsimplebox{error}{c01c28}{Important}" :order 4))
#+end_src

*** Reduce default packages

Thanks to our additions, we can remove a few packages from
~org-latex-default-packages-alist~.

There are also some obsolete entries in the default value, specifically
+ =grffile='s capabilities are built into the current version of =graphicx=
+ =textcomp='s functionality has been included in LaTeX's core for a while now

#+begin_src emacs-lisp
(setq org-latex-default-packages-alist
      '(("AUTO" "inputenc" t ("pdflatex"))
        ("T1" "fontenc" t ("pdflatex"))
        ("" "xcolor" nil) ; Generally useful
        ("" "hyperref" nil)))
#+end_src
** Nicer checkboxes

We'll assume that thanks to the clever preamble the various custom =\checkbox...=
commands below are defined.

#+begin_src emacs-lisp
(defun +org-export-latex-fancy-item-checkboxes (text backend info)
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string
     "\\\\item\\[{$\\\\\\(\\w+\\)$}\\]"
     (lambda (fullmatch)
       (concat "\\\\item[" (pcase (substring fullmatch 9 -3) ; content of capture group
                             ("square"   "\\\\checkboxUnchecked")
                             ("boxminus" "\\\\checkboxTransitive")
                             ("boxtimes" "\\\\checkboxChecked")
                             (_ (substring fullmatch 9 -3))) "]"))
     text)))

(add-to-list 'org-export-filter-item-functions
             '+org-export-latex-fancy-item-checkboxes)
#+end_src

** Font collections

Using the lovely conditional preamble, I'll define a number of font collections
that can be used for LaTeX exports. Who knows, maybe I'll use it with other
export formats too at some point.

To start with I'll create a default state variable and register =fontset= as part
of =#+options=.

#+begin_src emacs-lisp
(defvar org-latex-default-fontset 'alegreya
  "Fontset from `org-latex-fontsets' to use by default.
As cm (computer modern) is TeX's default, that causes nothing
to be added to the document.

If \"nil\" no custom fonts will ever be used.")

(eval '(cl-pushnew '(:latex-font-set nil "fontset" org-latex-default-fontset)
                   (org-export-backend-options (org-export-get-backend 'latex))))
#+end_src

Then a function is needed to generate a LaTeX snippet which applies the fontset. It
would be nice if this could be done for individual styles and use different
styles as the main document font. If the individual typefaces for a fontset are
defined individually as
src_elisp{:serif}, src_elisp{:sans}, src_elisp{:mono}, and src_elisp{:maths}.
I can use those to generate LaTeX for subsets of the full fontset. Then, if I
don't let any fontset names have =-= in them, I can use =-sans= and =-mono= as
suffixes that specify the document font to use.

#+begin_src emacs-lisp
(defun org-latex-fontset-entry ()
  "Get the fontset spec of the current file.
Has format \"name\" or \"name-style\" where 'name' is one of
the cars in `org-latex-fontsets'."
  (let ((fontset-spec
         (symbol-name
          (or (car (delq nil
                         (mapcar
                          (lambda (opt-line)
                            (plist-get (org-export--parse-option-keyword opt-line 'latex)
                                       :latex-font-set))
                          (cdar (org-collect-keywords '("OPTIONS"))))))
              org-latex-default-fontset))))
    (cons (intern (car (split-string fontset-spec "-")))
          (when (cadr (split-string fontset-spec "-"))
            (intern (concat ":" (cadr (split-string fontset-spec "-"))))))))

(defun org-latex-fontset (&rest desired-styles)
  "Generate a LaTeX preamble snippet which applies the current fontset for DESIRED-STYLES."
  (let* ((fontset-spec (org-latex-fontset-entry))
         (fontset (alist-get (car fontset-spec) org-latex-fontsets)))
    (if fontset
        (concat
         (mapconcat
          (lambda (style)
            (when (plist-get fontset style)
              (concat (plist-get fontset style) "\n")))
          desired-styles
          "")
         (when (memq (cdr fontset-spec) desired-styles)
           (pcase (cdr fontset-spec)
             (:serif "\\renewcommand{\\familydefault}{\\rmdefault}\n")
             (:sans "\\renewcommand{\\familydefault}{\\sfdefault}\n")
             (:mono "\\renewcommand{\\familydefault}{\\ttdefault}\n"))))
      (error "Font-set %s is not provided in org-latex-fontsets" (car fontset-spec)))))
#+end_src

Now that all the functionality has been implemented, we should hook it into our
preamble generation.

#+begin_src emacs-lisp
(add-to-list 'org-export-conditional-features '(org-latex-default-fontset . custom-font) t)
(add-to-list 'org-latex-feature-implementations (list 'custom-font :snippet (lambda (_info) (org-latex-fontset :serif :sans :mono)) :order 0) t)
(add-to-list 'org-latex-feature-implementations (list '.custom-maths-font :eager t :when '(custom-font maths) :snippet (lambda (_info) (org-latex-fontset :maths)) :order 0.3) t)
#+end_src

Finally, we just need to add some fonts.

#+begin_src emacs-lisp
(defvar org-latex-fontsets
  '((cm nil) ; computer modern
    (## nil) ; no font set
    (alegreya
     :serif "\\usepackage[osf]{Alegreya}"
     :sans "\\usepackage{AlegreyaSans}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (biolinum
     :serif "\\usepackage[osf]{libertineRoman}"
     :sans "\\usepackage[sfdefault,osf]{biolinum}"
     :mono "\\usepackage[scale=0.88]{sourcecodepro}"
     :maths "\\usepackage[libertine,varvw]{newtxmath}")
    (fira
     :sans "\\usepackage[sfdefault,scale=0.85]{FiraSans}"
     :mono "\\usepackage[scale=0.80]{FiraMono}"
     :maths "\\usepackage{newtxsf} % change to firamath in future?")
    (kp
     :serif "\\usepackage{kpfonts}")
    (newpx
     :serif "\\usepackage{newpxtext}"
     :sans "\\usepackage{gillius}"
     :mono "\\usepackage[scale=0.9]{sourcecodepro}"
     :maths "\\usepackage[varbb]{newpxmath}")
    (noto
     :serif "\\usepackage[osf]{noto-serif}"
     :sans "\\usepackage[osf]{noto-sans}"
     :mono "\\usepackage[scale=0.96]{noto-mono}"
     :maths "\\usepackage{notomath}")
    (plex
     :serif "\\usepackage{plex-serif}"
     :sans "\\usepackage{plex-sans}"
     :mono "\\usepackage[scale=0.95]{plex-mono}"
     :maths "\\usepackage{newtxmath}") ; may be plex-based in future
    (source
     :serif "\\usepackage[osf,semibold]{sourceserifpro}"
     :sans "\\usepackage[osf,semibold]{sourcesanspro}"
     :mono "\\usepackage[scale=0.92]{sourcecodepro}"
     :maths "\\usepackage{newtxmath}") ; may be sourceserifpro-based in future
    (times
     :serif "\\usepackage{newtxtext}"
     :maths "\\usepackage{newtxmath}"))
  "Alist of fontset specifications.
Each car is the name of the fontset (which cannot include \"-\").

Each cdr is a plist with (optional) keys :serif, :sans, :mono, and :maths.
A key's value is a LaTeX snippet which loads such a font.")
#+end_src

When we're using Alegreya we can apply a lovely little tweak to =tabular= which
(locally) changes the figures used to lining fixed-width.

#+begin_src emacs-lisp
(add-to-list 'org-export-conditional-features (list (lambda (_info) (string= (car (org-latex-fontset-entry)) "alegreya")) 'alegreya-typeface))
(add-to-list 'org-latex-feature-implementations '(alegreya-typeface) t)
(add-to-list 'org-latex-feature-implementations'(.alegreya-tabular-figures :eager t :when (alegreya-typeface table) :order 0.5 :snippet "
\\makeatletter
% tabular lining figures in tables
\\renewcommand{\\tabular}{\\AlegreyaTLF\\let\\@halignto\\@empty\\@tabular}
\\makeatother\n") t)
#+end_src

Due to Alegreya's metrics, the =\LaTeX= symbol doesn't quite look right. We
can correct for this by redefining it with subtlety shifted kerning.

#+begin_src emacs-lisp
(add-to-list 'org-export-conditional-features '("LaTeX" . latex-symbol))
(add-to-list 'org-latex-feature-implementations '(latex-symbol :when alegreya-typeface :order 0.5 :snippet "
\\makeatletter
% Kerning around the A needs adjusting
\\DeclareRobustCommand{\\LaTeX}{L\\kern-.24em%
        {\\sbox\\z@ T%
         \\vbox to\\ht\\z@{\\hbox{\\check@mathfonts
                              \\fontsize\\sf@size\\z@
                              \\math@fontsfalse\\selectfont
                              A}%
                        \\vss}%
        }%
        \\kern-.10em%
        \\TeX}
\\makeatother\n") t)
#+end_src

** Cover page

To make a nice cover page, a simple method that comes to mind is just redefining
=\maketitle=. To get precise control over the positioning we'll use the =tikz=
package, and then add in the Tikz libraries =calc= and =shapes.geometric= to make
some nice decorations for the background.

I'll start off by setting up the required additions to the preamble.
This will accomplish the following:
+ Load the required packages
+ Redefine =\maketitle=
+ Draw an Org icon with Tikz to use in the cover page (it's a little easter egg)
+ Start a new page after the table of contents by redefining =\tableofcontents=

#+name: latex-cover-page
#+begin_src LaTeX
\\usepackage{tikz}
\\usetikzlibrary{shapes.geometric}
\\usetikzlibrary{calc}

\\newsavebox\\orgicon
\\begin{lrbox}{\\orgicon}
  \\begin{tikzpicture}[y=0.80pt, x=0.80pt, inner sep=0pt, outer sep=0pt]
    \\path[fill=black!6] (16.15,24.00) .. controls (15.58,24.00) and (13.99,20.69) .. (12.77,18.06)arc(215.55:180.20:2.19) .. controls (12.33,19.91) and (11.27,19.09) .. (11.43,18.05) .. controls (11.36,18.09) and (10.17,17.83) .. (10.17,17.82) .. controls (9.94,18.75) and (9.37,19.44) .. (9.02,18.39) .. controls (8.32,16.72) and (8.14,15.40) .. (9.13,13.80) .. controls (8.22,9.74) and (2.18,7.75) .. (2.81,4.47) .. controls (2.99,4.47) and (4.45,0.99) .. (9.15,2.41) .. controls (14.71,3.99) and (17.77,0.30) .. (18.13,0.04) .. controls (18.65,-0.49) and (16.78,4.61) .. (12.83,6.90) .. controls (10.49,8.18) and (11.96,10.38) .. (12.12,11.15) .. controls (12.12,11.15) and (14.00,9.84) .. (15.36,11.85) .. controls (16.58,11.53) and (17.40,12.07) .. (18.46,11.69) .. controls (19.10,11.41) and (21.79,11.58) .. (20.79,13.08) .. controls (20.79,13.08) and (21.71,13.90) .. (21.80,13.99) .. controls (21.97,14.75) and (21.59,14.91) .. (21.47,15.12) .. controls (21.44,15.60) and (21.04,15.79) .. (20.55,15.44) .. controls (19.45,15.64) and (18.36,15.55) .. (17.83,15.59) .. controls (16.65,15.76) and (15.67,16.38) .. (15.67,16.38) .. controls (15.40,17.19) and (14.82,17.01) .. (14.09,17.32) .. controls (14.70,18.69) and (14.76,19.32) .. (15.50,21.32) .. controls (15.76,22.37) and (16.54,24.00) .. (16.15,24.00) -- cycle(7.83,16.74) .. controls (6.83,15.71) and (5.72,15.70) .. (4.05,15.42) .. controls (2.75,15.19) and (0.39,12.97) .. (0.02,10.68) .. controls (-0.02,10.07) and (-0.06,8.50) .. (0.45,7.18) .. controls (0.94,6.05) and (1.27,5.45) .. (2.29,4.85) .. controls (1.41,8.02) and (7.59,10.18) .. (8.55,13.80) -- (8.55,13.80) .. controls (7.73,15.00) and (7.80,15.64) .. (7.83,16.74) -- cycle;
  \\end{tikzpicture}
\\end{lrbox}

\\makeatletter
\\g@addto@macro\\tableofcontents{\\clearpage}
\\renewcommand\\maketitle{
  \\thispagestyle{empty}
  \\hyphenpenalty=10000 % hyphens look bad in titles
  \\renewcommand{\\baselinestretch}{1.1}
  \\NewCommandCopy{\\oldtoday}{\\today}
  \\renewcommand{\\today}{\\LARGE\\number\\year\\\\\\large%
    \\ifcase \\month \\or Jan\\or Feb\\or Mar\\or Apr\\or May \\or Jun\\or Jul\\or Aug\\or Sep\\or Oct\\or Nov\\or Dec\\fi
    ~\\number\\day}
  \\begin{tikzpicture}[remember picture,overlay]
    %% Background Polygons %%
    \\foreach \\i in {2.5,...,22} % bottom left
    {\\node[rounded corners,black!3.5,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.west)+(2.5,-4.2)$) {} ;}
    \\foreach \\i in {0.5,...,22} % top left
    {\\node[rounded corners,black!5,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {} ;}
    \\node[rounded corners,fill=black!4,regular polygon,regular polygon sides=6, minimum size=5.5 cm,ultra thick] at ($(current page.north west)+(2.5,2)$) {};
    \\foreach \\i in {0.5,...,24} % top right
    {\\node[rounded corners,black!2,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {} ;}
    \\node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2.5 cm,ultra thick] at ($(current page.north east)+(0,-8.5)$) {};
    \\foreach \\i in {21,...,3} % bottom right
    {\\node[black!3,rounded corners,draw,regular polygon,regular polygon sides=6, minimum size=\\i cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {} ;}
    \\node[fill=black!3,rounded corners,regular polygon,regular polygon sides=6, minimum size=2 cm,ultra thick] at ($(current page.south east)+(-1.5,0.75)$) {};
    \\node[align=center, scale=1.4] at ($(current page.south east)+(-1.5,0.75)$) {\\usebox\\orgicon};
    %% Text %%
    \\node[left, align=right, black, text width=0.8\\paperwidth, minimum height=3cm, rounded corners,font=\\Huge\\bfseries] at ($(current page.north east)+(-2,-8.5)$)
    {\\@title};
    \\node[left, align=right, black, text width=0.8\\paperwidth, minimum height=2cm, rounded corners, font=\\Large] at ($(current page.north east)+(-2,-11.8)$)
    {\\scshape \\@author};
    \\renewcommand{\\baselinestretch}{0.75}
    \\node[align=center,rounded corners,fill=black!3,text=black,regular polygon,regular polygon sides=6, minimum size=2.5 cm,inner sep=0, font=\\Large\\bfseries ] at ($(current page.west)+(2.5,-4.2)$)
    {\\@date};
  \\end{tikzpicture}
  \\let\\today\\oldtoday
  \\clearpage}
\\makeatother
#+end_src

Now we've got a nice cover page to work with, we just need to use it every now
and then. Adding this to =#+options= feels most appropriate.
Let's have the =coverpage= option accept =auto= as a value and then decide whether
or not a cover page should be used based on the word count --- I'll have this be
the global default. Then we just want to insert a LaTeX snippet tweak the
subtitle format to use the cover page.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-cover-page 'auto
  "When t, use a cover page by default.
When auto, use a cover page when the document's wordcount exceeds
`org-latex-cover-page-wordcount-threshold'.

Set with #+option: coverpage:{yes,auto,no} in org buffers.")
(defvar org-latex-cover-page-wordcount-threshold 5000
  "Document word count at which a cover page will be used automatically.
This condition is applied when cover page option is set to auto.")
(defvar org-latex-subtitle-coverpage-format "\\\\\\bigskip\n\\LARGE\\mdseries\\itshape\\color{black!80} %s\\par"
  "Variant of `org-latex-subtitle-format' to use with the cover page.")
(defvar org-latex-cover-page-maketitle "
<<latex-cover-page>>
"
  "LaTeX snippet for the preamble that sets \\maketitle to produce a cover page.")

(eval '(cl-pushnew '(:latex-cover-page nil "coverpage" org-latex-cover-page)
                   (org-export-backend-options (org-export-get-backend 'latex))))

(defun org-latex-cover-page-p ()
  "Whether a cover page should be used when exporting this Org file."
  (pcase (or (car
              (delq nil
                    (mapcar
                     (lambda (opt-line)
                       (plist-get (org-export--parse-option-keyword opt-line 'latex) :latex-cover-page))
                     (cdar (org-collect-keywords '("OPTIONS"))))))
             org-latex-cover-page)
    ((or 't 'yes) t)
    ('auto (when (> (count-words (point-min) (point-max)) org-latex-cover-page-wordcount-threshold) t))
    (_ nil)))

(defadvice! org-latex-set-coverpage-subtitle-format-a (contents info)
  "Set the subtitle format when a cover page is being used."
  :before #'org-latex-template
  (when (org-latex-cover-page-p)
    (setf info (plist-put info :latex-subtitle-format org-latex-subtitle-coverpage-format))))

(add-to-list 'org-latex-feature-implementations '(cover-page :snippet org-latex-cover-page-maketitle :order 9) t)
(add-to-list 'org-export-conditional-features (cons (lambda (_info) (org-latex-cover-page-p)) 'cover-page) t)
#+end_src

** Condensed lists

LaTeX is generally pretty good by default, but it's /really/ generous with how
much space it puts between list items by default. I'm generally not a fan.

Thankfully this is easy to correct with a small snippet:
#+name: latex-condense-lists
#+begin_src LaTeX
\\newcommand{\\setuplistspacing}{\\setlength{\\itemsep}{-0.5ex}\\setlength{\\parskip}{1.5ex}\\setlength{\\parsep}{0pt}}
\\let\\olditem\\itemize\\renewcommand{\\itemize}{\\olditem\\setuplistspacing}
\\let\\oldenum\\enumerate\\renewcommand{\\enumerate}{\\oldenum\\setuplistspacing}
\\let\\olddesc\\description\\renewcommand{\\description}{\\olddesc\\setuplistspacing}
#+end_src

Then we can just hook this in with our clever preamble.

#+begin_src emacs-lisp :noweb no-export
(defvar org-latex-condense-lists t
  "Reduce the space between list items.")
(defvar org-latex-condensed-lists "
<<latex-condense-lists>>
")

(add-to-list 'org-export-conditional-features (cons (lambda (_info) (and org-latex-condense-lists "^[ \t]*[-+]\\|^[ \t]*[1Aa][.)] ")) 'condensed-lists) t)
(add-to-list 'org-latex-feature-implementations '(condensed-lists :snippet org-latex-condensed-lists :order 0.7) t)
#+end_src

** Pretty code blocks

We could just use minted for syntax highlighting --- however, we can do better!
The =engrave-faces= package lets us use Emacs' font-lock for syntax highlighting,
exporting that as LaTeX commands.

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! engrave-faces :recipe (:host github :repo"tecosaur/engrave-faces"))
#+end_src

#+begin_src emacs-lisp
(use-package! engrave-faces-latex
  :after ox-latex)
#+end_src

Using this as in LaTeX exports is now as easy as

#+begin_src emacs-lisp
(setq org-latex-listings 'engraved)
#+end_src

One little annoyance with this is the interaction between microtype and =Verbatim=
environments. Protrusion is not desirable here. Thankfully, we can patch the
=Verbatim= environment to turn off protrusion locally.

#+begin_src emacs-lisp
(add-to-list
 'org-latex-feature-implementations
 '(.no-protrusion-in-code
   :snippet "\\ifcsname Code\\endcsname\n  \\let\\oldcode\\Code\\renewcommand{\\Code}{\\microtypesetup{protrusion=false}\\oldcode}\n\\fi"
   :when microtype
   :eager t
   :order 98.5) t)
#+end_src

At some point it would be nice to make the box colours easily customisable. At
the moment it's fairly easy to change the syntax highlighting colours with
src_elisp{(setq engrave-faces-preset-styles (engrave-faces-generate-preset))},
but perhaps a toggle which specifies whether to use the default values, the
current theme, or any named theme could be a good idea. It should also possible
to set the box background dynamically to match. The named theme could work by
looking for a style definition with a certain name in a cache dir, and then
switching to that theme and producing (and saving) the style definition if it
doesn't exist.

Now let's have the example block be styled similarly.

#+begin_src emacs-lisp
(defadvice! org-latex-example-block-engraved (orig-fn example-block contents info)
  "Like `org-latex-example-block', but supporting an engraved backend"
  :around #'org-latex-example-block
  (let ((output-block (funcall orig-fn example-block contents info)))
    (if (eq 'engraved (plist-get info :latex-listings))
        (format "\\begin{Code}[alt]\n%s\n\\end{Code}" output-block)
      output-block)))
#+end_src

In addition to the vastly superior visual output, this should also be much
faster to compile for code-heavy documents (like this config).

Performing a little benchmark with this document, I find that this is indeed the
case.

| LaTeX syntax highlighting backend | Compile time | Overhead | Overhead ratio |
|-----------------------------------+--------------+----------+----------------|
| verbatim                          | 12 s         | 0        |            0.0 |
| lstlistings                       | 15 s         | 3 s      |            0.2 |
| Engrave                           | 34 s         | 22 s     |            1.8 |
| Pygments (Minted)                 | 184 s        | 172 s    |           14.3 |
#+TBLFM: $3=$2-@2$2::$4=$3 / @2$2;%.1f

Treating the verbatim (no syntax highlighting) result as a baseline; this
rudimentary test suggest that =engrave-faces= is around eight times faster than
=pygments=, and takes three times as long as no syntax highlighting (verbatim).

** Julia code blocks

Julia code has fantastic support for unicode! The downside is that =pdflatex= is
/still/ a pain to use with unicode symbols. The solution --- =lualatex=. Now we just
need to make it automatic

#+begin_src emacs-lisp
(defadvice! org-latex-pick-compiler (_contents info)
  :before #'org-latex-template
  :before #'org-beamer-template
  (when (and (memq 'code (plist-get info :features))
             (memq 'julia-code (plist-get info :features))
             (save-excursion
               (goto-char (point-min))
               (re-search-forward "[^\x00-\x7F\u200b]" nil t)))
    (setf info (plist-put
                (if (member #'+org-latex-replace-non-ascii-chars (plist-get info :filter-final-output))
                    (plist-put info :filter-final-output
                               (delq #'+org-latex-replace-non-ascii-chars (plist-get info :filter-final-output)))
                  info)
                :latex-compiler "lualatex"))))
#+end_src

Then a font with unicode support must be used. JuliaMono is the obvious choice,
and we can use it with the =fontspec= package. In future it may be nice to set
this just as a fallback font (when it isn't a pain to do so).

#+name: julia-mono-fontspec
#+begin_src LaTeX
\\ifcsname directlua\\endcsname
  \\usepackage{fontspec}
  \\newfontfamily\\JuliaMono{JuliaMono-Regular.ttf}[Path=/usr/share/fonts/truetype/, Extension=.ttf]
  \\newfontface\\JuliaMonoRegular{JuliaMono-Regular}
  \\setmonofont{JuliaMonoRegular}[Contextuals=Alternate, Scale=MatchLowercase]
\\fi
#+end_src

Now all that remains is to hook this into the preamble generation.

#+begin_src emacs-lisp :noweb no-export
(setq org-latex-julia-mono-fontspec "
<<julia-mono-fontspec>>
")

(add-to-list 'org-latex-feature-implementations '(julia-code :when code :snippet org-latex-julia-mono-fontspec :order 0) t)
(add-to-list 'org-export-conditional-features '("^[ \t]*#\\+begin_src julia\\|^[ \t]*#\\+BEGIN_SRC julia\\|src_julia" . julia-code) t)

(add-to-list 'org-latex-feature-implementations '(.microtype-lualatex :eager t :when (microtype julia-code) :prevents microtype :order 0.1 :snippet "\\usepackage[activate={true,nocompatibility},final,tracking=true,factor=2000]{microtype}\n"))
(add-to-list 'org-latex-feature-implementations (list '.custom-font-no-mono :eager t :prevents 'custom-font :order 0 :snippet (lambda (_info) (org-latex-fontset :serif :sans))) t)
#+end_src

** Emojis

It would be nice to actually include emojis where used.
Thanks to =emojify=, we have a folder of emoji images just sitting and waiting to
be used ðŸ™‚.

First up, we want to detect when emojis are actually present. We can try
checking the unicode ranges with a collection of =[?-?]= regex groups, but Emojis
are actually spread around a fair bit and so this isn't very straightforward.
Instead I can iterate thorough non-ASCII characters and check if any have the
text property =emojified=.

#+begin_src emacs-lisp
(defun emojify-emoji-in-buffer-p ()
  "Determine if any emojis are present in the current buffer, using `emojify-mode'."
  (require 'emojify)
  (unless emojify-mode
    (emojify-mode 1)
    (emojify-display-emojis-in-region (point-min) (point-max)))
  (let (emoji-found end)
    (save-excursion
      (goto-char (point-min))
      (while (not (or emoji-found end))
        (if-let ((pos (re-search-forward "[^[:ascii:]]" nil t)))
            (when (get-text-property (1- pos) 'emojified)
              (setq emoji-found t))
          (setq end t))))
    emoji-found))
#+end_src

Once we know that there are emojis present we can add a bit of preamble to the
buffer to make insertion easier.

#+begin_src emacs-lisp
(defun org-latex-emoji-setup ()
  (format "\\newcommand\\emoji[1]{\\raisebox{-0.3ex}{\\includegraphics[height=1.8ex]{%s/#1}}}" (emojify-image-dir)))

(add-to-list 'org-export-conditional-features (cons (lambda (_info) (emojify-emoji-in-buffer-p)) 'emoji) t)
(add-to-list 'org-latex-feature-implementations (list 'emoji :requires 'image :snippet (lambda (_info) (org-latex-emoji-setup)) :order 3 ))
#+end_src

Once again making use of =emojify=, we can generate LaTeX commands for our emojis
fairly easily.

#+begin_src emacs-lisp
(defun emojify-latexify-emoji-in-buffer ()
  (unless emojify-mode
    (emojify-mode 1)
    (emojify-display-emojis-in-region (point-min) (point-max)))
  (let (end)
    (save-excursion
      (goto-char (point-min))
      (while (not end)
        (if-let ((pos (re-search-forward "[^[:ascii:]]\\{1,2\\}" nil t)))
            (when-let ((char (get-text-property (1- pos) 'emojify-text))
                       (emoji (emojify-get-emoji char)))
              (replace-match (format "\\\\emoji{%s}" (file-name-sans-extension (ht-get emoji "image")))))
          (setq end t))))))
#+end_src

Now we just need to hook this handy function into Org's export.
We can't use standard string-replacement as we rely on the buffer modifications
enacted by src_elisp{(emojify-mode)}.

As I have not yet implemented a nice way of sharing feature detection
information outside of src_elisp{(org-latex-generate-features-preamble)}, we'll
use the same check before attempting to LaTeXify emojis and hope that nothing
strange happens.

#+begin_src emacs-lisp
(defun +org-latex-convert-emojis (text backend _info)
  (when (org-export-derived-backend-p backend 'latex)
    (with-temp-buffer
      (insert text)
      (when (emojify-emoji-in-buffer-p)
        (emojify-latexify-emoji-in-buffer)
        (buffer-string)))))

(add-to-list 'org-export-filter-final-output-functions #'+org-latex-convert-emojis)
#+end_src

This works fairly nicely, there's just one little QOL upgrade that we can
perform. =emojify= downloads the ~72x72~ versions of Twemoji, however SVG versions
are also produced. We could use ~inkscape~ to convert those to PDFs, which would
likely be best for including.

First, it's worth checking whether =.pdf= graphics files will be prioritised over
=.png= files. If so, that would be ideal as no extra effort is required past
fetching and converting the files.

#+begin_src shell :tangle no :exports both :results output verbatim :wrap example
texdef -t pdflatex -p graphicx Gin@extensions
#+end_src

#+RESULTS:
#+begin_example
\Gin@extensions:
macro:->.pdf,.png,.jpg,.mps,.jpeg,.jbig2,.jb2,.PDF,.PNG,.JPG,.JPEG,.JBIG2,.JB2,.eps
#+end_example

Fantastic! We can see that =.pdf= actually comes first in the priority list. So
now we just need to fetch and convert those SVGs --- ideally with a handy
command to do so for us.

#+begin_src emacs-lisp
(defun org-latex-emoji-install-vector-graphics ()
  "Dowload, convert, and install vector emojis for use with LaTeX."
  (interactive)
  (let ((dir (org-latex-emoji-install-vector-graphics--download)))
    (org-latex-emoji-install-vector-graphics--convert dir)
    (org-latex-emoji-install-vector-graphics--install dir))
  (message "Vector emojis installed."))

(defun org-latex-emoji-install-vector-graphics--download ()
  (message "Locating latest emojis...")
  (let* ((twemoji-url (substring (shell-command-to-string "echo \"https://github.com$(curl -sL https://github.com/twitter/twemoji/releases/latest | grep '.zip\"' | cut -d '\"' -f 2)\"") 0 -1))
         (twemoji-version (replace-regexp-in-string "^.*tags/v\\(.*\\)\\.zip" "\\1" twemoji-url))
         (twemoji-dest-folder (make-temp-file "twemoji-" t)))
    (message "Downloading Twemoji v%s" twemoji-version)
    (let ((default-directory twemoji-dest-folder))
      (call-process "curl" nil nil nil "-L" twemoji-url "--output" "twemoji.zip")
      (message "Unzipping")
      (call-process "unzip" nil nil nil "twemoji.zip")
      (concat twemoji-dest-folder "/twemoji-" twemoji-version "/assets/svg"))))

(defun org-latex-emoji-install-vector-graphics--convert (dir)
  (let ((default-directory dir))
    (if (executable-find "cairosvg") ; cairo's PDFs are ~10% smaller
        (let* ((images (directory-files dir nil ".*.svg"))
               (num-images (length images))
               (index 0)
               (max-threads (1- (string-to-number (shell-command-to-string "nproc"))))
               (threads 0))
          (while (< index num-images)
            (setf threads (1+ threads))
            (message "Converting emoji %d/%d (%s)" (1+ index) num-images (nth index images))
            (make-process :name "cairosvg"
                          :command (list "cairosvg" (nth index images) "-o" (concat (file-name-sans-extension (nth index images)) ".pdf"))
                          :sentinel (lambda (proc msg)
                                      (when (memq (process-status proc) '(exit signal))
                                        (setf threads (1- threads)))))
            (setq index (1+ index))
            (while (> threads max-threads)
              (sleep-for 0.01)))
          (while (> threads 0)
            (sleep-for 0.01))
          (message "Finished conversion!")))
    (shell-command "inkscape --batch-process --export-type='pdf' *.svg")))

(defun org-latex-emoji-install-vector-graphics--install (dir)
  (message "Installing vector emojis into emoji directory")
  (let ((images (directory-files dir t ".*.pdf"))
        (emoji-dir (concat (emojify-image-dir) "/")))
    (mapcar
     (lambda (image)
       (rename-file image emoji-dir t))
     images)))
#+end_src

** Remove non-ascii chars

When using ~pdflatex~, almost non-ascii characters are generally problematic, and
don't appear in the pdf. It's preferable to see that there was /some/ character
which wasn't displayed as opposed to nothing.

We check every non-ascii character to make sure it's not a character encoded by
the =inputenc= packages when loaded with the =utf8= option. We'll also allow
box-drawing characters since they can be mostly supported with =pmboxdraw=.
Finally, we see if we have our own LaTeX conversion we can apply and if there is
none we replace the non-ascii char with =Â¿=.

No to make sure we only remove characters that can't be displayed, we check
=/usr/share/texmf/tex/latex/base/utf8enc.dfu=.

We just need to make sure this is appended to the list of filter functions,
since we want to let emoji processing occur first.

#+begin_src emacs-lisp
(defvar +org-pdflatex-inputenc-encoded-chars
  "[[:ascii:]\u00A0-\u01F0\u0218-\u021BÈ²È³È·Ë†Ë‡ËœË˜Ë™Ë›Ë\u0400-\u04FFá¸‚á¸ƒáºž\u200B\u200C\u2010-\u201Eâ€ â€¡â€¢â€¦â€°â€±â€¹â€ºâ€»â€½â„âŽâ’â‚¡â‚¤â‚¦â‚©â‚«â‚¬â‚±â„ƒâ„–â„—â„žâ„ â„¢â„¦â„§â„®â†â†‘â†’â†“âŒ©âŒªâ¢â£â—¦â—¯â™ªâŸ¨âŸ©á¸ á¸¡\uFB00-\uFB06\u2500-\u259F]")

(defun +org-latex-replace-non-ascii-chars (text backend info)
  "Replace non-ascii chars with \\char\"XYZ forms."
  (when (and (org-export-derived-backend-p backend 'latex)
             (string= (plist-get info :latex-compiler) "pdflatex"))
    (let (case-replace)
      (replace-regexp-in-string "[^[:ascii:]]"
                                (lambda (nonascii)
                                  (if (string-match-p +org-pdflatex-inputenc-encoded-chars nonascii) nonascii
                                    (or (cdr (assoc nonascii +org-latex-non-ascii-char-substitutions)) "Â¿")))
                                text))))

(add-to-list 'org-export-filter-plain-text-functions #'+org-latex-replace-non-ascii-chars t)
#+end_src

Now, there are some symbols that aren't included in =inputenc=, but we should be
able to handle anyway. For them we define a table of LaTeX translations

#+name: latex-non-ascii-char-substitutions
| Character | LaTeX |
|-----------+-------|
| É‘          | \(\alpha\)  |
| Î²         | \(\beta\) |
| Î³          | \(\gamma\)  |
| Î´          | \(\delta\)  |
| Îµ          | \(\epsilon\)  |
| Ïµ          | \(\varepsilon\)  |
| Î¶          | \(\zeta\)  |
| Î·          | \(\eta\)  |
| Î¸          | \(\theta\)  |
| Ï‘         | \(\vartheta\) |
| Î¹          | \(\iota\)  |
| Îº          | \(\kappa\)  |
| Î»         | \(\lambda\) |
| Î¼          | \(\mu\)  |
| Î½          | \(\nu\)  |
| Î¾          | \(\xi\)  |
| Ï€         | \(\pi\) |
| Ï–         | \(\varpi\) |
| Ï          | \(\rho\)  |
| Ï±          | \(\varrho\)  |
| Ïƒ          | \(\sigma\)  |
| Ï‚          | \(\varsigma\)  |
| Ï„          | \(\tau\)  |
| Ï…          | \(\upsilon\)  |
| Ï•         | \(\phi\) |
| Ï†         | \(\varphi\) |
| Ïˆ         | \(\psi\) |
| Ï‰         | \(\omega\) |
| Î“          | \(\Gamma\)  |
| Î”          | \(\Delta\)  |
| Î˜         | \(\Theta\) |
| Î›          | \(\Lambda\)  |
| Îž          | \(\Xi\)  |
| Î          | \(\Pi\) |
| Î£          | \(\Sigma\)  |
| Î¥          | \(\Upsilon\)  |
| Î¦         | \(\Phi\) |
| Î¨         | \(\Psi\) |
| Î©         | \(\Omega\) |
| ×         | \(\aleph\)  |
| ×‘          | \(\beth\)  |
| ×“          | \(\daleth\)  |
| ×’          | \(\gimel\)  |

#+name: gen-latex-non-ascii-char-substitutions
#+begin_src emacs-lisp :noweb-ref none :var latex-non-ascii-char-substitutions=latex-non-ascii-char-substitutions
(replace-regexp-in-string
 " '((" "\n   '(("
 (replace-regexp-in-string
  ") (" ")\n     ("
  (prin1-to-string
   `(defvar +org-latex-non-ascii-char-substitutions
      ',(mapcar
         (lambda (entry)
           (cons (car entry) (replace-regexp-in-string "\\\\" "\\\\\\\\" (cadr entry))))
         latex-non-ascii-char-substitutions)))))
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<gen-latex-non-ascii-char-substitutions()>>
#+end_src

** Normal spaces after abbreviations

In LaTeX inter-word and sentence spaces are typically of different widths. This
can be an issue when using abbreviations i.e. e.g. etc. et al..
This can be corrected by forcing a normal space with src_LaTeX{\ }.
When exporting Org documents, we can add a filter to check for common
abbreviations and make the space normal.

#+begin_src emacs-lisp
(defvar +org-latex-abbreviations
  '(;; Latin
    "cf." "e.g." "etc." "et al." "i.e." "v." "vs." "viz." "n.b."
    ;; Corperate
    "inc." "govt." "ltd." "pty." "dept."
    ;; Temporal
    "est." "c."
    ;; Honorifics
    "Prof." "Dr." "Mr." "Mrs." "Ms." "Miss." "Sr." "Jr."
    ;; Components of a work
    "ed." "vol." "sec." "chap." "pt." "pp." "op." "no."
    ;; Common usage
    "approx." "misc." "min." "max.")
  "A list of abbreviations that should be spaced correctly when exporting to LaTeX.")

(defun +org-latex-correct-latin-abbreviation-spaces (text backend _info)
  "Normalise spaces after Latin abbreviations."
  (when (org-export-derived-backend-p backend 'latex)
    (replace-regexp-in-string (rx (group (or line-start space)
                                         (regexp (regexp-opt-group +org-latex-abbreviations)))
                                  (or line-end space))
                              "\\1\\\\ "
                              text)))

(add-to-list 'org-export-filter-paragraph-functions #'+org-latex-correct-latin-abbreviation-spaces t)
#+end_src

** Extra special strings

LaTeX already recognises =---= and =--= as em/en-dashes, =\-= as a shy hyphen, and the
conversion of =...= to =\ldots{}= is hardcoded into ~org-latex-plain-text~ (unlike
~org-html-plain-text~).

I'd quite like to also recognise =->= and =<-=, so let's set come up with some advice.

#+begin_src emacs-lisp
(defvar org-latex-extra-special-string-regexps
  '(("<->" . "\\\\(\\\\leftrightarrow{}\\\\)")
    ("->" . "\\\\textrightarrow{}")
    ("<-" . "\\\\textleftarrow{}")))

(defun org-latex-convert-extra-special-strings (string)
  "Convert special characters in STRING to LaTeX."
  (dolist (a org-latex-extra-special-string-regexps string)
    (let ((re (car a))
          (rpl (cdr a)))
      (setq string (replace-regexp-in-string re rpl string t)))))

(defadvice! org-latex-plain-text-extra-special-a (orig-fn text info)
  "Make `org-latex-plain-text' handle some extra special strings."
  :around #'org-latex-plain-text
  (let ((output (funcall orig-fn text info)))
    (when (plist-get info :with-special-strings)
      (setq output (org-latex-convert-extra-special-strings output)))
    output))
#+end_src

** Chameleon --- aka. match theme


Once I had the idea of having the look of the LaTeX document produced match the
current Emacs theme, I was enraptured. The result is the pseudo-class ~chameleon~,
which I have implemented in the package =ox-chameleon=.

#+begin_src emacs-lisp :tangle packages.el
(package! ox-chameleon :recipe (:host github :repo"tecosaur/ox-chameleon"))
#+end_src

#+begin_src emacs-lisp
(use-package! ox-chameleon
  :after ox)
#+end_src

** Make verbatim different to code

Since have just gone to so much effort above let's make the most of it by making
=verbatim= use ~verb~ instead of ~protectedtexttt~ (default).

This gives the same advantages as mentioned in the [[*Make verbatim different to code][HTML export section]].

#+begin_src emacs-lisp
(setq org-latex-text-markup-alist
      '((bold . "\\textbf{%s}")
        (code . protectedtexttt)
        (italic . "\\emph{%s}")
        (strike-through . "\\sout{%s}")
        (underline . "\\uline{%s}")
        (verbatim . verb)))
#+end_src

** Check for required packages

For how I've setup Org's LaTeX export, the following packages are needed:
#+name: org-latex-required-packages-list
| Package    | Description                                           |
|------------+-------------------------------------------------------|
| adjustbox  | Adjust general LaTeX material in like includegraphics |
| amsmath    | A near-essential maths package                        |
| booktabs   | Nice horizontal lines in tables                       |
| cancel     | Cancel terms in equations                             |
| capt-of    | Captions outside floats                               |
| caption    | Finer control over captions                           |
| cleveref   | Easy cross-referencing                                |
| embedall   | Embed files in the document                           |
| float      | Floating environments                                 |
| fontenc    | Font encodings                                        |
| fvextra    | Enhanced verbatim environments                        |
| graphicx   | An extended graphics package                          |
| hanging    | Used by oc-csl                                        |
| hyperref   | Links                                                 |
| inputenc   | Input file encodings                                  |
| longtable  | Multi-page tables                                     |
| mathalpha  | Set extended math alphabet fonts                      |
| mathtools  | Typesetting tools for maths                           |
| microtype  | Microtypography                                       |
| pdfx       | Create pdf/a- and pdf/x- compatible documents         |
| pifont     | A collection of symbols                               |
| preview    | Needed for AUCTeX and ob-latex                        |
| scrbase    | KOMA classes and more                                 |
| siunitx    | Proper unit support                                   |
| soul       | Strikethrough and underline, flexibly                 |
| subcaption | Form subfigures and subcaptions                       |
| svg        | Insert SVG images                                     |
| tikz       | Generally handy, as a dependancy and for graphics     |
| tcolorbox  | Nice boxes for code                                   |
| textcomp   | Font encodings                                        |
| xcolor     | Colours                                               |
| xparse     | Extended command/env definition forms                 |
| xcoffins   | Manipulate coffins (boxes) for typesetting            |

Then for the various fontsets:
#+name: org-latex-font-packages-list
+ Alegreya
+ arev
+ biolinum
+ FiraMono
+ FiraSans
+ fourier
+ gillius
+ kpfonts
+ libertine
+ newpxmath
+ newpxtext
+ newtxmath
+ newtxtext
+ newtxsf
+ noto
+ plex-mono
+ plex-sans
+ plex-serif
+ sourcecodepro
+ sourcesanspro
+ sourceserifpro

We can write a function which will check for each of these packages with
=kpsewhich=, and then if any of them are missing we'll inject some advice into the
generated config that gets a list of missing packages and warns us every time we
export to a PDF.

#+name: org-missing-latex-packages
#+begin_src emacs-lisp :noweb-ref none :var org-latex-required-packages-list=org-latex-required-packages-list[,0] :var org-latex-font-packages-list=org-latex-font-packages-list
(setq org-required-latex-packages (append org-latex-required-packages-list
                                          (mapcar #'car org-latex-font-packages-list)))

(defun check-for-latex-packages (packages)
  (delq nil (mapcar (lambda (package)
                      (unless
                          (= 0 (call-process "kpsewhich" nil nil nil (concat package ".sty")))
                        package))
                    packages)))

(if-let ((missing-pkgs (check-for-latex-packages org-required-latex-packages)))
    (concat
     (pp-to-string `(setq org-required-latex-packages ',org-required-latex-packages))
     (message ";; Detected missing LaTeX packages: %s\n" (mapconcat #'identity missing-pkgs ", "))
     (pp-to-string
      '(defun check-for-latex-packages (packages)
         (delq nil (mapcar (lambda (package)
                             (unless
                                 (= 0 (call-process "kpsewhich" nil nil nil (concat package ".sty")))
                               package))
                           packages))))
     (pp-to-string
      '(defun +org-warn-about-missing-latex-packages (&rest _)
         (message "Checking for missing LaTeX packages...")
         (sleep-for 0.4)
         (if-let (missing-pkgs (check-for-latex-packages org-required-latex-packages))
             (message "%s You are missing the following LaTeX packages: %s."
                      (propertize "Warning!" 'face '(bold warning))
                      (mapconcat (lambda (pkg) (propertize pkg 'face 'font-lock-variable-name-face))
                                 missing-pkgs
                                 ", "))
           (message "%s You have all the required LaTeX packages. Run %s to make this message go away."
                    (propertize "Success!" 'face '(bold success))
                    (propertize "doom sync" 'face 'font-lock-keyword-face))
           (advice-remove 'org-latex-export-to-pdf #'+org-warn-about-missing-latex-packages))
         (sleep-for 1)))
     (pp-to-string
      '(advice-add 'org-latex-export-to-pdf :before #'+org-warn-about-missing-latex-packages)))
  ";; No missing LaTeX packags detected")
#+end_src

#+begin_src emacs-lisp :noweb no-export
<<org-missing-latex-packages()>>
#+end_src
* org del
****** Citation


#+begin_quote
Extending the =:tools biblio= module.
#+end_quote

References in Org are fairly easy now, thanks to =org-cite=. The =:tools biblio=
module gives a fairly decent basic setup, but it would be nice to take it a bit
further. This mostly consists of tweaking settings, but there is one extra
package I'll grab for prettier in-buffer citations.

#+begin_src emacs-lisp :tangle packages.el
(package! org-cite-csl-activate :recipe (:host github :repo "andras-simonyi/org-cite-csl-activate") :pin "4fdb61c0f83b5d6db0d07dfd64d2a177fd46e931")
#+end_src

In particular, by setting ~org-cite-csl-activate-use-document-style~, we can have
the in-buffer displayed citations be the same as the exported form. Isn't that lovely!

Unfortunately, there's currently a potential for undesirable buffer
modifications, so we'll put all the activation code behind a function we can
call when we want it.

#+begin_src emacs-lisp
(use-package! oc-csl-activate
  :after oc
  :config
  (setq org-cite-csl-activate-use-document-style t)
  (defun +org-cite-csl-activate/enable ()
    (interactive)
    (setq org-cite-activate-processor 'csl-activate)
    (add-hook! 'org-mode-hook '((lambda () (cursor-sensor-mode 1)) org-cite-csl-activate-render-all))
    (defadvice! +org-cite-csl-activate-render-all-silent (orig-fn)
      :around #'org-cite-csl-activate-render-all
      (with-silent-modifications (funcall orig-fn)))
    (when (eq major-mode 'org-mode)
      (with-silent-modifications
        (save-excursion
          (goto-char (point-min))
          (org-cite-activate (point-max)))
        (org-cite-csl-activate-render-all)))
    (fmakunbound #'+org-cite-csl-activate/enable)))
#+end_src

Now that =oc-csl-activate= is set up, let's go ahead and customise some of the
packages already loaded. For starters, we can make use of the my Zotero files
with =citar=, and make the symbols a bit prettier.

#+begin_src emacs-lisp
(after! citar
  (setq citar-bibliography
        (let ((libfile-search-names '("library.json" "Library.json" "library.bib" "Library.bib"))
              (libfile-dir "~/Zotero")
              paths)
          (dolist (libfile libfile-search-names)
            (when (and (not paths)
                       (file-exists-p (expand-file-name libfile libfile-dir)))
              (setq paths (list (expand-file-name libfile libfile-dir)))))
          paths))
  (setq citar-symbols
        `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
          (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
          (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))))
#+end_src

We can also make the Zotero CSL styles available to use.

#+begin_src emacs-lisp
(after! oc-csl
  (setq org-cite-csl-styles-dir "~/Zotero/styles"))
#+end_src

Since CSL works so nicely everywhere, we might as well use it as the default
citation export processor for everything.

#+begin_src emacs-lisp
(after! oc
  (setq org-cite-export-processors '((t csl))))
#+end_src

Then, for convenience we'll cap things off by putting the citation command under
Org's localleader.

#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :localleader
      :desc "Insert citation" "@" #'org-cite-insert)
#+end_src

Lastly, just in case I come across any old citations of mine, I think it would
be nice to have a function to convert =org-ref= citations to =org-cite= forms.

#+begin_src emacs-lisp
(after! oc
  (defun org-ref-to-org-cite ()
    "Attempt to convert org-ref citations to org-cite syntax."
    (interactive)
    (let* ((cite-conversions '(("cite" . "//b") ("Cite" . "//bc")
                               ("nocite" . "/n")
                               ("citep" . "") ("citep*" . "//f")
                               ("parencite" . "") ("Parencite" . "//c")
                               ("citeauthor" . "/a/f") ("citeauthor*" . "/a")
                               ("citeyear" . "/na/b")
                               ("Citep" . "//c") ("Citealp" . "//bc")
                               ("Citeauthor" . "/a/cf") ("Citeauthor*" . "/a/c")
                               ("autocite" . "") ("Autocite" . "//c")
                               ("notecite" . "/l/b") ("Notecite" . "/l/bc")
                               ("pnotecite" . "/l") ("Pnotecite" . "/l/bc")))
           (cite-regexp (rx (regexp (regexp-opt (mapcar #'car cite-conversions) t))
                            ":" (group (+ (not (any "\n 	,.)]}")))))))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward cite-regexp nil t)
          (message (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2)))
          (replace-match (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2))))))))
#+end_src

****** cdlatex
#+begin_src emacs-lisp :tangle packages.el
(package! cdlatex)
#+end_src
It's also nice to be able to use ~cdlatex~.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

It's handy to be able to quickly insert environments with =C-c }=. I almost always
want to edit them afterwards though, so let's make that happen by default.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

At some point in the future it could be good to investigate [[https://scripter.co/splitting-an-org-block-into-two/][splitting org blocks]].
Likewise [[https://archive.casouri.cat/note/2020/insert-math-symbol-in-emacs/][this]] looks good for symbols.

****** View exported file
='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src

* EVA

Emacs Virtual assistant
#+begin_src emacs-lisp :tangle packages.el

(package! eva
    :recipe (:host github :repo "meedstrom/eva"
           :files (:defaults "assets" "renv" "*.R" "*.gnuplot")))

#+end_src
#+begin_src emacs-lisp :tangle no

(use-package! eva
:init
(setq ess-history-file "~/self/data/.Rhistory")
(setq ess-ask-for-ess-directory nil)
  (setq eva-ai-name "HAL"
        eva-user-name "Akhil"
        eva-user-birthday "1999-01-02"
        eva-user-short-title "Dude"
        eva-fallback-to-emacs-idle t)
      (setq eva--idle-secs-fn #'eva--idle-secs-gnome)
  (setq eva-idle-log-path         "~/self/data/idle.tsv")
  (setq eva-buffer-focus-log-path "~/self/data/buffer-focus.tsv")
  (setq eva-buffer-info-path      "~/self/data/buffer-info.tsv")
  (setq eva-main-ledger-path      "~/self/data/l.ledger")
  (setq eva-main-datetree-path    "~/org/notes/diary.org")
  :config
  (setq org-journal-dir "~/org/journal/")
    (setq org-journal-date-prefix "#+TITLE: "
        org-journal-file-format "%Y-%m-%d.org"
        org-journal-date-format "%A, %d %B %Y")
    (require 'eva-builtin)
  (require 'eva-activity)
    (add-hook 'eva-after-load-vars-hook #'eva-check-dangling-clock)
  (add-hook 'eva-after-load-vars-hook #'eva-check-org-variables)
   (setq eva-items
        (list
         (eva-item-create :fn #'eva-greet
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-query-mood
                          :dataset "~/self/data/mood.tsv"
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-query-activity
                          :dataset "~/self/data/activities.tsv"
                          :min-hours-wait 1)

         (eva-item-create :fn #'eva-present-diary
                          :max-successes-per-day 1)

         (eva-item-create :fn #'eva-query-weight
                          :dataset "~/self/data/weight.tsv"
                          :max-entries-per-day 1)

         (eva-item-create :fn #'eva-plot-weight
                          :max-entries-per-day 1)

         (eva-item-create :fn #'eva-query-sleep
                          :dataset "~/self/data/sleep.tsv"
                          :min-hours-wait 5
                          :lookup-posted-time t)

         (eva-item-create :fn #'eva-present-ledger-report)

         (eva-item-create :fn #'eva-present-org-agenda)

         (eva-item-create :fn #'eva-query-ingredients
                          :dataset "~/self/data/ingredients.tsv"
                          :min-hours-wait 5)

         (eva-item-create :fn #'eva-query-cold-shower
                          :dataset "~/self/data/cold.tsv"
                          :max-entries-per-day 1)

         ;; you can inline define the functions too
         (eva-item-create
          :fn (eva-defun my-bye ()
                (message (eva-emit "All done for now."))
                (bury-buffer (eva-buffer-chat)))
          :min-hours-wait 0)))
        (transient-replace-suffix 'eva-dispatch '(0)
    '["General actions"
      ("q" "Quit" bury-buffer)
      ("l" "View Ledger report" eva-present-ledger-report)
      ("f" "View Ledger file" eva-present-ledger-file)
      ("a" "View Org agenda" org-agenda-list)])

  (define-key eva-chat-mode-map (kbd "l") #'eva-present-ledger-report)
  (define-key eva-chat-mode-map (kbd "a") #'org-agenda-list)

  ;; Activities
  (setq eva-activity-list
        (list (eva-activity-create :name "sleep"
                                   :cost-false-pos 3
                                   :cost-false-neg 3)

              (eva-activity-create :name "studying"
                                   :cost-false-pos 8
                                   :cost-false-neg 8)

              (eva-activity-create :name "coding"
                                   :cost-false-pos 5
                                   :cost-false-neg 5)

              (eva-activity-create :name "working"
                                   :cost-false-pos 5
                                   :cost-false-neg 5)
              (eva-activity-create :name "unknown"
                                   :cost-false-pos 0
                                   :cost-false-neg 0)))
  (eva-mode))
#+end_src

* Davivil ivy mode
#+begin_src emacs-lisp :tangle no
;; Better Completions with Ivy
;; I currently use Ivy, Counsel, and Swiper to navigate around files, buffers, and projects super quickly. Here are some workflow notes on how to best use Ivy:

;; While in an Ivy minibuffer, you can search within the current results by using S-Space.
;; To quickly jump to an item in the minibuffer, use C-' to get Avy line jump keys.
;; To see actions for the selected minibuffer item, use M-o and then press the action's key.
;; Super useful: Use C-c C-o to open ivy-occur to open the search results in a separate buffer. From there you can click any item to perform the ivy action.

(use-package! ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-f" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-r" . ivy-reverse-i-search-kill))
  ;; :init
  ;; (ivy-mode 1)
  :config
  (defun my/ivy-switch-buffer-by-prefix (prefix)
    "Use ivy to select a buffer prefixed by PREFIX#."
    (minibuffer-with-setup-hook
        (lambda ()
          (insert (concat "^" prefix "# ")))
      (ivy-switch-buffer)))
  (defun my/ivy-switch-buffer-firefox ()
    "Use ivy to select a Firefox window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "F"))
  (defun my/ivy-switch-buffer-urxvt ()
    "Use ivy to select an URXVT window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "u"))
  (defun my/ivy-switch-buffer-detached-command ()
    "Use ivy to select a compilation buffer."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "d")))

  ;; (setcdr (assoc t ivy-format-functions-alist) #'ivy-format-function-line)
  ;; ;; (ivy-mode 1)
  ;; (setq ivy-use-virtual-buffers t)
  ;; (setq ivy-wrap t)
  ;; (setq ivy-count-format "(%d/%d) ")
  ;; (setq enable-recursive-minibuffers t)

  ;; ;; Use different regex strategies per completion command
  ;; (push '(completion-at-point . ivy--regex-fuzzy) ivy-re-builders-alist) ;; This doesn't seem to work...
  ;; (push '(swiper . ivy--regex-ignore-order) ivy-re-builders-alist)
  ;; (push '(counsel-M-x . ivy--regex-ignore-order) ivy-re-builders-alist)

  ;; Set minibuffer height for different commands
  ;; (setf (alist-get 'counsel-projectile-ag ivy-height-alist) 15)
  ;; (setf (alist-get 'counsel-projectile-rg ivy-height-alist) 15)
  ;; (setf (alist-get 'swiper ivy-height-alist) 15)
  ;; (setf (alist-get 'counsel-switch-buffer ivy-height-alist) 7))

  ;; (setf (alist-get '+default/search-emacsd ivy-height-alist) 7)
  ;; (setf (alist-get '+vertico/project-search-from-cwd ivy-height-alist) 7))
;; (use-package! ivy-hydra
;;   :defer t
;;   :after hydra)

;; (use-package! ivy-rich
;;   :init
;;   ;; (ivy-rich-mode 1)
;;   :after counsel
;;   :config
;;   (setq ivy-format-function #'ivy-format-function-line)
;;   (setq ivy-rich-display-transformers-list
;;         (plist-put ivy-rich-display-transformers-list
;;                    'ivy-switch-buffer
;;                    '(:columns
;;                      ((ivy-rich-candidate (:width 40))
;;                       (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
;;                       (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
;;                       (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
;;                       (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
;;                      :predicate
;;                      (lambda (cand)
;;                        (if-let ((buffer (get-buffer cand)))
;;                            ;; Don't mess with EXWM buffers
;;                            (with-current-buffer buffer
;;                              (not (derived-mode-p 'exwm-mode)))))))))

(use-package! counsel
  :demand t
  ;; :bind (("M-x" . counsel-M-x)
  ;;        ("C-c a" . counsel-ibuffer)
  ;;        ("C-x C-f" . counsel-find-file)
         ;; ("C-M-j" . counsel-switch-buffer)
         ;; ("C-c l" . counsel-imenu)
         ;; :map minibuffer-local-map
         ;; ("C-c r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (setq ivy-initial-inputs-alist nil) ;; Don't start searches with ^

  (defun my/counsel-find-file-no-tramp (&optional initial-input initial-directory)
    (interactive)
    (if (string-prefix-p "/ssh:" default-directory)
        (counsel-find-file "" "~/")
      (counsel-find-file initial-input initial-directory)))
  ;; Pending https://github.com/abo-abo/swiper/pull/2844/
  (defun counsel--esh-dir-history-action-cd (pair)
    "Change the current working directory to the selection.
This function is the default action for `counsel-esh-dir-history'
and changes the working directory in Eshell to the selected
candidate which must be provided as the `car' of PAIR."
    (eshell/cd (car pair)))
  (defun counsel--esh-dir-history-action-edit (pair)
    "Insert the selection to the Eshell buffer prefixed by \"cd \".
This function is an action for `counsel-esh-dir-history' to
insert the selected directory (provided as the `car' of PAIR) to
the Eshell buffer prefixed by \"cd \", allowing the caller to
modify parts of the directory before switching to it."
    (insert (format "cd %s" (car pair))))
  (defun counsel-esh-dir-history ()
    "Use Ivy to browse Eshell's directory stack."
    (interactive)
    (require 'em-dirs)
    (defvar eshell-last-dir-ring)
    (ivy-read "Directory to change to: " (ivy-history-contents eshell-last-dir-ring)
              :keymap ivy-reverse-i-search-map
              :action #'counsel--esh-dir-history-action-cd
              :caller #'counsel-esh-dir-history))
  (ivy-set-actions
   'counsel-esh-dir-history
   '(("e" counsel--esh-dir-history-action-edit "edit")))
  (defun counsel-fzf-action (x)
    (with-ivy-window
      (let ((default-directory counsel--fzf-dir))
        (find-file-other-window x)))
    (other-window -1))
  :custom
  (counsel-yank-pop-separator "\n-------------------\n")
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
(use-package! swiper
  :bind (("C-s" . isearch-forward)
         ("C-M-s" . swiper-thing-at-point)))
;; (use-package! flx  ;; Improves sorting for fuzzy-matched results
;;   :after ivy
;;   :defer t
;;   :init
;;   (setq ivy-flx-limit 10000))

;; (use-package! wgrep)

;; (use-package! ivy-posframe
;;   ;; :disabled
;;   :custom
;;   (ivy-posframe-width      115)
;;   (ivy-posframe-min-width  115)
;;   (ivy-posframe-height     10)
;;   (ivy-posframe-min-height 10)
;;   :config
;;   (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
;;   (setq ivy-posframe-parameters '((parent-frame . nil)
;;                                   (left-fringe . 8)
;;                                   (right-fringe . 8)))
;;   (ivy-posframe-mode nil))

;; (use-package! prescient
;;   :after counsel
;;   :config
;;   (prescient-persist-mode 1))

;; (use-package! ivy-prescient
;;   :after prescient
;;   :config
;;   (ivy-prescient-mode 1))

;; (dw/leader-key-def
;;   "r"   '(ivy-resume :which-key "ivy resume")
;;   "f"   '(:ignore t :which-key "files")
;;   "ff"  '(counsel-find-file :which-key "open file")
;;   "C-f" 'counsel-find-file
;;   "fr"  '(counsel-recentf :which-key "recent files")
;;   "fR"  '(revert-buffer :which-key "revert file")
;;   "fj"  '(counsel-file-jump :which-key "jump to file"))
#+end_src

#+RESULTS:
: swiper-thing-at-point

* vertico posframe
#+begin_src emacs-lisp :tangle packages.el
(package! vertico-posframe
    :recipe (:host github :repo "tumashu/vertico-posframe"
       :files ("vertico-posframe.el")))
#+end_src
#+begin_src emacs-lisp
(use-package! vertico-posframe
  :config
  (defun ct/vertico-posframe-get-size ()
    "Override of `vertico-posframe-get-size'"
    (let ((width (round (* (frame-width) 0.8))))
      (list
       :height vertico-posframe-height
       :width (min (or vertico-posframe-max-width
                       999999)
                   (or vertico-posframe-min-width
                       width))
       :min-height (or vertico-posframe-min-height
                       (let ((height (+ vertico-count 1)))
                         (min height (or vertico-posframe-height height))))
       :min-width (or vertico-posframe-min-width
                      vertico-posframe-max-width
                      width))))
  (defun ct/posframe-poshandler-frame-center-eyelevel (info)
    "Posframe position handler to put the posframe at eye level,
horizontally centered. Top position is fixed to avoid jittering
when filtering.

INFO can be found in docstring of `posframe-show'."
    (cons (- (/ (plist-get info :parent-frame-width) 2)
             (/ (plist-get info :posframe-width) 2))
          (- (/ (plist-get info :parent-frame-height) 4)
             (/ vertico-posframe-min-height 2))))

  (setq vertico-posframe-parameters '((left-fringe . 20)
                                      (right-fringe . 20))
        vertico-posframe-border-width 4
        vertico-posframe-min-height 3
        vertico-posframe-max-width 130  ;; Don't go too wide on ultrawide monitors
        vertico-posframe-poshandler #'ct/posframe-poshandler-frame-center-eyelevel
        vertico-posframe-size-function #'ct/vertico-posframe-get-size)
  :init
  (vertico-posframe-mode 1))
#+end_src

#+RESULTS:
: t

* Holidays
  :PROPERTIES:
  :CATEGORY: Holiday
  :END:
%%(org-calendar-holiday)   ; special function for holiday names

* Birthdays
  :PROPERTIES:
  :CATEGORY: Ann
  :END:
%%(org-anniversary 2022  10 17) Arthur Dent is %d years old
%%(org-anniversary 1869 10  2) Mahatma Gandhi would be %d years old

* [[https://d12frosted.io/posts/2021-01-16-task-management-with-roam-vol5.html][Dynamic and fast agenda]]
#+begin_src emacs-lisp :tangle no
(add-to-list 'org-tags-exclude-from-inheritance "project")
(defun vulpea-project-p ()
  "Return non-nil if current buffer has any todo entry.

TODO entries marked as done are ignored, meaning the this
function returns nil if current buffer contains only completed
tasks."
  (seq-find                                 ; (3)
   (lambda (type)
     (eq type 'todo))
   (org-element-map                         ; (2)
       (org-element-parse-buffer 'headline) ; (1)
       'headline
     (lambda (h)
       (org-element-property :todo-type h)))))

(defun vulpea-project-update-tag ()
    "Update PROJECT tag in the current buffer."
    (when (and (not (active-minibuffer-window))
               (vulpea-buffer-p))
      (save-excursion
        (goto-char (point-min))
        (let* ((tags (vulpea-buffer-tags-get))
               (original-tags tags))
          (if (vulpea-project-p)
              (setq tags (cons "project" tags))
            (setq tags (remove "project" tags)))

          ;; cleanup duplicates
          (setq tags (seq-uniq tags))

          ;; update tags if changed
          (when (or (seq-difference tags original-tags)
                    (seq-difference original-tags tags))
            (apply #'vulpea-buffer-tags-set tags))))))

(defun vulpea-buffer-p ()
  "Return non-nil if the currently visited buffer is a note."
  (and buffer-file-name
       (string-prefix-p
        (expand-file-name (file-name-as-directory org-roam-directory))
        (file-name-directory buffer-file-name))))

(defun vulpea-project-files ()
    "Return a list of note files containing 'project' tag." ;
    (seq-uniq
     (seq-map
      #'car
      (org-roam-db-query
       [:select [nodes:file]
        :from tags
        :left-join nodes
        :on (= tags:node-id nodes:id)
        :where (like tag (quote "%\"project\"%"))]))))

(defun vulpea-agenda-files-update (&rest _)
  "Update the value of `org-agenda-files'."
  (setq org-agenda-files (vulpea-project-files)))

(add-hook 'find-file-hook #'vulpea-project-update-tag)
(add-hook 'before-save-hook #'vulpea-project-update-tag)

(advice-add 'org-agenda :before #'vulpea-agenda-files-update)
(advice-add 'org-todo-list :before #'vulpea-agenda-files-update)
#+end_src

#+RESULTS:

* google answer (tuxi)
#+begin_src emacs-lisp

;; *** GOOGLE ANSWERS
;; Query Google's knowledge graph. This is the answer that shows up before the
;; first result in Google searches. For this purpose we use tuxi, an external
;; tool that queries Google.
(use-package! emacs
  :config
  (defvar google-search-history nil
    "List of queries to google-search-string.")
  (defun google-search-string (search-string)
    "Read SEARCH-STRING from the minibuffer and call the shell
command tuxi on it."
    (interactive (list (read-string "Google: " nil
                                    google-search-history
                                    (thing-at-point 'sexp))))
    (unless (executable-find "tuxi")
      (user-error "Cannot find shell command: tuxi"))
    (let ((search-output (string-trim-right
                          (shell-command-to-string
                           (concat
                            "tuxi -r "
                            (shell-quote-argument search-string))))))
      (with-current-buffer (get-buffer-create "*Tuxi Output*")
        (goto-char (point-max))
        (unless (bobp) (insert "\n\n* * *\n"))
        (insert (capitalize search-string) ":\n\n")
        (push-mark)
        (insert search-output)
        (let ((lines (count-lines (or (mark) (point-min)) (point-max))))
          (if (<= lines 1)
              (message search-output)
            (let ((win (display-buffer (current-buffer))))
              (set-window-start win (mark))
              (set-window-parameter win 'window-height (min lines 10))
              (goto-address-mode 1)))))))
  (defun google-search-at-point (&optional beg end)
    "Call the shell command tuxi on the symbol at point. With an
active region use it instead."
    (interactive "r")
    (if-let ((search-string (if (use-region-p)
                                (buffer-substring-no-properties beg end)
                              (thing-at-point 'symbol))))
        (google-search-string search-string)
      ;; (message "No symbol to search for at point!")
      (call-interactively #'google-search-string)))
  :bind (:map help-map
              ("g" . google-search-string)
              ("C-=" . google-search-at-point)))

#+end_src

#+RESULTS:
: google-search-at-point
* org

***** Symbols

It's also nice to change the character used for collapsed items (by default ~â€¦~),
I think ~â–¾~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.
I've also added some fun alternatives, just commented out.
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("â—‰" "â—‹" "âœ¸" "âœ¿" "âœ¤" "âœœ" "â—†" "â–¶")
        org-superstar-prettify-item-bullets t ))

        ;; org-superstar-headline-bullets-list '("â—‰" "â—" "â—‹" "â—†" "â—" "â—‹" "â—†")
        ;; org-superstar-item-bullet-alist '((?+ . ?âž¤) (?- . ?âœ¦)) ; changes +/- symbols in item lists

(setq org-ellipsis " â–¾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src
It's also nice to make use of the Unicode characters for check boxes, and other commands.
#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "â˜"
            :pending       "â—¼"
            :checkedbox    "â˜‘"
            :list_property "âˆ·"
            :em_dash       "â€”"
            :ellipses      "â€¦"
            :arrow_right   "â†’"
            :arrow_left    "â†"
            :title         "ð™"
            :subtitle      "ð™©"
            :author        "ð˜¼"
            :date          "ð˜¿"
            :property      "â˜¸"
            :options       "âŒ¥"
            :startup       "â»"
            :macro         "ð“œ"
            :html_head     "ðŸ…·"
            :html          "ðŸ…—"
            :latex_class   "ðŸ„»"
            :latex_header  "ðŸ…»"
            :beamer_header "ðŸ…‘"
            :latex         "ðŸ…›"
            :attr_latex    "ðŸ„›"
            :attr_html     "ðŸ„—"
            :attr_org      "â’ª"
            :begin_quote   "â"
            :end_quote     "âž"
            :caption       "â˜°"
            :header        "â€º"
            :results       "ðŸ ¶"
            :begin_export  "â©"
            :end_export    "âª"
            :properties    "âš™"
            :end           "âˆŽ"
            :priority_a   ,(propertize "âš‘" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "â¬†" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "â– " 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "â¬‡" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "â“" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]"
  :roam_tags     "#+roam_tags:"
  :filetags      "#+filetags:")
(plist-put +ligatures-extra-symbols :name "â")

;; (with-eval-after-load 'org
;;   (plist-put org-format-latex-options :background 'default))
#+end_src

#+RESULTS:
| :name | â  | :src_block | Â» | :src_block_end | Â« | :quote | â€œ | :quote_end | â€ | :lambda | Î» | :def | Æ’ | :composition | âˆ˜ | :map | â†¦ | :null | âˆ… | :true | ð•‹ | :false | ð”½  | :int | â„¤ | :float | â„  | :str | ð•Š  | :bool | ð”¹ | :list | ð•ƒ | :not | ï¿¢ | :in | âˆˆ | :not-in | âˆ‰ | :and | âˆ§ | :or | âˆ¨ | :for | âˆ€ | :some | âˆƒ | :return | âŸ¼ | :yield | âŸ» | :union | â‹ƒ | :intersect | âˆ© | :diff | âˆ–  | :tuple | â¨‚ | :pipe | î„µ | :dot | â€¢ | :checkbox | â˜ | :pending | â—¼  | :checkedbox | â˜‘ | :list_property | âˆ· | :em_dash | â€” | :ellipses | â€¦ | :arrow_right | â†’ | :arrow_left | â† | :title | ð™  | :subtitle | ð™©  | :author | ð˜¼  | :date | ð˜¿  | :property | â˜¸ | :options | âŒ¥ | :startup | â» | :macro | ð“œ | :html_head | ðŸ…· | :html | ðŸ…— | :latex_class | ðŸ„» | :latex_header | ðŸ…» | :beamer_header | ðŸ…‘ | :latex | ðŸ…› | :attr_latex | ðŸ„› | :attr_html | ðŸ„— | :attr_org | â’ª | :begin_quote | â | :end_quote | âž | :caption | â˜° | :header | â€º | :results | ðŸ ¶ | :begin_export | â© | :end_export | âª | :properties | âš™ | :end | âˆŽ | :priority_a | âš‘  | :priority_b | â¬† | :priority_c | â–  | :priority_d | â¬‡ | :priority_e | â“ | :checkbox | â˜ | :pending | â—¼  | :checkedbox | â˜‘ | :list_property | âˆ· | :em_dash | â€” | :ellipses | â€¦ | :arrow_right | â†’ | :arrow_left | â† | :title | ð™  | :subtitle | ð™©  | :author | ð˜¼  | :date | ð˜¿  | :property | â˜¸ | :options | âŒ¥ | :startup | â» | :macro | ð“œ | :html_head | ðŸ…· | :html | ðŸ…— | :latex_class | ðŸ„» | :latex_header | ðŸ…» | :beamer_header | ðŸ…‘ | :latex | ðŸ…› | :attr_latex | ðŸ„› | :attr_html | ðŸ„— | :attr_org | â’ª | :begin_quote | â | :end_quote | âž | :caption | â˜° | :header | â€º | :results | ðŸ ¶ | :begin_export | â© | :end_export | âª | :properties | âš™ | :end | âˆŽ | :priority_a | âš‘  | :priority_b | â¬† | :priority_c | â–  | :priority_d | â¬‡ | :priority_e | â“ |

~org-superstar-mode~ is great. While we're at it we may as well make tags prettier as well ðŸ™‚
#+begin_src emacs-lisp :tangle packages.el
;; (package! org-pretty-tags :pin "5c7521651b35ae9a7d3add4a66ae8cc176ae1c76")
#+end_src

#+begin_src emacs-lisp
;; (use-package! org-pretty-tags
;; :config
;;  (setq org-pretty-tags-surrogate-strings
;;        `(("uni"        . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
;;          ("ucc"        . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
;;          ("assignment" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("test"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("lecture"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("read"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
;;          ("article"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("web"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
;;          ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("issue"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("someday"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
;;          ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))
;;  (org-pretty-tags-global-mode))
#+end_src
* org mode
** ORG MODE
*** Org
Finally, because this section is fairly expensive to initialise, we'll wrap it
in an *src_elisp* {(after! ...)} block.
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
)
#+end_src
**** DONE System config
CLOSED: [2022-04-01 Fri 19:27]
***** Mime types
Org mode isn't recognised as it's own mime type by default, but that can easily
be changed with the following file. For system-wide changes try
~/usr/share/mime/packages/org.xml~.
#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src
What's nice is that Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][now]] has an icon for =text/org=.
One simply needs to refresh their mime database
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src
Then set Emacs as the default editor
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs.desktop text/org
#+end_src
***** Git diffs
Protesilaos wrote a [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][very helpful article]] in which he explains how to change the
git diff chunk heading to something more useful than just the immediate line
above the hunk --- like the parent heading.

This can be achieved by first adding a new diff mode to git in =~/.config/git/attributes=
#+begin_src fundamental :tangle no
,*.org   diff=org
#+end_src

Then adding a regex for it to =~/.config/git/config=
#+begin_src gitconfig :tangle no
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"
#+end_src

**** Packages
***** DONE Visuals
CLOSED: [2022-04-01 Fri 18:18]
****** Tables

Org tables aren't the prettiest thing to look at. This package is supposed to
redraw them in the buffer with box-drawing characters. Sounds like an
improvement to me! We'll make use of this with =writeroom-mode=.

#+begin_src emacs-lisp :tangle packages.el
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "7bd68b420d3402826fea16ee5099d04aa9879b78")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

****** Emphasis markers
While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.
#+begin_src emacs-lisp :tangle packages.el
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "303fcc8d5d85a4ebff2798dab50b2ccc0255ea5f")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

Allows you to jump in and out of latex fragments without using `C-c C-x C-l` all the time, beautiful.
#+begin_src emacs-lisp :tangle no
(use-package! org-fragtog
  :after org
  :hook (org-mode . org-fragtog-mode)
  )

#+end_src
****** Emphasis faces

Custom Highlighting -  so = becomes =red=.
#+begin_src emacs-lisp :tangle no
(after! org
  (setq org-emphasis-alist
        '(("*" (bold))
          ("/" italic)
          ("_" underline)
          ("=" org-verbatim verbatim)
          ("~" org-code verbatim)
          ("=" redd)
          ("~" code)
          ("+"
           (:strike-through t)))))

#+end_src

#+RESULTS:
| * | (bold)              |          |
| _ | underline           |          |
| = | org-verbatim        | verbatim |
| ~ | org-code            | verbatim |
| = | redd                |          |
| ~ | code                |          |
| + | (:strike-through t) |          |

****** Heading structure
Speaking of headlines, a nice package for viewing and managing the heading
structure has come to my attention.
#+begin_src emacs-lisp :tangle packages.el
(package! org-ol-tree :recipe (:host github :repo "Townk/org-ol-tree")
  :pin "207c748aa5fea8626be619e8c55bdb1c16118c25")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-ol-tree
  :commands org-ol-tree
  :config
  (setq org-ol-tree-ui-icon-set
        (if (and (display-graphic-p)
                 (fboundp 'all-the-icons-material))
            'all-the-icons
          'unicode))
  (org-ol-tree-ui--update-icon-set))

(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src

#+RESULTS:

****** Better indirect buffers
Copied from =Thomas Journa='s config to move around org-buffers.

#+begin_src emacs-lisp :tangle yes
(defun +org-tree-to-indirect-buffer-options (option)
    (let* ((old-value org-indirect-buffer-display))
          (progn
            (setq org-indirect-buffer-display option)
          (org-tree-to-indirect-buffer)
          (setq org-indirect-buffer-display old-value))))

(defun +org-tree-to-indirect-other-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'other-window))

(defun +org-tree-to-indirect-current-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'current-window))

(defun +org-tree-to-indirect-dedicated-frame ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'dedicated-frame))
#+end_src
***** Org Modern

Fontifying =org-mode= buffers to be as pretty as possible is of paramount importance,
and Minad's lovely =org-modern= goes a long way in this regard.

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern :pin "537e6b75e38bc0eff083c390c257098c9fc9ab49")
#+end_src

...with a touch of configuration...

#+begin_src emacs-lisp :tangle no
(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :config
  (setq org-modern-star '("â—‰" "â—‹" "âœ¸" "âœ¿" "âœ¤" "âœœ" "â—†" "â–¶")
        org-modern-table-vertical 1
        org-modern-table-horizontal 0.2
        org-modern-list '((43 . "âž¤")
                          (45 . "â€“")
                          (42 . "â€¢"))
        org-modern-todo-faces
        '(("TODO" :inverse-video t :inherit org-todo)
          ("PROJ" :inverse-video t :inherit +org-todo-project)
          ("STRT" :inverse-video t :inherit +org-todo-active)
          ("[-]"  :inverse-video t :inherit +org-todo-active)
          ("HOLD" :inverse-video t :inherit +org-todo-onhold)
          ("WAIT" :inverse-video t :inherit +org-todo-onhold)
          ("[?]"  :inverse-video t :inherit +org-todo-onhold)
          ("KILL" :inverse-video t :inherit +org-todo-cancel)
          ("NO"   :inverse-video t :inherit +org-todo-cancel))
        org-modern-footnote
        (cons nil (cadr org-script-display))
        org-modern-block-fringe nil
        org-modern-block-name
        '((t . t)
          ("src" "Â»" "Â«")
          ("example" "Â»â€“" "â€“Â«")
          ("quote" "â" "âž")
          ("export" "â©" "âª"))
        org-modern-progress nil
        org-modern-priority nil
        org-modern-horizontal-rule (make-string 36 ?â”€)
        org-modern-keyword
        '((t . t)
          ("title" . "ð™")
          ("subtitle" . "ð™©")
          ("author" . "ð˜¼")
          ("email" . #("îƒ¡" 0 1 (display (raise -0.14))))
          ("date" . "ð˜¿")
          ("property" . "â˜¸")
          ("options" . "âŒ¥")
          ("startup" . "â»")
          ("macro" . "ð“œ")
          ("bind" . #("î…—" 0 1 (display (raise -0.1))))
          ("bibliography" . "ï…")
          ("print_bibliography" . #("î•‹" 0 1 (display (raise -0.1))))
          ("cite_export" . "ï…â®­")
          ("print_glossary" . #("î•‹á´¬á¶»" 0 1 (display (raise -0.1))))
          ("glossary_sources" . #("î“" 0 1 (display (raise -0.14))))
          ("include" . "â‡¤")
          ("setupfile" . "â‡š")
          ("html_head" . "ðŸ…·")
          ("html" . "ðŸ…—")
          ("latex_class" . "ðŸ„»")
          ("latex_class_options" . #("ðŸ„»î¢¸" 1 2 (display (raise -0.14))))
          ("latex_header" . "ðŸ…»")
          ("latex_header_extra" . "ðŸ…»âº")
          ("latex" . "ðŸ…›")
          ("beamer_theme" . "ðŸ„±")
          ("beamer_color_theme" . #("ðŸ„±îŠ" 1 2 (display (raise -0.12))))
          ("beamer_font_theme" . "ðŸ„±ð€")
          ("beamer_header" . "ðŸ…±")
          ("beamer" . "ðŸ…‘")
          ("attr_latex" . "ðŸ„›")
          ("attr_html" . "ðŸ„—")
          ("attr_org" . "â’ª")
          ("call" . #("î•¦" 0 1 (display (raise -0.15))))
          ("name" . "â")
          ("header" . "â€º")
          ("caption" . "â˜°")
          ("RESULTS" . "ðŸ ¶")))
  (custom-set-faces! '(org-modern-statistics :inherit org-checkbox-statistics-todo)))
#+end_src

#+RESULTS:
| org-modern-mode | mixed-pitch-mode | org-fragtog-mode | locally-defer-font-lock | +org-pretty-mode | org-ref-org-menu | er/add-org-mode-expansions | turn-on-org-cdlatex | org-appear-mode | elpher-org-mode-integration | auto-revert-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | beginend-org-mode | +lookup--init-org-mode-handlers-h | (closure ((hook . org-mode-hook) (--dolist-tail--) t) (&rest _) (add-hook 'before-save-hook 'org-encrypt-entries nil t)) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-make-last-point-visible-h | org-fancy-priorities-mode | org-superstar-mode | evil-org-mode | toc-org-enable | flyspell-mode | embrace-org-mode-hook | org-eldoc-load | +literate-enable-recompile-h |

Since =org-modern='s tag face supplants Org's tag face, we need to adjust the
spell-check face ignore list

#+begin_src emacs-lisp
(after! spell-fu
  (cl-pushnew 'org-modern-tag (alist-get 'org-mode +spell-excluded-faces-alist)))
#+end_src
**** Behaviour
***** Tweaking defaults
#+begin_src emacs-lisp :tangle yes

(map! :leader
      :desc "Org babel tangle" "m B" #'org-babel-tangle)
#+end_src

#+RESULTS:
: org-babel-tangle

#+begin_src emacs-lisp
(setq org-directory "~/org"                      ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-export-in-background t                  ; run export processes in external emacs process
      org-export-allow-bind-keywords t     ; Bind keywords can be handy
      org-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}


(setq org-use-tag-inheritance nil)
(setq org-startup-indented t)
(setq org-hide-leading-stars t)
(setq org-treat-S-cursor-todo-selection-as-state-change t)
(setq org-hide-emphasis-markers t)
(setq org-support-shift-select t)
(require 'org-inlinetask)
(setq org-image-actual-width nil)
(setq org-time-stamp-custom-formats '("<%A, %B %d, %Y>" . "<%m/%d/%y %a %H:%M>"))
(setq org-archive-location (concat "org/archive-"
                                   (format-time-string "%Y%m" (current-time))
                                   ".org_archive::"))
(with-eval-after-load 'ox
  (require 'ox-pandoc))
(setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
(setq org-export-with-smart-quotes t)
#+end_src

#+RESULTS:
: t

I also like the src_elisp{:comments} header-argument, so let's make that a
default.
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

By default, ~visual-line-mode~ is turned =on=, and ~auto-fill-mode~ =off= by a hook.
However this messes with tables in Org-mode, and other plaintext files (e.g.
markdown, \LaTeX) so I'll turn it off for this, and manually enable it for more
specific modes as desired.
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

There also seem to be a few keybindings which use =hjkl=, but miss arrow key equivalents.
#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src
***** Extra functionality
****** Org buffer creation
Let's also make creating an org buffer just that little bit easier.
#+begin_src emacs-lisp
(evil-define-command evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "New empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src
****** The utility of zero-width spaces
Occasionally in Org you run into annoyances where you want to have two seperate
blocks right together without a space. For example, to *empâ€‹h*â€‹asise part of a word,
or put a currency symbol immediately before an inline source block.
There is a solution to this, it just sounds slightly hacky --- zero width spaces.
Because this is Emacs, we can make this feel much less hacky by making a minor
addition to the Org key map ðŸ™‚.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :nie "M-SPC M-SPC" (cmd! (insert "\u200B")))
#+end_src

We â€‹then want to stop the space from being included in exports, which can be done
with a little filter.
#+begin_src emacs-lisp
(defun +org-export-remove-zero-width-space (text _backend _info)
  "Remove zero width spaces from TEXT."
  (unless (org-export-derived-backend-p 'org)
    (replace-regexp-in-string "\u200B" "" text)))

(after! ox
  (add-to-list 'org-export-filter-final-output-functions #'+org-export-remove-zero-width-space t))
#+end_src
****** List bullet sequence
I think it makes sense to have list bullets change with depth
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
****** Spellcheck
My spelling is atrocious, so let's get flycheck going.
#+begin_src emacs-lisp :tangle no
(add-hook 'org-mode-hook 'turn-on-flyspell)
#+end_src
****** LSP support in ~src~ blocks
Now, by default, LSPs don't really function at all in ~src~ blocks.
#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src
****** Importing with Pandoc

Sometimes I'm given non-org files, that's very sad. Luckily Pandoc offers a way
to make that right again, and this package makes that even easier to do.
#+begin_src emacs-lisp :tangle packages.el
(package! org-pandoc-import :recipe
  (:host github :repo "tecosaur/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-pandoc-import
  :after org)
#+end_src

****** Document comparison
It's quite nice to compare Org files, and the richest way to compare content is
probably =latexdiff=. There are a few annoying steps involved here, and so I've
written a package to streamline the process.

#+begin_src emacs-lisp :tangle packages.el
(package! orgdiff :recipe (:host github :repo "tecosaur/orgdiff"))
#+end_src

The only little annoyance is the fact that =latexdiff= uses ~#FF0000~ and ~#0000FF~ as
the red/blue change indication colours. We can make this a bit nicer by
post-processing the =latexdiff= result.

#+begin_src emacs-lisp :tangle yes
(use-package! orgdiff
  :defer t
  :config
  (defun +orgdiff-nicer-change-colours ()
    (goto-char (point-min))
    ;; Set red/blue based on whether chameleon is being used
    (if (search-forward "%% make document follow Emacs theme" nil t)
        (setq red  (substring (doom-blend 'red 'fg 0.8) 1)
              blue (substring (doom-blend 'blue 'teal 0.6) 1))
      (setq red  "c82829"
            blue "00618a"))
    (when (and (search-forward "%DIF PREAMBLE EXTENSION ADDED BY LATEXDIFF" nil t)
               (search-forward "\\RequirePackage{color}" nil t))
      (when (re-search-forward "definecolor{red}{rgb}{1,0,0}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{red}{HTML}{%s}" red)))
      (when (re-search-forward "definecolor{blue}{rgb}{0,0,1}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{blue}{HTML}{%s}" blue)))))
  (add-to-list 'orgdiff-latexdiff-postprocess-hooks #'+orgdiff-nicer-change-colours))
#+end_src

****** OKAY org-todo-keywords
CLOSED: [2022-10-07 Fri 20:58]
#+begin_src emacs-lisp

(setq org-todo-keywords
      '((sequence "TODO(t!)" "PROJ(p)" "LOOP(l)" "CLAR(L@)" "READ(R@/!)" "WAIT(w@/!)" "FIXME(f@/!)" "IDEA(i)" "STRT(s)" "NEXT(n)" "DUPLICATE(u@)" "|" "DONE(d!)" "KILL(k@/!)"  "HOLD(h@/!)" "BLOCKED(B@)")
       (sequence "BACKLOG(b)" "SOMEDAY(S)" "PLAN(P)" "READY(r)" "FOUND(F@/!)" "ACTIVE(a@)" "REVIEW(v!)" "|" "COMPLETED(c)" "CANC(C@)")
       (sequence "[ ](T)" "[-](B)" "[?](W)" "|" "[X](D)")
       (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

#+end_src

****** Citation


#+begin_quote
Extending the =:tools biblio= module.
#+end_quote

References in Org are fairly easy now, thanks to =org-cite=. The =:tools biblio=
module gives a fairly decent basic setup, but it would be nice to take it a bit
further. This mostly consists of tweaking settings, but there is one extra
package I'll grab for prettier in-buffer citations.

#+begin_src emacs-lisp :tangle packages.el
(package! org-cite-csl-activate :recipe (:host github :repo "andras-simonyi/org-cite-csl-activate") :pin "4fdb61c0f83b5d6db0d07dfd64d2a177fd46e931")
#+end_src

In particular, by setting ~org-cite-csl-activate-use-document-style~, we can have
the in-buffer displayed citations be the same as the exported form. Isn't that lovely!

Unfortunately, there's currently a potential for undesirable buffer
modifications, so we'll put all the activation code behind a function we can
call when we want it.

#+begin_src emacs-lisp
(use-package! oc-csl-activate
  :after oc
  :config
  (setq org-cite-csl-activate-use-document-style t)
  (defun +org-cite-csl-activate/enable ()
    (interactive)
    (setq org-cite-activate-processor 'csl-activate)
    (add-hook! 'org-mode-hook '((lambda () (cursor-sensor-mode 1)) org-cite-csl-activate-render-all))
    (defadvice! +org-cite-csl-activate-render-all-silent (orig-fn)
      :around #'org-cite-csl-activate-render-all
      (with-silent-modifications (funcall orig-fn)))
    (when (eq major-mode 'org-mode)
      (with-silent-modifications
        (save-excursion
          (goto-char (point-min))
          (org-cite-activate (point-max)))
        (org-cite-csl-activate-render-all)))
    (fmakunbound #'+org-cite-csl-activate/enable)))
#+end_src

Now that =oc-csl-activate= is set up, let's go ahead and customise some of the
packages already loaded. For starters, we can make use of the my Zotero files
with =citar=, and make the symbols a bit prettier.

#+begin_src emacs-lisp
(after! citar
  (setq citar-bibliography
        (let ((libfile-search-names '("library.json" "Library.json" "library.bib" "Library.bib"))
              (libfile-dir "~/Zotero")
              paths)
          (dolist (libfile libfile-search-names)
            (when (and (not paths)
                       (file-exists-p (expand-file-name libfile libfile-dir)))
              (setq paths (list (expand-file-name libfile libfile-dir)))))
          paths))
  (setq citar-symbols
        `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
          (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
          (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))))
#+end_src

We can also make the Zotero CSL styles available to use.

#+begin_src emacs-lisp
(after! oc-csl
  (setq org-cite-csl-styles-dir "~/Zotero/styles"))
#+end_src

Since CSL works so nicely everywhere, we might as well use it as the default
citation export processor for everything.

#+begin_src emacs-lisp
(after! oc
  (setq org-cite-export-processors '((t csl))))
#+end_src

Then, for convenience we'll cap things off by putting the citation command under
Org's localleader.

#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :localleader
      :desc "Insert citation" "@" #'org-cite-insert)
#+end_src

Lastly, just in case I come across any old citations of mine, I think it would
be nice to have a function to convert =org-ref= citations to =org-cite= forms.

#+begin_src emacs-lisp
(after! oc
  (defun org-ref-to-org-cite ()
    "Attempt to convert org-ref citations to org-cite syntax."
    (interactive)
    (let* ((cite-conversions '(("cite" . "//b") ("Cite" . "//bc")
                               ("nocite" . "/n")
                               ("citep" . "") ("citep*" . "//f")
                               ("parencite" . "") ("Parencite" . "//c")
                               ("citeauthor" . "/a/f") ("citeauthor*" . "/a")
                               ("citeyear" . "/na/b")
                               ("Citep" . "//c") ("Citealp" . "//bc")
                               ("Citeauthor" . "/a/cf") ("Citeauthor*" . "/a/c")
                               ("autocite" . "") ("Autocite" . "//c")
                               ("notecite" . "/l/b") ("Notecite" . "/l/bc")
                               ("pnotecite" . "/l") ("Pnotecite" . "/l/bc")))
           (cite-regexp (rx (regexp (regexp-opt (mapcar #'car cite-conversions) t))
                            ":" (group (+ (not (any "\n 	,.)]}")))))))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward cite-regexp nil t)
          (message (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2)))
          (replace-match (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2))))))))
#+end_src

****** cdlatex
#+begin_src emacs-lisp :tangle packages.el
(package! cdlatex)
#+end_src
It's also nice to be able to use ~cdlatex~.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

It's handy to be able to quickly insert environments with =C-c }=. I almost always
want to edit them afterwards though, so let's make that happen by default.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

At some point in the future it could be good to investigate [[https://scripter.co/splitting-an-org-block-into-two/][splitting org blocks]].
Likewise [[https://archive.casouri.cat/note/2020/insert-math-symbol-in-emacs/][this]] looks good for symbols.

****** View exported file
='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src
***** getting things done

   Getting things done package to make my life work.

  #+begin_src emacs-lisp :tangle no
(use-package! org-gtd
  :after org
  :config
  ;; where org-gtd will put its files. This value is also the default one.
  (setq org-gtd-directory "~/org/Daily/")
  ;; package: https://github.com/Malabarba/org-agenda-property
  ;; this is so you can see who an item was delegated to in the agenda
  (setq org-agenda-property-list '("DELEGATED_TO"))
  ;; I think this makes the agenda easier to read
  (setq org-agenda-property-position 'next-line)
  ;; package: https://www.nongnu.org/org-edna-el/
  ;; org-edna is used to make sure that when a project task gets DONE,
  ;; the next TODO is automatically changed to NEXT.
  (setq org-edna-use-inheritance t)
  (org-edna-load)
  :bind
  (("C-c d c" . org-gtd-capture) ;; add item to inbox
  ("C-c d a" . org-agenda-list) ;; see what's on your plate today
  ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
  ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
  ("C-c d s" . org-gtd-show-stuck-projects)) ;; see projects that don't have a NEXT item
  :init
  (bind-key "C-c c" 'org-gtd-clarify-finalize)) ;; the keybinding to hit when you're done editing an item in the processing phase
#+end_src
***** Org Capture
Let's setup some org-capture templates, and make them visually nice to access.


~doct~ (Declarative Org Capture Templates) seems to be a nicer way to
set up org-capture.
#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  :pin "9ed9b8c7f7e2ea2d2fb739d65ae4626a1cf16b9f")
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! doct
  :commands doct)
#+end_src

#+begin_src emacs-lisp :noweb no-export
(require 'org-protocol-capture-html)

(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (defvar +org-capture-recipies  "~/org/org-capture/recipies.org")
  (setq +org-capture-todo-file  "~/org/org-capture/todo.org")
  ;; (defvar +org-capture-notes-file  "~/org/org-capture/notes.org")
  ;; (defvar +org-capture-journal-file  "~/org/org-capture/journal.org")
  ;; (defvar +org-capture-projects-file  "~/org/org-capture/project.org")
  ;; (defvar +org-capture-changelog-file  "~/org/org-capture/changelog.org")

  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %?"
                              "%i %a"))
                  ("Personal note" :keys "N"
                   :icon ("sticky-note-o" :set "faicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* %?"
                              "%i %a"))

                  ("Web site" :keys "w"
                   :icon ("globe" :set "faicon" :color "blue")
                   :file "~/org/org-capture/webnotes.org"
                   :prepend t
                   :headline ""
                   :type entry
                   :template ("* %?\n%c\n%:initial"))

                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic}"
                              "%U %i %a"))

                  ("Appointment" :keys "a"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Appointment"
                   :type entry
                   :template ("* %? \n:PROPERTIES:\n:calendar-id: akhilpratapsingh3417@gmail.com\n:LOCATION:\n:END:\n\n:org-gcal:\n%^T\n:END:\nLink: %a"))

                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web")
                              ("Article" :keys "a"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:reaserch")
                              ("\tRecipie" :keys "r"
                               :icon ("spoon" :set "faicon" :color "dorange")
                               :file +org-capture-recipies
                               :headline "Unsorted"
                               :template "%(org-chef-get-recipe-from-url)")
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info")
                              ("Idea" :keys "I"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "idea")))

                  ("Tasks" :keys "k"
                   :icon ("inbox" :set "octicon" :color "yellow")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Tasks"
                   :type entry
                   :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                   :children (("General Task" :keys "k"
                               :icon ("inbox" :set "octicon" :color "yellow")
                               :extra "")
                              ("Task with deadline" :keys "d"
                               :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                               :extra "\nDEADLINE: %^{Deadline:}t")
                              ("Scheduled Task" :keys "s"
                               :icon ("calendar" :set "octicon" :color "orange")
                               :extra "\nSCHEDULED: %^{Start time:}t")))

                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file)))

                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file)))))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src

#+RESULTS:

It would also be nice to improve how the capture dialogue looks
#+name: prettify-capture
#+begin_src emacs-lisp :noweb-ref none
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"â€¦

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "â€º" 'face 'font-lock-comment-face) "  " desc "â€¦" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src

#+RESULTS: prettify-capture

The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but I'd be nicer with a smaller frame, and
no modeline.
#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "â– Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (set-window-parameter nil 'mode-line-format 'none) | (org-capture) |

***** Habit Tracking

https://orgmode.org/manual/Tracking-your-habits.html

#+begin_src emacs-lisp

(require 'org-habit)
(add-to-list 'org-modules 'org-habit)
(setq org-habit-graph-column 60)

#+end_src

#+RESULTS:
: 60
***** Super agenda

The agenda is nice, but a souped up version is nicer.
#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda :pin "fb5e2ef277bc811a3b061106c99e4c47b6b86f80")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :commands org-super-agenda-mode)

#+end_src

#+begin_src emacs-lisp :tangle no
(after! org
  (setq org-agenda-files '("~/org/org-agenda/daily"
                           "~/org/org-agenda/incubate.org"
                           "~/org/org-agenda/openquestions.org"
                           "~/org/org-agenda/todo.org/"
                           "~/org/org-agenda/agenda.org"
                           "~/org/org-capture/todo.org"
                           "~/org/org-roam2/daily/"
                           "~/org/org-roam2/todo.org/")))

(custom-set-variables
 '(org-agenda-files
   '("~/org/org-agenda/daily"
     "~/org/org-agenda/incubate.org"
     "~/org/org-agenda/openquestions.org"
     "~/org/org-agenda/todo.org/"
     "~/org/org-agenda/agenda.org"
     "~/org/org-capture/todo.org"
     "~/org/org-roam2/daily/"
     "~/org/org-roam2/todo.org/")))
 (setq org-default-notes-file "~/org/notes/notes.org")
#+end_src

#+RESULTS:
| ~/org/notes/ |


#+RESULTS:

#+begin_src emacs-lisp :tangle no

(setq org-super-agenda-groups
      '((:name "Next Items"
               :time-grid t
               :tag ("NEXT" "outbox"))
        (:name "Important"
               :priority "A")
        (:name "Quick Picks"
               :effort< "0:30")
        (:priority<= "B"
                     :scheduled future
                     :order 1)))
#+end_src

#+RESULTS:
| :name       | Next Items  | :time-grid | t      | :tag   | (NEXT outbox) |
| :name       | Important   | :priority  | A      |        |               |
| :name       | Quick Picks | :effort<   | 0:30   |        |               |
| :priority<= | B           | :scheduled | future | :order |             1 |


#+RESULTS:
: prot-org-custom-daily-agenda

#+begin_src emacs-lisp :tangle yes
;; (after! org-agenda
;; (org-super-agenda-mode)

(after! org-agenda
  (let ((inhibit-message t))
    (org-super-agenda-mode)))

;; (setq org-agenda-buffer-name "Agenda")
;; (setq org-agenda-scheduled-leaders '("SCH: " "Sched.%2dx: "))
;; (setq org-agenda-hide-tags-regexp "work\\|paperwork\\|GCAL\\|refile\\|research\\|planner\\|noexport\\|health\\|ideas\\|notes\\|home\\|school\\|personal\\|tasks\\|proposal\\|habit")
;; ;; (setq diary-file "~/org/org-roam2/daily/")
;; ;; (setq org-agenda-deadline-leaders '("DUE TODAY: " "In %3d d.: " "%2d d. ago: "))
;; ;;(setq org-agenda-skip-scheduled-if-deadline-is-shown t)
;; ;; (setq org-agenda-todo-list-sublevels t)
;; ;;(setq org-agenda-todo-ignore-deadlines 'future)
;; (setq org-deadline-warning-days 7)

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-start-with-log-mode t
      calendar-latitude 34.034520
      calendar-longitude -84.456010
      calendar-location-name "Marietta, GA"
      org-agenda-compact-blocks t
      org-agenda-include-diary t)
;; org-agenda-start-with-log-mode t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-agenda-start-day nil)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :todo ("FIXME" "CLAR")
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :todo "PROJ"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :tag ("FOUND")
                           :order 15)
                          (:name "To read"
                           :tag ("Read" "learn")
                           :todo "READ"
                           :order 30)
                          (:name "Waiting"
                           :todo ("WAIT" "HOLD" "LOOP")
                           :order 20)
                          (:name "In Review"
                           :todo ("REVIEW" "DUPLICATE")
                           :order 21)
                          (:name "In Planning"
                           :todo ("PLAN" "IDEA")
                           :order 22)
                          (:name "Project Backlog"
                           :todo "BACKLOG"
                           :order 23)
                          (:name "Ready For Work"
                           :todo "READY"
                           :order 24)
                          (:name "Active Projects"
                           :todo ("ACTIVE" "STRT")
                           :order 25)
                          (:name "Completed Projects"
                           :todo ("COMPLETED" "KILL" "BLOCKED")
                           :order 26)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Binge Watch"
                           :tag ("tvshow" "movie" "documentry")
                           :order 33)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))
        ("d" "Dashboard"
          ((agenda "" ((org-deadline-warning-days 7)))
           (todo "NEXT"
                 ((org-agenda-overriding-header "Next Tasks")))
           (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

         ("n" "Next Tasks"
          ((todo "NEXT"
                 ((org-agenda-overriding-header "Next Tasks")))))


         ("w" "Work Tasks" tags-todo "+work")

         ;; Low-effort next actions
         ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
          ((org-agenda-overriding-header "Low Effort Tasks")
           (org-agenda-max-todos 20)
           (org-agenda-files org-agenda-files)))

         ("W" "Workflow Status"
          ((todo "WAIT"
                 ((org-agenda-overriding-header "Waiting on External")
                  (org-agenda-files org-agenda-files)))
           (todo "REVIEW"
                 ((org-agenda-overriding-header "In Review")
                  (org-agenda-files org-agenda-files)))
           (todo "PLAN"
                 ((org-agenda-overriding-header "In Planning")
                  (org-agenda-todo-list-sublevels nil)
                  (org-agenda-files org-agenda-files)))
           (todo "BACKLOG"
                 ((org-agenda-overriding-header "Project Backlog")
                  (org-agenda-todo-list-sublevels nil)
                  (org-agenda-files org-agenda-files)))
           (todo "READY"
                 ((org-agenda-overriding-header "Ready for Work")
                  (org-agenda-files org-agenda-files)))
           (todo "ACTIVE"
                 ((org-agenda-overriding-header "Active Projects")
                  (org-agenda-files org-agenda-files)))
           (todo "COMPLETED"
                 ((org-agenda-overriding-header "Completed Projects")
                  (org-agenda-files org-agenda-files)))
           (todo "CANC"
                 ((org-agenda-overriding-header "Cancelled Projects")
                  (org-agenda-files org-agenda-files)))))))


(let ((map global-map))
  (define-key map (kbd "C-c a") #'org-agenda)
  (define-key map (kbd "C-c c") #'org-capture)
  (define-key map (kbd "C-c l") #'org-store-link)
  (define-key map (kbd "C-c L") #'org-insert-link-global)
  (define-key map (kbd "C-c O") #'org-open-at-point-global))
(let ((map org-mode-map))
  (define-key map (kbd "C-c M-l") #'org-insert-last-stored-link)
  (define-key map (kbd "C-c C-M-l") #'org-toggle-link-display))

(defun my-org-check-agenda ()
  "Peek at agenda."
  (interactive)
  (cond
   ((derived-mode-p 'org-agenda-mode)
    (if (window-parent) (delete-window) (bury-buffer)))
   ((get-buffer "*Org Agenda*")
    (switch-to-buffer-other-window "*Org Agenda*"))
   (t (org-agenda nil "a"))))

#+end_src

#+RESULTS:
: my-org-check-agenda


#+RESULTS:
| o | Overview | ((agenda  ((org-agenda-span 'day) (org-super-agenda-groups '((:name Today :time-grid t :date today :todo TODAY :scheduled today :order 1))))) (alltodo  ((org-agenda-overriding-header ) (org-super-agenda-groups '((:name Next to do :todo NEXT :order 1) (:name Important :tag Important :priority A :order 6) (:name Due Today :deadline today :order 2) (:name Due Soon :deadline future :order 8) (:name Overdue :deadline past :face error :order 7) (:name Assignments :tag Assignment :order 10) (:name Issues :tag Issue :order 12) (:name Emacs :tag Emacs :order 13) (:name Projects :tag Project :order 14) (:name Research :tag Research :order 15) (:name To read :tag Read :order 30) (:name Waiting :todo WAITING :order 20) (:name University :tag uni :order 32) (:name Trivial :priority<= E :tag (Trivial Unimportant) :todo (SOMEDAY) :order 90) (:discard (:tag (Chore Routine Daily)))))))) |
***** org capture academics

Set some capture templates, to work with GTD.
#+begin_src emacs-lisp :tangle no
(after! org
(setq org-capture-templates `(("i" "Inbox"
                                 entry (file "~/Dropbox/Org/references/notes/inbox.org")
                                 "* %?\n%U\n\n  %i"
                                 :kill-buffer t)
                                ("l" "Todo with link"
                                 entry (file "~/Dropbox/Org/references/notes/inbox.org")
                                 "* %?\n%U\n\n  %i\n  %a"
                                 :kill-buffer t)
                                ("m" "Meeting"
                                 entry (file+headline "/Dropbox/Org/references/notes/agenda.org" "Future")
                                ,(concat "* TODO %? :meeting:\n" "<%<%Y-%m-%d %a %H:00>>"))
                                ("o" "Open Question Thesis"
                                 entry (file+headline "~/Dropbox/Org/references/notes/openquestions.org" "Questions")
                                 "* OPEN %? \n %U\n")))
(set-face-attribute 'org-headline-done nil :strike-through t)
)
#+end_src
***** Roam
****** Basic settings

| COMMAND                         | DESCRIPTION                     | KEYBINDING  |
|---------------------------------+---------------------------------+-------------|
| org-roam-find-file              | org roam find file              | SPC n r f   |
| org-roam-insert                 | org roam insert                 | SPC n r i   |
| org-roam-dailies-find-date      | org roam dailies find date      | SPC n r d d |
| org-roam-dailies-find-today     | org roam dailies find today     | SPC n r d t |
| org-roam-dailies-find-tomorrow  | org roam dailies find tomorrow  | SPC n r d m |
| org-roam-dailies-find-yesterday | org roam dailies find yesterday | SPC n r d y |

I'll just set this to be within =Organisation= folder for now, in the future it
could be worth seeing if I could hook this up to a [[https://nextcloud.com/][Nextcloud]] instance.
#+begin_src emacs-lisp :tangle yes
;;(after! org-roam
(setq
      org-roam-directory "~/org/org-roam2/"
      org-roam-db-location (concat org-roam-directory "org-roam.db")
      org-roam-todo-file (concat org-roam-directory "todo/todo.org"))
(save-window-excursion
  (find-file org-roam-todo-file)
  (save-buffer))
#+end_src

#+RESULTS:

That said, if the directory doesn't exist we likely don't want to be using roam.
Since we don't want to trigger errors (which will happen as soon as roam tries
to initialise), let's not load roam.
#+begin_src emacs-lisp :tangle (if (file-exists-p "~/org/org-roam2/") "no" "packages.el")
(package! org-roam :disable t)
#+end_src
****** v2 baby
#+begin_src emacs-lisp :tangle no
(setq org-roam-v2-ack t)

(use-package! org-roam
  :after org
  :config
  (setq org-roam-v2-ack t)
  (setq org-roam-mode-sections
        (list #'org-roam-backlinks-insert-section
              #'org-roam-reflinks-insert-section
              #'org-roam-unlinked-references-insert-section))
  (org-roam-setup))
 #+end_src

 #+RESULTS:
 : t

****** Hotter Buffer
#+begin_src emacs-lisp :tangle no
(defun org-roam-buffer-setup ()
  "Function to make org-roam-buffer more pretty."
  (progn
    (setq-local olivetti-body-width 44)
    (variable-pitch-mode 1)
    (olivetti-mode 1)
    ;; (centaur-tabs-local-mode -1)

  (set-face-background 'magit-section-highlight (face-background 'default))))

(after! org-roam
(add-hook! 'org-roam-mode-hook #'org-roam-buffer-setup))
#+end_src

#+RESULTS:

****** Modeline file name
All those numbers! It's messy. Let's adjust this in a similar way that I have in
the [[*Window title][Window title]].
#+begin_src emacs-lisp
(defadvice! doom-modeline--buffer-file-name-roam-aware-a (orig-fun)
  :around #'doom-modeline-buffer-file-name ; takes no args
  (if (s-contains-p org-roam-directory (or buffer-file-name ""))
      (replace-regexp-in-string
       "\\(?:^\\|.*/\\)\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)[0-9]*-"
       "ðŸ¢”(\\1-\\2-\\3) "
       (subst-char-in-string ?_ ?  buffer-file-name))
    (funcall orig-fun)))
#+end_src

****** Graph view

Org-roam is nice by itself, but there are so /extra/ nice packages which integrate
with it.
#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui :recipe (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")) :pin "309fe3c58c7081de4e2c9c64f7b40ea291926048")
(package! websocket :pin "fda4455333309545c0787a79d73c19ddbeb57980") ; dependency of `org-roam-ui'
#+end_src

#+begin_src emacs-lisp :tangle yes

(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :commands org-roam-ui-open
  :hook (org-roam . org-roam-ui-mode)
  :config
  (require 'org-roam) ; in case autoloaded
  (setq org-roam-ui-browser-function #'xwidget-webkit-browse-url)
  (defun org-roam-ui-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (unless org-roam-ui-mode (org-roam-ui-mode 1))
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-ui-port))))
#+end_src

#+RESULTS:
| org-roam-ui-mode |

****** Org-roam-capture templates

#+begin_src emacs-lisp :tangle yes

(after! org-roam
  (setq org-roam-capture-templates
        `(("s" "standard" plain "%?"
           :if-new
           (file+head "standard/%<%Y%m%d%H%M%S>--${slug}.org"
                      "#+title: ${title}\n#+date\n#+filetags: \n\n ")
           :unnarrowed t)

          ("d" "definition" plain
           "%?"
           :if-new
           (file+head "definition/${slug}.org" "#+title: ${title}\n#+filetags: definition \n\n* Definition\n\n\n* Examples\n")
           :unnarrowed t)
          ("r" "ref" plain "%?"
           :if-new
           (file+head "ref/${citekey}.org"
                      "#+title: ${slug}: ${title}\n
                      \n#+date : %<%Y%m%d%H%M%S>
                      \n#+filetags: reference ${keywords} \n
                      \n* ${title}\n\n
                      \n* Summary
                      \n\n\n* Rough note space\n")
           :unnarrowed t)
          ("P" "person" plain "%?"
           :if-new
           (file+head "${slug}.org" "%^{relation|some guy|family|friend|colleague}p %^{birthday}p %^{address}p
,#+title:${slug}\n#+filetags: :person: \n")
           :unnarrowed t)
          ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
           :if-new (file+head "Projects/%<%Y%m%d%H%M%S>--${slug}.org" "#+title: ${title}\n#+filetags: Project")
           :unnarrowed t)
          ("b" "book notes" plain
           "\n* Source\n\nAuthor: %^{Author}\nTitle: ${title}\nYear: %^{Year}\n\n* Summary\n\n%?"
           :if-new (file+head "BookNotes/%<%Y%m%d%H%M%S>--${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)
          ;; templates can be used as well, which is pretty cool
          ;; ("b" "book notes" plain (file "~/org/org-roam2/Templates/BookNotesTemplate.org")
          ;;  :if-new (file+head "BookNotes/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
          ;;  :unnarrowed t)
          ("l" "programming language" plain
           "* Characteristics\n\n- Family: %?\n- Inspired by: \n\n* Reference:\n\n"
           :if-new (file+head "ProgLangs/%<%Y%m%d%H%M%S>--${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)

          ("n" "notes" plain "%?"
           :if-new
           (file+head "Notes/%<%Y%m%d%H%M%S>--${title}.org" "#+title: ${title}\n#+STARTUP: content\n#+date : %<%Y-%m-%d>\n#+filetags: :%^{tags|article:note|learn|info|posix|web|intresting|emacs|gnu_linux|health|food|shopping|pentesting|tv_shows|elfeed|void_linux|internet} ")
           :immediate-finish t
           :unnarrowed t)

          ("a" "article" plain "%?"
           :if-new
           (file+head "Articles/%<%Y%m%d%H%M%S>--${title}.org" "#+title: ${title}\n#+STARTUP: content\n#+date : %<%Y-%m-%d>\n#+filetags: :%^{tags|article:read|learn|info|posix|web|intresting|emacs|gnu_linux|health|food|shopping|pentesting|tv_shows|elfeed|void_linux|internet} ")

           ;; (file+head "Articles/%<%Y%m%d%H%M%S>-${title}.org" "#+title: ${title}\n#+date : %<%Y%m%d%H%M%S>\n#+filetags: :article:%^{tags|read|learn|info}
            ;; \n\n%i %a")
           :immediate-finish t
           :unnarrowed t))))
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry "* %<%I:%M %p>: %?"
         :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))

;; ;; Creating the property â€œtypeâ€ on my nodes.
(cl-defmethod org-roam-node-type ((node org-roam-node))
  "Return the TYPE of NODE."
  (condition-case nil
      (file-name-nondirectory
       (directory-file-name
        (file-name-directory
         (file-relative-name (org-roam-node-file node) org-roam-directory))))
    (error "")))

;; Modifying the display template to show the node â€œtypeâ€

;; (setq org-roam-node-display-template
;;        (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
;; #("${doom-type:15} ${doom-hierarchy:*}  ${doom-tags:42}" 20 35
;;   (face font-lock-keyword-face)
;;   36 51
;;   (face org-tag)))

(defun my/org-roam--backlinks-list (file)
  (if (org-roam--org-roam-file-p file)
      (--reduce-from
       (concat acc (format "- [[file:%s][%s]]\n"
                           (file-relative-name (car it) org-roam-directory)
                           (org-roam--get-title-or-slug (car it))))
       "" (org-roam-sql [:select [from]
                         :from links
                         :where (= to $s1)
                         :and from :not :like $s2] file "%private%"))
    ""))

(defun my/org-export-preprocessor (_backend)
  (let ((links (my/org-roam--backlinks-list (buffer-file-name))))
    (unless (string= links "")
      (save-excursion
        (goto-char (point-max))
        (insert (concat "\n* Backlinks\n" links))))))
#+end_src

#+RESULTS:
: my/org-export-preprocessor

****** Citations
#+begin_src emacs-lisp :tangle no

(use-package! org-ref
    ;:after org-roam
    :config
    (setq
         org-ref-completion-library 'org-ref-ivy-cite
         org-ref-get-pdf-filename-function 'org-ref-get-pdf-filename-helm-bibtex
         bibtex-completion-bibliography (list "~/org/references/library.bib")
         bibtex-completion-notes "~/org/references/notes/bibnotes.org"
         org-ref-note-title-format "* %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :NOTER_DOCUMENT: %F\n :ROAM_KEY: cite:%k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n\n"
         org-ref-notes-directory "~/org/references/notes/"
         org-ref-notes-function 'orb-edit-notes
    ))

(after! org-ref
(setq
 bibtex-completion-notes-path "~/org/references/notes/"
 bibtex-completion-bibliography "~/org/references/library.bib"
 bibtex-completion-pdf-field "file"
 bibtex-completion-notes-template-multiple-files
 (concat
  "#+TITLE: ${title}\n"
  "#+ROAM_KEY: cite:${=key=}\n"
  "* TODO Notes\n"
  ":PROPERTIES:\n"
  ":Custom_ID: ${=key=}\n"
  ":NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n"
  ":AUTHOR: ${author-abbrev}\n"
  ":JOURNAL: ${journaltitle}\n"
  ":DATE: ${date}\n"
  ":YEAR: ${year}\n"
  ":DOI: ${doi}\n"
  ":URL: ${url}\n"
  ":END:\n\n"
  )
 )
)

#+end_src

#+RESULTS:

#+begin_example
,#+TITLE: ${title}
,#+ROAM_KEY: cite:${=key=}
,* TODO Notes
:PROPERTIES:
:Custom_ID: ${=key=}
:NOTER_DOCUMENT: %(orb-process-file-field "${=key=}")
:AUTHOR: ${author-abbrev}
:JOURNAL: ${journaltitle}
:DATE: ${date}
:YEAR: ${year}
:DOI: ${doi}
:URL: ${url}
:END:

#+end_example
****** org roam agenda
#+begin_src emacs-lisp

;; The buffer you put this code in must have lexical-binding set to t!
;; See the final configuration at the end for more details.

(defun my/org-roam-filter-by-tag (tag-name)
  (lambda (node)
    (member tag-name (org-roam-node-tags node))))

(defun my/org-roam-list-notes-by-tag (tag-name)
  (mapcar #'org-roam-node-file
          (seq-filter
           (my/org-roam-filter-by-tag tag-name)
           (org-roam-node-list))))

(defun my/org-roam-refresh-agenda-list ()
  (interactive)
  (setq org-agenda-files (my/org-roam-list-notes-by-tag "Project")))

;; Build the agenda list the first time for the session
(my/org-roam-refresh-agenda-list)
#+end_src

#+RESULTS:
***** Nicer generated heading IDs
Thanks to alphapapa's [[https://github.com/alphapapa/unpackaged.el#export-to-html-with-useful-anchors][unpackaged.el]].

By default, Org generated heading IDs like =#org80fc2a5= which ... works, but has
two issues
+ It's completely uninformative, I have no idea what's being referenced
+ If I export the same file, everything will change.
  Now, while without hardcoded values it's impossible to set references in
  stone, it would be nice for there to be a decent chance of staying the same.

Both of these issues can be addressed by generating IDs like
=#language-configuration=, which is what I'll do here.

It's worth noting that alphapapa's use of ~url-hexify-string~ seemed to cause me
some issues. Replacing that in ~a53899~ resolved this for me. To go one step
further, I create a function for producing nice short links, like an inferior
version of ~reftex-label~.

#+begin_src emacs-lisp
(defvar org-reference-contraction-max-words 3
  "Maximum number of words in a reference reference.")
(defvar org-reference-contraction-max-length 35
  "Maximum length of resulting reference reference, including joining characters.")
(defvar org-reference-contraction-stripped-words
  '("the" "on" "in" "off" "a" "for" "by" "of" "and" "is" "to")
  "Superfluous words to be removed from a reference.")
(defvar org-reference-contraction-joining-char "-"
  "Character used to join words in the reference reference.")

(defun org-reference-contraction-truncate-words (words)
  "Using `org-reference-contraction-max-length' as the total character 'budget' for the WORDS
and truncate individual words to conform to this budget.

To arrive at a budget that accounts for words undershooting their requisite average length,
the number of characters in the budget freed by short words is distributed among the words
exceeding the average length.  This adjusts the per-word budget to be the maximum feasable for
this particular situation, rather than the universal maximum average.

This budget-adjusted per-word maximum length is given by the mathematical expression below:

max length = \\floor{ \\frac{total length - chars for seperators - \\sum_{word \\leq average length} length(word) }{num(words) > average length} }"
  ;; trucate each word to a max word length determined by
  ;;
  (let* ((total-length-budget (- org-reference-contraction-max-length  ; how many non-separator chars we can use
                                 (1- (length words))))
         (word-length-budget (/ total-length-budget                      ; max length of each word to keep within budget
                                org-reference-contraction-max-words))
         (num-overlong (-count (lambda (word)                            ; how many words exceed that budget
                                 (> (length word) word-length-budget))
                               words))
         (total-short-length (-sum (mapcar (lambda (word)                ; total length of words under that budget
                                             (if (<= (length word) word-length-budget)
                                                 (length word) 0))
                                           words)))
         (max-length (/ (- total-length-budget total-short-length)       ; max(max-length) that we can have to fit within the budget
                        num-overlong)))
    (mapcar (lambda (word)
              (if (<= (length word) max-length)
                  word
                (substring word 0 max-length)))
            words)))

(defun org-reference-contraction (reference-string)
  "Give a contracted form of REFERENCE-STRING that is only contains alphanumeric characters.
Strips 'joining' words present in `org-reference-contraction-stripped-words',
and then limits the result to the first `org-reference-contraction-max-words' words.
If the total length is > `org-reference-contraction-max-length' then individual words are
truncated to fit within the limit using `org-reference-contraction-truncate-words'."
  (let ((reference-words
         (-filter (lambda (word)
                    (not (member word org-reference-contraction-stripped-words)))
                  (split-string
                   (->> reference-string
                        downcase
                        (replace-regexp-in-string "\\[\\[[^]]+\\]\\[\\([^]]+\\)\\]\\]" "\\1") ; get description from org-link
                        (replace-regexp-in-string "[-/ ]+" " ") ; replace seperator-type chars with space
                        puny-encode-string
                        (replace-regexp-in-string "^xn--\\(.*?\\) ?-?\\([a-z0-9]+\\)$" "\\2 \\1") ; rearrange punycode
                        (replace-regexp-in-string "[^A-Za-z0-9 ]" "") ; strip chars which need %-encoding in a uri
                        ) " +"))))
    (when (> (length reference-words)
             org-reference-contraction-max-words)
      (setq reference-words
            (cl-subseq reference-words 0 org-reference-contraction-max-words)))

    (when (> (apply #'+ (1- (length reference-words))
                    (mapcar #'length reference-words))
             org-reference-contraction-max-length)
      (setq reference-words (org-reference-contraction-truncate-words reference-words)))

    (string-join reference-words org-reference-contraction-joining-char)))
#+end_src

Now here's alphapapa's subtly tweaked mode.
#+begin_src emacs-lisp
(define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
  "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
  :global t
  (if unpackaged/org-export-html-with-useful-ids-mode
      (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
    (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))
(unpackaged/org-export-html-with-useful-ids-mode 1) ; ensure enabled, and advice run

(defun unpackaged/org-export-get-reference (datum info)
  "Like `org-export-get-reference', except uses heading titles instead of random numbers."
  (let ((cache (plist-get info :internal-references)))
    (or (car (rassq datum cache))
        (let* ((crossrefs (plist-get info :crossrefs))
               (cells (org-export-search-cells datum))
               ;; Preserve any pre-existing association between
               ;; a search cell and a reference, i.e., when some
               ;; previously published document referenced a location
               ;; within current file (see
               ;; `org-publish-resolve-external-link').
               ;;
               ;; However, there is no guarantee that search cells are
               ;; unique, e.g., there might be duplicate custom ID or
               ;; two headings with the same title in the file.
               ;;
               ;; As a consequence, before re-using any reference to
               ;; an element or object, we check that it doesn't refer
               ;; to a previous element or object.
               (new (or (cl-some
                         (lambda (cell)
                           (let ((stored (cdr (assoc cell crossrefs))))
                             (when stored
                               (let ((old (org-export-format-reference stored)))
                                 (and (not (assoc old cache)) stored)))))
                         cells)
                        (when (org-element-property :raw-value datum)
                          ;; Heading with a title
                          (unpackaged/org-export-new-named-reference datum cache))
                        (when (member (car datum) '(src-block table example fixed-width property-drawer))
                          ;; Nameable elements
                          (unpackaged/org-export-new-named-reference datum cache))
                        ;; NOTE: This probably breaks some Org Export
                        ;; feature, but if it does what I need, fine.
                        (org-export-format-reference
                         (org-export-new-reference cache))))
               (reference-string new))
          ;; Cache contains both data already associated to
          ;; a reference and in-use internal references, so as to make
          ;; unique references.
          (dolist (cell cells) (push (cons cell new) cache))
          ;; Retain a direct association between reference string and
          ;; DATUM since (1) not every object or element can be given
          ;; a search cell (2) it permits quick lookup.
          (push (cons reference-string datum) cache)
          (plist-put info :internal-references cache)
          reference-string))))

(defun unpackaged/org-export-new-named-reference (datum cache)
  "Return new reference for DATUM that is unique in CACHE."
  (cl-macrolet ((inc-suffixf (place)
                             `(progn
                                (string-match (rx bos
                                                  (minimal-match (group (1+ anything)))
                                                  (optional "--" (group (1+ digit)))
                                                  eos)
                                              ,place)
                                ;; HACK: `s1' instead of a gensym.
                                (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                           (match-string 2 ,place)))
                                        (suffix (if suffix
                                                    (string-to-number suffix)
                                                  0)))
                                  (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
    (let* ((headline-p (eq (car datum) 'headline))
           (title (if headline-p
                      (org-element-property :raw-value datum)
                    (or (org-element-property :name datum)
                        (concat (org-element-property :raw-value
                                                      (org-element-property :parent
                                                                            (org-element-property :parent datum)))))))
           ;; get ascii-only form of title without needing percent-encoding
           (ref (concat (org-reference-contraction (substring-no-properties title))
                        (unless (or headline-p (org-element-property :name datum))
                          (concat ","
                                  (pcase (car datum)
                                    ('src-block "code")
                                    ('example "example")
                                    ('fixed-width "mono")
                                    ('property-drawer "properties")
                                    (_ (symbol-name (car datum))))
                                  "--1"))))
           (parent (when headline-p (org-element-property :parent datum))))
      (while (--any (equal ref (car it))
                    cache)
        ;; Title not unique: make it so.
        (if parent
            ;; Append ancestor title.
            (setf title (concat (org-element-property :raw-value parent)
                                "--" title)
                  ;; get ascii-only form of title without needing percent-encoding
                  ref (org-reference-contraction (substring-no-properties title))
                  parent (when headline-p (org-element-property :parent parent)))
          ;; No more ancestors: add and increment a number.
          (inc-suffixf ref)))
      ref)))

(add-hook 'org-load-hook #'unpackaged/org-export-html-with-useful-ids-mode)
#+end_src
We also need to redefine src_elisp{(org-export-format-reference)} as it now may
be passed a string as well as a number.
#+begin_src emacs-lisp
(defadvice! org-export-format-reference-a (reference)
  "Format REFERENCE into a string.

REFERENCE is a either a number or a string representing a reference,
as returned by `org-export-new-reference'."
  :override #'org-export-format-reference
  (if (stringp reference) reference (format "org%07x" reference)))
#+end_src
***** Nicer ~org-return~
Once again, from [[https://github.com/alphapapa/unpackaged.el#org-return-dwim][unpackaged.el]]
#+begin_src emacs-lisp
(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  ;; MAYBE: Use `org-element-lineage'.
  (when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
        (unpackaged/org-element-descendant-of type parent))))

;;;###autoload
(defun unpackaged/org-return-dwim (&optional default)
  "A helpful replacement for `org-return-indent'.  With prefix, call `org-return-indent'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return t)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ;; ((eq 'link (car (org-element-context)))
     ;;  ;; Link: Open it.
     ;;  (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
        (goto-char (org-entry-end-position))
        (cond ((and (org-at-heading-p)
                    (= heading-start (org-entry-beginning-position)))
               ;; Entry ends on its heading; add newline after
               (end-of-line)
               (insert "\n\n"))
              (t
               ;; Entry ends after its heading; back up
               (forward-line -1)
               (end-of-line)
               (when (org-at-heading-p)
                 ;; At the same heading
                 (forward-line)
                 (insert "\n")
                 (forward-line -1))
               (while (not (looking-back "\\(?:[[:blank:]]?\n\\)\\{3\\}" nil))
                 (insert "\n"))
               (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
        (if (or (eq 'plain-list (car context))  ; First item in list
                (and (eq 'item (car context))
                     (not (eq (org-element-property :contents-begin context)
                              (org-element-property :contents-end context))))
                (unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
            ;; Non-empty item: Add new item.
            (org-insert-item)
          ;; Empty item: Close the list.
          ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
          (delete-region (line-beginning-position) (line-end-position))
          (insert "\n"))))

     ((when (fboundp 'org-inlinetask-in-task-p)
        (org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return t))

     ((org-at-table-p)
      (cond ((save-excursion
               (beginning-of-line)
               ;; See `org-table-next-field'.
               (cl-loop with end = (line-end-position)
                        for cell = (org-element-table-cell-parser)
                        always (equal (org-element-property :contents-begin cell)
                                      (org-element-property :contents-end cell))
                        while (re-search-forward "|" end t)))
             ;; Empty row: end the table.
             (delete-region (line-beginning-position) (line-end-position))
             (org-return t))
            (t
             ;; Non-empty row: call `org-return-indent'.
             (org-return t))))
     (t
      ;; All other cases: call `org-return-indent'.
      (org-return t)))))

(map!
 :after evil-org
 :map evil-org-mode-map
 :i [return] #'unpackaged/org-return-dwim)
#+end_src
***** Snippet Helpers
****** Structure Templates

#+begin_src emacs-lisp :tangle no

  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src
I often want to set =src-block= headers, and it's a pain to
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

#+RESULTS:
: +yas/org-src-header-p

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read values :prompt question :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

#+RESULTS:
: +yas/org-most-common-no-property-lang

***** Translate capital keywords (old) to lower case (new)
Everyone used to use ~#+CAPITAL~ keywords. Then people realised that ~#+lowercase~
is actually both marginally easier and visually nicer, so now the capital
version is just used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

To avoid sometimes having to choose between the hassle out of updating old
documents and using mixed syntax, I'll whip up a basic transcode-y function.
It likely misses some edge cases, but should mostly work.

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src

#+RESULTS:
: org-syntax-convert-keyword-case-to-lower

***** Extra links
****** xkcd
Because xkcd is cool, let's make it as easy and fun as possible to insert them.
Saving seconds adds up after all! (but only so much)

[[xkcd:1205]]

#+begin_src emacs-lisp
(org-link-set-parameters "xkcd"
                         :image-data-fun #'+org-xkcd-image-fn
                         :follow #'+org-xkcd-open-fn
                         :export #'+org-xkcd-export
                         :complete #'+org-xkcd-complete)

(defun +org-xkcd-open-fn (link)
  (+org-xkcd-image-fn nil link nil))

(defun +org-xkcd-image-fn (protocol link description)
  "Get image data for xkcd num LINK"
  (let* ((xkcd-info (+xkcd-fetch-info (string-to-number link)))
         (img (plist-get xkcd-info :img))
         (alt (plist-get xkcd-info :alt)))
    (message alt)
    (+org-image-file-data-fn protocol (xkcd-download img (string-to-number link)) description)))

(defun +org-xkcd-export (num desc backend _com)
  "Convert xkcd to html/LaTeX form"
  (let* ((xkcd-info (+xkcd-fetch-info (string-to-number num)))
         (img (plist-get xkcd-info :img))
         (alt (plist-get xkcd-info :alt))
         (title (plist-get xkcd-info :title))
         (file (xkcd-download img (string-to-number num))))
    (cond ((org-export-derived-backend-p backend 'html)
           (format "<img class='invertible' src='%s' title=\"%s\" alt='%s'>" img (subst-char-in-string ?\" ?â€œ alt) title))
          ((org-export-derived-backend-p backend 'latex)
           (format "\\begin{figure}[!htb]
  \\centering
  \\includegraphics[scale=0.4]{%s}%s
\\end{figure}" file (if (equal desc (format "xkcd:%s" num)) ""
                      (format "\n  \\caption*{\\label{xkcd:%s} %s}"
                              num
                              (or desc
                                  (format "\\textbf{%s} %s" title alt))))))
          (t (format "https://xkcd.com/%s" num)))))

(defun +org-xkcd-complete (&optional arg)
  "Complete xkcd using `+xkcd-stored-info'"
  (format "xkcd:%d" (+xkcd-select)))
#+end_src

#+RESULTS:
: +org-xkcd-complete

****** YouTube
The ~[[yt:...]]~ links preview nicely, but don't export nicely. Thankfully, we can
fix that.
#+begin_src emacs-lisp
(org-link-set-parameters "yt" :export #'+org-export-yt)
(defun +org-export-yt (path desc backend _com)
  (cond ((org-export-derived-backend-p backend 'html)
         (format "<iframe width='440' \
height='335' \
src='https://www.youtube.com/embed/%s' \
frameborder='0' \
allowfullscreen>%s</iframe>" path (or "" desc)))
        ((org-export-derived-backend-p backend 'latex)
         (format "\\href{https://youtu.be/%s}{%s}" path (or desc "youtube")))
        (t (format "https://youtu.be/%s" path))))
#+end_src

#+RESULTS:
: +org-export-yt

***** Fix problematic hooks
When one of the src_elisp{org-mode-hook} functions errors, it halts the hook
execution. This is problematic, and there are two hooks in particular which
cause issues. Let's make their failure less eventful.

#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  (ignore-errors (apply orig-fn args)))
#+end_src

#+RESULTS:

***** Flycheck with org-lint


Org may be simple, but that doesn't mean there's no such thing as malformed Org.
Thankfully, malformed Org is a much less annoying affair than malformed zipped
XML (looks at DOCX/ODT...), particularly because there's a rather helpful little
tool called ~org-lint~ bundled with Org that can tell you about your mistakes.


Flycheck doesn't currently support Org, and there's aren't any packages to do so
â˜¹. However, in an issue on ~org-lint~ there is [[https://github.com/flycheck/flycheck/issues/1757#issuecomment-759546940][some code]] which apparently works.
Surely this is what the clipboard was invented for? With that said, let's
regurgitate the code, cross our fingers, and hope it works.

#+begin_src emacs-lisp :tangle no
(defconst flycheck-org-lint-form
  (flycheck-prepare-emacs-lisp-form
    (require 'org)
    (require 'org-attach)
    (let ((source (car command-line-args-left))
          (process-default-directory default-directory))
      (with-temp-buffer
        (insert-file-contents source 'visit)
        (setq buffer-file-name source)
        (setq default-directory process-default-directory)
        (delay-mode-hooks (org-mode))
        (setq delayed-mode-hooks nil)
        (dolist (err (org-lint))
          (let ((inf (cl-second err)))
            (princ (elt inf 0))
            (princ ": ")
            (princ (elt inf 2))
            (terpri)))))))

(defconst flycheck-org-lint-variables
  '(org-directory
    org-id-locations
    org-id-locations-file
    org-attach-id-dir
    org-attach-use-inheritance
    org-attach-id-to-path-function-list
    org-link-parameters)
  "Variables inherited by the org-lint subprocess.")

(defun flycheck-org-lint-variables-form ()
  (require 'org-attach)  ; Needed to make variables available
  `(progn
     ,@(seq-map (lambda (opt) `(setq-default ,opt ',(symbol-value opt)))
                (seq-filter #'boundp flycheck-org-lint-variables))))

(eval ; To preveant eager macro expansion form loading flycheck early.
 '(flycheck-define-checker org-lint
   "Org buffer checker using `org-lint'."
   :command ("emacs" (eval flycheck-emacs-args)
             "--eval" (eval (concat "(add-to-list 'load-path \""
                                    (file-name-directory (locate-library "org"))
                                    "\")"))
             "--eval" (eval (flycheck-sexp-to-string
                             (flycheck-org-lint-variables-form)))
             "--eval" (eval (flycheck-sexp-to-string
                             (flycheck-org-lint-customisations-form)))
             "--eval" (eval flycheck-org-lint-form)
             "--" source)
   :error-patterns
   ((error line-start line ": " (message) line-end))
   :modes org-mode))
#+end_src

#+RESULTS:

Turns out it almost works. Running =M-x flycheck-verify-setup= after running that
snippet produces the following:
#+begin_example
The following syntax checkers are not registered:
  - org-lint
Try adding these syntax checkers to `flycheck-checkers'.
#+end_example

Well that's very nice and helpful. We'll just do that ðŸ™‚.
#+begin_src emacs-lisp :tangle no
(add-to-list 'flycheck-checkers 'org-lint)
#+end_src

It was missing custom link types, but that's easily fixed just by adding
~org-link-parameters~ to ~flycheck-org-lint-variables~.

One remaining little annoyance is that it reports extra =#+options= that I've
added to Org as errors. So we need to tell ~org-lint~ about them without having it
load my whole config. Code duplication isn't great, but at least this isn't
much.

#+name: org-syntax-modifications
#+begin_src emacs-lisp :tangle no
(defun flycheck-org-lint-customisations-form ()
  `(progn
     (require 'ox)
     (cl-pushnew '(:latex-cover-page nil "coverpage" nil)
                 (org-export-backend-options (org-export-get-backend 'latex)))
     (cl-pushnew '(:latex-font-set nil "fontset" nil)
                 (org-export-backend-options (org-export-get-backend 'latex)))))
#+end_src
***** org refile
#+begin_src emacs-lisp
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))
(setq org-refile-use-outline-path 'file)
(setq org-refile-active-region-within-subtree t)
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-allow-creating-parent-nodes (quote confirm))

#+end_src

**** DONE Visuals
CLOSED: [2022-04-01 Fri 18:12]

Here I try to do two things: improve the styling of the various documents, via
font changes etc, and also propagate colours from the current theme.

***** Font Display
Mixed pitch is great. As is ~+org-pretty-mode~, let's use them.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src

#+begin_src emacs-lisp :tangle no
(after! org
(custom-set-faces!
  '((org-block) :background nil)
  )
  (defface redd
    '((((class color) (min-colors 88) (background light))
      :foreground "red"))
    "Red."
    :group 'basic-faces)
  (custom-set-faces!
    ;'(org-document-title :height 1.6 :weight bold)
    '(org-level-1 :height 1.3 :weight extrabold :slant normal)
    '(org-level-2 :height 1.2 :weight bold :slant normal)
    '(org-level-3 :height 1.1 :weight regular :slant normal)
    ;'(org-document-info  :inherit 'nano-face-faded)
    '(org-document-title   ;:foreground ,(doom-color 'black)
                           :family "Roboto"
                           :height 250
                           :weight medium)))
#+end_src

#+RESULTS:
| doom--customize-themes-h-9 | doom--customize-themes-h-16 | doom--customize-themes-h-17 |

You can set the Org heading levels to be different font sizes.  So I choose to have level 1 headings to be 140% in height, level 2 to be 130%, etc.  Other interesting things you could play with include adding :foreground color and/or :background color if you want to override the theme colors.
Let's make headings a bit bigger

#+begin_src emacs-lisp :tangle yes
;; (after! org
  (custom-set-faces!
    '(org-level-1 :inherit outline-1 :weight extra-bold :height 1.35)
    '(org-level-2 :inherit outline-2 :weight bold :height 1.25)
    '(org-level-3 :inherit outline-3 :weight bold :height 1.22)
    '(org-level-4 :inherit outline-4 :weight bold :height 1.19)
    '(org-level-5 :inherit outline-5 :weight semi-bold :height 1.16)
    '(org-level-6 :inherit outline-6 :weight semi-bold :height 1.13)
    '(org-level-7 :inherit outline-7 :weight semi-bold)
    '(org-level-8 :inherit outline-8 :weight semi-bold)
    ;; Ensure that anything that should be fixed-pitch in org buffers appears that
    ;; way
    '(org-block nil :foreground nil :inherit 'fixed-pitch)
    '(org-code nil   :inherit '(shadow fixed-pitch))
    '(org-table nil   :inherit '(shadow fixed-pitch))
    '(org-verbatim nil :inherit '(shadow fixed-pitch))
    '(org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    '(org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    '(org-checkbox nil :inherit 'fixed-pitch))
#+end_src

#+RESULTS:
| doom--customize-themes-h-9 | doom--customize-themes-h-10 | doom--customize-themes-h-35 |


And the same with the title.
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

#+RESULTS:
| doom--customize-themes-h-13 | doom--customize-themes-h-14 | doom--customize-themes-h-33 | doom--customize-themes-h-34 | doom--customize-themes-h-35 | doom--customize-themes-h-36 |

It seems reasonable to have deadlines in the error face when they're passed.
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

We can then have quote blocks stand out a bit more by making them /italic/.
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

Org files can be rather nice to look at, particularly with some of the
customisations here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.
#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  ;; (when (> (buffer-size) 50000)
  (when (> (buffer-size) 5000);;as my laptop barely runs without graphics card
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src

#+RESULTS:
| (closure ((hook . org-mode-hook) (--dolist-tail--) t) (&rest _) (add-hook 'before-save-hook 'org-encrypt-entries nil t)) | mixed-pitch-mode | elpher-org-mode-integration | locally-defer-font-lock | +org-pretty-mode | turn-on-flyspell | org-appear-mode | flymake-proselint-setup | auto-revert-mode | beginend-org-mode | er/add-org-mode-expansions | +lookup--init-org-mode-handlers-h | (closure ((hook . org-mode-hook) (--dolist-tail--) t) (&rest _) (add-hook 'before-save-hook 'org-encrypt-entries nil t)) | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-make-last-point-visible-h | org-fancy-priorities-mode | org-superstar-mode | evil-org-mode | toc-org-enable | embrace-org-mode-hook | org-eldoc-load | +literate-enable-recompile-h |

Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do I'll use the above.
***** Reduced text indent

Thanks to the various bits and bobs of setup we have here, the non-heading lines
tend to appear over-indented in ~org-indent-mode~. We can adjust this by modifying
the generated text prefixes.

There's another issue we can have when using mixed-pitch mode, where the line
height is set by the indent prefix displayed with the fixed-pitch font. This
means that on 0-indent lines the line spacing can be different, which doesn't
look very good. We can also solve this problem by modifying the generated text
prefixes to but a fixed-pitch zero width space at the start of 0-indent lines
instead of nothing.

#+begin_src emacs-lisp
(defadvice! +org-indent--reduced-text-prefixes ()
  :after #'org-indent--compute-prefixes
  (setq org-indent--text-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (when (> org-indent-indentation-per-level 0)
    (dotimes (n org-indent--deepest-level)
      (aset org-indent--text-line-prefixes
            n
            (org-add-props
                (concat (make-string (* n (1- org-indent-indentation-per-level))
                                     ?\s)
                        (if (> n 0)
                             (char-to-string org-indent-boundary-char)
                          "\u200b"))
                nil 'face 'org-indent)))))
#+end_src

***** Fontifying inline src blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for
language's major-mode behind the scenes and pulling out the lovely colourful
results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to
stackexchange]] to voice their desire for inline src fontification. I was going to
steal their work, but unfortunately they didn't perform /true/ source code
fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~
we can apply language-appropriate syntax highlighting. Then, continuing on to
={{{results(...)}}}= , it can have the =org-block= face applied to match, and then
the value-surrounding constructs hidden by mimicking the behaviour of
~prettify-symbols-mode~.

#+begin_warning
This currently only highlights a single inline src block per line.
I have no idea why it stops, but I'd rather it didn't.
If you have any idea what's going on or how to fix this /please/ get in touch.
#+end_warning

#+begin_src emacs-lisp
(setq org-inline-src-prettify-results '("âŸ¨" . "âŸ©"))
#+end_src

Doom theme's extra fontification is more problematic than helpful.
#+begin_src emacs-lisp
(setq doom-themes-org-fontify-special-tags nil)
#+end_src

***** LaTeX Fragments
****** Prettier highlighting

First off, we want those fragments to look good.
#+begin_src emacs-lisp :tangle yes
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

#+RESULTS:
| native | script | entities |

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background colour.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.
#+begin_src emacs-lisp :tangle yes
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

#+RESULTS:
| latex | (:inherit default :extend t) |

****** More eager rendering


What's better than syntax-highlighted LaTeX is /rendered/ LaTeX though, and we can
have this be performed automatically with =org-fragtog=.

#+begin_src emacs-lisp :tangle packages.el
(package! org-fragtog :pin "680606189d5d28039e6f9301b55ec80517a24005")
#+end_src

#+RESULTS:
| org-fragtog | :modules | ((:user) (:user . modules)) | :pin | 680606189d5d28039e6f9301b55ec80517a24005 |

#+begin_src emacs-lisp :tangle yes
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

#+RESULTS:
| org-fragtog-mode | locally-defer-font-lock | +org-pretty-mode | org-ref-org-menu | er/add-org-mode-expansions | turn-on-org-cdlatex | org-appear-mode | elpher-org-mode-integration | auto-revert-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | beginend-org-mode | +lookup--init-org-mode-handlers-h | (closure ((hook . org-mode-hook) (--dolist-tail--) t) (&rest _) (add-hook 'before-save-hook 'org-encrypt-entries nil t)) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-make-last-point-visible-h | org-fancy-priorities-mode | org-superstar-mode | evil-org-mode | toc-org-enable | embrace-org-mode-hook | org-eldoc-load | +literate-enable-recompile-h |

****** Prettier rendering

It's nice to customise the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).
Let's start by adding a sans font. I'd also like to use some of the
functionality from =bmc-maths=, so we'll load that too.

#+begin_src emacs-lisp :tangle yes
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage[nofont,plaindd]{bmc-maths}
\\usepackage{arev}
")
#+end_src

#+RESULTS:
#+begin_example
\documentclass{article}
\usepackage[usenames]{xcolor}

\usepackage[T1]{fontenc}

\usepackage{booktabs}

\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\setlength{\textwidth}{\paperwidth}
\addtolength{\textwidth}{-3cm}
\setlength{\oddsidemargin}{1.5cm}
\addtolength{\oddsidemargin}{-2.54cm}
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textheight}{\paperheight}
\addtolength{\textheight}{-\headheight}
\addtolength{\textheight}{-\headsep}
\addtolength{\textheight}{-\footskip}
\addtolength{\textheight}{-3cm}
\setlength{\topmargin}{1.5cm}
\addtolength{\topmargin}{-2.54cm}
% my custom stuff
\usepackage[nofont,plaindd]{bmc-maths}
\usepackage{arev}
#+end_example

Since we can, instead of making the background colour match the =default= face,
let's make it transparent.
#+begin_src emacs-lisp :tangle yes
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src

#+RESULTS:
| :foreground | default | :background | Transparent | :scale | 1.5 | :html-foreground | Black | :html-background | Transparent | :html-scale | 1.0 | :matchers | (begin $1 $ $$ \( \[) |

With the background taken care of, we just need to make sure we're using the
theme-appropriate foreground.

# TODO check that this is still needed.

#+begin_src emacs-lisp :tangle no
(add-hook! 'doom-load-theme-hook
  (setq org-preview-latex-image-directory
        (concat doom-cache-dir "org-latex/" (symbol-name doom-theme) "/"))
  (dolist (buffer (doom-buffers-in-mode 'org-mode (buffer-list)))
    (with-current-buffer buffer
      (+org--toggle-inline-images-in-subtree (point-min) (point-max) 'refresh)
      (org-clear-latex-preview (point-min) (point-max))
      (org--latex-preview-region (point-min) (point-max)))))
#+end_src

#+RESULTS:

****** Rendering speed tests

We can either render from a ~dvi~ or ~pdf~ file, so let's benchmark ~latex~ and
~pdflatex~.
| ~latex~ time | ~pdflatex~ time |
|------------+---------------|
| 135 \pm 2 ms | 215 \pm 3 ms    |

On the rendering side, there are two ~.dvi~-to-image converters which I am
interested in: ~dvipng~ and ~dvisvgm~. Then with the a ~.pdf~ we have ~pdf2svg~.
For inline preview we care about speed, while for exporting we care about file
size and prefer a vector graphic.

Using the above latex expression and benchmarking lead to the following results:
| ~dvipng~ time | ~dvisvgm~ time | ~pdf2svg~ time |
|-------------+--------------+--------------|
| 89 \pm 2 ms   | 178 \pm 2 ms   | 12 \pm 2 ms    |

Now let's combine this to see what's best
| Tool chain         | Total time | Resultant file size |
|--------------------+------------+---------------------|
| ~latex~ + ~dvipng~     | 226 \pm 2 ms | 7 KiB               |
| ~latex~ + ~dvisvgm~    | 392 \pm 4 ms | 8 KiB               |
| ~pdflatex~ + ~pdf2svg~ | 230 \pm 2 ms | 16 KiB              |

So, let's use ~dvipng~ for previewing LaTeX fragments in-Emacs, but ~dvisvgm~ for [[LaTeX Rendering]].

#+begin_warning
Unfortunately, it seems that SVG sizing is annoying ATM, so let's actually not do this right now.
#+end_warning

***** Stolen from [[https://github.com/jkitchin/scimax][scimax]] (semi-working right now)

I want fragment justification
#+begin_src emacs-lisp
(defun scimax-org-latex-fragment-justify (justification)
  "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
  (interactive
   (list (intern-soft
          (completing-read "Justification (left): " '(left center right)
                           nil t nil nil 'left))))
  (let* ((ov (ov-at))
         (beg (ov-beg ov))
         (end (ov-end ov))
         (shift (- beg (line-beginning-position)))
         (img (overlay-get ov 'display))
         (img (and (and img (consp img) (eq (car img) 'image)
                        (image-type-available-p (plist-get (cdr img) :type)))
                   img))
         space-left offset)
    (when (and img
               ;; This means the equation is at the start of the line
               (= beg (line-beginning-position))
               (or
                (string= "" (s-trim (buffer-substring end (line-end-position))))
                (eq 'latex-environment (car (org-element-context)))))
      (setq space-left (- (window-max-chars-per-line) (car (image-size img)))
            offset (floor (cond
                           ((eq justification 'center)
                            (- (/ space-left 2) shift))
                           ((eq justification 'right)
                            (- space-left shift))
                           (t
                            0))))
      (when (>= offset 0)
        (overlay-put ov 'before-string (make-string offset ?\ ))))))

(defun scimax-org-latex-fragment-justify-advice (beg end image imagetype)
  "After advice function to justify fragments."
  (scimax-org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))


(defun scimax-toggle-latex-fragment-justification ()
  "Toggle if LaTeX fragment justification options can be used."
  (interactive)
  (if (not (get 'scimax-org-latex-fragment-justify-advice 'enabled))
      (progn
        (advice-add 'org--format-latex-make-overlay :after 'scimax-org-latex-fragment-justify-advice)
        (put 'scimax-org-latex-fragment-justify-advice 'enabled t)
        (message "Latex fragment justification enabled"))
    (advice-remove 'org--format-latex-make-overlay 'scimax-org-latex-fragment-justify-advice)
    (put 'scimax-org-latex-fragment-justify-advice 'enabled nil)
    (message "Latex fragment justification disabled")))
#+end_src
There's also this lovely equation numbering stuff I'll nick
#+begin_src emacs-lisp
;; Numbered equations all have (1) as the number for fragments with vanilla
;; org-mode. This code injects the correct numbers into the previews so they
;; look good.
(defun scimax-org-renumber-environment (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1)
        (numberp))
    (setq results (cl-loop for (begin . env) in
                           (org-element-map (org-element-parse-buffer) 'latex-environment
                             (lambda (env)
                               (cons
                                (org-element-property :begin env)
                                (org-element-property :value env))))
                           collect
                           (cond
                            ((and (string-match "\\\\begin{equation}" env)
                                  (not (string-match "\\\\tag{" env)))
                             (cl-incf counter)
                             (cons begin counter))
                            ((string-match "\\\\begin{align}" env)
                             (prog2
                                 (cl-incf counter)
                                 (cons begin counter)
                               (with-temp-buffer
                                 (insert env)
                                 (goto-char (point-min))
                                 ;; \\ is used for a new line. Each one leads to a number
                                 (cl-incf counter (count-matches "\\\\$"))
                                 ;; unless there are nonumbers.
                                 (goto-char (point-min))
                                 (cl-decf counter (count-matches "\\nonumber")))))
                            (t
                             (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))


(defun scimax-toggle-latex-equation-numbering ()
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (not (get 'scimax-org-renumber-environment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
        (put 'scimax-org-renumber-environment 'enabled t)
        (message "Latex numbering enabled"))
    (advice-remove 'org-create-formula-image #'scimax-org-renumber-environment)
    (put 'scimax-org-renumber-environment 'enabled nil)
    (message "Latex numbering disabled.")))

(advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
(put 'scimax-org-renumber-environment 'enabled t)
#+end_src


***** Symbols

It's also nice to change the character used for collapsed items (by default ~â€¦~),
I think ~â–¾~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.
I've also added some fun alternatives, just commented out.
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("â—‰" "â—‹" "âœ¸" "âœ¿" "âœ¤" "âœœ" "â—†" "â–¶")
        org-superstar-prettify-item-bullets t ))

        ;; org-superstar-headline-bullets-list '("â—‰" "â—" "â—‹" "â—†" "â—" "â—‹" "â—†")
        ;; org-superstar-item-bullet-alist '((?+ . ?âž¤) (?- . ?âœ¦)) ; changes +/- symbols in item lists

(setq org-ellipsis " â–¾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src
It's also nice to make use of the Unicode characters for check boxes, and other commands.
#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "â˜"
            :pending       "â—¼"
            :checkedbox    "â˜‘"
            :list_property "âˆ·"
            :em_dash       "â€”"
            :ellipses      "â€¦"
            :arrow_right   "â†’"
            :arrow_left    "â†"
            :title         "ð™"
            :subtitle      "ð™©"
            :author        "ð˜¼"
            :date          "ð˜¿"
            :property      "â˜¸"
            :options       "âŒ¥"
            :startup       "â»"
            :macro         "ð“œ"
            :html_head     "ðŸ…·"
            :html          "ðŸ…—"
            :latex_class   "ðŸ„»"
            :latex_header  "ðŸ…»"
            :beamer_header "ðŸ…‘"
            :latex         "ðŸ…›"
            :attr_latex    "ðŸ„›"
            :attr_html     "ðŸ„—"
            :attr_org      "â’ª"
            :begin_quote   "â"
            :end_quote     "âž"
            :caption       "â˜°"
            :header        "â€º"
            :results       "ðŸ ¶"
            :begin_export  "â©"
            :end_export    "âª"
            :properties    "âš™"
            :end           "âˆŽ"
            :priority_a   ,(propertize "âš‘" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "â¬†" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "â– " 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "â¬‡" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "â“" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]"
  :roam_tags     "#+roam_tags:"
  :filetags      "#+filetags:")
(plist-put +ligatures-extra-symbols :name "â")

;; (with-eval-after-load 'org
;;   (plist-put org-format-latex-options :background 'default))
#+end_src

#+RESULTS:
| :name | â  | :src_block | Â» | :src_block_end | Â« | :quote | â€œ | :quote_end | â€ | :lambda | Î» | :def | Æ’ | :composition | âˆ˜ | :map | â†¦ | :null | âˆ… | :true | ð•‹ | :false | ð”½  | :int | â„¤ | :float | â„  | :str | ð•Š  | :bool | ð”¹ | :list | ð•ƒ | :not | ï¿¢ | :in | âˆˆ | :not-in | âˆ‰ | :and | âˆ§ | :or | âˆ¨ | :for | âˆ€ | :some | âˆƒ | :return | âŸ¼ | :yield | âŸ» | :union | â‹ƒ | :intersect | âˆ© | :diff | âˆ–  | :tuple | â¨‚ | :pipe | î„µ | :dot | â€¢ | :checkbox | â˜ | :pending | â—¼  | :checkedbox | â˜‘ | :list_property | âˆ· | :em_dash | â€” | :ellipses | â€¦ | :arrow_right | â†’ | :arrow_left | â† | :title | ð™  | :subtitle | ð™©  | :author | ð˜¼  | :date | ð˜¿  | :property | â˜¸ | :options | âŒ¥ | :startup | â» | :macro | ð“œ | :html_head | ðŸ…· | :html | ðŸ…— | :latex_class | ðŸ„» | :latex_header | ðŸ…» | :beamer_header | ðŸ…‘ | :latex | ðŸ…› | :attr_latex | ðŸ„› | :attr_html | ðŸ„— | :attr_org | â’ª | :begin_quote | â | :end_quote | âž | :caption | â˜° | :header | â€º | :results | ðŸ ¶ | :begin_export | â© | :end_export | âª | :properties | âš™ | :end | âˆŽ | :priority_a | âš‘  | :priority_b | â¬† | :priority_c | â–  | :priority_d | â¬‡ | :priority_e | â“ | :checkbox | â˜ | :pending | â—¼  | :checkedbox | â˜‘ | :list_property | âˆ· | :em_dash | â€” | :ellipses | â€¦ | :arrow_right | â†’ | :arrow_left | â† | :title | ð™  | :subtitle | ð™©  | :author | ð˜¼  | :date | ð˜¿  | :property | â˜¸ | :options | âŒ¥ | :startup | â» | :macro | ð“œ | :html_head | ðŸ…· | :html | ðŸ…— | :latex_class | ðŸ„» | :latex_header | ðŸ…» | :beamer_header | ðŸ…‘ | :latex | ðŸ…› | :attr_latex | ðŸ„› | :attr_html | ðŸ„— | :attr_org | â’ª | :begin_quote | â | :end_quote | âž | :caption | â˜° | :header | â€º | :results | ðŸ ¶ | :begin_export | â© | :end_export | âª | :properties | âš™ | :end | âˆŽ | :priority_a | âš‘  | :priority_b | â¬† | :priority_c | â–  | :priority_d | â¬‡ | :priority_e | â“ |

~org-superstar-mode~ is great. While we're at it we may as well make tags prettier as well ðŸ™‚
#+begin_src emacs-lisp :tangle packages.el
;; (package! org-pretty-tags :pin "5c7521651b35ae9a7d3add4a66ae8cc176ae1c76")
#+end_src

#+begin_src emacs-lisp
;; (use-package! org-pretty-tags
;; :config
;;  (setq org-pretty-tags-surrogate-strings
;;        `(("uni"        . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
;;          ("ucc"        . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
;;          ("assignment" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("test"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("lecture"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("read"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
;;          ("article"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("web"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
;;          ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("issue"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("someday"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
;;          ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))
;;  (org-pretty-tags-global-mode))
#+end_src
***** Org Plot
We can use some of the variables in =org-plot= to use the current doom theme
colours.
#+begin_src emacs-lisp
(defvar +org-plot-term-size '(1050 . 650)
  "The size of the GNUPlot terminal, in the form (WIDTH . HEIGHT).")

(after! org-plot
  (defun +org-plot-generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# border styles
set tics out nomirror
set border 3

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)))

  (defun +org-plot-gnuplot-term-properties (_type)
    (format "background rgb '%s' size %s,%s"
            (doom-color 'bg) (car +org-plot-term-size) (cdr +org-plot-term-size)))

  (setq org-plot/gnuplot-script-preamble #'+org-plot-generate-theme)
  (setq org-plot/gnuplot-term-extra #'+org-plot-gnuplot-term-properties))
#+end_src

#+RESULTS:
***** custom minor mode

   Stolen from =Prot=

#+begin_src emacs-lisp :tangle yes
;;;;;


;;
;;    Custom Minor Modes
;;
;;;;;

(define-minor-mode prot/scroll-center-cursor-mode
  "Toggle centred cursor scrolling behavior"
  :init-value nil
  :lighter " S="
  :global nil
  (if prot/scroll-center-cursor-mode
      (setq-local scroll-margin (* (frame-height) 2)
                  scroll-conservatively 0
                  maximum-scroll-margin 0.5)
    (dolist (local '(scroll-preserve-screen-position
                     scroll-conservatively
                     maximum-scroll-margin
                     scroll-margin))
      (kill-local-variable `,local)))
  )


#+end_src

#+RESULTS:


Make everything variable pitch, who the hell likes reading fixed-pitch?

#+begin_src emacs-lisp :tangle yes
(define-minor-mode prot/variable-pitch-mode
  "Toggle 'mixed-pitch-modei, except for programming modes"
  :init-value nil
  :global nil
  (if prot/variable-pitch-mode
      (unless (derived-mode-p 'prog-mode)
        (variable-pitch-mode 1))
    (variable-pitch-mode -1)))
#+end_src

NO line numbers.

#+begin_src emacs-lisp :tangle yes

(define-minor-mode prot/display-line-number-mode
  "Disable line numbers, except for programming modes."
  :init-value nil
  :global nil
  (if prot/display-line-number-mode
      (unless (derived-mode-p 'prog-mode)
        (display-line-numbers-mode -1))
    (display-line-numbers-mode 1)))
#+end_src

**** Exporting
***** General settings

By default Org only exports the first three levels of headings as ... headings.
This is rather unfortunate as my documents frequently stray far beyond three
levels of depth. The two main formats I care about exporting to are LaTeX and
HTML. When using an =article= class, LaTeX headlines go from =\section=,
=\subsection=, =\subsubsection=, and =\paragraph= to =\subgraph= --- /five/ levels.
HTML5 has six levels of headings (=<h1>= to =<h6>=), but first level Org headings
get exported as =<h2>= elements --- leaving /five/ usable levels.

As such, it would seem to make sense to recognise the first /five/ levels of Org
headings when exporting.

#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src

I'm also going to make use of an item in =ox-extra= so that I can add an =:ignore:=
tag to headings for the content to be kept, but the heading itself ignored
(unlike =:noexport:= which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.
#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

Since I (roughly) track Org ~HEAD~, it makes sense to include the git version in
the creator string.
#+begin_src emacs-lisp
(setq org-export-creator-string
      (format "Emacs %s (Org mode %sâ€“%s)" emacs-version (org-release) (org-git-version)))
#+end_src

***** Acronym formatting

I like automatically using spaced small caps for acronyms. For strings I want to
be unaffected let's use ~;~ as a prefix to prevent the transformation --- i.e.
~;JFK~ (as one would want for two-letter geographic locations and names).

This has to be implemented on a per-format basis, currently HTML and LaTeX
exports are supported.

#+begin_src emacs-lisp
(defun org-export-filter-text-acronym (text backend _info)
  "Wrap suspected acronyms in acronyms-specific formatting.
Treat sequences of 2+ capital letters (optionally succeeded by \"s\") as an acronym.
Ignore if preceeded by \";\" (for manual prevention) or \"\\\" (for LaTeX commands).

TODO abstract backend implementations."
  (let ((base-backend
         (cond
          ((org-export-derived-backend-p backend 'latex) 'latex)
          ;; Markdown is derived from HTML, but we don't want to format it
          ((org-export-derived-backend-p backend 'md) nil)
          ((org-export-derived-backend-p backend 'html) 'html)))
        (case-fold-search nil))
    (when base-backend
      (replace-regexp-in-string
       "[;\\\\]?\\b[A-Z][A-Z]+s?\\(?:[^A-Za-z]\\|\\b\\)"
       (lambda (all-caps-str)
         (cond ((equal (aref all-caps-str 0) ?\\) all-caps-str)                ; don't format LaTeX commands
               ((equal (aref all-caps-str 0) ?\;) (substring all-caps-str 1))  ; just remove not-acronym indicator char ";"
               (t (let* ((final-char (if (string-match-p "[^A-Za-z]" (substring all-caps-str -1 (length all-caps-str)))
                                         (substring all-caps-str -1 (length all-caps-str))
                                       nil)) ; needed to re-insert the [^A-Za-z] at the end
                         (trailing-s (equal (aref all-caps-str (- (length all-caps-str) (if final-char 2 1))) ?s))
                         (acr (if final-char
                                  (substring all-caps-str 0 (if trailing-s -2 -1))
                                (substring all-caps-str 0 (+ (if trailing-s -1 (length all-caps-str)))))))
                    (pcase base-backend
                      ('latex (concat "\\acr{" (s-downcase acr) "}" (when trailing-s "\\acrs{}") final-char))
                      ('html (concat "<span class='acr'>" acr "</span>" (when trailing-s "<small>s</small>") final-char)))))))
       text t t))))

(add-to-list 'org-export-filter-plain-text-functions
             #'org-export-filter-text-acronym)

;; We won't use `org-export-filter-headline-functions' because it
;; passes (and formats) the entire section contents. That's no good.

(defun org-html-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-html-format-headline-default-function', but with acronym formatting."
  (org-html-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'html info) tags info))
(setq org-html-format-headline-function #'org-html-format-headline-acronymised)

(defun org-latex-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-latex-format-headline-default-function', but with acronym formatting."
  (org-latex-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'latex info) tags info))
(setq org-latex-format-headline-function #'org-latex-format-headline-acronymised)
#+end_src

***** Exporting Org code

With all our Org config and hooks, exporting an Org code block when using
a font-lock based method can produce undesirable results. To address this, we
can tweak ~+org-babel-mode-alist~ when exporting.

#+begin_src emacs-lisp
(defun +org-mode--fontlock-only-mode ()
  "Just apply org-mode's font-lock once."
  (let (org-mode-hook
        org-hide-leading-stars
        org-hide-emphasis-markers)
    (org-set-font-lock-defaults)
    (font-lock-ensure))
  (setq-local major-mode #'fundamental-mode))

(defun +org-export-babel-mask-org-config (_backend)
  "Use `+org-mode--fontlock-only-mode' instead of `org-mode'."
  (setq-local org-src-lang-modes
              (append org-src-lang-modes
                      (list (cons "org" #'+org-mode--fontlock-only)))))

(add-hook 'org-export-before-processing-hook #'+org-export-babel-mask-org-config)
#+end_src

**** HTML Export


I want to tweak a whole bunch of things. While I'll want my tweaks almost all
the time, occasionally I may want to test how something turns out using a more
default config. With that in mind, a global minor mode seems like the most
appropriate architecture to use.

#+begin_src emacs-lisp
(define-minor-mode org-fancy-html-export-mode
  "Toggle my fabulous org export tweaks. While this mode itself does a little bit,
the vast majority of the change in behaviour comes from switch statements in:
 - `org-html-template-fancier'
 - `org-html--build-meta-info-extended'
 - `org-html-src-block-collapsable'
 - `org-html-block-collapsable'
 - `org-html-table-wrapped'
 - `org-html--format-toc-headline-colapseable'
 - `org-html--toc-text-stripped-leaves'
 - `org-export-html-headline-anchor'"
  :global t
  :init-value t
  (if org-fancy-html-export-mode
      (setq org-html-style-default org-html-style-fancy
            org-html-meta-tags #'org-html-meta-tags-fancy
            org-html-checkbox-type 'html-span)
    (setq org-html-style-default org-html-style-plain
          org-html-meta-tags #'org-html-meta-tags-default
          org-html-checkbox-type 'html)))
#+end_src

***** Extra header content

We want to tack on a few more bits to the start of the body. Unfortunately, there
doesn't seem to be any nice variable or hook, so we'll just override the
relevant function.

This is done to allow me to add the date and author to the page header,
implement a CSS-only light/dark theme toggle, and a sprinkle of [[https://ogp.me/][Open Graph]]
metadata.
#+begin_src emacs-lisp
(defadvice! org-html-template-fancier (orig-fn contents info)
  "Return complete document string after HTML conversion.
CONTENTS is the transcoded contents string.  INFO is a plist
holding export options. Adds a few extra things to the body
compared to the default implementation."
  :around #'org-html-template
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn contents info)
    (concat
     (when (and (not (org-html-html5-p info)) (org-html-xhtml-p info))
       (let* ((xml-declaration (plist-get info :html-xml-declaration))
              (decl (or (and (stringp xml-declaration) xml-declaration)
                        (cdr (assoc (plist-get info :html-extension)
                                    xml-declaration))
                        (cdr (assoc "html" xml-declaration))
                        "")))
         (when (not (or (not decl) (string= "" decl)))
           (format "%s\n"
                   (format decl
                           (or (and org-html-coding-system
                                    (fboundp 'coding-system-get)
                                    (coding-system-get org-html-coding-system 'mime-charset))
                               "iso-8859-1"))))))
     (org-html-doctype info)
     "\n"
     (concat "<html"
             (cond ((org-html-xhtml-p info)
                    (format
                     " xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"%s\" xml:lang=\"%s\""
                     (plist-get info :language) (plist-get info :language)))
                   ((org-html-html5-p info)
                    (format " lang=\"%s\"" (plist-get info :language))))
             ">\n")
     "<head>\n"
     (org-html--build-meta-info info)
     (org-html--build-head info)
     (org-html--build-mathjax-config info)
     "</head>\n"
     "<body>\n<input type='checkbox' id='theme-switch'><div id='page'><label id='switch-label' for='theme-switch'></label>"
     (let ((link-up (org-trim (plist-get info :html-link-up)))
           (link-home (org-trim (plist-get info :html-link-home))))
       (unless (and (string= link-up "") (string= link-home ""))
         (format (plist-get info :html-home/up-format)
                 (or link-up link-home)
                 (or link-home link-up))))
     ;; Preamble.
     (org-html--build-pre/postamble 'preamble info)
     ;; Document contents.
     (let ((div (assq 'content (plist-get info :html-divs))))
       (format "<%s id=\"%s\">\n" (nth 1 div) (nth 2 div)))
     ;; Document title.
     (when (plist-get info :with-title)
       (let ((title (and (plist-get info :with-title)
                         (plist-get info :title)))
             (subtitle (plist-get info :subtitle))
             (html5-fancy (org-html--html5-fancy-p info)))
         (when title
           (format
            (if html5-fancy
                "<header class=\"page-header\">%s\n<h1 class=\"title\">%s</h1>\n%s</header>"
              "<h1 class=\"title\">%s%s</h1>\n")
            (if (or (plist-get info :with-date)
                    (plist-get info :with-author))
                (concat "<div class=\"page-meta\">"
                        (when (plist-get info :with-date)
                          (org-export-data (plist-get info :date) info))
                        (when (and (plist-get info :with-date) (plist-get info :with-author)) ", ")
                        (when (plist-get info :with-author)
                          (org-export-data (plist-get info :author) info))
                        "</div>\n")
              "")
            (org-export-data title info)
            (if subtitle
                (format
                 (if html5-fancy
                     "<p class=\"subtitle\" role=\"doc-subtitle\">%s</p>\n"
                   (concat "\n" (org-html-close-tag "br" nil info) "\n"
                           "<span class=\"subtitle\">%s</span>\n"))
                 (org-export-data subtitle info))
              "")))))
     contents
     (format "</%s>\n" (nth 1 (assq 'content (plist-get info :html-divs))))
     ;; Postamble.
     (org-html--build-pre/postamble 'postamble info)
     ;; Possibly use the Klipse library live code blocks.
     (when (plist-get info :html-klipsify-src)
       (concat "<script>" (plist-get info :html-klipse-selection-script)
               "</script><script src=\""
               org-html-klipse-js
               "\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\""
               org-html-klipse-css "\"/>"))
     ;; Closing document.
     "</div>\n</body>\n</html>")))
#+end_src

I think it would be nice if "Table of Contents" brought you back to the top of
the page. Well, since we've done this much advising already...
#+begin_src emacs-lisp
(defadvice! org-html-toc-linked (depth info &optional scope)
  "Build a table of contents.

Just like `org-html-toc', except the header is a link to \"#\".

DEPTH is an integer specifying the depth of the table.  INFO is
a plist used as a communication channel.  Optional argument SCOPE
is an element defining the scope of the table.  Return the table
of contents as a string, or nil if it is empty."
  :override #'org-html-toc
  (let ((toc-entries
         (mapcar (lambda (headline)
                   (cons (org-html--format-toc-headline headline info)
                         (org-export-get-relative-level headline info)))
                 (org-export-collect-headlines info depth scope))))
    (when toc-entries
      (let ((toc (concat "<div id=\"text-table-of-contents\">"
                         (org-html--toc-text toc-entries)
                         "</div>\n")))
        (if scope toc
          (let ((outer-tag (if (org-html--html5-fancy-p info)
                               "nav"
                             "div")))
            (concat (format "<%s id=\"table-of-contents\">\n" outer-tag)
                    (let ((top-level (plist-get info :html-toplevel-hlevel)))
                      (format "<h%d><a href=\"#\" style=\"color:inherit; text-decoration: none;\">%s</a></h%d>\n"
                              top-level
                              (org-html--translate "Table of Contents" info)
                              top-level))
                    toc
                    (format "</%s>\n" outer-tag))))))))
#+end_src

Lastly, let's pile on some metadata. This gives my pages nice embeds.
#+begin_src emacs-lisp
(defvar org-html-meta-tags-opengraph-image
  '(:image "https://tecosaur.com/resources/org/nib.png"
    :type "image/png"
    :width "200"
    :height "200"
    :alt "Green fountain pen nib")
  "Plist of og:image:PROP properties and their value, for use in `org-html-meta-tags-fancy'.")

(defun org-html-meta-tags-fancy (info)
  "Use the INFO plist to construct the meta tags, as described in `org-html-meta-tags'."
  (let ((title (org-html-plain-text
                (org-element-interpret-data (plist-get info :title)) info))
        (author (and (plist-get info :with-author)
                     (let ((auth (plist-get info :author)))
                       ;; Return raw Org syntax.
                       (and auth (org-html-plain-text
                                  (org-element-interpret-data auth) info))))))
    (append
     (list
      (when (org-string-nw-p author)
        (list "name" "author" author))
      (when (org-string-nw-p (plist-get info :description))
        (list "name" "description"
              (plist-get info :description)))
      '("name" "generator" "org mode")
      '("name" "theme-color" "#77aa99")
      '("property" "og:type" "article")
      (list "property" "og:title" title)
      (let ((subtitle (org-export-data (plist-get info :subtitle) info)))
        (when (org-string-nw-p subtitle)
          (list "property" "og:description" subtitle))))
     (when org-html-meta-tags-opengraph-image
       (list (list "property" "og:image" (plist-get org-html-meta-tags-opengraph-image :image))
             (list "property" "og:image:type" (plist-get org-html-meta-tags-opengraph-image :type))
             (list "property" "og:image:width" (plist-get org-html-meta-tags-opengraph-image :width))
             (list "property" "og:image:height" (plist-get org-html-meta-tags-opengraph-image :height))
             (list "property" "og:image:alt" (plist-get org-html-meta-tags-opengraph-image :alt))))
     (list
      (when (org-string-nw-p author)
        (list "property" "og:article:author:first_name" (car (s-split-up-to " " author 2))))
      (when (and (org-string-nw-p author) (s-contains-p " " author))
        (list "property" "og:article:author:last_name" (cadr (s-split-up-to " " author 2))))
      (list "property" "og:article:published_time"
            (format-time-string
             "%FT%T%z"
             (or
              (when-let ((date-str (cadar (org-collect-keywords '("DATE")))))
                (unless (string= date-str (format-time-string "%F"))
                  (ignore-errors (encode-time (org-parse-time-string date-str)))))
              (if buffer-file-name
                  (file-attribute-modification-time (file-attributes buffer-file-name))
                (current-time)))))
      (when buffer-file-name
        (list "property" "og:article:modified_time"
              (format-time-string "%FT%T%z" (file-attribute-modification-time (file-attributes buffer-file-name)))))))))

(unless (functionp #'org-html-meta-tags-default)
  (defalias 'org-html-meta-tags-default #'ignore))
(setq org-html-meta-tags #'org-html-meta-tags-fancy)
#+end_src

***** Custom CSS/JS

The default org HTML export is ... alright, but we can really jazz it up.
[[https://lepisma.xyz][lepisma.xyz]] has a really nice style, and from and org export too!
Suffice to say I've snatched it, with a few of my own tweaks applied.

#+begin_src html :tangle misc/org-export-header.html :comments no
<link rel="icon" href="https://tecosaur.com/resources/org/nib.ico" type="image/ico" />

<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-roman-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-italic-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextRegular.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextItalic.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextBold.woff2">
#+end_src

#+begin_src emacs-lisp
(setq org-html-style-plain org-html-style-default
      org-html-htmlize-output-type 'css
      org-html-doctype "html5"
      org-html-html5-fancy t)

(defun org-html-reload-fancy-style ()
  (interactive)
  (setq org-html-style-fancy
        (concat (f-read-text (expand-file-name "misc/org-export-header.html" doom-private-dir))
                "<script>\n"
                (f-read-text (expand-file-name "misc/org-css/main.js" doom-private-dir))
                "</script>\n<style>\n"
                (f-read-text (expand-file-name "misc/org-css/main.min.css" doom-private-dir))
                "</style>"))
  (when org-fancy-html-export-mode
    (setq org-html-style-default org-html-style-fancy)))
(org-html-reload-fancy-style)
#+end_src

***** Collapsable src and example blocks

By wrapping the ~<pre>~ element in a ~<details>~ block, we can obtain collapsable
blocks with no CSS, though we will toss a little in anyway to have this looking
somewhat spiffy.

Since this collapsability seems useful to have on by default for certain chunks
of code, it would be nice if you could set it with =#+attr_html: :collapsed t=.

It would be nice to also have a corresponding global / session-local way of
setting this, but I haven't quite been able to get that working (yet).

#+begin_src emacs-lisp
(defvar org-html-export-collapsed nil)
(eval '(cl-pushnew '(:collapsed "COLLAPSED" "collapsed" org-html-export-collapsed t)
                   (org-export-backend-options (org-export-get-backend 'html))))
(add-to-list 'org-default-properties "EXPORT_COLLAPSED")
#+end_src

We can take our src block modification a step further, and add a gutter on the
side of the src block containing both an anchor referencing the current block,
and a button to copy the content of the block.

#+name: Src blocks
#+begin_src emacs-lisp
(defadvice! org-html-src-block-collapsable (orig-fn src-block contents info)
  "Wrap the usual <pre> block in a <details>"
  :around #'org-html-src-block
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn src-block contents info)
    (let* ((properties (cadr src-block))
           (lang (mode-name-to-lang-name
                  (plist-get properties :language)))
           (name (plist-get properties :name))
           (ref (org-export-get-reference src-block info))
           (collapsed-p (member (or (org-export-read-attribute :attr_html src-block :collapsed)
                                    (plist-get info :collapsed))
                                '("y" "yes" "t" t "true" "all"))))
      (format
       "<details id='%s' class='code'%s><summary%s>%s</summary>
<div class='gutter'>
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>âŽ˜</button>\
</div>
%s
</details>"
       ref
       (if collapsed-p "" " open")
       (if name " class='named'" "")
       (concat
        (when name (concat "<span class=\"name\">" name "</span>"))
        "<span class=\"lang\">" lang "</span>")
       ref
       (if name
           (replace-regexp-in-string (format "<pre\\( class=\"[^\"]+\"\\)? id=\"%s\">" ref) "<pre\\1>"
                                     (funcall orig-fn src-block contents info))
         (funcall orig-fn src-block contents info))))))

(defun mode-name-to-lang-name (mode)
  (or (cadr (assoc mode
                   '(("asymptote" "Asymptote")
                     ("awk" "Awk")
                     ("C" "C")
                     ("clojure" "Clojure")
                     ("css" "CSS")
                     ("D" "D")
                     ("ditaa" "ditaa")
                     ("dot" "Graphviz")
                     ("calc" "Emacs Calc")
                     ("emacs-lisp" "Emacs Lisp")
                     ("fortran" "Fortran")
                     ("gnuplot" "gnuplot")
                     ("haskell" "Haskell")
                     ("hledger" "hledger")
                     ("java" "Java")
                     ("js" "Javascript")
                     ("latex" "LaTeX")
                     ("ledger" "Ledger")
                     ("lisp" "Lisp")
                     ("lilypond" "Lilypond")
                     ("lua" "Lua")
                     ("matlab" "MATLAB")
                     ("mscgen" "Mscgen")
                     ("ocaml" "Objective Caml")
                     ("octave" "Octave")
                     ("org" "Org mode")
                     ("oz" "OZ")
                     ("plantuml" "Plantuml")
                     ("processing" "Processing.js")
                     ("python" "Python")
                     ("R" "R")
                     ("ruby" "Ruby")
                     ("sass" "Sass")
                     ("scheme" "Scheme")
                     ("screen" "Gnu Screen")
                     ("sed" "Sed")
                     ("sh" "shell")
                     ("sql" "SQL")
                     ("sqlite" "SQLite")
                     ("forth" "Forth")
                     ("io" "IO")
                     ("J" "J")
                     ("makefile" "Makefile")
                     ("maxima" "Maxima")
                     ("perl" "Perl")
                     ("picolisp" "Pico Lisp")
                     ("scala" "Scala")
                     ("shell" "Shell Script")
                     ("ebnf2ps" "ebfn2ps")
                     ("cpp" "C++")
                     ("abc" "ABC")
                     ("coq" "Coq")
                     ("groovy" "Groovy")
                     ("bash" "bash")
                     ("csh" "csh")
                     ("ash" "ash")
                     ("dash" "dash")
                     ("ksh" "ksh")
                     ("mksh" "mksh")
                     ("posh" "posh")
                     ("ada" "Ada")
                     ("asm" "Assembler")
                     ("caml" "Caml")
                     ("delphi" "Delphi")
                     ("html" "HTML")
                     ("idl" "IDL")
                     ("mercury" "Mercury")
                     ("metapost" "MetaPost")
                     ("modula-2" "Modula-2")
                     ("pascal" "Pascal")
                     ("ps" "PostScript")
                     ("prolog" "Prolog")
                     ("simula" "Simula")
                     ("tcl" "tcl")
                     ("tex" "LaTeX")
                     ("plain-tex" "TeX")
                     ("verilog" "Verilog")
                     ("vhdl" "VHDL")
                     ("xml" "XML")
                     ("nxml" "XML")
                     ("conf" "Configuration File"))))
      mode))
#+end_src

#+name: Example, fixed width, and property blocks
#+begin_src emacs-lisp
(defun org-html-block-collapsable (orig-fn block contents info)
  "Wrap the usual block in a <details>"
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn block contents info)
    (let ((ref (org-export-get-reference block info))
          (type (pcase (car block)
                  ('property-drawer "Properties")))
          (collapsed-default (pcase (car block)
                               ('property-drawer t)
                               (_ nil)))
          (collapsed-value (org-export-read-attribute :attr_html block :collapsed))
          (collapsed-p (or (member (org-export-read-attribute :attr_html block :collapsed)
                                   '("y" "yes" "t" t "true"))
                           (member (plist-get info :collapsed) '("all")))))
      (format
       "<details id='%s' class='code'%s>
<summary%s>%s</summary>
<div class='gutter'>\
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>âŽ˜</button>\
</div>
%s\n
</details>"
       ref
       (if (or collapsed-p collapsed-default) "" " open")
       (if type " class='named'" "")
       (if type (format "<span class='type'>%s</span>" type) "")
       ref
       (funcall orig-fn block contents info)))))

(advice-add 'org-html-example-block   :around #'org-html-block-collapsable)
(advice-add 'org-html-fixed-width     :around #'org-html-block-collapsable)
(advice-add 'org-html-property-drawer :around #'org-html-block-collapsable)
#+end_src

***** Include extra font-locking in htmlize

Org uses [[https://github.com/hniksic/emacs-htmlize][htmlize.el]] to export buffers with syntax highlighting.

The works fantastically, for the most part. Minor modes that provide
font-locking are /not/ loaded, and so do not impact the result.

By enabling these modes in ~htmlize-before-hook~ we can correct this behaviour.

#+begin_src emacs-lisp
(autoload #'highlight-numbers--turn-on "highlight-numbers")
(add-hook 'htmlize-before-hook #'highlight-numbers--turn-on)
#+end_src

***** Handle table overflow

In order to accommodate wide tables ---particularly on mobile devices--- we want
to set a maximum width and scroll overflow. Unfortunately, this cannot be applied
directly to the ~table~ element, so we have to wrap it in a ~div~.

While we're at it, we can a link gutter, as we did with src blocks, and show the
~#+name~, if one is given.

#+begin_src emacs-lisp
(defadvice! org-html-table-wrapped (orig-fn table contents info)
  "Wrap the usual <table> in a <div>"
  :around #'org-html-table
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn table contents info)
    (let* ((name (plist-get (cadr table) :name))
           (ref (org-export-get-reference table info)))
      (format "<div id='%s' class='table'>
<div class='gutter'><a href='#%s'>#</a></div>
<div class='tabular'>
%s
</div>\
</div>"
              ref ref
              (if name
                  (replace-regexp-in-string (format "<table id=\"%s\"" ref) "<table"
                                            (funcall orig-fn table contents info))
                (funcall orig-fn table contents info))))))
#+end_src

***** TOC as a collapsable tree

The TOC is much nicer to navigate as a collapsable tree. Unfortunately we cannot
achieve this with CSS alone. Thankfully we can avoid JS though, by adapting the
TOC generation code to use a ~label~ for each item, and a hidden ~checkbox~ to keep
track of state.

To add this, we need to change one line in [[file:~/.emacs.d/.local/straight/repos/org/lisp/ox-html.el::(format "<a href=\"#%s\">%s</a>"][org-html--format-toc-headline]].

Since we can actually accomplish the desired effect by adding advice /around/ the
function, without overriding it --- let's do that to reduce the bug surface of
this config a tad.
#+begin_src emacs-lisp
(defadvice! org-html--format-toc-headline-colapseable (orig-fn headline info)
  "Add a label and checkbox to `org-html--format-toc-headline's usual output,
to allow the TOC to be a collapseable tree."
  :around #'org-html--format-toc-headline
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn headline info)
    (let ((id (or (org-element-property :CUSTOM_ID headline)
                  (org-export-get-reference headline info))))
      (format "<input type='checkbox' id='toc--%s'/><label for='toc--%s'>%s</label>"
              id id (funcall orig-fn headline info)))))
#+end_src

Now, leaves (headings with no children) shouldn't have the ~label~ item. The
obvious way to achieve this is by including some /if no children.../ logic in
~org-html--format-toc-headline-colapseable~. Unfortunately, I can't my elisp isn't
up to par to extract the number of child headings from the mountain of info that
org provides.
#+begin_src emacs-lisp
(defadvice! org-html--toc-text-stripped-leaves (orig-fn toc-entries)
  "Remove label"
  :around #'org-html--toc-text
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn toc-entries)
    (replace-regexp-in-string "<input [^>]+><label [^>]+>\\(.+?\\)</label></li>" "\\1</li>"
                              (funcall orig-fn toc-entries))))
#+end_src

***** Make verbatim different to code

Since we have =verbatim= and ~code~, let's make use of the difference.

We can use ~code~ exclusively for code snippets and commands like: "calling
src_elisp{(message "Hello")} in batch-mode Emacs prints to stdout like ~echo~".
Then we can use =verbatim= for miscellaneous 'other monospace' like keyboard
shortcuts: "either =C-c C-c= or =C-g= is likely the most useful keybinding in Emacs",
or file names: "I keep my configuration in =~/.config/doom/=", among other things.

Then, styling these two cases differently can help improve clarity in a document.

#+begin_src emacs-lisp
(setq org-html-text-markup-alist
      '((bold . "<b>%s</b>")
        (code . "<code>%s</code>")
        (italic . "<i>%s</i>")
        (strike-through . "<del>%s</del>")
        (underline . "<span class=\"underline\">%s</span>")
        (verbatim . "<kbd>%s</kbd>")))
#+end_src

***** Change checkbox type

We also want to use HTML checkboxes, however we want to get a bit fancier than default
#+begin_src emacs-lisp
(appendq! org-html-checkbox-types
          '((html-span
             (on . "<span class='checkbox'></span>")
             (off . "<span class='checkbox'></span>")
             (trans . "<span class='checkbox'></span>"))))
(setq org-html-checkbox-type 'html-span)
#+end_src
- [ ] I'm yet to do this
- [-] Work in progress
- [X] This is done

***** Extra special strings

The ~org-html-special-string-regexps~ variable defines substitutions for:
+ =\-=, a shy hyphen
+ =---=, an em dash
+ =--=, an en dash
+ =...=, (horizontal) ellipses

However I think it would be nice if there was also a substitution for left/right
arrows (=->= and =<-=). This is a ~defconst~, but as you may tell from the amount of
advice in this config, I'm not above messing with things I'm not 'supposed' to.

The only minor complication is that =<= and =>= are converted to =&lt;= and =&gt;=
before this stage of output processing.

#+begin_src emacs-lisp
(pushnew! org-html-special-string-regexps
          '("-&gt;" . "&#8594;")
          '("&lt;-" . "&#8592;"))
#+end_src

***** Header anchors

I want to add GitHub-style links on hover for headings.
#+begin_src emacs-lisp
(defun org-export-html-headline-anchor (text backend info)
  (when (and (org-export-derived-backend-p backend 'html)
             (not (org-export-derived-backend-p backend 're-reveal))
             org-fancy-html-export-mode)
    (unless (bound-and-true-p org-msg-export-in-progress)
      (replace-regexp-in-string
       "<h\\([0-9]\\) id=\"\\([a-z0-9-]+\\)\">\\(.*[^ ]\\)<\\/h[0-9]>" ; this is quite restrictive, but due to `org-reference-contraction' I can do this
       "<h\\1 id=\"\\2\">\\3<a aria-hidden=\"true\" href=\"#\\2\">#</a> </h\\1>"
       text))))

(add-to-list 'org-export-filter-headline-functions
             'org-export-html-headline-anchor)
#+end_src

***** Link previews

Sometimes it's nice to make a link particularly prominent, an embed/preview like
Twitter does would be nice I think.

We can do this without too much trouble by adding a new link type ever so
slightly different from =https= --- =Https=.

#+begin_src emacs-lisp
(org-link-set-parameters "Https"
                         :follow (lambda (url arg) (browse-url (concat "https:" url) arg))
                         :export #'org-url-fancy-export)
#+end_src

Then, if we can fetch a plist of the form src_elisp{(:title "..." :description
"..." :image "...")} for such links via a function ~org-url-unfurl-metadata~, we
can make a fancy export.

#+begin_src emacs-lisp
(defun org-url-fancy-export (url _desc backend)
  (let ((metadata (org-url-unfurl-metadata (concat "https:" url))))
    (cond
     ((org-export-derived-backend-p backend 'html)
      (concat
       "<div class=\"link-preview\">"
       (format "<a href=\"%s\">" (concat "https:" url))
       (when (plist-get metadata :image)
         (format "<img src=\"%s\"/>" (plist-get metadata :image)))
       "<small>"
       (replace-regexp-in-string "//\\(?:www\\.\\)?\\([^/]+\\)/?.*" "\\1" url)
       "</small><p>"
       (when (plist-get metadata :title)
         (concat "<b>" (org-html-encode-plain-text (plist-get metadata :title)) "</b></br>"))
       (when (plist-get metadata :description)
         (org-html-encode-plain-text (plist-get metadata :description)))
       "</p></a></div>"))
     (t url))))
#+end_src

Now we just need to actually implement that metadata extraction function.
#+begin_src emacs-lisp
(setq org-url-unfurl-metadata--cache nil)
(defun org-url-unfurl-metadata (url)
  (cdr (or (assoc url org-url-unfurl-metadata--cache)
           (car (push
                 (cons
                  url
                  (let* ((head-data
                          (-filter #'listp
                                   (cdaddr
                                    (with-current-buffer (progn (message "Fetching metadata from %s" url)
                                                                (url-retrieve-synchronously url t t 5))
                                      (goto-char (point-min))
                                      (delete-region (point-min) (- (search-forward "<head") 6))
                                      (delete-region (search-forward "</head>") (point-max))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<script[^\u2800]+?</script>" nil t)
                                        (replace-match ""))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<style[^\u2800]+?</style>" nil t)
                                        (replace-match ""))
                                      (libxml-parse-html-region (point-min) (point-max))))))
                         (meta (delq nil
                                     (mapcar
                                      (lambda (tag)
                                        (when (eq 'meta (car tag))
                                          (cons (or (cdr (assoc 'name (cadr tag)))
                                                    (cdr (assoc 'property (cadr tag))))
                                                (cdr (assoc 'content (cadr tag))))))
                                      head-data))))
                    (let ((title (or (cdr (assoc "og:title" meta))
                                     (cdr (assoc "twitter:title" meta))
                                     (nth 2 (assq 'title head-data))))
                          (description (or (cdr (assoc "og:description" meta))
                                           (cdr (assoc "twitter:description" meta))
                                           (cdr (assoc "description" meta))))
                          (image (or (cdr (assoc "og:image" meta))
                                     (cdr (assoc "twitter:image" meta)))))
                      (when image
                        (setq image (replace-regexp-in-string
                                     "^/" (concat "https://" (replace-regexp-in-string "//\\([^/]+\\)/?.*" "\\1" url) "/")
                                     (replace-regexp-in-string
                                      "^//" "https://"
                                      image))))
                      (list :title title :description description :image image))))
                 org-url-unfurl-metadata--cache)))))
#+end_src

***** LaTeX Rendering
****** Pre-rendered

I consider ~dvisvgm~ to be a rather compelling option. However this isn't scaled
very well at the moment.
#+begin_src emacs-lisp
;; (setq-default org-html-with-latex `dvisvgm)
#+end_src

****** MathJax

If MathJax is used, we want to use version 3 instead of the default version 2.
Looking at a [[https://www.intmath.com/cg5/katex-mathjax-comparison.php][comparison]] we seem to find that it is ~5 times as fast, uses a
single file instead of multiple, but seems to be a bit bigger unfortunately.
Thankfully this can be mitigated my adding the ~async~ attribute to defer loading.

#+begin_src emacs-lisp
(setq org-html-mathjax-options
      '((path "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" )
        (scale "1")
        (autonumber "ams")
        (multlinewidth "85%")
        (tagindent ".8em")
        (tagside "right")))

(setq org-html-mathjax-template
      "<script>
MathJax = {
  chtml: {
    scale: %SCALE
  },
  svg: {
    scale: %SCALE,
    fontCache: \"global\"
  },
  tex: {
    tags: \"%AUTONUMBER\",
    multlineWidth: \"%MULTLINEWIDTH\",
    tagSide: \"%TAGSIDE\",
    tagIndent: \"%TAGINDENT\"
  }
};
</script>
<script id=\"MathJax-script\" async
        src=\"%PATH\"></script>")
#+end_src

**** Reveal export
By default reveal is rather nice, there are just a few tweaks that I consider a
good idea.

#+begin_src emacs-lisp
(setq org-re-reveal-theme "white"
      org-re-reveal-transition "slide"
      org-re-reveal-plugins '(markdown notes math search zoom))
#+end_src

**** Babel


Doom lazy-loads babel languages, with is lovely.
It also pulls in [[https://github.com/astahlman/ob-async][ob-async]], which is nice, but it would be even better if it was
used by default.

There are two caveats to =ob-async=:
1. It does not support =:session=
   + So, we don't want =:async= used when =:session= is set
2. It adds a fixed delay to execution
   + This is undesirable in a number of cases, for example it's generally
     unwanted with =emacs-lisp= code
   + As such, I also introduce a async language blacklist to control when it's
     automatically enabled

Due to the nuance in the desired behaviour, instead of just adding =:async= to
~org-babel-default-header-args~, I advice ~org-babel-get-src-block-info~ to add
=:async= intelligently. As an escape hatch, it also recognises =:sync= as an
indication that =:async= should not be added.

I did originally have this enabled for everything except for =emacs-lisp= and
=LaTeX= (there were weird issues), but this added  a ~3s "startup" cost to every
src block evaluation, which was a bit of a pain. Since =:async= can be added
easily with =#+properties=, I've turned this behaviour from a blacklist to a
whitelist.

#+begin_src emacs-lisp
(add-transient-hook! #'org-babel-execute-src-block
  (require 'ob-async))

(defvar org-babel-auto-async-languages '()
  "Babel languages which should be executed asyncronously by default.")

(defadvice! org-babel-get-src-block-info-eager-async-a (orig-fn &optional light datum)
  "Eagarly add an :async parameter to the src information, unless it seems problematic.
This only acts o languages in `org-babel-auto-async-languages'.
Not added when either:
+ session is not \"none\"
+ :sync is set"
  :around #'org-babel-get-src-block-info
  (let ((result (funcall orig-fn light datum)))
    (when (and (string= "none" (cdr (assoc :session (caddr result))))
               (member (car result) org-babel-auto-async-languages)
               (not (assoc :async (caddr result))) ; don't duplicate
               (not (assoc :sync (caddr result))))
      (push '(:async) (caddr result)))
    result))
#+end_src

**** ESS


We don't want ~R~ evaluation to hang the editor, hence
#+begin_src emacs-lisp
(setq ess-eval-visibly 'nowait)
#+end_src

Syntax highlighting is nice, so let's turn all of that on
#+begin_src emacs-lisp
(setq ess-R-font-lock-keywords
      '((ess-R-fl-keyword:keywords . t)
        (ess-R-fl-keyword:constants . t)
        (ess-R-fl-keyword:modifiers . t)
        (ess-R-fl-keyword:fun-defs . t)
        (ess-R-fl-keyword:assign-ops . t)
        (ess-R-fl-keyword:%op% . t)
        (ess-fl-keyword:fun-calls . t)
        (ess-fl-keyword:numbers . t)
        (ess-fl-keyword:operators . t)
        (ess-fl-keyword:delimiters . t)
        (ess-fl-keyword:= . t)
        (ess-R-fl-keyword:F&T . t)))
#+end_src

Lastly, in the event that I use =JAGS=, it would be nice to be able to use =jags= as
the language identifier, not =ess-jags=.
#+begin_src emacs-lisp
(after! org
  (add-to-list '+org-babel-mode-alist '(jags . ess-jags)))
#+end_src

**** ASCII export


To start with, why settle for ASCII when UTF-8 exists?
#+begin_src emacs-lisp
(setq org-ascii-charset 'utf-8)
#+end_src

The ASCII export is generally fairly nice. I think the main aspect that could
benefit from improvement is the appearance of LaTeX fragments. There's a nice
utility we can use to create unicode representation, which are much nicer.
It's called ~latex2text~, and it's part of the =pylatexenc= package, and it's [[https://repology.org/project/python:pylatexenc/versions][not
really packaged]]. So, we'll resort to installing it with =pip=.

#+begin_src shell :tangle (if (executable-find "latex2text") "no" "setup.sh")
sudo python3 -m pip install pylatexenc
#+end_src

With that installed, we can override the *src_elisp* {(org-ascii-latex-fragment)} and
*src-elisp*  {(org-ascii-latex-environment)} functions, which are conveniently very
slim --- just extracting the content, and indenting. We'll only do something
different when =utf-8= is set.

#+begin_src emacs-lisp
(when (executable-find "latex2text")
  (after! ox-ascii
    (defvar org-ascii-convert-latex t
      "Use latex2text to convert LaTeX elements to unicode.")

    (defadvice! org-ascii-latex-environment-unicode-a (latex-environment _contents info)
      "Transcode a LATEX-ENVIRONMENT element from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
      :override #'org-ascii-latex-environment
      (when (plist-get info :with-latex)
        (org-ascii--justify-element
         (org-remove-indentation
          (let* ((latex (org-element-property :value latex-environment))
                 (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                               org-ascii-convert-latex
                               (doom-call-process "latex2text" "-q" "--code" latex))))
            (if (= (car unicode) 0) ; utf-8 set, and sucessfully ran latex2text
                (cdr unicode) latex)))
         latex-environment info)))

    (defadvice! org-ascii-latex-fragment-unicode-a (latex-fragment _contents info)
      "Transcode a LATEX-FRAGMENT object from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
      :override #'org-ascii-latex-fragment
      (when (plist-get info :with-latex)
        (let* ((latex (org-element-property :value latex-fragment))
               (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                             org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
          (if (and unicode (= (car unicode) 0)) ; utf-8 set, and sucessfully ran latex2text
              (cdr unicode) latex))))))
#+end_src

**** Markdown Export
***** GFM


Because of the /[[https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors][lovely variety in markdown implementations]]/ there isn't actually
such a thing a standard table spec ... or standard anything really. Because
~org-md~ is a goody-two-shoes, it just uses HTML for all these non-standardised
elements (a lot of them). So ~ox-gfm~ is handy for exporting markdown with all the
features that GitHub has.

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! ox-gfm :pin "99f93011b069e02b37c9660b8fcb45dab086a07f")
#+end_src

#+begin_src emacs-lisp
(use-package! ox-gfm
  :after ox)
#+end_src

***** Character substitutions

When I want to paste exported markdown somewhere (for example when using [[Emacs Everywhere][Emacs
Everywhere]]), it can be preferable to have unicode characters for =---= etc. instead
of =&#x2014;=.

To accomplish this, we just need to locally rebind the alist which provides
these substitution.

#+begin_src emacs-lisp
(defadvice! org-md-plain-text-unicode-a (orig-fn text info)
  "Locally rebind `org-html-special-string-regexps'"
  :around #'org-md-plain-text
  (let ((org-html-special-string-regexps
         '(("\\\\-" . "-")
           ("---\\([^-]\\|$\\)" . "â€”\\1")
           ("--\\([^-]\\|$\\)" . "â€“\\1")
           ("\\.\\.\\." . "â€¦")
           ("<->" . "âŸ·")
           ("->" . "â†’")
           ("<-" . "â†"))))
    (funcall orig-fn text (plist-put info :with-smart-quotes nil))))
#+end_src

In the future, I may want to check =info= to only have this active when =ox-gfm= is
being used.

Another worthwhile consideration is LaTeX formatting. It seems most Markdown
parsers are fixated on TeX-style syntax (=$= and =$$=). As unfortunate as this is,
it's probably best to accommodate them, for the sake of decent rendering.

=ox-md= doesn't provide any transcoders for this, so we'll have to whip up our own
and push them onto the =md= transcoders alist.

#+begin_src emacs-lisp
(after! ox-md
  (defun org-md-latex-fragment (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to Markdown."
    (let ((frag (org-element-property :value latex-fragment)))
      (cond
       ((string-match-p "^\\\\(" frag)
        (concat "$" (substring frag 2 -2) "$"))
       ((string-match-p "^\\\\\\[" frag)
        (concat "$$" (substring frag 2 -2) "$$"))
       (t (message "unrecognised fragment: %s" frag)
          frag))))

  (defun org-md-latex-environment (latex-environment contents info)
    "Transcode a LATEX-ENVIRONMENT object from Org to Markdown."
    (concat "$$\n"
            (org-html-latex-environment latex-environment contents info)
            "$$\n"))

  (defun org-utf8-entity (entity _contents _info)
    "Transcode an ENTITY object from Org to utf-8.
CONTENTS are the definition itself.  INFO is a plist holding
contextual information."
    (org-element-property :utf-8 entity))

  ;; We can't let this be immediately parsed and evaluated,
  ;; because eager macro-expansion tries to call as-of-yet
  ;; undefined functions.
  ;; NOTE in the near future this shouldn't be required
  (eval
   '(dolist (extra-transcoder
             '((latex-fragment . org-md-latex-fragment)
               (latex-environment . org-md-latex-environment)
               (entity . org-utf8-entity)))
      (unless (member extra-transcoder (org-export-backend-transcoders
                                        (org-export-get-backend 'md)))
        (push extra-transcoder (org-export-backend-transcoders
                                (org-export-get-backend 'md)))))))
#+end_src

**** ORB - Org-Roam Bibtex

The package that allows us to search through bibliography files and take notes on them. Makes Org-Roam work better as a zettlekasten for academic research.

#+begin_src emacs-lisp :tangle no

(use-package! org-roam-bibtex
  :after org-roam
  :hook (org-mode . org-roam-bibtex-mode)
  :config
  (require 'org-ref)
  (setq orb-preformat-keywords
   '("citekey" "title" "url" "file" "author-or-editor" "keywords" "pdf" "doi" "author" "tags" "year" "author-bbrev")))
;)
#+end_src

**** Org-journal
#+begin_src emacs-lisp
(use-package org-journal
      ;; :defer t
      :bind
      ("C-c n j" . org-journal-new-entry)
      :custom
      (org-journal-dir "~/org/journal")
      (org-journal-date-prefix "#+TITLE: ")
      (org-journal-time-prefix "** ")
      (org-journal-file-format "%Y-%m-%d.org")
      (org-journal-date-format "%A, %d %B %Y"))
(setq org-journal-enable-agenda-integration t)
#+end_src

#+RESULTS:
: t

**** Org-publish
#+begin_src emacs-lisp
(setq org-publish-use-timestamps-flag nil)
(setq org-export-with-broken-links t)
(setq org-publish-project-alist
      '(("my.site"
         :base-directory "~/org/mysite/"
         :base-extension "org"
         :publishing-directory "~/org/mysite/html/"
         :recursive t
         :exclude "org-html-themes/.*"
         :with-author nil           ;; Don't include author name
         :with-author nil           ;; Don't include author name
         :with-creator t            ;; Include Emacs and Org versions in footer
         :with-toc t                ;; Include a table of contents
         :section-numbers nil       ;; Don't include section numbers
         :time-stamp-file nil   ;; Don't include time stamp in file
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t)
         ("org-static"
         :base-directory "~/org/website"
         :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
         :publishing-directory "~/public_html/"
         :recursive t
         :exclude ".*/org-html-themes/.*"
         :publishing-function org-publish-attachment)
      ))
;; Generate the site output
;; (org-publish-all t)

;; (message "Build complete!")



#+end_src

#+RESULTS:
: Build complete!

**** Ox-Hugo
I have recently started using =ox-hugo= to help post on my Hugo based website. The following section sets up an org-capture to enable quick blogging.
#+BEGIN_SRC elisp :tangle no
(defun org-hugo-new-subtree-post-capture-template ()
  "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
  (let* (;; http://www.holgerschurig.de/en/emacs-blog-from-org-to-hugo/
         (date (format-time-string (org-time-stamp-format  :inactive) (org-current-time)))
         (title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
         (fname (org-hugo-slug title)))
    (mapconcat #'identity
               `(
                 ,(concat "* TODO " title)
                 ":PROPERTIES:"
                 ,(concat ":EXPORT_FILE_NAME: " fname)
                 ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                 ,(concat ":EXPORT_HUGO_CUSTOM_FRONT_MATTER: "  ":tags something :subtitle booyea :featured false :categories abc :highlight true ")
                 ":END:"
                 "%?\n")          ;Place the cursor here
               "\n")))
(defvar hugo-org-path "/home/cantos/Dropbox/blog/sunny-website/org-content/"
  "define the place where we put our org files for hugo")
;;(defvar org-capture-blog (concat hugo-org-path "blog.org"))

(setq org-capture-templates
      '(
        ("h" "Hugo Post"
         entry
         (file+olp "/home/cantos/Dropbox/blog/sunny-website/org-content/blog.org" "Posts")
         (function  org-hugo-new-subtree-post-capture-template))))
#+END_SRC
**** improving the html output-file

At this point have a decent basic output for our website, but what if we want to make it look a little bit nicer?
By setting a few more variables, we can use a nice stylesheet to give our site a more polished look:

#+begin_src emacs-lisp :tangle no


;; Customize the HTML output
(setq org-html-validation-link nil            ;; Don't show validation link
      org-html-head-include-scripts nil       ;; Use our own scripts
      org-html-head-include-default-style nil ;; Use our own styles
      org-html-head "<link rel=\"stylesheet\" href=\"https://cdn.simplecss.org/simple.min.css\" />")

#+end_src

#+RESULTS:
: <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />

This will remove the default JavaScript and CSS code that gets injected into the HTML output by default and replace it with the link to a nice stylesheet called Simple.css (or a CSS file of your own!).

**** Org-ref settings

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-ref)

(setq reftex-default-bibliography '("~/Dropbox/Dissertation/library.bib"))
(setq org-ref-default-bibliography '("~/Dropbox/Dissertation/library.bib")
      org-ref-pdf-directory "~/Dropbox/Zotero/storage")
(setq org-ref-default-citation-link "citep")
(setq bibtex-dialect 'biblatex)
(defun my/org-ref-open-pdf-at-point ()
  "Open the pdf for bibtex key under point if it exists."
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
         (key (car results))
         (pdf-file (car (bibtex-completion-find-pdf key))))
    (if (file-exists-p pdf-file)
        (org-open-file pdf-file)
      (message "No PDF found for %s" key))))
(setq org-ref-open-pdf-function 'my/org-ref-open-pdf-at-point)
(setq bibtex-completion-pdf-field "file")
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator ""
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-titleword-separator ""
      bibtex-autokey-titlewords 0
      bibtex-autokey-titlewords-stretch 0
      bibtex-autokey-titleword-length 0)
(setq org-ref-notes-function 'orb-edit-notes)
(setq org-ref-note-title-format
  "* TODO %y -%t
 :PROPERTIES:
  :Custom_ID: %k
  :AUTHOR: %9a
  :JOURNAL: %j
  :VOLUME: %v
  :DOI: %D
  :URL: %U
 :END:

")
#+END_SRC

**** Bibtex-completion

#+BEGIN_SRC emacs-lisp :tangle no
(setq-default bibtex-completion-bibliography "~/Dropbox/Dissertation/library.bib")
(setq bibtex-completion-pdf-field "File")
(setq bibtex-completion-notes-path "~/Dropbox/org")
(setq bibtex-completion-notes-template-multiple-files
 (concat
  " ${title}\n"
  "#+ROAM_KEY: cite:${=key=}\n\n\n"
  "- tags ::\n"
  "- keywords :: ${keywords}\n\n"
  "* Meta information\n"
  ":PROPERTIES:\n"
  ":Custom_ID: ${=key=}\n"
  ":INTERLEAVE_PDF: %(orb-process-file-field \"${=key=}\")\n"
  ":AUTHOR: ${author-abbrev}\n"
  ":JOURNAL: ${journaltitle}\n"
  ":DATE: ${date}\n"
  ":YEAR: ${year}\n"
  ":DOI: ${doi}\n"
  ":URL: ${url}\n"
  ":END:\n\n"
  ))
#+END_SRC

**** Org-appt settings

#+BEGIN_SRC emacs-lisp :tangle no
(require 'appt)

(setq-default appt-display-mode-line t)
(appt-activate 1)
(org-agenda-to-appt 1)
(appt-check 1)
(setq appt-message-warning-time 60)
(setq appt-display-interval 900)
#+END_SRC

**** Org-roam-bibtex

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-roam-bibtex
  :after (org-roam)
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :config
  (setq orb-preformat-keywords
    '("=key=" "title" "url" "file" "author-or-editor" "keywords"))
  (setq orb-autokey-format "%A%y")
  (setq orb-pdf-scrapper-export-fields
    '("author" "editor" "title" "journal" "date"))
  (setq orb-templates
        '(("r" "ref" plain (function org-roam-capture--get-point)
           ""
           :file-name "${=key=}"
           :head "#+TITLE: ${title}\n
                  #+ROAM_KEY: ${ref}

- tags ::
- keywords :: ${keywords}\n

 * Meta information\n
        :PROPERTIES:\n
        :Custom_ID: ${=key=}\n
        :URL: ${url}\n
        :AUTHOR: ${author-or-editor}\n
        :INTERLEAVE_PDF: %(orb-process-file-field \"${=key=}\")\n
        :INTERLEAVE_PAGE_NOTE: \n
        :END:\n\n"

        :unnarrowed t)))
  :bind (:map org-mode-map
         (("C-c n a" . orb-note-actions))))
#+END_SRC

#+RESULTS:
: orb-note-actions

**** Org-roam-server

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-roam-server
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20)
  (defun org-roam-server-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (org-roam-server-mode 1)
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-server-port))))
#+END_SRC

** REVIEW Org fonts
- State "REVIEW"     from "HOLD"       [2022-10-16 Sun 13:23]
- State "HOLD"       from "READY"      [2022-10-16 Sun 13:22]
Distrotube  have created an interactive function for each color scheme (M-x dt/org-colors-*).  These functions will set appropriate colors and font attributes for org-level fonts and the org-table font.
#+begin_src emacs-lisp :tangle no

(defun dt/org-colors-doom-one ()
  "Enable Doom One colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#51afef" ultra-bold)
         (org-level-2 1.6 "#c678dd" extra-bold)
         (org-level-3 1.5 "#98be65" bold)
         (org-level-4 1.4 "#da8548" semi-bold)
         (org-level-5 1.3 "#5699af" normal)
         (org-level-6 1.2 "#a9a1e1" normal)
         (org-level-7 1.1 "#46d9ff" normal)
         (org-level-8 1.0 "#ff6c6b" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-dracula ()
  "Enable Dracula colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#8be9fd" ultra-bold)
         (org-level-2 1.6 "#bd93f9" extra-bold)
         (org-level-3 1.5 "#50fa7b" bold)
         (org-level-4 1.4 "#ff79c6" semi-bold)
         (org-level-5 1.3 "#9aedfe" normal)
         (org-level-6 1.2 "#caa9fa" normal)
         (org-level-7 1.1 "#5af78e" normal)
         (org-level-8 1.0 "#ff92d0" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-gruvbox-dark ()
  "Enable Gruvbox Dark colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#458588" ultra-bold)
         (org-level-2 1.6 "#b16286" extra-bold)
         (org-level-3 1.5 "#98971a" bold)
         (org-level-4 1.4 "#fb4934" semi-bold)
         (org-level-5 1.3 "#83a598" normal)
         (org-level-6 1.2 "#d3869b" normal)
         (org-level-7 1.1 "#d79921" normal)
         (org-level-8 1.0 "#8ec07c" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-monokai-pro ()
  "Enable Monokai Pro colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#78dce8" ultra-bold)
         (org-level-2 1.6 "#ab9df2" extra-bold)
         (org-level-3 1.5 "#a9dc76" bold)
         (org-level-4 1.4 "#fc9867" semi-bold)
         (org-level-5 1.3 "#ff6188" normal)
         (org-level-6 1.2 "#ffd866" normal)
         (org-level-7 1.1 "#78dce8" normal)
         (org-level-8 1.0 "#ab9df2" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-nord ()
  "Enable Nord colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#81a1c1" ultra-bold)
         (org-level-2 1.6 "#b48ead" extra-bold)
         (org-level-3 1.5 "#a3be8c" bold)
         (org-level-4 1.4 "#ebcb8b" semi-bold)
         (org-level-5 1.3 "#bf616a" normal)
         (org-level-6 1.2 "#88c0d0" normal)
         (org-level-7 1.1 "#81a1c1" normal)
         (org-level-8 1.0 "#b48ead" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-oceanic-next ()
  "Enable Oceanic Next colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#6699cc" ultra-bold)
         (org-level-2 1.6 "#c594c5" extra-bold)
         (org-level-3 1.5 "#99c794" bold)
         (org-level-4 1.4 "#fac863" semi-bold)
         (org-level-5 1.3 "#5fb3b3" normal)
         (org-level-6 1.2 "#ec5f67" normal)
         (org-level-7 1.1 "#6699cc" normal)
         (org-level-8 1.0 "#c594c5" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-palenight ()
  "Enable Palenight colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#82aaff" ultra-bold)
         (org-level-2 1.6 "#c792ea" extra-bold)
         (org-level-3 1.5 "#c3e88d" bold)
         (org-level-4 1.4 "#ffcb6b" semi-bold)
         (org-level-5 1.3 "#a3f7ff" normal)
         (org-level-6 1.2 "#e1acff" normal)
         (org-level-7 1.1 "#f07178" normal)
         (org-level-8 1.0 "#ddffa7" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-solarized-dark ()
  "Enable Solarized Dark colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#268bd2" ultra-bold)
         (org-level-2 1.6 "#d33682" extra-bold)
         (org-level-3 1.5 "#859900" bold)
         (org-level-4 1.4 "#b58900" semi-bold)
         (org-level-5 1.3 "#cb4b16" normal)
         (org-level-6 1.2 "#6c71c4" normal)
         (org-level-7 1.1 "#2aa198" normal)
         (org-level-8 1.0 "#657b83" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-solarized-light ()
  "Enable Solarized Light colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#268bd2" ultra-bold)
         (org-level-2 1.6 "#d33682" extra-bold)
         (org-level-3 1.5 "#859900" bold)
         (org-level-4 1.4 "#b58900" semi-bold)
         (org-level-5 1.3 "#cb4b16" normal)
         (org-level-6 1.2 "#6c71c4" normal)
         (org-level-7 1.1 "#2aa198" normal)
         (org-level-8 1.0 "#657b83" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

(defun dt/org-colors-tomorrow-night ()
  "Enable Tomorrow Night colors for Org headers."
  (interactive)
  (dolist
      (face
       '((org-level-1 1.7 "#81a2be" ultra-bold)
         (org-level-2 1.6 "#b294bb" extra-bold)
         (org-level-3 1.5 "#b5bd68" bold)
         (org-level-4 1.4 "#e6c547" semi-bold)
         (org-level-5 1.3 "#cc6666" normal)
         (org-level-6 1.2 "#70c0ba" normal)
         (org-level-7 1.1 "#b77ee0" normal)
         (org-level-8 1.0 "#9ec400" normal)))
    (set-face-attribute (nth 0 face) nil :font doom-variable-pitch-font :weight (nth 3 face) :height (nth 1 face) :foreground (nth 2 face)))
    (set-face-attribute 'org-table nil :font doom-font :weight 'normal :height 1.0 :foreground "#bfafdf"))

;; Load our desired dt/org-colors-* theme on startup
(dt/org-colors-doom-one)

#+end_src

#+RESULTS:
