 #+TITLE:Akhil's Doom Emacs Config
#+AUTHOR: Akhil Pratap Singh
#+DESCRIPTION: Akhil's personal Doom Emacs config.
#+STARTUP: fold
#+PROPERTY: header-args:emacs-lisp :tangle config.el

ABOUT THIS CONFIG
This is my personal Doom Emacs config.  Doom Emacs is a distribution of Emacs that uses the "evil" keybindings (Vim keybindings) and includes a number of nice extensions and a bit of configuration out of the box.  I am maintaining this config not just for myself, but also for those that want to explore some of what is possible with Emacs.  I will add a lot of examples of plugins and settings, some of them I may not even use personally.  I do this because many people following me on YouTube look at my configs as "documentation".

* Loading instructions
** Info
This is where you install packages, by declaring them with the ~package!~ macro in
=packages.el=, then running ~doom refresh~ on the command line.
This file shouldn't be byte compiled.
#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.


;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")


;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)

#+end_src

You'll then need to restart Emacs for your changes to take effect! Or at least,
run =M-x doom/reload=.

*Warning*: Don't disable core packages listed in =~/.emacs.d/core/packages.el=.
Doom requires these, and disabling them may have terrible side effects.

** packages
*** Packages in MELPA/ELPA/emacsmirror
To install ~some-package~ from MELPA, ELPA or emacsmirror:
#+begin_src emacs-lisp :tangle packages.el
 ;; After placing it, say myplugin.el to your ~/.emacs.d/ directory, add the following in your .emacs file:

;; (add-to-list 'load-path "~/.emacs.d/")
;; (load "myplugin.el")
;; Also, in many cases you would need the following instead of the second line:

;; (require 'myplugin)
  (package! easy-kill)
  (package! exotica-theme)
  (package! underwater-theme)
  (package! volatile-highlights)
  (package! shell-pop)
  (package! key-chord)
  (package! undo-tree)
  (package! recursion-indicator)
  (package! ibuffer-project)
  (package! ibuffer-vc)
  (package! kind-icon)
  (package! prism)
  (package! trashed)
  ;; (package! mpv)
  (package! moody)
  (package! ytel)
  (package! winum)
  (package! osm)
  (package! olivetti)
  (package! flymake-shellcheck)
  (package! flymake-proselint)
  (package! flymake-diagnostic-at-point)
  (package! package-lint-flymake)
  (package! desktop)
  (package! saveplace)
  (package! amx)
  (package! framemove)
  (package! edwina)
  (package! monkeytype)
  (package! hacker-typer)
  (package! pinentry)
  (package! org-modern)
  (package! openwith)
  (package! expand-region)
  (package! popper)
  ;; (package! telephone-line)
  ;; (package! ivy)
  ;; (package! ivy-prescient)
  ;; (package! ivy-hydra)
  ;; (package! ivy-rich)
  ;; (package! prescient)
  (package! counsel)
  (package! ranger)
  (package! minions)
  ;; (package! pulsar) ;;prots line blinker
  (package! diminish)
  ;; (package! perspective)
  (package! dired-single)
  (package! dired-collapse)
  (package! dired-ranger)
  (package! bufler)
  (package! corfu)
  (package! smart-mode-line)
  (package! flx)
  (package! simpleclip)
  (package! webpaste)
  (package! shackle)
  (package! versuri)
  (package! mentor)
  (package! google-translate)
  (package! mw-thesaurus)
  (package! elpher)
  (package! all-the-icons-ivy-rich)
  (package! transpose-frame)
  (package! bookmark)
  (package! beginend)
  ;; (package! drag-stuff)
  ;; (package! fast-scroll)
  (package! dired-subtree)
  (package! eshell-bookmark)
  (package! eshell-prompt-extras)
  (package! engine-mode)
  (package! all-the-icons-ivy)
  (package! wolfram)
  ;; (package! atomic-chrome)
  ;; (package! async)
  (package! calfw)
  (package! calfw-org)
  (package! dashboard)
  (package! dired-open)
  (package! dmenu)
  (package! elfeed-goodies)
  (package! emojify)
  (package! evil-tutor)
  (package! ivy-posframe)
  (package! ox-gemini)
  (package! pacmacs)
  (package! peep-dired)
  (package! password-store)
  (package! rainbow-mode)
  (package! resize-window)
  (package! tldr)
  (package! wc-mode)
  (package! exwm)
  (package! desktop-environment)
  (package! browse-url)
  ;; (package! hungry-delete)
  ;; (package! dimmer)
  ;; (package! goggles)
  ;; (package! which-func)
  (package! youtube-dl)
  (package! aurel)
  (package! speed-type)
  (package! boxquote)
  ;; (package! define-word)
  ;; (package! impatient-mode)
  (package! pdf-tools)
  ;; (package! popwin)
  ;; (package! pretty-mode)
  (package! systemd)
  ;; (package! google-maps)
  ;; (package! git-timemachine)
  ;; (package! elfeed)
  (package! org-pdfview)
  (package! xelb)
  ;; (package! buffer-move)
  (package! exwm-edit)
  (package! emms)
  (package! page-break-lines)
  ;; (package! org-roam-server)
  ;; (package! org-ref)
  (package! nov)
  ;; (package! dired-narrow)
  ;; (package! lsp-treemacs)
  (package! multi-vterm)
  ;; (package! aggressive-indent)
  (package! cloc)
  (package! yahtzee)
  (package! sudoku)
  (package! 2048-game)
  (package! auth-source)
  (package! chess)

  (package! gitconfig-mode
	    :recipe (:host github :repo "magit/git-modes"
			   :files ("gitconfig-mode.el")))
  (package! gitignore-mode
	    :recipe (:host github :repo "magit/git-modes"
			   :files ("gitignore-mode.el")))
#+end_src

*** Packages from git repositories
To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp :tangle packages.el
;; (package! bufler
;;   :recipe (:host github
;;            :repo "alphapapa/bufler.el"
;;            :files (:defaults (:exclude "helm-bufler.el"))))
;; Make Elisp files in that directory available to the user.
(add-to-list 'load-path "~/.config/doom/lisp/")
(package! kbd-mode
  :recipe (:host github
           :repo "kmonad/kbd-mode"))
(package! exwm-mff :recipe (:host github :repo "ieure/exwm-mff" :branch "main"))
;; (package! exwm-firefox-core :recipe (:host github :repo "walseb/exwm-firefox-core" :branch "master"))
;; (package! vulpea :recipe (:host github :repo "d12frosted/vulpea" :branch "master"))
(package! nano-emacs
  :recipe (:host github :repo "rougier/nano-emacs"))
(package! telega
  :recipe (:host github :repo "zevlg/telega.el"))
(package! mathpix.el
  :recipe (:host github :repo "jethrokuan/mathpix.el"))
(package! telega
  :recipe (:host github :repo "zevlg/telega.el"))
(package! mct
  :recipe (:host github :repo "protesilaos/mct"))
(package! gitignore-mode
    :recipe (:host github :repo "magit/git-modes"
       :files ("gitignore-mode.el")))
(package! cape
    :recipe (:host github :repo "minad/cape"
       :files ("cape.el")))

(package! pulsar
    :recipe (:host github :repo "protesilaos/pulsar"
       :files ("pulsar.el")))
(package! tmr
    :recipe (:host github :repo "protesilaos/tmr.el"
       :files ("tmr.el")))
(package! usls
    :recipe (:host github :repo "protesilaos/usls"
       :files ("usls.el")))
(package! lin
    :recipe (:host github :repo "protesilaos/lin"
       :files ("lin.el")))
(package! logos
    :recipe (:host github :repo "protesilaos/logos"
       :files ("logos.el")))

;; (package! another-package
;;   :recipe (:host github :repo "username/repo"))
#+end_src

#+RESULTS:
| vertico | :modules | ((:private . config) (:private . modules)) | :recipe | (:host github :repo minad/vertico) |

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:
#+begin_src emacs-lisp :tangle no

;; (package! discover :recipe (:host github :repo "mickeynp/discover.el"))
;; (package! xah-fly-keys :recipe (:host github :repo "xahlee/xah-fly-keys"))
;; (package! maple-iedit :recipe (:host github :repo "honmaple/emacs-maple-iedit"))
;; (package! ctrlf :recipe (:host github :repo "raxod502/ctrlf"))
;; (package! scrollkeeper :recipe (:host github :repo "alphapapa/scrollkeeper.el"))
;; (package! awesome-tab :recipe (:host github :repo "manateelazycat/awesome-tab"))
;; (package! ob-session-async :recipe (:host github :repo "jackkamm/ob-session-async"))
;; (package! maple-explorer :recipe (:host github :repo "honmaple/emacs-maple-explorer"))
;; (package! sunrise-commander :recipe (:host github :repo "sunrise-commander/sunrise-commander"))
;; (package! awesome-pair :recipe (:host github :repo "manateelazycat/awesome-pair"))
;; (package! eaf :recipe (:host github
;;                             :repo "manateelazycat/emacs-application-framework"
;;                             :files ("*")
;;                             :no-byte-compile t))
;; (package! this-package
  ;; :recipe (:host github :repo "username/repo"
           ;; :files ("some-file.el" "src/lisp/*.el")))
#+end_src

*** Disabling built-in packages
If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
#+begin_src emacs-lisp :tangle no
(package! builtin-package :recipe (:branch "develop"))
#+end_src
* Desktop Configuration
** Personal Information
It's useful to have some basic personal information
#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
;;    let's get encryption established
    (setenv "GPG_AGENT_INFO" nil)  ;; use emacs pinentry
    (setq auth-source-debug t)

    (setq epg-gpg-program "gpg2")  ;; not necessary
    (require 'epa-file)
    (epa-file-enable)
    (setq epa-pinentry-mode 'loopback)
    (setq epg-pinentry-mode 'loopback)
    (pinentry-start)

    (require 'org-crypt)
    (org-crypt-use-before-save-magic)
#+END_SRC

#+RESULTS:

#+begin_src emacs-lisp
(setq user-full-name "Akhil Pratap Singh"
      user-mail-address "akhilpratapsingh3417@gmail.com")
#+end_src

#+RESULTS:
: akhilpratapsingh3417@gmail.com

Apparently this is used by ~GPG~, and all sorts of other things.

Speaking of ~GPG~, I want to use =~/.authinfo.gpg= instead of the default in
=~/.emacs.d=. Why? Because my home directory is already cluttered, so this won't
make a difference, and I don't want to accidentally purge this file I have done
src_shell{rm -rf~/.emac.d~ before}. I also want to cache as much as possible, as
my home machine is pretty safe, and my laptop is shutdown a lot.
#+begin_src emacs-lisp
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil) ; default is 7200 (2h)
#+end_src

#+RESULTS:
** directories
#+begin_src emacs-lisp
(setq my/home-dir "/home/shiva/")
(setq my/sync-base-dir (concat my/home-dir "Sync/"))
(setq my/work-base-dir (concat my/home-dir "Work/"))
(setq my/media-base-dir (concat my/home-dir "Media/"))
#+end_src

#+RESULTS:
: /home/shiva/Media/

** org
#+begin_src emacs-lisp
(setq org-directory my/sync-base-dir
      org-roam-directory "/home/shiva/Sync/org-roam2/"
      org-roam-db-location (concat org-roam-directory "org-roam.db")
      my/org-roam-todo-file (concat org-roam-directory "orgzly/todo.org"))

(save-window-excursion
  (find-file my/org-roam-todo-file)
  (save-buffer))
#+end_src

#+RESULTS:

** Basic setup.ui
#+begin_src emacs-lisp
;; -*- lexical-binding: t -*-
(add-to-list 'load-path "~/.config/doom/lisp/")
(load "prot-common.el")
(load "setup-ui.el")
(load "better-buffers.el")
;; (load "setup-ibuffer.el")
;; (load "setup-corfu.el")
(load "setup-marginalia.el")
(load "setup-orderless.el")
(load "setup-vertico.el")
(load "setup-embark.el")
(load "setup-consult.el")
;; (load "setup-email.el")
;; (load "setup-elfeed.el")


;; (load "setup-email.el")

;; (load "setup-elfeed.el")

;; (load "setup-eww.el")
;; (require 'setup-eww)

(load "setup-ytel.el")

;; ytel provides an elfeed-like interface to search invidious instances for
;; youtube videos. Phew. The churn rate of Invidious urls is quite high, which
;; makes this flaky, but anything's better than the browser interface to
;; Youtube.

#+end_src


#+RESULTS:
: t
** Simple settings
Browsing the web and seeing [[https://github.com/angrybacon/dotemacs/blob/master/dotemacs.org#use-better-defaults][angrybacon/dotemacs]] and comparing with the values
shown by =SPC h v= and selecting what I thought looks good, I've ended up adding
the following:

#+begin_src emacs-lisp
(setq-default
 delete-by-moving-to-trash t                      ; Delete files to trash
 window-combination-resize t                      ; take new window space from all other windows (not just current)
 x-stretch-cursor t)                              ; Stretch cursor to the glyph width

(setq undo-limit 80000000                         ; Raise undo-limit to 80Mb
      evil-want-fine-undo t                       ; By default while in insert all changes are one big blob. Be more granular
      auto-save-default t                         ; Nobody likes to loose work, I certainly don't
      truncate-string-ellipsis "…"                ; Unicode ellispis are nicer than "...", and also save /precious/ space
      password-cache-expiry nil                   ; I can trust my computers ... can't I?
      ;; scroll-preserve-screen-position 'always     ; Don't have `point' jump around
      scroll-margin 2)                            ; It's nice to maintain a little margin

(display-time-mode 1)                             ; Enable time in the mode-line

(unless (string-match-p "^Power N/A" (battery))   ; On laptops...
  (display-battery-mode 1))                       ; it's nice to know how much power you have

(global-subword-mode 1)                           ; Iterate through CamelCase words

;; Underline looks a bit better when drawn lower
(setq x-underline-at-descent-line t)
#+end_src

#+RESULTS:
: t

** Auto-customisations
By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.
#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-private-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

#+RESULTS:

** Rudimentry Settings
#+begin_src emacs-lisp

;; show the matching parenthesis when the cursor is above one of them.
(setq show-paren-delay 0)
;; (show-paren-mode t)
;; Keybindings for scaling text (although hydra function exists)
;; (global-set-key (kbd "C-=") 'text-scale-increase)
;; (global-set-key (kbd "C--") 'text-scale-decrease)

(global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
(global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)

;; Hydra allows for good keybindings for repetitive tasks
(use-package hydra)
;; (use-package ivy-hydra)

(defhydra hydra-text-scale (:timeout 4) ; Change the size of text
  "scale text"
  ("j" text-scale-increase "inc")
  ("k" text-scale-decrease "dec")
  ("q" nil "finished" :exit t))

(defhydra hydra-cycle-buffers (:timeout 4) ; Cycle through buffers, killing uneccessary ones
  "cycle buffers"
  ("j" next-buffer "next")
  ("k" previous-buffer "prev")
  ("SPC" kill-current-buffer "kill")
  ("q" nil "quit" :exit t))

;; EXWM Functions:
;; (defun max/exwm-update-class ()
;;   (exwm-workspace-rename-buffer exwm-class-name))

;; (defun max/exwm-init-hook ()
;;   (exwm-workspace-switch-create 1)) ; Start on workspace 1, not 0



;; (global-set-key (kbd "<M-tab>") 'evil-window-next)
;; (global-set-key (kbd "<s-right>") 'evil-window-right)
;; (global-set-key (kbd "<s-up>") 'evil-window-up)
;; (global-set-key (kbd "<s-down>") 'evil-window-down)
;; (global-set-key (kbd "<s-left>") 'evil-window-left)
;; This hydra function allows for control of volume

(defhydra hydra-volume-up (:timeout 4)
  "Configure Volume"
  ;; ("j" desktop-environment-volume-normal-increment (<XF86AudioRaiseVolume>))
  ;; ("k" desktop-environment-volume-normal-decrement (<XF86AudioLowerVolume>))
  ("j" emms-volume-lower)
  ("k" emms-volume-raise)
  ("q" nil "quit" :exit t))
;; This hydra function allows for control of brightness
(defhydra hydra-brightness-up (:timeout 4)
  "Configure Brightness"
  ("j" desktop-environment-brightness-normal-increment "up")
  ("k" desktop-environment-brightness-normal-decrement "down")
  ("q" nil "quit" :exit t))

;; (delete-selection-mode 1)
;;delete all the whitespace
;; (use-package hungry-delete
;;   :ensure t
;;   :defer t
;;   :init
;;   (global-hungry-delete-mode 1))

;; Move current line or region with M-up or M-down.

;; browser settings
;; (setq browse-url-browser-function 'eaf-open-browser)
;; (defalias 'browse-web #'eaf-open-browser)
;; (setq browse-url-browser-function 'browse-url-generic
;;       browse-url-generic-program "firefox")
;; (setq browse-url-browser-function 'browse-url-generic
;;       browse-url-generic-program "qutebrowser")
;; (set-fringe-mode 10)        ; Give some breathing room
;; (global-set-key (kbd "<escape>") 'keyboard-escape-quit)

#+end_src

#+RESULTS:
: hydra-brightness-up/body

* Exwm Config
** Exwm
#+begin_src emacs-lisp
  (require 'exwm)
  ;; using xim input
  (require 'exwm-xim)
  (exwm-xim-enable)
  (push ?\C-\\ exwm-input-prefix-keys)   ;; use Ctrl + \ to switch input method
#+END_SRC

#+begin_src emacs-lisp

(setq-default tab-width 2)
(setq-default evil-shift-width tab-width);; Window manager
(setq-default indent-tabs-mode nil)
(use-package exwm
  :init
  (setq mouse-autoselect-window nil
        focus-follows-mouse t
        exwm-workspace-warp-cursor t
        exwm-workspace-number 5)
                                        ;exwm-workspace-display-echo-area-timeout 5
                                        ;exwm-workspace-minibuffer-position 'bottom) ;; Annoying focus issues
  :config

;; (defun exwm/init-exwm ()
;;   (use-package exwm
;;     :init
;;     ;; Disable dialog boxes since they are unusable in EXWM
;;     (setq use-dialog-box nil)
;;     ;; You may want Emacs to show you the time
;;     (display-time-mode t)
;;     (when exwm-hide-tiling-modeline
;;       (add-hook 'exwm-mode-hook #'hidden-mode-line-mode))
;;     (setq exwm-input-line-mode-passthrough t)))

(defun exwm//persp-mode-inhibit-p (frame)
  (frame-parameter frame 'unsplittable))

  (defun efs/exwm-update-class ()
    (add-hook 'exwm-update-class-hook #'efs/exwm-update-class
              (lambda ()
                (exwm-workspace-rename-buffer exwm-class-name)))
    (add-hook 'exwm-update-title-hook #'efs/exwm-update-title
              (lambda ()
                (pcase exwm-class-name
                  ("Vimb" (exwm-workspace-rename-buffer (format "vimb: %s" exwm-title)))
                  ("firefoxdeveloperedition" (exwm-workspace-rename-buffer (format "FirefoxD: %s" exwm-title)))
                  ("qutebrowser" (exwm-workspace-rename-buffer (format "#F %s" exwm-title)))))))

  (defun exwm/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

  (defun exwm/bind-function (key invocation &rest bindings)
    "Bind KEYs to FUNCTIONs globally"
    (while key
      (exwm-input-set-key (kbd key)
                          `(lambda ()
                             (interactive)
                             (funcall ',invocation)))
      (setq key (pop bindings)
            invocation (pop bindings))))

  (defun exwm/bind-command (key command &rest bindings)
    "Bind KEYs to COMMANDs globally"
    (while key
      (exwm-input-set-key (kbd key)
                          `(lambda ()
                             (interactive)
                             (exwm/run-in-background ,command)))
      (setq key (pop bindings)
            command (pop bindings))))

;; Simulate insert state by using line mode without passthrough
(defun exwm/enter-insert-state ()
  (interactive)
  (setq exwm-input-line-mode-passthrough nil)
  (call-interactively 'exwm-input-grab-keyboard)
  (evil-insert-state))

;; Simulate normal state by using line mode with passthrough, i.e. forward all commands to emacs
(defun exwm/enter-normal-state ()
  (interactive)
  (setq exwm-input-line-mode-passthrough t)
  (call-interactively 'exwm-input-grab-keyboard)
  (evil-normal-state))

(defun exwm/escape ()
  "Switch to normal state, and cancel possible fullscreen layout.  Also close minibuffer."
  (interactive)
  (exwm/enter-normal-state)
  (exwm-layout-unset-fullscreen)
  (when (active-minibuffer-window)
    (minibuffer-keyboard-quit)))

(defun exwm/enter-char-mode ()
  "Enter EXWM char mode."
  (interactive)
  (when exwm--id
    (exwm/enter-insert-state)
    ;; (exwm-input-toggle-keyboard)
    (call-interactively 'exwm-input-release-keyboard)))
  (defun efs/exwm-init-hook ()
    ;; Make workspace 1 be the one where we land at startup
    (exwm-workspace-switch-create 1)
    (defun exwm/run-vimb ()
      (exwm/run-in-background "vimb")
      (exwm-workspace-switch-create 2))

    (defun exwm/run-qute ()
      (exwm/run-in-background "qutebrowser")
      (exwm-workspace-switch-create 2))
    ;; (eshell)
    ;; (exwm/run-in-background "syncthing-gtk --minimized")
    ;; (exwm/run-in-background "udiskie -t")
    ;; (exwm/run-in-background "redshift -l 47.675510:-122.203362 -t 6500:3500"))
    ;; Set up perspective names on initial workspaces
    (exwm-workspace-switch-create 0)
    (persp-switch "Chat")

    ;; Launch Telega in workspace 0 if we've logged in before
    (when (file-exists-p "~/.telega/db.sqlite")
      (telega nil))

    (persp-kill "Main")
    (exwm-workspace-switch-create 1)
    (exwm-workspace-switch-create 2)
    (persp-switch "Browsers")
    (persp-kill "Main")
    (exwm-workspace-switch-create 3)
    (persp-switch "Comms")
    (persp-kill "Main")
    (exwm-workspace-switch-create 4)
    (persp-switch "Media")
    (persp-kill "Main")
    (efs/start-panel)
    ;; Launch apps that will run in the background
    (exwm/run-in-background "dunst")
    (exwm/run-in-background "nm-applet")
    (exwm/run-in-background "pasystray")
    (exwm/run-in-background "blueman-applet")
    (exwm/run-in-background "volumeicon"))
  (use-package exwm
    :config

    ;; (add-hook 'exwm-mode-hook
    ;;           (lambda ()
    ;;             (evil-local-set-key 'motion (kbd "C-u") nil)))

    (defun dw/setup-window-by-class ()
      (interactive)
      (pcase exwm-class-name
        ("Pidgin" (exwm-workspace-move-window 0))
        ("Pidgin<2>" (exwm-workspace-move-window 0))
        ("discord" (exwm-workspace-move-window 3))
        ("Microsoft Teams - Preview" (exwm-workspace-move-window 3))
        ("Spotify" (exwm-workspace-move-window 4))
        ("Vimb" (exwm-workspace-move-window 2))
        ("qutebrowser" (exwm-workspace-move-window 2)
                                ;; (exwm-layout-toggle-mode-line)
                                (exwm-workspace-toggle-minibuffer))
        ("firefoxdeveloperedition" (exwm-workspace-move-window 2)
                                (exwm-layout-toggle-mode-line))
        ("qjackctl" (exwm-floating-toggle-floating))
        ("mpv" (exwm-floating-toggle-floating)
         (exwm/position-window))
        ("gsi" (exwm-input-toggle-keyboard)))

    ;; position a window
    (defun exwm/position-window ()
      (let* ((pos (frame-position))
             (pos-x (car pos))
             (pos-y (cdr pos)))

        (exwm-floating-move (- pos-x) (- pos-y)))))
    ;; Manipulate windows as they're created
    (add-hook 'exwm-manage-finish-hook
              (lambda ()
                ;; Send the window where it belongs
                (dw/setup-window-by-class)))

    ;; Hide the modeline on all X windows
                                        ;(exwm-layout-hide-mode-line)))

    ;; Hide the modeline on all X windows
    (add-hook 'exwm-floating-setup-hook
              (lambda ()
                (exwm-layout-hide-mode-line))))

  (defun efs/set-wallpaper ()
    (interactive)
    ;; NOTE: You will need to update this to a valid background path!
    (start-process-shell-command
     "feh" nil  "feh --bg-scale /usr/share/backgrounds/dtos-backgrounds/3JWY37f.jpg"))
  (efs/set-wallpaper)

  (set-frame-parameter (selected-frame) 'alpha '(95 . 80))
  (add-to-list 'default-frame-alist '(alpha . (95 . 80)))
  (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))


  (setq-default my/exwm--do-not-mass-kill nil)
  (defun my/exwm-toggle-or-set-buffer-protection (&optional arg value)
    "Toggle or set EXWM mass-buffer-deletion protection.
When called interactively, toggle. Otherwise set to VALUE."
    (interactive "p")
    (when (derived-mode-p 'exwm-mode)
      (if arg
          (progn
            (if my/exwm--do-not-mass-kill
                (kill-local-variable 'my/exwm--do-not-mass-kill)
              (setq-local my/exwm--do-not-mass-kill t))
            (when arg
              (message "EXWM buffer protection set to %s" my/exwm--do-not-mass-kill)))
        (setq-local my/exwm--do-not-mass-kill value))))
  (defun my/exwm-kill-unprotected-by-prefix (prefix)
    "Kill all EXWM buffers with PREFIX that have `my/exwm--do-not-mass-kill' set to nil."
    (interactive "sPrefix: ")
    (dolist (buf (buffer-list (current-buffer)))
      (with-current-buffer buf
        (when
            (and
             (eq major-mode 'exwm-mode)
             (string-prefix-p (concat prefix "#") (buffer-name))
             (not my/exwm--do-not-mass-kill))
          (kill-buffer)))))

  (defun my/exwm--format-window-title-firefox (title &optional length)
    "Removes noise from and trims Firefox window titles.
Assumes the Add URL to Window Title extension is enabled and
configured to use @ (at symbol) as separator."
    (let* ((length (or length 45))
           (title (concat "F# " (replace-regexp-in-string " [-—] Firefox Developer Edition$" "" title)))
           (title-and-hostname (split-string title "@" nil " "))
           (hostname (substring (car (last title-and-hostname)) 0 -1))
           (page-title (string-join (reverse (nthcdr 1 (reverse title-and-hostname))) " "))
           (short-title (reverse (string-truncate-left (reverse page-title) length))))
      (if (length> title-and-hostname 1)
          (concat short-title " @ " hostname)
        (reverse (string-truncate-left (reverse title) length)))))
  ;; to disable simulation keys for whtever
;; (add-hook 'exwm-manage-finish-hook
;;           (lambda ()
;;             (when (and exwm-class-name
;;                        (string= exwm-class-name "Firefox"))
;;               (exwm-input-set-local-simulation-keys nil))))

  (defun efs/exwm-update-class ()
    (exwm-workspace-rename-buffer exwm-class-name))

  (defun efs/exwm-update-title ()
    (pcase exwm-class-name
      ("firefoxdeveloperedition" (exwm-workspace-rename-buffer (format "F# %s" exwm-title)))))
  (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

  (defun efs/exwm-update-title ()
    (pcase exwm-class-name
      ("qutebrowser" (exwm-workspace-rename-buffer (format "F# %s" exwm-title)))))
  (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)
  ;; position a window
  (defun efs/position-window ()
    (let* ((pos (frame-position))
           (pos-x (car pos))
           (pos-y (cdr pos)))

      (exwm-floating-move (- pos-x) (- pos-y))))

  (add-hook 'exwm-mode-hook
            (lambda ()
              (evil-local-set-key 'motion (kbd "C-u") nil)))


  ;; (defun efs/configure-window-by-class ()
  ;;   (interactive)
  ;;   (message "Window '%s' appeared!" exwm-class))
                                        ; This function isn't currently used, only serves as an example how to
  ;; here uxrvt

  (use-package! exwm-mff
    :config
    (add-hook 'exwm-mode-hook 'exwm-mff-mode))


  (defun zackteo/launch (command)
    (interactive (list (read-shell-command "$ ")))
    (start-process-shell-command command nil command))

  (defun zackteo/screen-to-clipboard ()
    (interactive  )
    (shell-command
     (concat "bash -c 'FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME"
             " && xclip $FILENAME -selection clipboard "
             "-t image/png &> /dev/null && rm $FILENAME'"))
    (message "Added to clipboard."))

  (defun zackteo/flameshot ()
    (interactive)
    (shell-command "flameshot gui"))

  (define-ibuffer-column exwm-class (:name "Class")
    (if (bound-and-true-p exwm-class-name)
        exwm-class-name
      ""))
  (define-ibuffer-column exwm-instance (:name "Instance")
    (if (bound-and-true-p exwm-instance-name)
        exwm-instance-name
      ""))
  (define-ibuffer-column exwm-urgent (:name "U")
    (if (bound-and-true-p exwm--hints-urgency)
        "U"
      " "))
  ;; Set the default number of workspaces
  (setq exwm-workspace-number 7)
  ;; When window "class" updates, use it to set the buffer name
  (add-hook 'exwm-update-class-hook #'efs/exwm-update-class)

  ;; When window title updates, use it to set the buffer name
  (add-hook 'exwm-update-title-hook #'efs/exwm-update-title)

  ;; Configure windows as they're created
  ;; (add-hook 'exwm-manage-finish-hook #'efs/configure-window-by-class)

  ;; When EXWM starts up, do some extra confifuration
  (add-hook 'exwm-init-hook #'efs/exwm-init-hook)

  ;; Rebind CapsLock to Ctrl
  ;; (start-process-shell-command "xmodmap" nil "xmodmap ~/.config/doom/exwm/Xmodmap")

  ;; NOTE: Uncomment the following two options if you want window buffers
  ;;       to be available on all workspaces!

  ;; Automatically move EXWM buffer to current workspace when selected
  ;; (setq exwm-layout-show-all-buffers t)

  ;; Display all EXWM buffers in every workspace buffer list
  ;; (setq exwm-workspace-show-all-buffers t)

  (setq exwm-workspace-switch-create-limit 9)

  ;; (setq exwm-debug-on t)

  ;; NOTE: Uncomment this option if you want to detach the minibuffer!
  ;; Detach the minibuffer (show it with exwm-workspace-toggle-minibuffer)
  ;; (setq exwm-workspace-minibuffer-position 'top)

  ;; NOTE: This is disabled because we now use Polybar!
  ;; Load the system tray before exwm-init
  (require 'exwm-systemtray)
  (setq exwm-systemtray-height 16)
  (exwm-systemtray-enable)

  ;; Automatically send the mouse cursor to the selected workspace's display
  (setq exwm-workspace-warp-cursor t)
  ;; Window focus should follow the mouse pointer
  (setq mouse-autoselect-window t
        focus-follows-mouse t)
  ;; ;; Don't override any keybindings in line-mode
  ;; (setq exwm-input-prefix-keys '())
  (defun my/exwm--format-window-title-urxvt (title)
    "Removes noise from URxvt window titles."
    (concat "U# " (replace-regexp-in-string ":.*$" "" title)))

  (defun my/exwm--format-window-title-alacritty (title)
    "Removes noise from URxvt window titles."
    (concat "U# " (replace-regexp-in-string ":.*$" "" title)))


  (defun my/exwm--format-window-title-st (title)
    "Removes noise from URxvt window titles."
    (concat "U# " (replace-regexp-in-string ":.*$" "" title)))

  (defun my/exwm--format-window-title-* (title)
    "Removes annoying notifications counters."
    (string-trim (replace-regexp-in-string "([[:digit:]]+)" "" title)))

  (defun my/exwm-buffer-name ()
    "Guesses (and formats) the buffer name using the class of the X client."
    (let ((title (my/exwm--format-window-title-* exwm-title))
          (formatter (intern
                      (format "my/exwm--format-window-title-%s"
                              (downcase exwm-class-name)))))
      (if (fboundp formatter)
          (funcall formatter title)
        title)))
  ;; Undo window configurations
  (exwm-input-set-key (kbd "s-u") #'winner-undo)
  (exwm-input-set-key (kbd "s-U") #'winner-redo)
  ;; ;; Focusing windows
  ;; (exwm-input-set-key (kbd "s-h") #'evil-window-left)
  ;; (exwm-input-set-key (kbd "s-j") #'evil-window-down)
  ;; (exwm-input-set-key (kbd "s-k") #'evil-window-up)
  ;; (exwm-input-set-key (kbd "s-l") #'evil-window-right)
  ;; ;; Moving Windows
  (exwm-input-set-key (kbd "s-t") #'toggle-window-split)
  (exwm-input-set-key (kbd "s-s") #'swap-windows)
  (exwm-input-set-key (kbd "s-h") #'next-user-buffer)
  (exwm-input-set-key (kbd "s-a") #'previous-user-buffer)
  (exwm-input-set-key (kbd "s-H") #'+evil/window-move-left)
  (exwm-input-set-key (kbd "s-J") #'+evil/window-move-down)
  (exwm-input-set-key (kbd "s-K") #'+evil/window-move-up)
  (exwm-input-set-key (kbd "s-L") #'+evil/window-move-right)
  ;; Resize
  ;; (exwm-input-set-key (kbd "M-s-h") #'exwm-layout-shrink-window-horizontally)
  (exwm-input-set-key (kbd "M-s-l") #'exwm-layout-enlarge-window-vertically)
  (exwm-input-set-key (kbd "M-s-j") #'exwm-layout-enlarge-window)
  (exwm-input-set-key (kbd "M-s-k") #'exwm-layout-shrink-window)
  (exwm-input-set-key (kbd "s-o") #'doom/window-maximize-buffer)
  (exwm-input-set-key (kbd "s-C-l") #'doom/window-maximize-horizontally)
  (exwm-input-set-key (kbd "s-C-U") #'doom/window-maximize-vertically)
  ;; Workspaces
  (exwm-input-set-key (kbd "s-]") #'exwm/workspace-next)
  (exwm-input-set-key (kbd "s-[") #'exwm/workspace-prev)
  (exwm-input-set-key (kbd "s-}") #'exwm/workspace-move-buffer-next)
  (exwm-input-set-key (kbd "s-{") #'exwm/workspace-move-buffer-prev)
  ;; (exwm-input-set-key (kbd "s-v") #'evil-window-vsplit)
  ;; (exwm-input-set-key (kbd "s-z") #'evil-window-split)
  (exwm-input-set-key (kbd "s-W") #'exwm-workspace-swap)
  (exwm-input-set-key (kbd "s-C-w") #'exwm-workspace-move)
  (exwm-input-set-key (kbd "<s-return>") #'eshell)
  (exwm-input-set-key (kbd "<s-S-return>") #'dmenu)
  ;; (exwm-input-set-key (kbd "s-C") #'kill-current-buffer)
 (global-set-key (kbd "s-q") 'kill-buffer-and-window)
  (exwm-input-set-key (kbd "s-C-h") #'evil-window-move-far-right)
  (exwm-input-set-key (kbd "s-C-l") #'evil-window-move-far-left)
  (exwm-input-set-key (kbd "s-c") #'exwm-input-toggle-keyboard)
  ;; (exwm-input-set-key (kbd "s-c") #'exwm-input-toggle-keyboard)
  ;; ;; (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;; ;; (exwm-input-set-key (kbd "s-f") #'my/toggle-single-window)
  (exwm-input-set-key (kbd "s-F") #'exwm-toggle-floating-window)
  (exwm-input-set-key (kbd "s-m") #'exwm-layout-toggle-mode-line)
  (exwm-input-set-key (kbd "<f11>") #'exwm-layout-toggle-fullscreen)
  (exwm-input-set-key (kbd "s-C-r") #'resize-window)
  (exwm-input-set-key (kbd "<C-escape>") #'consult-buffer)
  (exwm-input-set-key (kbd "C-c o") #'consult-buffer-other-window)
  ;; (exwm-input-set-key (kbd "s-I") #'evil-window-delete)
  (exwm-input-set-key (kbd "s-'") #'hydra-text-scale/body)
  (exwm-input-set-key (kbd "s-.") #'hydra-cycle-buffers/body)
  ;; (exwm-input-set-key (kbd "s-,") #'exwm-window-resize/body)
  (exwm-input-set-key (kbd "C-c x") #'exwm/escape)
  (exwm-input-set-key (kbd "C-c X") #'exwm/enter-insert-state)
  (exwm-input-set-key (kbd "s-d") 'counsel-linux-app)
  ;; Autorandr
  ;; ;; Ctrl+Q will enable the next key to be sent directly
  (define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

  (global-set-key (kbd "s-n") 'counsel-network-manager)
  ;; ;; Set up global key bindings.  These always work, no matter the input state!
  ;; Keep in mind that changing this list after EXWM initializes has no effect.
  ;; Workspace switching
  (exwm-input-set-key (kbd "C-?") #'execute-extended-command)
  ;; (setq exwm-input-simulation-keys
  ;;       '(
  ;;         ([?\C-y] . [?\C-v])))

  (setq exwm-input-simulation-keys
        ;; '(
        ;;   ([?\C-y] . [?\C-v])))


        '(([C-u] . [C-u])       ; multiplier, doesn't need to be here but reminder
          ;; movement TODO add more more text like jump para
          ([?\C-b] . [left])
          ([?\M-b] . [C-left])
          ([?\C-f] . [right])
          ([?\M-f] . [C-right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])
          ([?\C-a] . [home]) ;; to change??
          ([?\C-e] . [end])
          ([?\C-v] . [next])
          ([?\M-v] . [prior])
          ([?\M-<] . [C-home])
          ([?\M->] . [C-end])
          ;; delete
          ([?\C-d] . [delete])
          ([?\M-d] . [C-delete])
          ;; kill/cut/copy/paste/selection
          ([?\C-k] . [S-end C-x])
          ([?\C-w] . [?\C-x])
          ([?\M-w] . [?\C-c])
          ([?\C-y] . [?\C-v])             ; Add C-S-V ?
          ([?\s-a] . [?\C-a])             ; should it be s-h cause C-x h
          ([?\s-h] . [?\C-a])             ; just both lmao
          ;; undo/redo
          ([?\C-/] . [?\C-z])
          ([?\C-?] . [?\C-y])             ; redo
          ;; search
          ([?\C-s] . [?\C-f])
          ;; selection-shift movements
          ([?\C-\S-b] . [S-left])
          ([?\C-\S-f] . [S-right])
          ([?\C-\S-p] . [S-up])
          ([?\C-\S-n] . [S-down])
          ([?\M-B] . [C-S-left])
          ([?\M-F] . [C-S-right])
          ;; newline/esc
          ([\\S-\\r] . [end return])
          ([?\C-g] . [escape])
          ;;Navigation C-] is going to home ? Alt-Home?
          ([?\M-\[] . [M-left])           ; back
          ([?\M-\]] . [M-right])          ; forward
          ;; Toggle Developer Tools
          ([?\M-i] . [C-S-i])
          ([?\M-k] . [C-S-k]) ;; web console - can't toggle
          ;; C-S-M Responsive Design View
          ;; C-S-S Debugger
          ;; M-s Menu

          ;; firefox stuffs? F7 Caret mode!!
          ;; Focus Tab Bar
          ([?\s-z] . [?\C-l S-tab S-tab S-tab]) ;; sometime no back history button hmmm
          ;; copy link
          ([?\C-l] . [?\C-l ?\C-c])
          ;; questionable shifting line up/down
          ([?\M-p] . [home S-end ?\C-c backspace delete up home return up ?\C-v])
          ([?\M-n] . [home S-end ?\C-c backspace delete end return ?\C-v])
          ([?\C-\"] . [\" end \" return]) ;; quoting

          ;; Ensure ways to still access old bindings
          ([?\C-\s-b] . [?\C-b]) ;; bookmark
          ([?\C-\s-s] . [?\C-s]) ;; save
          ([?\C-\s-p] . [C-p])
          ([?\C-\s-n] . [C-n])
          ([?\C-\S-w] . [?\C-w]) ;; close
          ([?\C-\s-k] . [C-k])
          ([?\C-\s-b] . [?\C-b]) ;; bookmark
          ([?\C-\s-s] . [?\C-s]) ;; save
          ;; QuickFind next
          ([?\C-,] . [C-g])
          ([?\C-.] . [C-S-g])
          ;;idk
          ;; ([?\C-\S-u] . [C-S-f])
          ;; Open new window?
          ;; ([?\M-P] . [C-S-p])
          ;; ([?\M-N] . [C-S-n])
          ;; ([?\C-\'] . [\" home \" return])
          ;; idk
          ))
  (setq exwm-manage-force-tiling t)

  ;; (define-key exwm-mode-map (kbd "C-c") nil)
  (setq exwm-input-prefix-keys
        '(?\C-x
          ?\C-h
          ?\M-x
          ?\M-`
          ?\M-&
          ?\s-@
          ?\C-c
          ?\M-b
          ?\s-b
          ?\C-W
          ?\M-:
          ?\C-\M-j  ;; Buffer list
          ?\C-\M-k  ;; Browser list
          ?\C-\M-n  ;; Next workspace
          ?\C-\     ;; Ctrl+Space
          ?\C-\;))
  ;; Buffer switching
  ;; (add-to-list 'exwm-input-prefix-keys ?\s-@)
  ;; (add-to-list 'exwm-input-prefix-keys ?\C-c)
  ;; (add-to-list 'exwm-input-prefix-keys ?\M-b)
  ;; ;; Engine mode
  ;; (add-to-list 'exwm-input-prefix-keys ?\s-b)
  ;; (add-to-list 'exwm-input-prefix-keys ?\C-W)
  ;; (exwm/bind-function
  ;;   "s-o" 'exwm/run-qute
  ;;   "s-q" 'kill-buffer)
  ;; Project
  ;; (add-to-list 'exwm-input-prefix-keys ?\C-p)
  ;; Window switching
  (define-key exwm-mode-map (kbd "<f8>") 'other-window)
  (define-key exwm-mode-map (kbd "C-<f8>") 'window-swap-states)
  (define-key exwm-mode-map (kbd "M-<f8>") 'rotate-frame-clockwise)

  ;; (exwm-input-set-key (kbd "M-y") #'my/exwm-counsel-yank-pop)
  (exwm-input-set-key (kbd "M-y") 'consult-yank-pop)

  (use-package desktop-environment
    :after exwm
    :config (desktop-environment-mode)
    :custom
    (desktop-environment-brightness-small-increment "2%+")
    (desktop-environment-brightness-small-decrement "2%-")
    (desktop-environment-brightness-normal-increment "5%+")
    (desktop-environment-brightness-normal-decrement "5%-")
    (desktop-environment-screenshot-command "flameshot gui"))

  ;; This needs a more elegant ASCII banner
  (defhydra hydra-exwm-move-resize (:timeout 4)
    "Move/Resize Window (Shift is bigger steps, Ctrl moves window)"
    ("j" (lambda () (interactive) (exwm-layout-enlarge-window 10)) "V 10")
    ("J" (lambda () (interactive) (exwm-layout-enlarge-window 30)) "V 30")
    ("k" (lambda () (interactive) (exwm-layout-shrink-window 10)) "^ 10")
    ("K" (lambda () (interactive) (exwm-layout-shrink-window 30)) "^ 30")
    ("h" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 10)) "< 10")
    ("H" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 30)) "< 30")
    ("l" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 10)) "> 10")
    ("L" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 30)) "> 30")
    ("C-j" (lambda () (interactive) (exwm-floating-move 0 10)) "V 10")
    ("C-S-j" (lambda () (interactive) (exwm-floating-move 0 30)) "V 30")
    ("C-k" (lambda () (interactive) (exwm-floating-move 0 -10)) "^ 10")
    ("C-S-k" (lambda () (interactive) (exwm-floating-move 0 -30)) "^ 30")
    ("C-h" (lambda () (interactive) (exwm-floating-move -10 0)) "< 10")
    ("C-S-h" (lambda () (interactive) (exwm-floating-move -30 0)) "< 30")
    ("C-l" (lambda () (interactive) (exwm-floating-move 10 0)) "> 10")
    ("C-S-l" (lambda () (interactive) (exwm-floating-move 30 0)) "> 30")
    ("f" nil "finished" :exit t))

;;   (defun my/exwm-counsel-yank-pop ()
;;     "Same as `counsel-yank-pop' and paste into exwm buffer.
;; Stolen from https://github.com/DamienCassou/gpastel#for-exwmcounsel-users
;; and adapted to use simulations keys to have a common yank keystroke."
;;     (interactive)
;;     (let ((inhibit-read-only t)
;;           (yank-pop-change-selection t))
;;       (call-interactively #'counsel-yank-pop))
;;     (when (derived-mode-p 'exwm-mode)
;;       ;; https://github.com/ch11ng/exwm/issues/413#issuecomment-386858496
;;       (exwm-input--set-focus (exwm--buffer->id (window-buffer (selected-window))))
;;       (let ((keys (gethash [?\C-y]
;;                            exwm-input--simulation-keys)))
;;         (dolist (key keys)
;;           (exwm-input--fake-key key)))))

  (add-hook 'exwm-update-title-hook
            (lambda ()
              (exwm-workspace-rename-buffer (my/exwm-buffer-name))))

  (add-hook 'exwm-manage-finish-hook
            (lambda ()
              (setq-local default-directory (expand-file-name "~/"))
              (when (and exwm-class-name
                         (string= (downcase exwm-class-name) "urxvt"))
                (exwm-input-set-local-simulation-keys
                 (append
                  exwm-input-simulation-keys
                  '(([?\C-y] . [?\C-\S-v])))))
              (when (and exwm-class-name
                         (string= (downcase exwm-class-name) "firefoxdeveloperedition"))
                (exwm-input-set-local-simulation-keys
                 (append
                  exwm-input-simulation-keys
                  '(([?\C-s] . [?\C-f]) ; Swiper!
                    ([?\C-g] . [escape])
                    ([?\C-t] . nil))))))) ; Prevent accidental tab ; creation

  ;; (add-hook 'exwm-init-hook
  ;;           (lambda ()
  ;;             (progn
  ;;               (split-window-right)
  ;;               (start-process-shell-command "xmodmap" nil "xmodmap ~/.Xmodmap")
  ;;               (eshell))))
  (add-hook 'exwm-init-hook
            (lambda ()
              (progn
                (split-window-right)
                (start-process-shell-command "kmonad" nil "kmonad test.kbd")
                (eshell))))

  (setq exwm-input-global-keys
        `(
          ([?\s-r]
           . exwm-reset)
          ([?\s-c]
           . exwm-input-toggle-keyboard)
          ([?\s-f]
           . my/toggle-single-window)
          ([?\s-z]
           . split-window-below)
          ([?\s-v]
           . split-window-right)
          ([?\s-I]
           . delete-window)
          ([?\s-e] . dired-jump)
          ([?\s-E] . (lambda () (interactive) (dired "~")))
          ([?\s-C] . (lambda () (interactive) (kill-buffer)))
          ;; Switch workspace
          ([?\s-w] . exwm-workspace-switch)
          ([?\s-`] . (lambda () (interactive) (exwm-workspace-switch-create 0)))
          ([?\s-d] .
           (lambda ()
             (interactive)
             (counsel-linux-app)))

          ;; go to scratch
          ([s-escape] . (lambda ()
                          (interactive)
                          (switch-to-buffer "*scratch*")))
          ;; Bind "s-<f2>" to "slock", a simple X display locker.
          ([s-f2] . (lambda ()
                      (interactive)
                      (start-process "" nil "/usr/bin/slock")))
          ;; simple text to speech. Need to copy clipboard
          ([s-f7] . (lambda ()
                      (interactive)
                      (start-process-shell-command "" nil "xclip -o -sel clip | espeak-ng")))

          ([?\s-y] . (lambda ()
                       (interactive)
                       (start-process-shell-command "" nil "yt -D")))

          ;; Launch applications via shell command
	  ([?\s-&] . (lambda (command)
		       (interactive (list (read-shell-command "$ ")))
		       (start-process-shell-command command nil command)))
          ([?\s-#] .
           (lambda ()
             (interactive)
             (my/ivy-switch-buffer-firefox)))
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" (car i))) .
                        (lambda ()
                          (interactive)
                          (my/switch-to-buffer-if-exists-back-and-forth ,(cdr i)))))
                    '((2 . "Telegram") (3 . "Signal") (6 . "*eshell*")))
          ,@(mapcar (lambda (i)
                      `(,(kbd (format "s-%d" i)) .
                        (lambda (arg)
                          (interactive "P")
                          (my/bookmark-buffer-or-switch-to-bookmark arg))))
                    '(6 7))

	  ;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
	  ,@(mapcar (lambda (i)
	              `(,(kbd (format "s-%d" i)) .
	        	(lambda ()
	        	  (interactive)
	        	  (exwm-workspace-switch-create ,i))))
	            (number-sequence 0 5))

          ([?\s-8]
           . my/ivy-switch-buffer-detached-command)
          ;; ([?\s-8]
          ;;  . mu4e-headers-search-bookmark)
          ([?\s-9] .
           (lambda ()
             (interactive)
             (my/ivy-switch-buffer-urxvt)))
          ;; ([?\s-0]
          ;;  . erc-track-switch-buffer)
          ;; ([?\s-r] .
          ;;  (lambda ()
          ;;    (interactive)
          ;;    (eradio-toggle)))
          ([?\s-$] .
           (lambda ()
             (interactive)
             (start-process "" nil "/usr/bin/firefox-developer-edition")))
          ([?\s-p]
           . my/exwm-toggle-or-set-buffer-protection)
          ([?\s-q] .
           (lambda ()
             (interactive)
             (start-process "" nil "/usr/bin/alacritty")))
          ([?\s-=]
           . balance-windows)
          ([?\s-L] .
           (lambda ()
             (interactive)
             (exwm-layout-enlarge-window-horizontally 100)))
          ([?\s-U] .
           (lambda ()
             (interactive)
             (exwm-layout-shrink-window-horizontally 100)))))

  (exwm-enable))
#+end_src

#+RESULTS:
: t

** Desktop File

This file is used by your "login manager" (GDM, LightDM, etc) to display EXWM as a desktop environment option when you log in.

*IMPORTANT*: Make sure you create a symbolic link for this file into =/usr/share/xsessions=:

#+begin_src sh :tangle no

sudo ln -f ~/.config/doom/exwm/EXWM.desktop /usr/share/xsessions/EXWM.desktop

#+end_src

#+begin_src shell :tangle ./exwm/EXWM.desktop :mkdirp yes

  [Desktop Entry]
  Name=EXWM
  Comment=Emacs Window Manager
  Exec=sh /home/shiva/.config/doom/exwm/start-exwm.sh
  TryExec=sh
  Type=Application
  X-LightDM-DesktopName=exwm
  DesktopNames=exwm

#+end_src

#+RESULTS:

** launcher script v2
#+begin_src shell :tangle ./exwm/start-exwm.sh :shebang #!/bin/sh
#!/bin/bash
# Very important: Avoid spawning daemons here.
# They will not exit with this process, so we will no longer have a clean X11 shutdown.

killall emacs
# Disable access control for the current user.
xhost +SI:localuser:$USER

## you might need to append the TTY you are working on
xinit

wmname LG3D
# Make Java applications aware this is a non-reparenting window manager.
export _JAVA_AWT_WM_NONREPARENTING=1

# ## Run site init scripts. Usually not necessary.
# if [ -d /etc/X11/xinit/xinitrc.d ] ; then
#     for f in /etc/X11/xinit/xinitrc.d/?*.sh ; do
#         [ -x "$f" ] && . "$f"
#     done
#     unset f
# fi

# . ~/exwm_screen_layout
# ~/exwm_xrandr.bash

# Set themes, etc.
# xrdb -override ~/exwm_x11_resources.xrdb
# Note: xsettingsd just publishes settings. You must ensure that it has settings to publish.
# /usr/bin/xsettingsd &
# Try to control screen blanking
# xset s off dpms 1200 1400 1600
# Set keyboard repeat rate. Default is 660 25 ("xset q")
# xset r rate 200 30

# Set default cursor.
xsetroot -cursor_name left_ptr

# Hide the mouse pointer if unused for a duration
/usr/bin/unclutter &

# One can also start processes unrelated to X11, just ensure that they will exit when this process exits.

# Enable "Num Lock" mode, on keyboard keypad
# /usr/bin/numlockx on &

  # Run the screen compositor
picom &
  # Enable screen locking on suspend
xss-lock -- slock &
# Uncomment the following block to use the exwm-xim module. Not something I use.
export XMODIFIERS=@im=exwm-xim
export GTK_IM_MODULE=xim
export QT_IM_MODULE=xim
export CLUTTER_IM_MODULE=xim

# If Emacs is started in server mode, `emacsclient` is a convenient way to
# edit files in place (used by e.g. `git commit`).

export VISUAL=emacsclient
export EDITOR="$VISUAL"
# Finally start Emacs
# Scrolling gtk3 apps won't work, unless GDK_CORE_DEVICE_EVENTS is defined
export GDK_CORE_DEVICE_EVENTS=1
# exec dbus-launch --exit-with-session /usr/local/bin/emacs --eval "(progn (require 'exwm) (exwm-enable))"
# "exwm-enable" has to be called before the frame is spawned.
# usr/local/bin/emacs --daemon --eval "(require 'exwm)" -f exwm-enable
# emacs --daemon --eval "(require 'exwm)" -f exwm-enable
# exec dbus-launch --exit-with-session emacs -mm --debug-init

# exec emacs --daemon && emacsclient -c --eval "(exwm-enable)"
exec dbus-launch --exit-with-session emacs --eval "(exwm-enable)"
# exec emacsclient -c
#+end_src
** Keyboard Configuration

The =Xmodmap= file will be used with the =xmodmap= program to remap CapsLock to Ctrl inside of our desktop environment:

#+begin_src sh :tangle ./exwm/Xmodmap

  clear lock
  clear control
  keycode 66 = Control_L
  add control = Control_L
  add Lock = Control_R

#+end_src

** DPI configuration

The =Xresources= file will be used with =xrdb= in =start-exwm.sh= to set our screen DPI:

#+begin_src conf :tangle ./exwm/Xresources

  Xft.dpi:   100   # Set this to your desired DPI!  Larger number means bigger text and UI

#+end_src
** Polybar
Fira Code** Panel with Polybar

Polybar provides a great, minimalistic panel for your EXWM desktop configuration.  The following config integrates =emacsclient= and Polybar with =polybar-msg= to enable you to gather *any* information from Emacs and display it in the panel!

Check out the Polybar wiki for more details on how to configure it: https://github.com/polybar/polybar/wiki

#+begin_src emacs-lisp

  ;; Make sure the server is started (better to do this in your main Emacs config!)
  (server-start)

  (defvar efs/polybar-process nil
    "Holds the process of the running Polybar instance, if any")

  (defun efs/kill-panel ()
    (interactive)
    (when efs/polybar-process
      (ignore-errors
        (kill-process efs/polybar-process)))
    (setq efs/polybar-process nil))

  (defun efs/start-panel ()
    (interactive)
    (efs/kill-panel)
    (setq efs/polybar-process (start-process-shell-command "polybar" nil "polybar panel")))
    ;; (setq efs/polybar-process (start-process-shell-command "polybar" nil "bash ~/.config/polybar/launch.sh --material")))
  (defun efs/send-polybar-hook (module-name hook-index)
    (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" module-name hook-index)))

  (defun efs/send-polybar-exwm-workspace ()
    (efs/send-polybar-hook "exwm-workspace" 1))

  ;; Update panel indicator when workspace changes
  (add-hook 'exwm-workspace-switch-hook #'efs/send-polybar-exwm-workspace)

(defun dw/send-polybar-hook (name number)
  (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" name number)))

(defun dw/update-polybar-exwm (&optional path)
  (dw/send-polybar-hook "exwm" 1)
  (dw/send-polybar-hook "exwm-path" 1))

(defun dw/update-polybar-telegram ()
  (dw/send-polybar-hook "telegram" 1))

(defun dw/polybar-exwm-workspace ()
  (pcase exwm-workspace-current-index
    (0 "")
    (1 "")
    (2 "")
    (3 "")
    (4 "")))

(defun dw/polybar-exwm-workspace-path ()
  (let ((workspace-path (frame-parameter nil 'bufler-workspace-path-formatted)))
    (if workspace-path
        (substring-no-properties workspace-path)
      "")))

(defun dw/polybar-mail-count (max-count)
  (if (and dw/mail-enabled dw/mu4e-inbox-query)
    (let* ((mail-count (shell-command-to-string
                         (format "mu find --nocolor -n %s \"%s\" | wc -l" max-count dw/mu4e-inbox-query))))
      (format " %s" (string-trim mail-count)))
    ""))

(defun dw/telega-normalize-name (chat-name)
  (let* ((trimmed-name (string-trim-left (string-trim-right chat-name "}") "◀{"))
         (first-name (nth 0 (split-string trimmed-name " "))))
    first-name))

(defun dw/propertized-to-polybar (buffer-name)
  (if-let* ((text (substring-no-properties buffer-name))
            (fg-face (get-text-property 0 'face buffer-name))
            (fg-color (face-attribute fg-face :foreground)))
    (format "%%{F%s}%s%%{F-}" fg-color (dw/telega-normalize-name text))
    text))

(defun dw/polybar-telegram-chats ()
  (if (> (length tracking-buffers) 0)
    (format " %s" (string-join (mapcar 'dw/propertized-to-polybar tracking-buffers) ", "))
    ""))

(add-hook 'exwm-workspace-switch-hook #'dw/update-polybar-exwm)
(add-hook 'bufler-workspace-set-hook #'dw/update-polybar-exwm)
#+end_src

** polybar config
The configuration for our ingeniously named panel, "panel".  Invoke it with =polybar panel= on the command line!
#+RESULTS:
#+begin_src conf :tangle ~/.config/polybar/config :mkdirp yes

; Docs: https://github.com/polybar/polybar
;==========================================================

[settings]
screenchange-reload = true
; pseudo-transparency = true

[global/wm]
margin-top = 0
margin-bottom = 0

[colors]
background = #f0232635
background-alt = #576075
foreground = #A6Accd
foreground-alt = #555
primary = #ffb52a
secondary = #e60053
alert = #bd2c40
underline-1 = #c792ea
draculamem = #ff5555
draculabat = #ff6e67
draculanet = #bd93f9
draculacpu = #f1fa8c
draculagreen = #5af78e
draculapink = #ff79c6


[bar/panel]
width = 100%
; height = <<get-setting(name="polybar/height")>>
height = 20
offset-x = 0
offset-y = 0
fixed-center = true
enable-ipc = true

background = ${colors.background}
foreground = ${colors.foreground}

line-size = 2
line-color = #f00

border-size = 0
border-color = #00000000

padding-top = 4
padding-left = 1
padding-right = 1

module-margin = 1

font-0 = "Cantarell:size=10:weight=bold;1"
font-1 = "Font Awesome:size=7;1"
font-2 = "Material Icons:size=10;3"
font-3 = "Fira Mono:size=6;-3"

modules-left = exwm exwm-path exwm-workspace
modules-center = spotify
; modules-left = exwm-workspace
modules-right = wireless-network networkspeedup networkspeeddown  cpu memory uptime arch-aur-updates battery temperature date

; exwm-workspace exwm exwm-path spotify mu4e telegram xkeyboard cpu cpu1 date battery1 battery temperture temperature1 xbacklight wireless-network wired-network
; weathe volume uptime filesystem pulseaudio memory wlan eth network networkspeedup networkspeeddown networkspeedup1 networkspeeddown1 arch-aur-updates aur-updates
; filesystem1 kernel load-average mpd release pub-ip pavolume
tray-position = right
tray-padding =2
tray-maxsize =40

cursor-click = pointer
cursor-scroll = ns-resize

[module/exwm-workspace]
type = custom/ipc
hook-0 = emacsclient -e "exwm-workspace-current-index" | sed -e 's/^"//' -e 's/"$//'
initial = 1
format-underline = ${colors.underline-1}
format-padding = 1

[module/exwm]
type = custom/ipc
hook-0 = emacsclient -e "(dw/polybar-exwm-workspace)" | sed -e 's/^"//' -e 's/"$//'
initial = 1
format-underline = ${colors.underline-1}
format-background = ${colors.background-alt}
format-padding = 1


[module/exwm-path]
type = custom/ipc
hook-0 = emacsclient -e "(dw/polybar-exwm-workspace-path)" | sed -e 's/^"//' -e 's/"$//'
format-foreground = #f78c6c
initial = 1

; [module/spotify]
; type = custom/script
; exec = ~/.config/polybar/player-status.sh
; interval = 3

; [module/mu4e]
; type = custom/ipc
; hook-0 = emacsclient -e '(dw/polybar-mail-count 500)' | sed -e 's/^"//' -e 's/"$//'
; initial = 1
; format-underline = ${colors.underline-1}
; click-left = emacsclient -e '(dw/go-to-inbox)'

; [module/telegram]
; type = custom/ipc
; hook-0 = emacsclient -e '(dw/polybar-telegram-chats)' | sed -e 's/^"//' -e 's/"$//'
; format-padding = 3
; initial = 1

[module/xkeyboard]
type = internal/xkeyboard
blacklist-0 = num lock

format-prefix-font = 1
format-prefix-foreground = ${colors.foreground-alt}
format-prefix-underline = ${colors.underline-1}

label-layout = %layout%
label-layout-underline = ${colors.underline-1}

label-indicator-padding = 2
label-indicator-margin = 1
label-indicator-underline = ${colors.underline-1}


[module/cpu]
type = internal/cpu
interval = 2
format = <label> <ramp-coreload>
format-foreground = ${colors.draculacpu}
format-underline = ${colors.draculacpu}
click-left = emacsclient -e "(proced)"
label = %percentage:2%%
label-foreground = ${colors.draculacpu}
ramp-coreload-spacing = 1
; ramp-coreload-0 = ▁
; ramp-coreload-0-foreground = ${colors.draculacpu}
; ramp-coreload-1 = ▂
; ramp-coreload-2 = ▃
; ramp-coreload-3 = ▄
; ramp-coreload-4 = ▅
; ramp-coreload-5 = ▆
; ramp-coreload-6 = ▇

ramp-coreload-0 = ▁
ramp-coreload-0-font = 3
ramp-coreload-0-foreground = #aaff77
ramp-coreload-1 = ▂
ramp-coreload-1-font = 3
ramp-coreload-1-foreground = #aaff77
ramp-coreload-2 = ▃
ramp-coreload-2-font = 3
ramp-coreload-2-foreground = #aaff77
ramp-coreload-3 = ▄
ramp-coreload-3-font = 3
ramp-coreload-3-foreground = #aaff77
ramp-coreload-4 = ▅
ramp-coreload-4-font = 3
ramp-coreload-4-foreground = #fba922
ramp-coreload-5 = ▆
ramp-coreload-5-font = 3
ramp-coreload-5-foreground = #fba922
ramp-coreload-6 = ▇
ramp-coreload-6-font = 3
ramp-coreload-6-foreground = #ff5555
ramp-coreload-7 = █
ramp-coreload-7-font = 3
ramp-coreload-7-foreground = #ff5555
[module/cpu1]
;https://github.com/jaagr/polybar/wiki/Module:-cpu
type = internal/cpu
; Seconds to sleep between updates
; Default: 1
interval = 1
format-foreground = ${colors.draculacpu}
format-background = ${colors.background}
;   
format-prefix = " "
format-prefix-foreground = #cd1f3f
format-underline = #645377
click-left = emacsclient -e "(proced)"
; Available tags:
;   <label> (default)
;   <bar-load>
;   <ramp-load>
;   <ramp-coreload>
format = <label> <ramp-coreload>

format-padding = 2

; Available tokens:
;   %percentage% (default) - total cpu load
;   %percentage-cores% - load percentage for each core
;   %percentage-core[1-9]% - load percentage for specific core
label-font = 3
; label = CPU: %percentage%%
label = %percentage:2%%
ramp-coreload-0 = ▁
ramp-coreload-0-font = 3
ramp-coreload-0-foreground = #aaff77
ramp-coreload-1 = ▂
ramp-coreload-1-font = 3
ramp-coreload-1-foreground = #aaff77
ramp-coreload-2 = ▃
ramp-coreload-2-font = 3
ramp-coreload-2-foreground = #aaff77
ramp-coreload-3 = ▄
ramp-coreload-3-font = 3
ramp-coreload-3-foreground = #aaff77
ramp-coreload-4 = ▅
ramp-coreload-4-font = 3
ramp-coreload-4-foreground = #fba922
ramp-coreload-5 = ▆
ramp-coreload-5-font = 3
ramp-coreload-5-foreground = #fba922
ramp-coreload-6 = ▇
ramp-coreload-6-font = 3
ramp-coreload-6-foreground = #ff5555
ramp-coreload-7 = █
ramp-coreload-7-font = 3
ramp-coreload-7-foreground = #ff5555

[module/date]
type = internal/date
interval = 5

date = "%a %b %e"
date-alt = "%A %B %d %Y"

time = %l:%M %p
time-alt = %H:%M:%S

format-prefix-foreground = ${colors.draculapink}
format-underline = ${colors.draculapink}

label = %date% %time%
label-foreground = ${colors.draculapink}

[module/battery1a]
;https://github.com/jaagr/polybar/wiki/Module:-battery
type = internal/battery
battery = BAT1
adapter = AC0
full-at = 100

format-charging = <animation-charging> <label-charging>
label-charging =  %percentage%%
format-charging-foreground = ${colors.foreground}
format-charging-background = ${colors.background}
format-charging-underline = #a3c725

format-discharging = <ramp-capacity> <label-discharging>
label-discharging =  %percentage%%
format-discharging-underline = #c7ae25
format-discharging-foreground = ${colors.foreground}
format-discharging-background = ${colors.background}

format-full-prefix = " "
format-full-prefix-foreground = #a3c725
format-full-underline = #a3c725
format-full-foreground = ${colors.foreground}
format-full-background = ${colors.background}

ramp-capacity-0 = 
ramp-capacity-1 = 
ramp-capacity-2 = 
ramp-capacity-3 = 
ramp-capacity-4 = 
ramp-capacity-foreground = #c7ae25

animation-charging-0 = 
animation-charging-1 = 
animation-charging-2 = 
animation-charging-3 = 
animation-charging-4 = 
animation-charging-foreground = #a3c725
animation-charging-framerate = 750
[module/battery]
type = internal/battery
battery = BAT1
adapter = ADP1
full-at = 98
time-format = %-l:%M

label-charging = %percentage%% / %time%
format-charging = <animation-charging> <label-charging>
format-charging-underline = ${colors.draculagreen}
label-charging-foreground = ${colors.draculagreen}

label-discharging = %percentage%% / %time%
label-discharging-foreground = ${colors.draculagreen}
format-discharging = <ramp-capacity> <label-discharging>
format-discharging-underline = ${self.format-charging-underline}

format-full = <ramp-capacity> <label-full>
format-full-underline = ${self.format-charging-underline}

ramp-capacity-0 = 
ramp-capacity-1 = 
ramp-capacity-2 = 
ramp-capacity-3 = 
ramp-capacity-4 = 
ramp-capacity-foreground = ${colors.draculagreen}
animation-charging-0 = 
animation-charging-1 = 
animation-charging-2 = 
animation-charging-3 = 
animation-charging-4 = 
animation-charging-framerate = 750

[module/temperature]
type = internal/temperature
thermal-zone = 0
warn-temperature = 60

format = <label>
format-underline = ${colors.underline-1}
format-warn = <label-warn>
format-warn-underline = ${self.format-underline}

label = %temperature-c%
label-warn = %temperature-c%!
label-warn-foreground = ${colors.secondary}

[module/temperature1]
;https://github.com/jaagr/polybar/wiki/Module:-temperature
type = internal/temperature
; Thermal zone to use
; To list all the zone types, run
; $ for i in /sys/class/thermal/thermal_zone*; do echo "$i: $(<$i/type)"; done
; Default: 0
thermal-zone = 0

; Full path of temperature sysfs path
; Use `sensors` to find preferred temperature source, then run
; $ for i in /sys/class/hwmon/hwmon*/temp*_input; do echo "$(<$(dirname $i)/name): $(cat ${i%_*}_label 2>/dev/null || echo $(basename ${i%_*})) $(readlink -f $i)"; done
; to find path to desired file
; Default reverts to thermal zone setting
hwmon-path = /sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input

warn-temperature = 70
format = <ramp> <label>
format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-underline = #c72581
format-warn = <ramp> <label-warn>
format-warn-underline = #c7254f
label = %temperature%
label-warn =  %temperature%
label-warn-foreground = #c7254f

ramp-0 = 
ramp-1 = 
ramp-2 = 
ramp-3 = 
ramp-4 = 
ramp-foreground =${colors.foreground}

[module/xbacklight]

;https://github.com/jaagr/polybar/wiki/Module:-xbacklight
type = internal/xbacklight
format = <label> <bar>
format-prefix = "   "
format-prefix-foreground = ${colors.foreground}
format-prefix-background = ${colors.background}
format-prefix-underline = #9f78e1
format-underline = #9f78e1
label = %percentage%%
bar-width = 2
; bar-width = 10
bar-indicator = 
bar-indicator-foreground = #fff
bar-indicator-font = 2
bar-fill = 
bar-fill-font = 2
bar-fill-foreground = #9f78e1
bar-empty = 
bar-empty-font = 2
bar-empty-foreground = #fff
format-foreground = ${colors.foreground}
format-background = ${colors.background}
[module/wireless-network]
;https://github.com/jaagr/polybar/wiki/Module:-network
type = internal/network
interface = wlp2s0
interval = 3.0
label-connected = %essid%

format-connected = <label-connected>
;format-connected = <ramp-signal> <label-connected>
format-connected-foreground = ${colors.foreground}
format-connected-background = ${colors.background}
format-connected-prefix = "  "
format-connected-prefix-foreground = #7e52c6
format-connected-prefix-background = ${colors.background}
format-connected-underline = #7e52c6

label-disconnected = %ifname% disconnected
label-disconnected-foreground = ${colors.alert}
label-disconnected-background = ${colors.background}

format-disconnected = <label-disconnected>
format-disconnected-foreground = ${colors.alert}
format-disconnected-background = ${colors.background}
format-disconnected-prefix = "  "
format-disconnected-prefix-foreground = ${colors.alert}
format-disconnected-prefix-background = ${colors.background}
format-disconnected-underline =${colors.alert}

ramp-signal-0 = ▁
ramp-signal-1 = ▂
ramp-signal-2 = ▃
ramp-signal-3 = ▄
ramp-signal-4 = ▅
ramp-signal-5 = ▆
ramp-signal-6 = ▇
ramp-signal-7 = █
ramp-signal-foreground = #7e52c6
[module/wired-network]
;https://github.com/jaagr/polybar/wiki/Module:-network
type = internal/network
interface = enp4s0
;interface = enp14s0
interval = 3.0

; Available tokens:
;   %ifname%    [wireless+wired]
;   %local_ip%  [wireless+wired]
;   %essid%     [wireless]
;   %signal%    [wireless]
;   %upspeed%   [wireless+wired]
;   %downspeed% [wireless+wired]
;   %linkspeed% [wired]
; Default: %ifname% %local_ip%
label-connected =  %ifname%
label-disconnected = %ifname% disconnected

format-connected-foreground = ${colors.foreground}
format-connected-background = ${colors.background}
format-connected-underline = #55aa55
format-connected-prefix = " "
format-connected-prefix-foreground = #55aa55
format-connected-prefix-background = ${colors.background}

format-disconnected = <label-disconnected>
format-disconnected-underline = ${colors.alert}
label-disconnected-foreground = ${colors.foreground}
[module/weather]
type = custom/script
interval = 10
format = <label>
format-prefix = " "
format-prefix-foreground = #3EC13F
format-underline = #3EC13F
format-foreground = ${colors.foreground}
format-background = ${colors.background}
exec = python -u ~/.config/polybar/scripts/weather.py
tail = true
[module/volume]
;https://github.com/jaagr/polybar/wiki/Module:-volume
type = internal/volume
format-volume = "<label-volume>  <bar-volume>"
format-volume-underline = #40ad4b

label-volume = " "
label-volume-underline = #40ad4b
label-volume-foreground = #40ad4b
label-muted = muted

bar-volume-width = 5
bar-volume-foreground-0 = #40ad4b
bar-volume-foreground-1 = #40ad4b
bar-volume-foreground-2 = #40ad4b
bar-volume-foreground-3 = #40ad4b
bar-volume-foreground-4 = #40ad4b
bar-volume-foreground-5 = #40ad4b
bar-volume-foreground-6 = #40ad4b
bar-volume-gradient = false
bar-volume-indicator = 
bar-volume-indicator-font = 2
bar-volume-fill = 
bar-volume-fill-font = 2
bar-volume-empty = 
bar-volume-empty-font = 2
bar-volume-empty-foreground = ${colors.foreground}
format-volume-foreground = ${colors.foreground}
format-volume-background = ${colors.background}
format-muted-prefix = "  "
format-muted-prefix-foreground = "#ff0000"
format-muted-foreground = ${colors.foreground}
format-muted-background = ${colors.background}
[module/uptime]
;https://github.com/jaagr/polybar/wiki/User-contributed-modules#uptime
type = custom/script
exec = uptime | awk -F, '{sub(".*up ",x,$1);print $1}'
interval = 100
label = Uptime : %output%

format-foreground =#98be65
format-background = ${colors.background}
format-prefix = " "
format-prefix-foreground = #98be65
format-underline = #98be65
[module/filesystem]
type = internal/fs
interval = 25

mount-0 = /

label-mounted = %{F#F0C674}%mountpoint%%{F-} %{F#5af78e}%percentage_used%%{F-}
label-mounted-foreground = ${colors.draculagreen}
label-mounted-underline = ${colors.draculagreen}
label-unmounted = %mountpoint% not mounted
label-unmounted-foreground = ${colors.draculagreen}

[module/pulseaudio]
type = internal/pulseaudio

; format-volume-prefix = "V: "
; format-volume-prefix-underline = ${colors.underline-1}
; format-volume-prefix-foreground = ${colors.foreground}
; format-volume = <label-volume>

label-volume = %percentage%%
label-volume-underline = ${colors.underline-1}

label-muted = muted
label-muted-foreground = ${colors.foreground}
[module/memory]
type = internal/memory
interval = 2
format-underline = ${colors.draculamem}
format-prefix = "RAM "
format-prefix-foreground = ${colors.draculamem}
label = %percentage_used:2%%
label-foreground = ${colors.draculamem}
[network-base]
type = internal/network
interval = 5
format-underline = ${colors.underline-1}
format-connected = <label-connected>
format-disconnected = <label-disconnected>
label-disconnected = %{F#F0C674}%ifname%%{F#707880} disconnected

[module/wlan]
inherit = network-base
interface-type = wireless
label-connected = %{F#bd93f9}%essid%%{F-} %{F#bd93f9}%local_ip%%{F-}
; label-connected = %{F#bd93f9}%ifname%%{F-} %{F#bd93f9}%essid%%{F-} %{F#bd93f9}%local_ip%%{F-}
label-connected-underline = ${colors.underline-1}
[module/eth]
inherit = network-base
format-underline = ${colors.underline-1}
interface-type = wired
label-connected = %{F#F0C674}%ifname%%{F-} %local_ip%


[module/network]
type = internal/network
interface = wlp2s0
interval = 1.0
label-connected = "  %downspeed%   %upspeed%  "
label-disconnected = disconnected
label-connected-background = #FF0000

[module/networkspeedup]
type = internal/network
interface = wlp2s0
label-connected = "%upspeed:7%"
format-connected = <label-connected>
format-connected-underline = ${colors.underline-1}
format-connected-prefix = " "
format-connected-prefix-foreground = ${colors.underline-1}
; format-connected-prefix-foreground = #fefefe
; format-connected-foreground = #fefefe
format-connected-foreground = ${colors.draculanet}
; format-connected-background = #8d62a9

[module/networkspeeddown]
type = internal/network
interface = wlp2s0
label-connected = "%downspeed:7%"
format-connected = <label-connected>
format-connected-underline = ${colors.underline-1}
format-connected-prefix = "  "
format-connected-prefix-foreground = ${colors.underline-1}
; format-connected-prefix-foreground = #fefefe
; format-connected-foreground = #fefefe
format-connected-foreground = ${colors.draculanet}
; format-connected-background = #8d62ad

[module/networkspeedup1]
type = internal/network
interface = wlp2s0
label-connected = "%upspeed:7%"
format-connected = <label-connected>
format-connected-prefix = ""
format-connected-prefix-foreground = #cb410b
format-connected-foreground = ${colors.foreground}
format-connected-background = ${colors.background}
format-connected-underline = #006600
; ip link show =interface

[module/networkspeeddown1]
type = internal/network
interface = wlp2s0
label-connected = "%downspeed:7%"
format-connected = <label-connected>
format-connected-prefix = ""
format-connected-prefix-foreground = #7c0a02
format-connected-foreground = ${colors.foreground}
format-connected-background = ${colors.background}
format-connected-underline = #006600

[module/arch-aur-updates]
type = custom/script
exec = ~/.config/polybar/scripts/check-arch-updates.sh
interval = 1000
label = Updates: %output%
; format-foreground = ${colors.foreground}
format-foreground = #FFBB00
format-background = ${colors.background}
format-underline = #FFBB00
format-prefix = "  "
format-prefix-foreground = #fefefe


[module/aur-updates]
type = custom/script
exec = ~/.config/polybar/scripts/check-aur-updates.sh
interval = 1000
label = Aur: %output%
; format-foreground = ${colors.foreground}
format-foreground = #FFBB00
format-background = ${colors.background}
format-prefix = "  "
; format-prefix-foreground = #FFBB00
format-prefix-foreground = #fefefe
format-underline = #FFBB00

[module/filesystem1]
;https://github.com/jaagr/polybar/wiki/Module:-filesystem
type = internal/fs

; Mountpoints to display
mount-0 = /
mount-1 = /home
;mount-2 = /var

; Seconds to sleep between updates
; Default: 30
interval = 30

; Display fixed precision values
; Default: false
fixed-values = false

; Spacing between entries
; Default: 2
spacing = 4

; Available tags:
;   <label-mounted> (default)
;   <bar-free>
;   <bar-used>
;   <ramp-capacity>
format-mounted = <label-mounted>
format-mounted-foreground = ${colors.foreground}
format-mounted-background = ${colors.background}
format-mounted-underline = #fe0000


; Available tokens:
;   %mountpoint%
;   %type%
;   %fsname%
;   %percentage_free%
;   %percentage_used%
;   %total%
;   %free%
;   %used%
; Default: %mountpoint% %percentage_free%%
; label-mounted = %mountpoint% : %used% used of %total%
label-mounted = %mountpoint% : %used%/%total%

; Available tokens:
;   %mountpoint%
; Default: %mountpoint% is not mounted
label-unmounted = %mountpoint% not mounted
format-unmounted-foreground = ${colors.foreground}
format-unmounted-background = ${colors.background}
;format-unmounted-underline = ${colors.alert}

[module/kernel]
type = custom/script
exec = uname -r
tail = false
interval = 1024

format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-prefix = "  "
format-prefix-foreground = #0084FF
format-underline = #4B5665

[module/load-average]
type = custom/script
exec = uptime | grep -ohe 'load average[s:][: ].*' | awk '{ print $3" "$4" "$5"," }' | sed 's/,//g'
interval = 100

;HOW TO SET IT MINIMAL 10 CHARACTERS - HIDDEN BEHIND SYSTEM ICONS
;label = %output%
label = %output:10%

format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-prefix = "  "
format-prefix-foreground = #62FF00
format-underline = #62FF00
[module/mpd]
;https://github.com/jaagr/polybar/wiki/Module:-mpd
type = internal/mpd
;format-online =  "<label-song>   <icon-prev>  <icon-stop>  <toggle>  <icon-next>"
format-online =  "<label-song>  <bar-progress>"
;format-online =  "<label-song>  <bar-progress> <icon-prev>  <icon-stop>  <toggle>  <icon-next>"
icon-prev = 
icon-stop = 
icon-play = 
icon-pause = 
icon-next = 
label-song-maxlen = 40
label-song-ellipsis = true
bar-progress-width = 10
bar-progress-indicator = 
bar-progress-fill = 
bar-progress-empty = 
bar-progress-fill-foreground = #ff0
bar-progress-fill-background = ${colors.background}
bar-progress-indicator-foreground = ${colors.foreground}
format-online-foreground = ${colors.foreground}
format-online-background = ${colors.background}

; [module/release]
; type = custom/script
; exec = (lsb_release -d | awk {'print $2'} ;echo " "; lsb_release -r | awk {'print $2'}) | tr -d '\n'
; interval = 6000

; format-foreground = ${colors.foreground}
; format-background = ${colors.background}
; format-prefix = "  "
; format-prefix-foreground = #62FF00
; format-underline = #62FF00
; interval = 6000

[module/pub-ip]
;https://linuxconfig.org/polybar-a-better-wm-panel-for-your-linux-system
type = custom/script
exec = ~/.config/polybar/scripts/pub-ip.sh
interval = 100
format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-underline = #FFBB00
label = %output%
format-prefix = "  "
format-prefix-foreground = #FFBB00

[module/pavolume]
type = custom/script
tail = true
label = %output%
exec = ~/.config/polybar/scripts/pavolume.sh --listen
click-right = exec pavucontrol
click-left = ~/.config/polybar/scripts/pavolume.sh --togmute
scroll-up = ~/.config/polybar/scripts/pavolume.sh --up
scroll-down = ~/.config/polybar/scripts/pavolume.sh --down
format-foreground = #fefefe
format-background = #668bd7
#+end_src

;; I created a simple script to grab Spotify player information using playerctl:

#+begin_src shell :tangle ~/.config/polybar/player-status.sh :shebang #!/bin/sh


status="$(playerctl -p spotify status 2>&1)"
if [ "$status" != "No players found" ]
then
  artist="$(playerctl -p spotify metadata artist)"
  if [ "$artist" != "" ]
  then
    echo " $(playerctl -p spotify metadata artist) - $(playerctl -p spotify metadata title)"
  else
    # Clear any string that was previously displayed
    echo ""
  fi
else
  # Clear any string that was previously displayed
  echo ""
fi
#+end_src
** Desktop Notifications with Dunst

We use anapplication called [[https://dunst-project.org/][Dunst]] to enable the display of desktop notifications from Emacs and other applications running within EXWM.  Consult the [[https://dunst-project.org/documentation/][documentation]] for more details on how to configure this to your liking!

Here are some things you might want to consider changing:

- =format= - Customize how notification text contents are displayed
- =geometry= - Where the notification appears and how large it should be by default
- =urgency_normal=, etc - configures the background and frame color for notifications of different types
- =max_icon_size= - Constrain icon display since some icons will be larger than others
- =icon_path= - Important if your icons are not in a common location (like when using GNU Guix)
- =idle_threshold= - Wait for user to become active for this long before hiding notifications
- =mouse_left/right/middle_click= - Action to take when clicking a notification
- Any of the key bindings in the =shortcuts= section (though these are deprecated in 1.5.0, use =dunstctl=)

# +begin_src conf :tangle ~/.config/dunst/dunstrc :mkdirp yes

[global]
    ### Display ###
    monitor = 0

    # The geometry of the window:
    #   [{width}]x{height}[+/-{x}+/-{y}]
    geometry = "500x10-10+50"

    # Show how many messages are currently hidden (because of geometry).
    indicate_hidden = yes

    # Shrink window if it's smaller than the width.  Will be ignored if
    # width is 0.
    shrink = no

    # The transparency of the window.  Range: [0; 100].
    transparency = 10

    # The height of the entire notification.  If the height is smaller
    # than the font height and padding combined, it will be raised
    # to the font height and padding.
    notification_height = 0

    # Draw a line of "separator_height" pixel height between two
    # notifications.
    # Set to 0 to disable.
    separator_height = 1
    separator_color = frame

    # Padding between text and separator.
    padding = 4

    # Horizontal padding.
    horizontal_padding = 4

    # Defines width in pixels of frame around the notification window.
    # Set to 0 to disable.
    frame_width = 1

    # Defines color of the frame around the notification window.
    frame_color = "#89AAEB"

    # Sort messages by urgency.
    sort = yes

    # Don't remove messages, if the user is idle (no mouse or keyboard input)
    # for longer than idle_threshold seconds.
    idle_threshold = 120

    ### Text ###

    font = Cantarell 9

    # The spacing between lines.  If the height is smaller than the
    # font height, it will get raised to the font height.
    line_height = 0
    markup = full

    # The format of the message.  Possible variables are:
    #   %a  appname
    #   %s  summary
    #   %b  body
    #   %i  iconname (including its path)
    #   %I  iconname (without its path)
    #   %p  progress value if set ([  0%] to [100%]) or nothing
    #   %n  progress value if set without any extra characters
    #   %%  Literal %
    # Markup is allowed
    format = "<b>%s</b>\n%b"

    # Alignment of message text.
    # Possible values are "left", "center" and "right".
    alignment = left

    # Show age of message if message is older than show_age_threshold
    # seconds.
    # Set to -1 to disable.
    show_age_threshold = 60

    # Split notifications into multiple lines if they don't fit into
    # geometry.
    word_wrap = yes

    # When word_wrap is set to no, specify where to make an ellipsis in long lines.
    # Possible values are "start", "middle" and "end".
    ellipsize = middle

    # Ignore newlines '\n' in notifications.
    ignore_newline = no

    # Stack together notifications with the same content
    stack_duplicates = true

    # Hide the count of stacked notifications with the same content
    hide_duplicate_count = false

    # Display indicators for URLs (U) and actions (A).
    show_indicators = yes

    ### Icons ###

    # Align icons left/right/off
    icon_position = left

    # Scale larger icons down to this size, set to 0 to disable
    max_icon_size = 0

    # Paths to default icons.
    icon_path = /usr/share/icons/Adwaita/96x96/status:/usr/share/icons/Adwaita/96x96/emblems

    ### History ###

    # Should a notification popped up from history be sticky or timeout
    # as if it would normally do.
    sticky_history = no

    # Maximum amount of notifications kept in history
    history_length = 20

    ### Misc/Advanced ###

    # Browser for opening urls in context menu.
    browser = qutebrowser

    # Always run rule-defined scripts, even if the notification is suppressed
    always_run_script = true

    # Define the title of the windows spawned by dunst
    title = Dunst

    # Define the class of the windows spawned by dunst
    class = Dunst

    startup_notification = false
    verbosity = mesg
&
    # Define the corner radius of the notification window
    # in pixel size. If the radius is 0, you have no rounded
    # corners.
    # The radius will be automatically lowered if it exceeds half of the
    # notification height to avoid clipping text and/or icons.
    corner_radius = 2

    mouse_left_click = close_current
    mouse_middle_click = do_action
    mouse_right_click = close_all

# Experimental features that may or may not work correctly. Do not expect them
# to have a consistent behaviour across releases.
[experimental]
    # Calculate the dpi to use on a per-monitor basis.
    # If this setting is enabled the Xft.dpi value will be ignored and instead
    # dunst will attempt to calculate an appropriate dpi value for each monitor
    # using the resolution and physical size. This might be useful in setups
    # where there are multiple screens with very different dpi values.
    # per_monitor_dpi = false

[shortcuts]

    # Shortcuts are specified as [modifier+][modifier+]...key
    # Available modifiers are "ctrl", "mod1" (the alt-key), "mod2",
    # "mod3" and "mod4" (windows-key).
    # Xev might be helpful to find names for keys.

    # Close notification.
    #close = ctrl+space

    # Close all notifications.
    #close_all = ctrl+shift+space

    # Redisplay last message(s).
    # On the US keyboard layout "grave" is normally above TAB and left
    # of "1". Make sure this key actually exists on your keyboard layout,
    # e.g. check output of 'xmodmap -pke'
    history = ctrl+grave

    # Context menu.
    context = ctrl+shift+period

[urgency_low]
    # IMPORTANT: colors have to be defined in quotation marks.
    # Otherwise the "#" and following would be interpreted as a comment.
    background = "#222222"
    foreground = "#888888"
    timeout = 10
    # Icon for notifications with low urgency, uncomment to enable
    # icon = /path/to/icon

[urgency_normal]
    background = "#1c1f26"
    foreground = "#ffffff"
    timeout = 10
    # Icon for notifications with normal urgency, uncomment to enable
    #icon = /path/to/icon

[urgency_critical]
    background = "#900000"
    foreground = "#ffffff"
    frame_color = "#ff0000"
    timeout = 0
    # Icon for notifications with critical urgency, uncomment to enable
    #icon = /path/to/icon

#+end_src

We can also set up some functions for enabling and disabling notifications at any time:

#+begin_src emacs-lisp

  (defun efs/disable-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_PAUSE\""))

  (defun efs/enable-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_RESUME\""))

  (defun efs/toggle-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_TOGGLE\""))

#+end_src

#+RESULTS:
: efs/toggle-desktop-notifications

 ABOUT THIS CONFIG
This is my personal Doom Emacs config.  Doom Emacs is a distribution of Emacs that uses the "evil" keybindings (Vim keybindings) and includes a number of nice extensions and a bit of configuration out of the box.  I am maintaining this config not just for myself, but also for those that want to explore some of what is possible with Emacs.  I will add a lot of examples of plugins and settings, some of them I may not even use personally.  I do this because many people following me on YouTube look at my configs as "documentation".

** movement and window switching
#+begin_src emacs-lisp

(use-package window
  :ensure nil
  :bind (("<f8>" . other-window)
         ("C-<f8>" . window-swap-states)
         ("C-x 1" . my/toggle-single-window))
  :init
  (defun my/toggle-single-window ()
  "Toggles between a single window configuration and
the previously multi-windowed one"
  (interactive)
  (if (one-window-p)
    (when (boundp 'my-saved-window-configuration)
      (set-window-configuration my-saved-window-configuration))
    (progn
      (setq my-saved-window-configuration (current-window-configuration))
      (delete-other-windows)))))

(use-package transpose-frame
  :bind (("M-<f8>" . rotate-frame-clockwise)))

(use-package bookmark
  :ensure nil
  :custom
  (bookmark-save-flag 1))

(use-package beginend
  :config
  (beginend-global-mode))

;; (use-package drag-stuff
;;   :bind
;;   (("C-M-<up>" . drag-stuff-up)
;;    ("C-M-<down>" . drag-stuff-down))
;;   :config
;;   (drag-stuff-global-mode))

#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25130 54428 460394 790000) :init (25130 54428 460089 20000) :init-secs (0 0 194 725000) :use-package-secs (0 0 527 776000)))

** Desktop Key Bindings

We use the [[https://github.com/DamienCassou/desktop-environment][desktop-environment]] package to automatically bind to well-known programs for controlling the volume, screen brightness, media playback, and doing other things like locking the screen and taking screenshots.  Make sure that you install the necessary programs to make this functionality work!  Check the [[https://github.com/DamienCassou/desktop-environment#default-configuration][default programs]] list to know what you need to install.

#+begin_src emacs-lisp
(use-package desktop-environment
  :after (exwm)
  :config
  (exwm-input-set-key (kbd "s-<up>") #'desktop-environment-volume-increment)
  (exwm-input-set-key (kbd "s-<down>") #'desktop-environment-volume-decrement)
  (exwm-input-set-key (kbd "s-m") #'desktop-environment-toggle-mute)
  (exwm-input-set-key (kbd "s-l") #'desktop-environment-lock-screen)
  (exwm-input-set-key (kbd "<XF86AudioPlay>") #'desktop-environment-toggle-music)
  (exwm-input-set-key (kbd "<XF86AudioPause>") #'desktop-environment-toggle-music)
  (exwm-input-set-key (kbd "<XF86AudioNext>") #'desktop-environment-music-next)
  ;; (exwm-input-set-key (kbd "s-s") #'desktop-environment-screenshot-part)
  :custom
  (desktop-environment-brightness-small-increment "2%+")
  (desktop-environment-brightness-small-decrement "2%-")
  (desktop-environment-brightness-normal-increment "5%+")
  (desktop-environment-brightness-normal-decrement "5%-")
  (desktop-environment-volume-get-command "pamixer --get-volume")
  (desktop-environment-volume-set-command "pamixer %s")
  (desktop-environment-volume-get-regexp "\\([0-9]+\\)")
  (desktop-environment-volume-normal-increment "-i 5 --allow-boost")
  (desktop-environment-volume-normal-decrement "-d 5")
  (desktop-environment-volume-toggle-command "pamixer -t")
  (desktop-environment-screenshot-directory "~")
  (desktop-environment-screenshot-partial-command "import png:- | xclip -selection c -t image/png -verbose")
  (desktop-environment-screenlock-command "xscreensaver-command -lock"))

#+end_src

#+RESULTS:
: t

** Window title
I'd like to have just the buffer name, then if applicable the project folder
#+begin_src emacs-lisp :tangle no
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

#+RESULTS:
|   | (:eval (if (s-contains-p org-roam-directory (or buffer-file-name )) (replace-regexp-in-string .*/[0-9]*-? ☰  (subst-char-in-string 95 32 buffer-file-name)) %b)) | (:eval (let ((project-name (projectile-project-name))) (unless (string= - project-name) (format (if (buffer-modified-p)  ◉ %s   ●  %s) project-name)))) |

For example when I open my config file it the window will be titled =config.org ●
doom= then as soon as I make a change it will become =config.org ◉ doom=.
** Defvar exwm
#+begin_src emacs-lisp

(defvar exwm-locking-command "lock"
  "Command to run when locking session")

(defvar exwm-install-logind-lock-handler nil
  "If this is non-nil and `exwm-locking-command' is set, register a D-BUS handler on the session lock signal.")

(defvar exwm-app-launcher--prompt "$ "
  "Prompt for the EXWM application launcher")

(defvar exwm-hide-tiling-modeline nil
  "Whether to hide modeline.")

(defvar exwm-buffer-name-prefix "X:"
  "A prefix to append to each buffer managed by exwm")

(defvar exwm-enable-systray 't
  "Whether to enable EXWM's bundled system tray implementation.")

(defvar exwm-autostart-xdg-applications nil
  "Whether to run $XDG_USER_HOME/autostart applications after initialization.")

(defvar exwm-autostart-environment '()
  "List of \"KEY=value\" strings which should be set when running autostart applications.

Example: '(\"DESKTOP_SESSION=kde\" \"KDE_SESSION_VERSION=5\") ")

(defvar exwm-custom-init nil
  "This can be set to a function that runs after all other EXWM initialization.")

(defvar exwm-workspace-switch-wrap t
  "Whether `exwm/workspace-next' and `exwm/workspace-prev' should wrap.")

(defvar exwm-randr-dwim t
  "Whether to try to dwim workspace/screen association in the screen change hook.")

(defvar exwm-move-frame-at-edge t
  "If enabled, use framemove to switch frames when trying to move
  outside of current frame." )
#+end_src

#+RESULTS:
: exwm-move-frame-at-edge

** funcs
#+begin_src emacs-lisp

(defun exwm//persp-mode-inhibit-p (frame)
  (frame-parameter frame 'unsplittable))

;; Simulate insert state by using line mode without passthrough
(defun exwm/enter-insert-state ()
  (interactive)
  (setq exwm-input-line-mode-passthrough nil)
  (call-interactively 'exwm-input-grab-keyboard)
  (evil-insert-state))

;; Simulate normal state by using line mode with passthrough, i.e. forward all commands to emacs
(defun exwm/enter-normal-state ()
  (interactive)
  (setq exwm-input-line-mode-passthrough t)
  (call-interactively 'exwm-input-grab-keyboard)
  (evil-normal-state))

(defun exwm/escape ()
  "Switch to normal state, and cancel possible fullscreen layout.  Also close minibuffer."
  (interactive)
  (exwm/enter-normal-state)
  (exwm-layout-unset-fullscreen)
  (when (active-minibuffer-window)
    (minibuffer-keyboard-quit)))

(defun exwm/enter-char-mode ()
  "Enter EXWM char mode."
  (interactive)
  (when exwm--id
    (exwm/enter-insert-state)
    ;; (exwm-input-toggle-keyboard)
    (call-interactively 'exwm-input-release-keyboard)))

(defun exwm/switch-to-buffer-or-run (window-class command)
  "Switch to first buffer with window-class, and if not present, run command."
  (let ((buffer
         (cl-find window-class (buffer-list) :key (lambda(b) (cdr (assoc 'exwm-class-name (buffer-local-variables b)))) :test 'string-equal)))
    (if buffer
        (exwm-workspace-switch-to-buffer buffer)
      (start-process-shell-command command nil command))))

;; Helper
;; TODO: actually incorporate exwm-workspace-switch-wrap here...
(defun exwm//ws-offset (offset)
  "Return the number of the workspace which is OFFSET workspaces
  away from the current workspace, cycling if necessary."
  (mod (+ offset exwm-workspace-current-index) (exwm-workspace--count)))

(defun exwm/workspace-next ()
  "Switch to next exwm-workspace (to the right)."
  (interactive)
  (exwm-workspace-switch (exwm//ws-offset 1)))

(defun exwm/workspace-prev ()
  "Switch to next exwm-workspace (to the left)."
  (interactive)
  (exwm-workspace-switch (exwm//ws-offset -1)))

;; Buffer move between frames semantics:
;; - In source window, display last buffer that was replaced in this frame using `other-window'
;; - In target frame, show the buffer in the active window
(defun exwm/workspace-move-buffer-to-workspace (ws-id)
  "Move the current buffer to the exwm-workspace with id WS-ID"
  (let ((target-frame (exwm-workspace--workspace-from-frame-or-index ws-id))
        (src-exwm-id exwm--id))
    (if src-exwm-id
        (progn
          (exwm-workspace-move-window target-frame src-exwm-id)
          (exwm-workspace-switch target-frame))
      (let ((src-buffer (current-buffer)))
        (switch-to-buffer (other-buffer src-buffer))
        (pop-to-buffer src-buffer `((display-buffer-in-previous-window
                                     display-buffer-use-some-window
                                     display-buffer-pop-up-window
                                     ;; display-buffer-use-some-frame
                                     )
                                    (inhibit-same-window . t)
                                    (reusable-frames . ,target-frame)
                                    ;; (frame-predicate . (lambda(f) (eql f ,target-frame)))
                                    ))))))

(defun exwm/workspace-move-buffer-next ()
  "Display active buffer in next frame (to the right)."
  (interactive)
  (exwm/workspace-move-buffer-to-workspace (exwm//ws-offset 1)))

(defun exwm/workspace-move-buffer-prev ()
  "Display active buffer in next frame (to the right)."
  (interactive)
  (exwm/workspace-move-buffer-to-workspace (exwm//ws-offset -1)))

(defun exwm/layout-toggle-fullscreen ()
  "Togggles full screen for Emacs and X windows"
  (interactive)
  (if exwm--id
      (if (exwm-layout--fullscreen-p)
          (exwm-reset)
        (exwm-layout-set-fullscreen))
    (spacemacs/toggle-maximize-buffer)))

(defun exwm/run-program-in-home (command)
  (let ((default-directory user-home-directory))
    (start-process-shell-command command nil command)))

(defun exwm/app-launcher (command)
  "Launches an application in your PATH.
Can show completions at point for COMMAND using helm or ivy"
  (interactive (list (read-shell-command exwm-app-launcher--prompt)))
  (exwm/run-program-in-home command))

(defun exwm/launch-split-below (command)
  (interactive (list (read-shell-command exwm-app-launcher--prompt)))
  (split-window-below-and-focus)
  (exwm/run-program-in-home command))

(defun exwm/launch-split-right (command)
  (interactive (list (read-shell-command exwm-app-launcher--prompt)))
  (split-window-right-and-focus)
  (exwm/run-program-in-home command))

(defun exwm/jump-to-last-exwm ()
  (interactive)
  (exwm-workspace-switch exwm-toggle-workspace))

(defun exwm/exwm-buffers-info ()
  (interactive)
  "Helper, return information about open exwm windows"
  (cl-loop for buffer in (buffer-list)
        for name = (buffer-name buffer)
        for ecname = (buffer-local-value 'exwm-class-name buffer)
        when ecname
        do (message "Buffer name: '%s', exwm class name: '%s'" name ecname)))

(defun exwm//convert-key-to-event (key)
  "Converts something from (kbd ...) format to something suitable for
    exwm-input-prefix-keys"
  (let ((key (kbd key)))
    (if (and (sequencep key)
             (= (length key) 1))
        (etypecase key
          (string (string-to-char key))
          (vector (elt key 0)))
      (error "cannot convert to key event: %s" key))))


(let ((debug-modes-active nil))
  (defun exwm/toggle-debug-mode ()
   "Toggle exwm and xcb debug modes"
   (interactive)
   (setf debug-modes-active (not debug-modes-active))
   (message (if debug-modes-active
                "Enabling xcb and exwm debug modes."
              "Disabling xcb and exqm debug modes."))
   (let ((flag (if debug-modes-active 1 0)))
     (exwm-debug flag)
     (xcb:debug flag))))

(defvar exwm//autostart-process-list nil
  "List of processes run during autostart.")

(defun exwm/autostart-process (name command &optional directory)
  "Can be used during initialization to run COMMAND as a process
  with NAME and add it to the list of autostarted processes.

DIRECTORY can be set to a string which will be used as working directory for the
process.  If not supplied, will be set to `user-home-directory'.

Prepends the value of `exwm-autostart-environmwnt' to
`process-environment' for the started process.
"
  (push (let ((default-directory (or directory user-home-directory))
              (process-environment (append exwm-autostart-environment process-environment)))
          (start-process-shell-command name nil command))
        exwm//autostart-process-list))

(defun exwm//start-desktop-application (basename xdg)
  "Autostart an application from a XDG desktop entry specification."
  (let* ((type (gethash "Type" xdg))
         ;; (name (gethash "Name" xdg))
         (cmd (gethash "Exec" xdg))
         (hidden (gethash "Hidden" xdg))
         (include (gethash "OnlyShowIn" xdg))
         (exclude (gethash "NotShowIn" xdg))
         (try-exec (gethash "TryExec" xdg))
         (exec-directory (gethash "Path" xdg))
         ;; (dbus-p (gethash "DBusActivatable" xdg)) ; TODO: support
         (included-p (cond (include (member "EXWM" (split-string include ";" t)))
                           (exclude (not (member "EXWM" (split-string exclude ";" t))))
                           (t)))
         (should-exec-p (and
                         (string= type "Application")
                         included-p
                         (if try-exec
                             (executable-find try-exec)
                           t))))
    (when should-exec-p (exwm/autostart-process basename cmd exec-directory))))

(defun exwm//read-xdg-autostart-files ()
  "Return a hashtable for autostart applications as defined by the freedesktop specification."
  (cl-loop with xdg-specs = (make-hash-table :test 'equal)
           for dir in (append (xdg-config-dirs) (list (xdg-config-home)))
           for autostart-dir = (expand-file-name "autostart/" dir)
           for autostart-files = (when (file-exists-p autostart-dir)
                                   (directory-files autostart-dir t (rx (1+ word) ".desktop")))
           do
           (cl-loop for file in autostart-files do
                    (setf (gethash (file-name-base file) xdg-specs) (xdg-desktop-read-file file)))
           finally (return xdg-specs)))

(defun exwm//autostart-xdg-applications ()
  "Run the autostart applications as defined by the freedesktop autostart specification."
  (unless exwm//autostart-process-list
    (cl-loop for basename being the hash-keys of
             (exwm//read-xdg-autostart-files)
             using (hash-values xdg) do
             (exwm//start-desktop-application basename xdg))))

(defun exwm//kill-autostart-processes ()
  (cl-loop for p in exwm//autostart-process-list do
        (if (process-live-p p) (kill-process p)))
  (setq exwm//autostart-process-list nil))

(let ((sm-keyvec (elt (edmacro-parse-keys doom-leader-key t) 0))
      (our-keyvec (elt (edmacro-parse-keys "s-SPC" t) 0)))
  (defun exwm//which-key-transform-filter (oldargs)
    (cl-destructuring-bind (key-seq &rest rest) oldargs
      (list* (cl-substitute sm-keyvec our-keyvec key-seq) rest))))

;; D-Bus locking
;; We should be able to talk to loginctl to handle the current session, so we
;; can react to the lock signal.

(defun exwm//install-logind-lock-handler ()
  (let ((session (dbus-call-method :system "org.freedesktop.login1" "/org/freedesktop/login1"
                                   "org.freedesktop.login1.Manager" "GetSessionByPID" (emacs-pid))))
    (dbus-register-signal :system "org.freedesktop.login1" session
                          "org.freedesktop.login1.Session" "Lock"
                          (lambda()
                            (message "Lock signal received")
                            (start-process-shell-command "session-lock" nil exwm-locking-command)))))


#+end_src

#+RESULTS:
: exwm//install-logind-lock-handler

** Packages
#+begin_src emacs-lisp

(defun exwm/init-framemove ()
  (use-package framemove
    :after exwm
    :config
    (progn
      ;; Emacs frame parameters don't seem to be too reliable...
      (define-advice fm-frame-bbox (:around (oldfun frame) exwm-frame-bbox-from-randr)
        (if (frame-parameter frame 'exwm-geometry)
            (exwm//fm-frame-bbox-from-randr frame)
          (funcall oldfun frame)))
      (setq framemove-hook-into-windmove exwm-move-frame-at-edge))))

(defun exwm/init-exwm ()
  (use-package exwm
    :init
    ;; Disable dialog boxes since they are unusable in EXWM
    (setq use-dialog-box nil)
    ;; You may want Emacs to show you the time
    (display-time-mode t)
    (when exwm-hide-tiling-modeline
      (add-hook 'exwm-mode-hook #'hidden-mode-line-mode))
    (setq exwm-input-line-mode-passthrough t)



    ;; make winner aware of new window configuration
    (with-eval-after-load 'winner
      (add-hook 'exwm-manage-finish-hook 'winner-save-old-configurations t))
    :config

    ;; make sure that displaying transient states gets the keyboard input.
    ;; Borrowed from: https://github.com/abo-abo/hydra/issues/232
    (define-advice hydra-set-transient-map (:around (fun keymap on-exit &optional foreign-keys) exwm-passthrough)
      (setq exwm-input-line-mode-passthrough t)
      (let ((on-exit (lexical-let ((on-exit on-exit))
                       (lambda ()
                         (setq exwm-input-line-mode-passthrough nil)
                         (when on-exit (funcall on-exit))))))
        (funcall fun keymap on-exit foreign-keys)))

    ;; override persp-mode's idea of frame creation for floating frames.  These
    ;; are characterized by the 'unsplittable' frame parameter, and should not
    ;; be tried to assign an existing layout to.

    (eval-after-load 'persp-mode
      (advice-add 'persp-init-new-frame :before-until 'exwm//persp-mode-inhibit-p))

    (eval-after-load 'terminal-here
      (exwm-input-set-key (kbd "<s-return>") 'terminal-here-launch))

    (add-hook 'exwm-update-class-hook 'exwm/rename-buffer)
    (add-hook 'exwm-update-title-hook 'exwm/rename-buffer)

    ;; kick all exwm buffers into insert mode per default
    (add-hook 'exwm-manage-finish-hook 'exwm/enter-insert-state)

    (evil-define-key 'normal exwm-mode-map (kbd "i") 'exwm/enter-insert-state)
    ;; Quick swtiching between workspaces
    (defvar exwm-toggle-workspace 0
      "Previously selected workspace. Used with `exwm/jump-to-last-exwm'.")

    (defadvice exwm-workspace-switch (before save-toggle-workspace activate)
      (setq exwm-toggle-workspace exwm-workspace-current-index))

    (when (and exwm-install-logind-lock-handler
               exwm-locking-command)
      (add-hook 'exwm-init-hook 'exwm//install-logind-lock-handler))
    (when exwm-autostart-xdg-applications
      (add-hook 'exwm-init-hook 'exwm//autostart-xdg-applications t))
    (add-hook 'exwm-init-hook 'exwm//install-frame-keybindings t)
    (when exwm-custom-init
      (add-hook 'exwm-init-hook exwm-custom-init t))
    ))
#+end_src

#+RESULTS:
: exwm/init-exwm
* UI
** setup.ui
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/setup-ui.el

;; -*- lexical-binding: t -*-
(setq inhibit-startup-message t
      inhibit-splash-screen t
      inhibit-startup-echo-area-message user-login-name
      inhibit-default-init t
      initial-major-mode 'fundamental-mode
      initial-scratch-message nil)
(fset #'display-startup-echo-area-message #'ignore)

;; Stop the cursor from blinking.
(blink-cursor-mode 0)
;; No fat cursors.
(setq x-stretch-cursor nil)

;; Turn off the menu, tool bars and the scroll bar
(menu-bar-mode 0)
(tool-bar-mode 0)
(scroll-bar-mode 0)
;; Turn on image viewing
(auto-image-file-mode t)

;; Get rid of the annoying system beep.
(setq ring-bell-function 'ignore)

;; Show me what I type, immediately.
(setq echo-keystrokes 0.01)

;; Middle-click paste at point, not at cursor.
(setq mouse-yank-at-point t)
;; Mouse available in terminal
(add-hook 'tty-setup-hook #'xterm-mouse-mode)

;; Scrolling
(setq scroll-margin 0
      scroll-preserve-screen-position t
      next-screen-context-lines 2)
;;; mouse
;;; (setq mouse-wheel-scroll-amount '(t ((shift) . 2))
;;;       mouse-wheel-progressive-speed t)

;;; (setq-hook! '(eshell-mode-hook term-mode-hook) hscroll-margin 0)

;; Reduce the clutter in the fringes; we'd like to reserve that space for more
;; useful information, like git-gutter and flycheck.
(setq indicate-buffer-boundaries t
      indicate-empty-lines nil
      scroll-conservatively 101
      auto-window-vscroll nil)

;;; remove continuation arrow on right fringe
;;; (delq! 'continuation fringe-indicator-alist 'assq)

;; Don't resize emacs in steps.
(setq window-resize-pixelwise t
      frame-resize-pixelwise t)

;; The native border "consumes" a pixel of the fringe on righter-most splits,
;; `window-divider' does not. Available since Emacs 25.1.
(setq window-divider-default-places t
      window-divider-default-bottom-width 2
      window-divider-default-right-width 2)
(add-hook 'after-init-hook #'window-divider-mode)

;; No popup dialogs
(setq use-dialog-box nil)

;; native linux tooltips are ugly
(when IS-LINUX
  (setq x-gtk-use-system-tooltips t))

;; Window splitting
;; Set horizontal splits as the default
;; #+begin_src emacs-lisp
;; (setq split-width-threshold 120
;;       split-height-threshold 80)
;; #+end_src
;; or favor vertical splits over horizontal ones?
(setq split-width-threshold 180
      split-height-threshold 80)

;;; ;;;###package pos-tip
;;; (setq pos-tip-internal-border-width 6
;;;       pos-tip-border-width 1)
;;; ;; Better fontification of number literals in code

;;; (use-package! highlight-numbers
;;;   :hook ((prog-mode conf-mode) . highlight-numbers-mode)
;;;   :config (setq highlight-numbers-generic-regexp "\\_<[[:digit:]]+\\(?:\\.[0-9]*\\)?\\_>"))

;;; ;;;###package hide-mode-line-mode
;;; (add-hook! '(completion-list-mode-hook Man-mode-hook)
;;;            #'hide-mode-line-mode)

(provide 'setup-ui)
;; setup-ui ends here
#+end_src

#+RESULTS:
: setup-ui

** volatile hilights
  #+begin_src emacs-lisp
    (use-package volatile-highlights
      :config
      (volatile-highlights-mode t))
  #+end_src

  #+RESULTS:
  : t
** Windows
I find it rather handy to be asked which buffer I want to see after splitting
the window. Let's make that happen.

First, we'll enter the new window
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

#+RESULTS:

Then, we'll pull up a buffer prompt.
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

#+RESULTS:

** Frame sizing
It's nice to control the size of new frames, when launching Emacs that can be
done with src_shell{emacs -geometry 160x48}. After the font size adjustment
during initialisation this works out to be ~102x31~.

Thanks to hotkeys, it's easy for me to expand a frame to half/full-screen, so it
makes sense to be conservative with the sizing of new frames.

Then, for creating new frames within the same Emacs instance, we'll just set the
default to be something roughly 80% of that size.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))
#+end_src

#+RESULTS:
: ((right-divider-width . 1) (bottom-divider-width . 1) (font . -*-Input Mono Narrow-semilight-*-*-*-15-*-*-*-*-*-*-*) (width . 80) (height . 24) (fullscreen . maximized) (alpha 95 . 80) (vertical-scroll-bars) (tool-bar-lines . 0) (menu-bar-lines . 0) (internal-border-width . 1) (buffer-predicate . exwm-layout--other-buffer-predicate))

** transparency
  #+begin_src emacs-lisp
    (defun toggle-transparency ()
      (interactive)
      (let ((alpha (frame-parameter nil 'alpha)))
	(set-frame-parameter
	 nil 'alpha
	 (if (eql (cond ((numberp alpha) alpha)
			((numberp (cdr alpha)) (cdr alpha))
			;; also handle undocumented (<active> <inactive>) form.
			((numberp (cadr alpha)) (cadr alpha)))
		  100)
	     '(85 . 50) '(100 . 100)))))
    (global-set-key (kbd "C-c T") 'toggle-transparency)
  #+end_src

  #+RESULTS:
  : toggle-transparency

** FONTS
*** Shortcut for changing font-size
#+BEGIN_SRC emacs-lisp :tangle no
  (defun zoom-in ()
    (interactive)
    (let ((x (+ (face-attribute 'default :height)
                10)))
      (set-face-attribute 'default nil :height x)))

  (defun zoom-out ()
    (interactive)
    (let ((x (- (face-attribute 'default :height)
                10)))
      (set-face-attribute 'default nil :height x)))

  (define-key global-map (kbd "C-1") 'zoom-in)
  (define-key global-map (kbd "C-0") 'zoom-out)
#+END_SRC

#+RESULTS:
: zoom-out

*** Font gen
Settings related to fonts within Doom Emacs:
+ 'doom-font' -- standard monospace font that is used for most things in Emacs.
+ 'doom-variable-pitch-font' -- variable font which is useful in some Emacs plugins.
+ 'doom-big-font' -- used in doom-big-font-mode; useful for presentations.
+ 'font-lock-comment-face' -- for comments.
+ 'font-lock-keyword-face' -- for keywords with special significance like 'setq' in elisp.

#+BEGIN_SRC emacs-lisp

(setq     doom-font (font-spec :family "Iosevka" :size 15)
          doom-variable-pitch-font (font-spec :family "Roboto" :size 16)
          doom-serif-font (font-spec :family "Libre Baskerville"))

;; (setq doom-font (font-spec :family "JetBrains Mono" :size 12)
;;       doom-big-font (font-spec :family "JetBrains Mono" :size 18)
;;       doom-variable-pitch-font (font-spec :family "Overpass" :size 12)
;;       doom-unicode-font (font-spec :family "JuliaMono")
;;       doom-serif-font (font-spec :family "IBM Plex Mono" :weight 'light))
;;; Add to ~/.doom.d/config.el
;; (setq doom-font (font-spec :family "Input Mono Narrow" :size 15 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "Fira Sans") ; inherits `doom-font''s :size
;;       doom-unicode-font (font-spec :family "Input Mono Narrow" :size 15)
;;       doom-big-font (font-spec :family "Fira Mono" :size 17))

;; (setq  doom-font (font-spec :family "Hack" :size 15)
;;        doom-variable-pitch-font (font-spec :family "Libre Baskerville")
;;        doom-serif-font (font-spec :family "Libre Baskerville"))


;; Thin grey line separating windows
(set-face-background 'vertical-border "grey")
(set-face-foreground 'vertical-border (face-background 'vertical-border))

;; (setq doom-font (font-spec :family "Source Code Pro" :size 15)
;;       doom-variable-pitch-font (font-spec :family "Ubuntu" :size 15)
;;       doom-big-font (font-spec :family "Source Code Pro" :size 24))
(after! doom-themes
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t))
(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+END_SRC

#+RESULTS:
| doom--customize-themes-h-12 | doom--customize-themes-h-14 | doom--customize-themes-h-21 |

In addition to these fonts, Merriweather is used with =nov.el=, and Alegreya as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

*** detect fonts
#+name: detect-missing-fonts
#+begin_src emacs-lisp
(defvar required-fonts '("JetBrainsMono.*" "Overpass" "JuliaMono" "IBM Plex Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

*** Mixed pitch
#+begin_quote
From the =:ui zen= module.
#+end_quote


We'd like to use mixed pitch in certain modes. If we simply add a hook, when
directly opening a file with (a new) Emacs =mixed-pitch-mode= runs before UI
initialisation, which is problematic. To resolve this, we create a hook that
runs after UI initialisation and both
+ conditionally enables =mixed-pitch-mode=
+ sets up the mixed pitch hooks

#+begin_src emacs-lisp :tangle no
(defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
  "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

#+RESULTS:
| init-mixed-pitch-h | persp-mode | window-divider-mode | +ligatures-init-h | +popup-mode |

As mixed pitch uses the variable =mixed-pitch-face=, we can create a new function
to apply mixed pitch with a serif face instead of the default. This was created
for writeroom mode.

#+begin_src emacs-lisp :tangle no
(autoload #'mixed-pitch-serif-mode "mixed-pitch"
  "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(after! mixed-pitch
  (defface variable-pitch-serif
    '((t (:family "serif")))
    "A variable-pitch face with serifs."
    :group 'basic-faces)
  (setq mixed-pitch-set-height t)
  (setq variable-pitch-serif-font (font-spec :family "Alegreya" :size 21))
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))
#+end_src

Now, as Harfbuzz is currently used in Emacs, we'll be missing out on the
following Alegreya ligatures:
#+begin_center
ff /ff/ ffi /ffi/ ffj /ffj/ ffl /ffl/
fft /fft/ fi /fi/ fj /fj/ ft /ft/
Th /Th/
#+end_center

Thankfully, it isn't to hard to add these to the ~composition-function-table~.
#+begin_src emacs-lisp :tangle no
(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijlt]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src

#+RESULTS:
| [\(?:Th\) 0 font-shape-gstring] |

** Enhancements to hl-line-mode (lin.el)
:PROPERTIES:
:CUSTOM_ID: h:601027a1-7288-4dcd-bb78-435965df27ba
:END:
*** desc
This is another package of mine: <https://protesilaos.com/emacs/lin>.
Li is a stylistic enhancement for Emacs' built-in =hl-line-mode=.  It
remaps the =hl-line= face (or equivalent) buffer-locally to a style that
is optimal for major modes where line selection is the primary mode of
interaction.

The idea is that =hl-line-mode= cannot work equally well for contexts
with competing priorities: (i) line selection, or (ii) simple line
highlight.  In the former case, the current line needs to be made
prominent because it carries a specific meaning of some significance in
the given context: the user has to select a line.  Whereas in the latter
case, the primary mode of interaction does not revolve around the line
highlight itself: it may be because the focus is on editing text or
reading through the buffer's contents, so the current line highlight is
more of a reminder of the point's location on the vertical axis.

=lin-mode= enables =hl-line-mode= by adding it to every hook specified
in the user option =lin-mode-hooks=.  Users are advised to configure
that variable with =customize-set-variable=, or the Custom UI, or
equivalent as it has a function which automatically sets up Lin.  Those
who prefer to set values with =setq= must handle the process manually,
by using the =lin-setup= function.

Users can selected their preferred style by customizing the user option
=lin-face=.  Options include the faces =lin-red=, =lin-green=,
=lin-yellow=, =lin-blue= (default), =lin-magenta=, =lin-cyan=,
=lin-mac=, =lin-red-override-fg=, =lin-green-override-fg=,
=lin-yellow-override-fg=, =lin-blue-override-fg=,
=lin-magenta-override-fg=, =lin-cyan-override-fg=,
=lin-mac-override-fg=, or any other face that preferably has a
background attribute.  The Lin faces with the =-override-fg= suffix set
a foreground value which replaces that of the underlying text.  Whereas
the others only specify a background attribute.

*** code
#+begin_src emacs-lisp
;;; Enhancements to hl-line-mode (lin.el)
(use-package lin
  ;; Either run `lin-setup' or change `lin-mode-hooks'.  I prefer the
  ;; latter.

  ;; (lin-setup)

  ;; Do not use `setq' for `lin-mode-hooks' and `lin-face'.  Both have a
  ;; custom setter function associated with them, which automatically
  ;; sets things up when they are configured via Custom (with
  ;; `custom-set-variables', `customize-set-variable', the Custom UI,
  ;; the `:custom' keyword of `use-package', or related).  Read their
  ;; doc strings if you still want to use `setq'.
  :config
  (custom-set-variables
   '(lin-mode-hooks
     '(bongo-mode-hook
       dired-mode-hook
       elfeed-search-mode-hook
       git-rebase-mode-hook
       ibuffer-mode-hook
       ilist-mode-hook
       ledger-report-mode-hook
       log-view-mode-hook
       magit-log-mode-hook
       mu4e-headers-mode
       notmuch-search-mode-hook
       notmuch-tree-mode-hook
       occur-mode-hook
       org-agenda-mode-hook
       tabulated-list-mode-hook))
   '(lin-face 'lin-blue))) ; check `lin-face' doc string for alternative styles
#+end_src

#+RESULTS:
: t

** Modus themes (my highly accessible themes)
:PROPERTIES:
:CUSTOM_ID: h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6
:END:
*** desc
This is a project I started as soon as I switched to Emacs in July 2019.
About a year later the themes became part of upstream Emacs, available
for Emacs version 28 (as of version 0.12.0 of the themes).  I have
benefited a lot from community contributions, of which I am most
thankful of, as discussed in [[https://protesilaos.com/codelog/2020-08-27-emacs-modus-themes-core/][My Modus themes are now shipped with Emacs]]
(2020-08-27).

The Modus themes are designed for accessible readability.  They conform
with the highest standard for colour contrast between foreground and
background values.  This stands for a minimum contrast ratio of 7:1,
also known as the WCAG AAA standard (the highest of its kind).

The themes are "Modus Operandi" (light) and "Modus Vivendi" (dark).  The
source code is available [[https://gitlab.com/protesilaos/modus-themes][on their GitLab page]] while you can read the
HTML version of [[https://protesilaos.com/emacs/modus-themes][their manual on my website]].  If you have the package
installed or are using Emacs >=28, you can read the manual from the
built-in Info reader.  Evaluate: =(info "(modus-themes) Top")=.

The manual covers everything from the basics to more advanced,
"do-it-yourself" cases.

The list of supported packages is comprehensive and a lot of work goes
into getting the details right.  Plus, there are *lots of customisation
options* to tweak the looks of the themes (note though that the values I
set for those variables in the following code block are not indicative
of my preferences, as I always try different combinations to test things
across a range of scenaria).

Lastly, if you are curious about the underlying methodology, read my
essay [[https://protesilaos.com/codelog/2020-03-17-design-modus-themes-emacs/][on the design of the Modus themes]] (2020-03-17).  And here are some
more resources from my website for those who are really into the minutia
and wish to get a glimpse of how much work goes into this project:

+ [[https://protesilaos.com/codelog/2020-05-10-modus-operandi-palette-review/][Modus Operandi theme subtle palette review]] (2020-05-10)
+ [[https://protesilaos.com/codelog/2020-06-13-modus-vivendi-palette-review/][Modus Vivendi theme subtle palette review]] (2020-06-13)
+ [[https://protesilaos.com/codelog/2020-07-04-modus-themes-faint-colours/][Modus themes: new "faint syntax" option]] (2020-07-04)
+ [[https://protesilaos.com/codelog/2020-07-08-modus-themes-nuanced-colours/][Modus themes: major review of "nuanced" colours]] (2020-07-08)
+ [[https://protesilaos.com/codelog/2020-08-09-modus-themes-paren-match/][Modus themes: review "paren-match" colours]] (2020-08-09)
+ [[https://protesilaos.com/codelog/2020-08-28-notes-emacs-theme-devs/][Notes for aspiring Emacs theme developers]] (2020-08-28)
+ [[https://protesilaos.com/codelog/2020-09-14-modus-themes-review-blues/][Modus themes: report on the review of the main blue colours]] (2020-09-14)
+ [[https://protesilaos.com/codelog/2020-12-27-modus-themes-review-rainbow-delimiters/][Modus themes: review rainbow-delimiters faces]] (2020-12-27)
+ [[https://protesilaos.com/codelog/2021-01-11-modus-themes-review-select-faint-colours/][Modus themes: review of select "faint" colours]] (2021-01-11)
+ [[https://protesilaos.com/codelog/2021-02-25-modus-themes-diffs-deuteranopia/][The Modus themes now cover deuteranopia in diffs]] (2021-02-25)
+ [[https://protesilaos.com/codelog/2021-05-19-modus-themes-status-update/][Status update on the Modus themes for Emacs]] (2021-05-19)
+ [[https://protesilaos.com/codelog/2021-06-02-modus-themes-org-agenda/][Introducing the variable modus-themes-org-agenda]] (2021-06-02)
+ [[https://protesilaos.com/codelog/2022-01-02-review-modus-themes-org-habit-colours/][Modus themes: review of the org-habit graph colours]] (2022-01-02)
+ [[https://protesilaos.com/codelog/2022-01-03-modus-themes-port-faq/][Re: VSCode or Vim ports of the Emacs modus-themes?]] (2022-01-03)

And if you do enjoy reading such entries, then you may also wish to
check the [[https://protesilaos.com/emacs/modus-themes-changelog/][Change Log of the Modus themes]].

*** code
#+begin_src emacs-lisp
;;; Modus themes (my highly accessible themes)
(use-package modus-themes
  ;; Add all your customizations prior to loading the themes
  ;;
  ;; NOTE: these are not my preferences!  I am always testing various
  ;; configurations.  Though I still like what I have here.
  :config
  (setq modus-themes-italic-constructs nil
        modus-themes-bold-constructs t
        modus-themes-mixed-fonts nil
        modus-themes-subtle-line-numbers nil
        modus-themes-intense-mouseovers t
        modus-themes-deuteranopia t
        modus-themes-tabs-accented nil
        modus-themes-variable-pitch-ui nil
        modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

        modus-themes-fringes nil ; {nil,'subtle,'intense}

        ;; Options for `modus-themes-lang-checkers' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `straight-underline', `text-also', `background',
        ;; `intense' OR `faint'.
        modus-themes-lang-checkers nil

        ;; Options for `modus-themes-mode-line' are either nil, or a list
        ;; that can combine any of `3d' OR `moody', `borderless',
        ;; `accented', a natural number for extra padding (or a cons cell
        ;; of padding and NATNUM), and a floating point for the height of
        ;; the text relative to the base font size (or a cons cell of
        ;; height and FLOAT)
        modus-themes-mode-line nil

        ;; Options for `modus-themes-markup' are either nil, or a list
        ;; that can combine any of `bold', `italic', `background',
        ;; `intense'.
        modus-themes-markup nil

        ;; Options for `modus-themes-syntax' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `faint', `yellow-comments', `green-strings', `alt-syntax'
        modus-themes-syntax nil

        ;; Options for `modus-themes-hl-line' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `accented', `underline', `intense'
        modus-themes-hl-line '(intense)

        ;; Options for `modus-themes-paren-match' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `bold', `intense', `underline'
        modus-themes-paren-match nil

        ;; Options for `modus-themes-links' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `neutral-underline' OR `no-underline', `faint' OR `no-color',
        ;; `bold', `italic', `background'
        modus-themes-links nil

        ;; Options for `modus-themes-box-buttons' are either nil (the
        ;; default), or a list that can combine any of `flat',
        ;; `accented', `faint', `variable-pitch', `underline', the
        ;; symbol of any font weight as listed in
        ;; `modus-themes-weights', and a floating point number
        ;; (e.g. 0.9) for the height of the button's text.
        modus-themes-box-buttons '(variable-pitch flat faint 0.9)

        ;; Options for `modus-themes-prompts' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `background', `bold', `gray', `intense', `italic'
        modus-themes-prompts '(background subtle)

        ;; The `modus-themes-completions' is an alist that reads three
        ;; keys: `matches', `selection', `popup'.  Each accepts a nil
        ;; value (or empty list) or a list of properties that can include
        ;; any of the following (for WEIGHT read further below):
        ;;
        ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
        ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
        ;; `popup' - same as `selected'
        ;; `t' - applies to any key not explicitly referenced (check docs)
        ;;
        ;; WEIGHT is a symbol such as `semibold', `light', or anything
        ;; covered in `modus-themes-weights'.  Bold is used in the absence
        ;; of an explicit WEIGHT.
        modus-themes-completions
        '((matches . (extrabold background))
          (selection . (semibold intense accented text-also))
          (popup . (accented intense)))

        modus-themes-mail-citations nil ; {nil,'intense,'faint,'monochrome}

        ;; Options for `modus-themes-region' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `no-extend', `bg-only', `accented'
        modus-themes-region '(no-extend)

        ;; Options for `modus-themes-diffs': nil, 'desaturated, 'bg-only
        modus-themes-diffs 'desaturated

        modus-themes-org-blocks nil ; {nil,'gray-background,'tinted-background}

        modus-themes-org-agenda ; this is an alist: read the manual or its doc string
        '((header-block . (variable-pitch regular 1.4))
          (header-date . (bold-today grayscale underline-today 1.2))
          (event . (accented italic varied))
          (scheduled . uniform)
          (habit . nil))

        modus-themes-headings ; this is an alist: read the manual or its doc string
        '((t . (variable-pitch extrabold)))

        ;; Sample for headings:

        ;; modus-themes-headings
        ;; '((1 . (variable-pitch light 1.6))
        ;;   (2 . (variable-pitch regular 1.4))
        ;;   (3 . (variable-pitch regular 1.3))
        ;;   (4 . (1.2))
        ;;   (5 . (1.1))
        ;;   (t . (monochrome 1.05)))
        )

  ;; Load the theme files efore enabling a theme (else you get an error).
  (modus-themes-load-themes)

  ;; Custom faces (for demo purposes---check the themes' manual for more
  ;; advanced uses).
  (defun prot/modus-themes-custom-faces ()
    (modus-themes-with-colors
      (custom-set-faces
       ;; Here add all your face definitions.
       `(cursor ((,class :background ,magenta-intense))))))

  (add-hook 'modus-themes-after-load-theme-hook #'prot/modus-themes-custom-faces)

  ;; Enable the theme at startup.  This is done after loading the files.
  ;; You only need `modus-themes-load-operandi' for the light theme or
  ;; `modus-themes-load-vivendi' for the dark one.  What I have here is
  ;; a simple test to load a light/dark theme based on some general time
  ;; ranges (just accounting for the hour and without checking for the
  ;; actual sunrise/sunset times).  Plus we have `modus-themes-toggle'
  ;; to switch themes at will.
  (let ((time (string-to-number (format-time-string "%H"))))
    (if (and (> time 5) (< time 18))
        (modus-themes-load-operandi)
      (modus-themes-load-vivendi)))

  ;; Also check my package configurations for `prot-fonts' because I use
  ;; the `modus-themes-after-load-theme-hook' for some typeface-related
  ;; tweaks (as those are made at the "face" level).
  (define-key global-map (kbd "<f5>") #'modus-themes-toggle))
#+end_src
*** doom spe
#+begin_src emacs-lisp :tangle no

(use-package modus-themes
  :ensure
  :init
  ;; Add all your customizations prior to loading the themes
  (setq modus-themes-italic-constructs t
        modus-themes-completions 'opinionated
        modus-themes-variable-pitch-headings t
        modus-themes-scale-headings t
        modus-themes-variable-pitch-ui t
        modus-themes-org-agenda
        '((header-block . (variable-pitch scale-title))
          (header-date . (grayscale bold-all)))
        modus-themes-org-blocks
        '(grayscale)
        modus-themes-mode-line
        '(borderless)
        modus-themes-region '(bg-only no-extend))

  ;; Load the theme files before enabling a theme
  (modus-themes-load-themes)
  :config
  (modus-themes-load-operandi)
  :bind ("<f5>" . modus-themes-toggle))
#+end_src

#+RESULTS:
: modus-themes-toggle

** MODELINE
*** Theme and modeline

Setting the theme to doom-vibrant.  To try out new themes, I set a keybinding for counsel-load-theme with 'SPC h t'.
#+begin_src emacs-lisp
(use-package! doom-themes
  :config
  ;; Global settings (defaults)
  ;; (load-theme 'doom-vibrant t)
  ;; (load-theme 'leuven t)
  ;; (load-theme 'doom-dark+ t)
  ;; (load-theme 'doom-solarized-light t)
  ;; (load-theme 'doom-one t)
  ;; (load-theme 'doom-one-light t)
  ;; (load-theme 'doom-nord-light t)

  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)

  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))

;; (setq doom-theme 'modus-vivendi)
  (doom-themes-visual-bell-config)
(map! :leader
      :desc "Load new theme" "h t" #'load-theme)
#+END_SRC

#+RESULTS:
: counsel-load-theme

#+end_src

However, by default ~red~ text is used in the ~modeline~, so let's make that orange
so I don't feel like something's gone /wrong/ when editing files.

#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src

#+RESULTS:
| doom--customize-themes-h-33 | doom--customize-themes-h-34 |

While we're modifying the modeline, =LF UTF-8= is the default file encoding, and
thus not worth noting in the modeline. So, let's conditionally hide it.

#+begin_src emacs-lisp :tangle no
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

;; (add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

#+RESULTS:
: doom-modeline-conditional-buffer-encoding

*** General modeline
The modeline is the bottom status bar that appears in Emacs windows.  For more information on what is available to configure in the Doom modeline, check out:
https://github.com/seagle0128/doom-modeline

#+begin_src emacs-lisp :tangle no
;; (set-face-attribute 'mode-line nil :font "Ubuntu Mono-13")
;; (setq doom-modeline-height 20     ;; sets modeline height
;;       doom-modeline-bar-width 2   ;; sets right bar width
;;       doom-modeline-persp-name t  ;; adds perspective name to modeline
;;       doom-modeline-persp-icon t) ;; addsfolder icon next to persp name

(setq display-time-format "%l:%M %p %b %y"
      display-time-default-load-average nil)

;; You must run (all-the-icons-install-fonts) one time after
;; installing this package!

(use-package minions
  :hook (doom-modeline-mode . minions-mode))

(use-package doom-modeline
  :after eshell     ;; Make sure it gets hooked after eshell
  :hook (after-init . doom-modeline-init)
  :custom-face
  (mode-line ((t (:height 0.90))))
  (mode-line-inactive ((t (:height 0.90))))
  :custom
  (doom-modeline-height 15)
  (doom-modeline-bar-width 5)
  (doom-modeline-lsp t)
  (doom-modeline-github nil)
  (doom-modeline-mu4e nil)
  (doom-modeline-irc nil)
  (doom-modeline-minor-modes t)
  (doom-modeline-persp-name nil)
  (doom-modeline-buffer-file-name-style 'truncate-except-project)
  (doom-modeline-major-mode-icon nil))
#+end_src

#+RESULTS:
| doom-init-fonts-h | doom-init-theme-h | doom-modeline-init | global-emojify-mode | #[0 \303\211\235\203\0\304"\301\305!\210\210	\205\0\306 \210\307\211\207 [command-line-args desktop-save-mode inhibit-startup-screen --no-desktop delete 0 desktop-read t] 4] | org-persist-load-all | global-auto-revert-mode | savehist-mode | window-divider-mode | doom-modeline-mode | doom-init-leader-keys-h | general-auto-unbind-keys | x-wm-set-size-hint | tramp-register-archive-file-name-handler | magit-maybe-define-global-key-bindings | magit-auto-revert-mode--init-kludge | magit-startup-asserts | magit-version | table--make-cell-map |

*** Mode line
***** desc
The mode line is an integral part of the Emacs interface.  While there
are lots of third party packages that style it in a variety of ways, I
find the default to be "good enough".

In the code snippet right below I reshuffle some of the mode line
indicators.  Nothing too fancy.  The =mode-line-defining-kbd-macro= is
tweaked to use a more appropriate string for its indicator and to apply
colours that are designed specifically for the mode line (the default
uses the generic font-lock warning face).

Note that in [[#h:77d14350-978d-4820-ab7f-4641706c445a][Custom extensions for "focus mode" (logos.el)]] I provide a
snippet that optionally toggles the visibility of the modeline while
entering a bespoke "focus mode" for writing/reading.
***** code
#+begin_src emacs-lisp
;;; Mode line
(setq mode-line-percent-position '(-3 "%p"))
(setq mode-line-position-column-line-format '(" %l,%c")) ; Emacs 28
(setq mode-line-defining-kbd-macro
      (propertize " Macro" 'face 'mode-line-emphasis))

;; Thanks to Daniel Mendler for this!  It removes the square brackets
;; that denote recursive edits in the modeline.  I do not need them
;; because I am using Daniel's `recursion-indicator':
;; <https://github.com/minad/recursion-indicator>.
(setq-default mode-line-modes
              (seq-filter (lambda (s)
                            (not (and (stringp s)
                                      (string-match-p
                                       "^\\(%\\[\\|%\\]\\)$" s))))
                          mode-line-modes))

(setq mode-line-compact nil)            ; Emacs 28
(setq-default mode-line-format
              '("%e"
                mode-line-front-space
                mode-line-mule-info
                mode-line-client
                mode-line-modified
                mode-line-remote
                mode-line-frame-identification
                mode-line-buffer-identification
                "  "
                mode-line-position
                mode-line-modes
                "  "
                (vc-mode vc-mode)
                "  "
                mode-line-misc-info
                mode-line-end-spaces))
#+end_src

#+RESULTS:
| %e | mode-line-front-space | mode-line-mule-info | mode-line-client | mode-line-modified | mode-line-remote | mode-line-frame-identification | mode-line-buffer-identification |   | mode-line-position | mode-line-modes |   | (vc-mode vc-mode) |   | mode-line-misc-info | mode-line-end-spaces |

In the following sub-sections I provide customisations for some tools
that place information on the mode line.  Again, nothing flamboyant.

**** Moody.el (simple mode line configuration utility)
:PROPERTIES:
:CUSTOM_ID: h:c07b9dfc-14a2-41a6-9310-53539dec8684
:END:

=moody.el= is a lightweight library that adds some flair to the mode line
without complicating things.  It is developed by Jonas Bernoulli.  I
have been using it on and off to make sure that it works well with my
themes (see [[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).

My fairly minor tweaks in =prot-moody.el= (reproduced further below) align
Moody with my [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]].  What I basically
want is to make the mode line gracefully adapt to changes in font size.

#+begin_src emacs-lisp
;;; Moody.el (simple mode line configuration utility)
(use-package moody)
(add-to-list 'load-path "~/.config/doom/lisp/")
(load "prot-moody.el")
(use-package prot-moody)
  ;; Adjust this and then evaluate `prot-moody-set-height'.  Not all
  ;; fonts work equally well with the same value.
  (setq prot-moody-font-height-multiplier 1.35)

  ;; Also check the Modus themes' `modus-themes-mode-line' which can set
  ;; the styles specifically for Moody.
  (prot-moody-set-height -1)
#+end_src

#+RESULTS:

**** Hide modeline "lighters" (minions.el)
:PROPERTIES:
:CUSTOM_ID: h:b31005e3-c475-4be9-87fd-85b404550d8c
:END:

This package by Jonas Bernoulli neatly wraps up all minor mode
"lighters" and hides them behind a single character.  The "lighter" is
the text that identifies the minor mode on the mode line.  Having a
few of them is usually okay, but a lot of them do not scale well.

#+begin_src emacs-lisp
;;; Hide modeline "lighters" (minions.el)
(use-package minions
  :config
  (setq minions-mode-line-lighter ";")
  ;; NOTE: This will be expanded whenever I find a mode that should not
  ;; be hidden
  (setq minions-prominent-modes
        (list 'defining-kbd-macro
              'flymake-mode
              'prot-simple-monocle))
  (minions-mode 1))
#+end_src

#+RESULTS:
: t

**** Mode line recursion indicators
:PROPERTIES:
:CUSTOM_ID: h:bb707bec-bcaf-44d0-bb82-1ed6bb0cb33b
:END:

This utility by Daniel Mendler provides a couple of indicators for
denoting minibuffer recursion.  They offer a reminder that we are in the
midst of a recursive editing session when we should, perhaps, not be in
one.  I consider =recursion-indicator= complementary to what is already
built into Emacs in the form of =minibuffer-depth-indicate-mode= which
shows the level of recursion at the current minibuffer prompt (refer to
[[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

#+begin_src emacs-lisp
;;; Mode line recursion indicators
(use-package recursion-indicator
  :config
  (setq recursion-indicator-general "&")
  (setq recursion-indicator-minibuffer "@")
  (recursion-indicator-mode 1))
#+end_src

#+RESULTS:
: t

**** Display current time (and =world-clock=)
***** desc
I normally use Emacs in fullscreen view.  No system panels, no window
decorations, no icons and blinking indicators.  Nothing to distract me.
While I really like this immersive experience, sometimes I need to take
a look at the time...  Thankfully Emacs offers a convenient, built-in
way of displaying such information in the mode line: just enable
=display-time-mode=.

The =display-time-format= can be configured to show the current date and
time in all the various formats we would expect, using a string of
specifiers (find the docs with =C-h v format-time-string=).  Setting its
value to =nil= means that the information on display will be the combined
result of =display-time-24hr-format= and =display-time-day-and-date=.  I
prefer to just write a string directly, keeping those two inactive.

The =display-time-mode= can output more than just the current time.  It
also shows the load average and an email indicator.  I do not need the
load average as it adds too much noise.  As for the mail indicator, I
used it for a while, but eventually decided to use my own approach which
also shows the number of new emails (refer to the [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]] and
search, in particular, for either the old =prot-mail-mail-indicator= or
the newer =prot-notmuch-mail-indicator=).

Since the inception of =prot-tab.el= which creates a status line that
replaces mode lines, I enable the clock and mail indicator only when the
status line is enabled (see [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts]]).

Lastly, I use the =world-clock= command (for Emacs28+) when I need to get
an overview of the current time in various parts of the planet.

***** code
#+begin_src emacs-lisp :tangle no
;;; Display current time
(use-package time
  :config
  (setq display-time-format "%a %e %b, %H:%M")
  ;;;; Covered by `display-time-format'
  ;; (setq display-time-24hr-format t)
  ;; (setq display-time-day-and-date t)
  (setq display-time-interval 60)
  (setq display-time-default-load-average nil)
  ;; NOTE 2021-04-19: For all those, I have implemented a custom
  ;; solution that also shows the number of new items.  Refer to my
  ;; email settings, specifically `prot-mail-mail-indicator'.
  ;;
  ;; NOTE 2021-05-16: Or better check `prot-notmuch-mail-indicator'.
  (setq display-time-mail-directory nil)
  (setq display-time-mail-function nil)
  (setq display-time-use-mail-icon nil)
  (setq display-time-mail-string nil)
  (setq display-time-mail-face nil)

;;; World clock
  (setq zoneinfo-style-world-list
        '(("America/Los_Angeles" "Los Angeles")
          ("America/Chicago" "Chicago")
          ("Brazil/Acre" "Rio Branco")
          ("America/New_York" "New York")
          ("Brazil/East" "Brasília")
          ("Europe/Lisbon" "Lisbon")
          ("Europe/Brussels" "Brussels")
          ("Europe/Athens" "Athens")
          ("Asia/Tehran" "Tehran")
          ("Asia/Tbilisi" "Tbilisi")
          ("Asia/Yekaterinburg" "Yekaterinburg")
          ("Asia/Shanghai" "Shanghai")
          ("Asia/Tokyo" "Tokyo")
          ("Asia/Vladivostok" "Vladivostok")))

  ;; All of the following variables are for Emacs 28
  (setq world-clock-list t)
  (setq world-clock-time-format "%R %z  %A %d %B")
  (setq world-clock-buffer-name "*world-clock*") ; Placement handled by `display-buffer-alist'
  (setq world-clock-timer-enable t)
  (setq world-clock-timer-second 60)

  ;; ;; NOTE 2021-10-04: Check `prot-tab-status-line'.
  ;; (add-hook 'after-init-hook #'display-time-mode)
  )
#+end_src

#+RESULTS:
: t

**** Name of current form (which-function-mode)
:PROPERTIES:
:CUSTOM_ID: h:3f2c2d04-01c0-4c35-9a4f-a0cb00bb3062
:END:

The built-in =which-function-mode= is a global minor-mode that shows the
name of the form at point.  In programming modes that is the current
function or, in the case of Elisp, the top-level form.  In Org it is the
title of the current section.  In diffs it is the heading of the present
hunk (to get useful headings for Elisp and Org diffs, read my blog
[[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][Informative diff hunks for Emacs Lisp and Org]] (2021-01-26)).

To control the buffers in which this mode is active, we write them as a
list for =which-func-modes=.  A value of =t= signifies every mode, which I
do not consider a good default for a global minor mode.

#+begin_src emacs-lisp
;;; Name of current form (which-function-mode)
(use-package which-func
  :config
  (setq which-func-unknown "")
  (setq which-func-format     ; NOTE 2021-07-28: removes square brackets
        `((:propertize which-func-current
		               local-map ,which-func-keymap
		               face which-func
		               mouse-face mode-line-highlight
		               help-echo "mouse-1: go to beginning\n\
mouse-2: toggle rest visibility\n\
mouse-3: go to end")))
  (setq which-func-modes
        ;; '( emacs-lisp-mode org-mode markdown-mode diff-mode)
        '( emacs-lisp-mode diff-mode))

  (which-function-mode 1))
#+end_src

#+RESULTS:
: t

**** Keycast mode
:PROPERTIES:
:CUSTOM_ID: h:e8e51a73-e583-4250-ac26-15627cd93932
:END:

Once enabled, this package uses the mode line to show the keys being
pressed and the command they call.  It is quite useful for screen
casting.

The placement of the indicator is controlled by the user option
=keycast-mode-line-window-predicate= which I set to the current window.
The =moody.el= library offers that specific piece of functionality
(though [[#h:c07b9dfc-14a2-41a6-9310-53539dec8684][I also configure Moody]] for its primary purpose of styling the
mode line).

The tweaks to the =keycast-substitute-alist= prevent the display of
self-inserting characters and some other commands that are not
particularly useful while screen casting.  Now the indicator will only
show commands, which looks cleaner.  I got the idea and original piece
of Elisp from the [[https://github.com/aadcg/dotfiles][dotfiles of André Alexandre Gomes]] and then added a few
tweaks of my own.

#+begin_src emacs-lisp
;;; Keycast mode
(use-package keycast
  :config
  ;; Those are for `keycast-mode'
  (setq keycast-mode-line-window-predicate 'moody-window-active-p) ; assumes `moody.el'
  (setq keycast-separator-width 1)
  (setq keycast-mode-line-remove-tail-elements nil)

  (dolist (input '(self-insert-command
                   org-self-insert-command))
    (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))

  (dolist (event '(mouse-event-p
                   mouse-movement-p
                   mwheel-scroll))
    (add-to-list 'keycast-substitute-alist `(,event nil)))

  ;; Those are for the `keycast-log-mode'
  (setq keycast-log-format "%-20K%C\n")
  (setq keycast-log-frame-alist
        '((minibuffer . nil)))
  (setq keycast-log-newest-first t)

  ;; Specify `keycast-insert-after' buffer identification.  This make it
  ;; possible to seamlessly toggle `prot-moody-set-height' without
  ;; disrupting keycast.
  (with-eval-after-load 'prot-moody
    (add-hook 'prot-moody-set-height-hook #'prot-moody-keycast-insert-after)))
#+end_src

#+RESULTS:
: t

*** Doom modeline
#+begin_quote
From the =:ui modeline= module.
#+end_quote


Very nice and pretty, however I think the PDF modeline could do with tweaking.
I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this, however the response was basically "put your
preferences in your personal config, the current default is sensible" --- so
here we are.

First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp :tangle no
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

#+RESULTS:
: doom-modeline-format--pdf

*** smart modeline
Smart Mode Line
Prettify the modeline with smart-mode-line. Really need to re-evaluate the ordering of mode-line-format. Also not sure if rm-excluded-modes is needed anymore if I set up diminish correctly.

#+begin_src emacs-lisp :tangle no

(use-package diminish)
(use-package smart-mode-line
  ;; :disabled
  ;; :if dw/is-termux
  :config
  (setq sml/no-confirm-load-theme nil)
  (sml/setup)
  (sml/apply-theme 'respectful)  ; Respect the theme colors
  (setq sml/mode-width 'right
      sml/name-width 60)

  (setq-default mode-line-format
  `("%e"
      ;; ,(when exwm-enabled
      ;;     '(:eval (format "[%d] " exwm-workspace-current-index)))
      mode-line-front-space
      evil-mode-line-tag
      mode-line-mule-info
      mode-line-client
      mode-line-modified
      mode-line-remote
      mode-line-frame-identification
      mode-line-buffer-identification
      sml/pos-id-separator
      (vc-mode vc-mode)
      " "
      ;mode-line-position
      sml/pre-modes-separator
      mode-line-modes
      " "
      mode-line-misc-info))

  (setq rm-excluded-modes
    (mapconcat
      'identity
      ; These names must start with a space!
      '(" GitGutter" " MRev" " company"
      " Helm" " Undo-Tree" " Projectile.*" " Z" " Ind"
      " Org-Agenda.*" " ElDoc" " SP/s" " cider.*")
      "\\|")))
#+end_src

#+RESULTS:
: t

** pulsar.el (highlight cursor position)
:PROPERTIES:
:CUSTOM_ID: h:6bbc41d6-da7c-4301-84c6-c5887c29283f
:END:

This is a small package of mine that highlights the current line after a
given command is invoked.  The affected commands are defined in the user
option =pulsar-pulse-functions=.  This is one of the few options I set
with =customize-set-variable=.  Unlike =setq= this has the ability to
run the custom-setter code specified in the option's definition.  Put
concretely, it makes sure the affected functions are updated properly.

Pulsar builds on top of the built-in =pulse.el=.  More information in
the official manual: https://protesilaos.com/emacs/pulsar.

#+begin_src emacs-lisp
;;; pulsar.el (highlight cursor position)
;; Read the pulsar manual: <https://protesilaos.com/emacs/pulsar>.
(use-package pulsar
  :config
  (customize-set-variable
   'pulsar-pulse-functions ; Read the doc string for why not `setq'
   '(recenter-top-bottom
     move-to-window-line-top-bottom
     reposition-window
     bookmark-jump
     other-window
     delete-window
     delete-other-windows
     forward-page
     backward-page
     scroll-up-command
     scroll-down-command
     windmove-right
     windmove-left
     windmove-up
     windmove-down
     windmove-swap-states-right
     windmove-swap-states-left
     windmove-swap-states-up
     windmove-swap-states-down
     tab-new
     tab-close
     tab-next
     org-next-visible-heading
     org-previous-visible-heading
     org-forward-heading-same-level
     org-backward-heading-same-level
     outline-backward-same-level
     outline-forward-same-level
     outline-next-visible-heading
     outline-previous-visible-heading
     outline-up-heading))

  (setq pulsar-pulse t)
  (setq pulsar-delay 0.055)
  (setq pulsar-iterations 10)
  (setq pulsar-face 'pulsar-magenta)

  ;; pulsar does not define any key bindings.  This is just my personal
  ;; preference.  Remember to read the manual on the matter.  Evaluate:
  ;;
  ;; (info "(elisp) Key Binding Conventions")
  (let ((map global-map))
    (define-key map (kbd "C-x l") #'pulsar-pulse-line) ; override `count-lines-page'
    (define-key map (kbd "C-x L") #'pulsar-highlight-line)))
#+end_src

#+RESULTS:
: t

** DASHBOARD
Emacs Dashboard is an extensible startup screen showing you recent files, bookmarks, agenda items and an Emacs banner.
*** Configuring Dashboard
#+begin_src emacs-lisp
(use-package dashboard
  :init      ;; tweak dashboard config before loading it
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-banner-logo-title "\nKEYBINDINGS:\
\nFind file               (SPC .)     \
Open buffer list    (SPC b i)\
\nFind recent files       (SPC f r)   \
Open the eshell     (SPC e s)\
\nOpen dired file manager (SPC d d)   \
List of keybindings (SPC h b b)")
  ;;(setq dashboard-startup-banner 'logo) ;; use standard emacs logo as banner
  (setq dashboard-startup-banner "~/.config/doom/doom-emacs-dash.png")  ;; use custom image as banner
  ;; (setq dashboard-startup-banner "~/.doom.d/doom-emacs-dash.png")  ;; use custom image as banner
  (setq dashboard-center-content nil) ;; set to 't' for centered content
  (setq dashboard-items '((recents . 5)
                          (agenda . 5 )
                          (bookmarks . 5)
                          (projects . 5)
                          (registers . 5)))
  :config
  (dashboard-setup-startup-hook)
  (dashboard-modify-heading-icons '((recents . "file-text")
                                    (bookmarks . "book"))))
#+end_src

#+RESULTS:
: t

*** Dashboard in Emacsclient
This setting ensures that emacsclient always opens on *dashboard* rather than *scratch*.
#+begin_src emacs-lisp
(setq doom-fallback-buffer "*dashboard*")
 (setq doom-fallback-buffer-name "► Doom"
     +doom-dashboard-name "► Doom")
#+end_src

#+RESULTS:
: ► Doom

** LINE SETTINGS
*** Line numbers and relevant indicators (prot-sideline.el)
:PROPERTIES:
:CUSTOM_ID: h:cb76fcee-e304-4b86-a764-6c3c6775da51
:END:

=prot-sideline.el= (reproduced after the package configurations) is a set
of simplete-minded features:

1. It bundles up together three distinct visual elements as part of a
   common minor mode: =prot-sideline-mode=.  Its constituents are current
   line highlighting (=hl-line-mode=), diff indicators (=diff-hl-mode=), and
   line numbers (=display-line-numbers-mode=).  Line numbers and line
   highlighting are built into Emacs.

2. A simple toggle for =whitespace-mode=, which I only ever use to double
   check some area's indentation or to confirm that no newline is
   missing at the end of the file.

Note that the =diff-hl= package offers some more features other than the
obvious colour-coded highlighting of changes, such as the ability to
move between diff hunks (with =C-x v [= and =C-x v ]=) or to revert the
current hunk (=C-x v n=).  Those can come in handy (check my comprehensive
extensions in [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]).

#+begin_src emacs-lisp
;;; Line numbers and relevant indicators (prot-sideline.el)
(load "prot-sideline")
(use-package prot-sideline
  :config
  (require 'display-line-numbers)
  ;; Set absolute line numbers.  A value of "relative" is also useful.
  (setq display-line-numbers-type t)
  ;; Those two variables were introduced in Emacs 27.1
  (setq display-line-numbers-major-tick 0)
  (setq display-line-numbers-minor-tick 0)
  ;; Use absolute numbers in narrowed buffers
  (setq-default display-line-numbers-widen t)

  (use-package diff-hl
    :config
    (setq diff-hl-draw-borders nil)
    (setq diff-hl-side 'left))

  (require 'hl-line)
  (setq hl-line-sticky-flag nil)
  (setq hl-line-overlay-priority -50) ; emacs28

  (require 'whitespace)

  (let ((map global-map))
    (define-key map (kbd "<f6>") #'prot-sideline-negative-space-toggle)
    (define-key map (kbd "<f7>") #'prot-sideline-mode)
    (define-key map (kbd "C-c z") #'delete-trailing-whitespace)))
#+end_src

#+RESULTS:
: t

*** general line
I set comment-line to 'SPC TAB TAB' which is a rather comfortable keybinding for me on my ZSA Moonlander keyboard.  The standard Emacs keybinding for comment-line is 'C-x C-;'.  The other keybindings are for commands that toggle on/off various line-related settings.  Doom Emacs uses 'SPC t' for "toggle" commands, so I choose 'SPC t' plus 'key' for those bindings.

| COMMAND                  | DESCRIPTION                               | KEYBINDING  |
|--------------------------+-------------------------------------------+-------------|
| comment-line             | /Comment or uncomment lines/                | SPC TAB TAB |
| hl-line-mode             | /Toggle line highlighting in current frame/ | SPC t h     |
| global-hl-line-mode      | /Toggle line highlighting globally/         | SPC t H     |
| doom/toggle-line-numbers | /Toggle line numbers/                       | SPC t l     |
| toggle-truncate-lines    | /Toggle truncate lines/                     | SPC t t     |

Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.
#+BEGIN_SRC emacs-lisp
;; (setq display-line-numbers-type 'relative)
(setq display-line-numbers-type nil)
(map! :leader
      :desc "Comment or uncomment lines" "TAB TAB" #'comment-line
      (:prefix ("t" . "toggle")
       :desc "Toggle line numbers" "l" #'doom/toggle-line-numbers
       :desc "Toggle line highlight in frame" "h" #'hl-line-mode
       :desc "Toggle line highlight globally" "H" #'global-hl-line-mode
       :desc "Toggle truncate lines" "t" #'toggle-truncate-lines))
#+END_SRC

#+RESULTS:
: toggle-truncate-lines

** org modern
#+begin_src emacs-lisp
;; (setq nano-font-family-monospaced "Roboto Mono")
;; Add frame borders and window dividers
;; (require 'nano)
;; (setq nano-font-family-proportional nil)
;; (setq nano-font-size 14)
(modify-all-frames-parameters
 '((right-divider-width . 5)
   (internal-border-width . 1)))
(dolist (face '(window-divider
                window-divider-first-pixel
                window-divider-last-pixel))
  (face-spec-reset-face face)
  (set-face-foreground face (face-attribute 'default :background)))
(set-face-background 'fringe (face-attribute 'default :background))

(setq
 ;; Edit settings
 org-auto-align-tags nil
 org-tags-column 0
 org-catch-invisible-edits 'show-and-error
 org-special-ctrl-a/e t
 org-insert-heading-respect-content t

 ;; Org styling, hide markup etc.
 org-hide-emphasis-markers t
 org-pretty-entities t
 org-ellipsis "…"

 ;; Agenda styling
 org-agenda-block-separator ?─
 org-agenda-time-grid
 '((daily today require-timed)
   (800 1000 1200 1400 1600 1800 2000)
   " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄")
 org-agenda-current-time-string
 "⭠ now ─────────────────────────────────────────────────")

;; Enable org-modern-mode
(add-hook 'org-mode-hook #'org-modern-mode)
(add-hook 'org-agenda-finalize-hook #'org-modern-agenda)
#+end_src

#+RESULTS:
| org-modern-agenda | +org-exclude-agenda-buffers-from-workspace-h | +org-defer-mode-in-agenda-buffers-h |

** Info colours
This makes manual pages nicer to look at by adding variable pitch fontification
and colouring 🙂.

#+begin_src emacs-lisp :tangle packages.el
(package! info-colors :pin "47ee73cc19b1049eef32c9f3e264ea7ef2aaf8a5")
#+end_src

To use this we'll just hook it into =Info=.

#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

#+RESULTS:
| info-colors-fontify-node |

** Modus themes
Proteolas did a lovely job with the Modus themes, so much so that they were
welcomed into Emacs 28. However, he is also rather attentive with updates, and
so I'd like to make sure we have a recent version.

#+begin_src emacs-lisp :tangle packages.el
(package! modus-themes :pin "59422c05e00d65582a005ccb06c3767622d14e03")
#+end_src

** Theme magic

With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp :tangle packages.el
(package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

This operates using =pywal=, which is present in some repositories, but most
reliably installed with =pip=.
#+begin_src shell :eval no :tangle (if (executable-find "wal") "no" "setup.sh")
sudo python3 -m pip install pywal
#+end_src

Theme magic takes a look at a number of faces, the saturation levels, and colour
differences to try to cleverly pick eight colours to use. However, it uses the
same colours for the light variants, and doesn't always make the best picks.
Since we're using =doom-themes=, our life is a little easier and we can use the
colour utilities from Doom themes to easily grab sensible colours and generate
lightened versions --- let's do that.

#+begin_src emacs-lisp
(use-package! theme-magic
  :commands theme-magic-from-emacs
  :config
  (defadvice! theme-magic--auto-extract-16-doom-colors ()
    :override #'theme-magic--auto-extract-16-colors
    (list
     (face-attribute 'default :background)
     (doom-color 'error)
     (doom-color 'success)
     (doom-color 'type)
     (doom-color 'keywords)
     (doom-color 'constants)
     (doom-color 'functions)
     (face-attribute 'default :foreground)
     (face-attribute 'shadow :foreground)
     (doom-blend 'base8 'error 0.1)
     (doom-blend 'base8 'success 0.1)
     (doom-blend 'base8 'type 0.1)
     (doom-blend 'base8 'keywords 0.1)
     (doom-blend 'base8 'constants 0.1)
     (doom-blend 'base8 'functions 0.1)
     (face-attribute 'default :foreground))))
#+end_src

#+RESULTS:

** Emojify
#+begin_quote
From the =:ui emoji= module.
#+end_quote


For starters, twitter's emojis look nicer than emoji-one.
Other than that, this is pretty great OOTB 😀.

#+begin_src emacs-lisp
(setq emojify-emoji-set "twemoji-v2")
#+end_src

One minor annoyance is the use of emojis over the default character
when the default is actually preferred. This occurs with overlay symbols I use
in Org mode, such as checkbox state, and a few other miscellaneous cases.

We can accommodate our preferences by deleting those entries from the emoji hash
table

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀"
    ;; I just want to see this as text
    "©" "™")
  "Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

#+RESULTS:

Now, it would be good to have a minor mode which allowed you to type ascii/gh
emojis and get them converted to unicode. Let's make one.
#+begin_src emacs-lisp
(defun emojify--replace-text-with-emoji (orig-fn emoji text buffer start end &optional target)
  "Modify `emojify--propertize-text-for-emoji' to replace ascii/github emoticons with unicode emojis, on the fly."
  (if (or (not emoticon-to-emoji) (= 1 (length text)))
      (funcall orig-fn emoji text buffer start end target)
    (delete-region start end)
    (insert (ht-get emoji "unicode"))))

(define-minor-mode emoticon-to-emoji
  "Write ascii/gh emojis, and have them converted to unicode live."
  :global nil
  :init-value nil
  (if emoticon-to-emoji
      (progn
        (setq-local emojify-emoji-styles '(ascii github unicode))
        (advice-add 'emojify--propertize-text-for-emoji :around #'emojify--replace-text-with-emoji)
        (unless emojify-mode
          (emojify-turn-on-emojify-mode)))
    (setq-local emojify-emoji-styles (default-value 'emojify-emoji-styles))
    (advice-remove 'emojify--propertize-text-for-emoji #'emojify--replace-text-with-emoji)))
#+end_src

#+RESULTS:

This new minor mode of ours will be nice for messages, so let's hook it in for
Email and IRC.
#+begin_src emacs-lisp
(add-hook! '(mu4e-compose-mode org-msg-edit-mode circe-channel-mode) (emoticon-to-emoji 1))
#+end_src
** Keycast

For some reason, I find myself demoing Emacs every now and then. Showing what
keyboard stuff I'm doing on-screen seems helpful. While [[https://gitlab.com/screenkey/screenkey][screenkey]] does exist,
having something that doesn't cover up screen content is nice.


#+begin_src emacs-lisp :tangle packages.el
(package! keycast :pin "72d9add8ba16e0cae8cfcff7fc050fa75e493b4e")
#+end_src

Let's just make sure this is lazy-loaded appropriately.
#+begin_src emacs-lisp :tangle no
(use-package! keycast
  :commands keycast-mode
  :config
  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (progn
          (add-hook 'pre-command-hook 'keycast--update t)
          (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
      (remove-hook 'pre-command-hook 'keycast--update)
      (setq global-mode-string (remove '("" mode-line-keycast " ") global-mode-string))))
  (custom-set-faces!
    '(keycast-command :inherit doom-modeline-debug
                      :height 0.9)
    '(keycast-key :inherit custom-modified
                  :height 1.1
                  :weight bold)))
#+end_src

#+RESULTS:
: t

** Screencast

In a similar manner to [[Keycast]], [[https://gitlab.com/ambrevar/emacs-gif-screencast][gif-screencast]] may come in handy.
#+begin_src emacs-lisp :tangle packages.el
(package! gif-screencast :pin "5517a557a17d8016c9e26b0acb74197550f829b9")
#+end_src

We can lazy load this using the start/stop commands.

I initially installed ~scrot~ for this, since it was the default capture program.
However it raised ~glib error: Saving to file ... failed~ each time it was run.
Google didn't reveal any easy fixed, so I switched to [[https://github.com/naelstrof/maim][maim]]. We now need to pass
it the window ID. This doesn't change throughout the lifetime of an emacs
instance, so as long as a single window is used ~xdotool getactivewindow~ will
give a satisfactory result.

It seems that when new colours appear, that tends to make ~gifsicle~ introduce
artefacts. To avoid this we pre-populate the colour map using the current doom
theme.
#+begin_src emacs-lisp
(use-package! gif-screencast
  :commands gif-screencast-mode
  :config
  (map! :map gif-screencast-mode-map
        :g "<f8>" #'gif-screencast-toggle-pause
        :g "<f9>" #'gif-screencast-stop)
  (setq gif-screencast-program "maim"
        gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
                                                     (shell-command-to-string
                                                      "xdotool getactivewindow")))
        gif-screencast-optimize-args '("--batch" "--optimize=3" "--usecolormap=/tmp/doom-color-theme"))
  (defun gif-screencast-write-colormap ()
    (f-write-text
     (replace-regexp-in-string
      "\n+" "\n"
      (mapconcat (lambda (c) (if (listp (cdr c))
                                 (cadr c))) doom-themes--colors "\n"))
     'utf-8
     "/tmp/doom-color-theme" ))
  (gif-screencast-write-colormap)
  (add-hook 'doom-load-theme-hook #'gif-screencast-write-colormap))
#+end_src
** Marginalia
#+begin_quote
Part of the =:completion vertico= module.
#+end_quote

Marginalia is nice, but the file metadata annotations are a little too plain.
Specifically, I have these gripes
+ File attributes would be nicer if coloured
+ I don't care about the user/group information if the user/group is me
+ When a file time is recent, a relative age (e.g. =2h ago=) is more useful than
  the date
+ An indication of file fatness would be nice

Thanks to the ~marginalia-annotator-registry~, we don't have to advise, we can
just add a new =file= annotator.

Another small thing is the face used for docstrings. At the moment it's =(italic
shadow)=, but I don't like that.

#+begin_src emacs-lisp :tangle no
(after! marginalia
  (setq marginalia-censor-variables nil)

  (defadvice! +marginalia--anotate-local-file-colorful (cand)
    "Just a more colourful version of `marginalia--anotate-local-file'."
    :override #'marginalia--annotate-local-file
    (when-let (attrs (file-attributes (substitute-in-file-name
                                       (marginalia--full-candidate cand))
                                      'integer))
      (marginalia--fields
       ((marginalia--file-owner attrs)
        :width 12 :face 'marginalia-file-owner)
       ((marginalia--file-modes attrs))
       ((+marginalia-file-size-colorful (file-attribute-size attrs))
        :width 7)
       ((+marginalia--time-colorful (file-attribute-modification-time attrs))
        :width 12))))

  (defun +marginalia--time-colorful (time)
    (let* ((seconds (float-time (time-subtract (current-time) time)))
           (color (doom-blend
                   (face-attribute 'marginalia-date :foreground nil t)
                   (face-attribute 'marginalia-documentation :foreground nil t)
                   (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
      ;; 1 - log(3 + 1/(days + 1)) % grey
      (propertize (marginalia--time time) 'face (list :foreground color))))

  (defun +marginalia-file-size-colorful (size)
    (let* ((size-index (/ (log10 (+ 1 size)) 7.0))
           (color (if (< size-index 10000000) ; 10m
                      (doom-blend 'orange 'green size-index)
                    (doom-blend 'red 'orange (- size-index 1)))))
      (propertize (file-size-human-readable size) 'face (list :foreground color)))))
#+end_src

#+RESULTS:

** All the icons
#+begin_quote
From the =:core packages= module.
#+end_quote


=all-the-icons= does a generally great job giving file names icons. One minor
niggle I have is that when /I/ open a =.m= file, it's much more likely to be Matlab
than Objective-C. As such, it'll be switching the icon associated with =.m=.
#+begin_src emacs-lisp
(after! all-the-icons
  (setcdr (assoc "m" all-the-icons-extension-icon-alist)
          (cdr (assoc "matlab" all-the-icons-extension-icon-alist))))
#+end_src

** Prettier page breaks

In some files, =^L= appears as a page break character. This isn't that visually
appealing, and Steve Purcell has been nice enough to make a package to display
these as horizontal rules.
#+begin_src emacs-lisp :tangle no
(package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines"))
#+end_src

#+begin_src emacs-lisp  :tangle no

(use-package! page-break-lines
  :commands page-break-lines-mode
  :init
  (autoload 'turn-on-page-break-lines-mode "page-break-lines")
  :config
  (setq page-break-lines-max-width fill-column)
  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src
** Writeroom
#+begin_quote
From the =:ui zen= module.
#+end_quote

For starters, I think Doom is a bit over-zealous when zooming in
#+begin_src emacs-lisp :tangle no
(setq +zen-text-scale 0.8)
#+end_src

Then, when using Org it would be nice to make a number of other aesthetic
tweaks. Namely:
+ Use a serifed variable-pitch font
+ Hiding headline leading stars
+ Using fleurons as headline bullets
+ Hiding line numbers
+ Removing outline indentation
+ Centring the text
+ Turning on ~org-pretty-table-mode~

#+begin_src emacs-lisp :tangle no
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defvar-local +zen--original-org-pretty-table-mode-p nil)
  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-superstar-headline-bullets-list
            'org-superstar-remove-leading-stars)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (when (featurep 'org-superstar)
                  (setq-local org-superstar-headline-bullets-list '("🙘" "🙙" "🙚" "🙛")
                              ;; org-superstar-headline-bullets-list '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
                              org-superstar-remove-leading-stars t)
                  (org-superstar-restart))
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 +zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
                (org-indent-mode -1)
                (org-pretty-table-mode 1))))
  (add-hook 'writeroom-mode-disable-hook
            (defun +zen-nonprose-org-h ()
              "Reverse the effect of `+zen-prose-org'."
              (when (eq major-mode 'org-mode)
                (when (featurep 'org-superstar)
                  (org-superstar-restart))
                (when +zen--original-org-indent-mode-p (org-indent-mode 1))
                ;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
                ))))
#+end_src

** Treemacs
#+begin_quote
From the =:ui treemacs= module.
#+end_quote

Quite often there are superfluous files I'm not that interested in. There's no
good reason for them to take up space. Let's add a mechanism to ignore them.
#+begin_src emacs-lisp :tangle no
(after! treemacs
  (defvar treemacs-file-ignore-extensions '()
    "File extension which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-globs '()
    "Globs which will are transformed to `treemacs-file-ignore-regexps' which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-regexps '()
    "RegExps to be tested to ignore files, generated from `treeemacs-file-ignore-globs'")
  (defun treemacs-file-ignore-generate-regexps ()
    "Generate `treemacs-file-ignore-regexps' from `treemacs-file-ignore-globs'"
    (setq treemacs-file-ignore-regexps (mapcar 'dired-glob-regexp treemacs-file-ignore-globs)))
  (if (equal treemacs-file-ignore-globs '()) nil (treemacs-file-ignore-generate-regexps))
  (defun treemacs-ignore-filter (file full-path)
    "Ignore files specified by `treemacs-file-ignore-extensions', and `treemacs-file-ignore-regexps'"
    (or (member (file-name-extension file) treemacs-file-ignore-extensions)
        (let ((ignore-file nil))
          (dolist (regexp treemacs-file-ignore-regexps ignore-file)
            (setq ignore-file (or ignore-file (if (string-match-p regexp full-path) t nil)))))))
  (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-filter))
#+end_src

Now, we just identify the files in question.
#+begin_src emacs-lisp :tangle no
(setq treemacs-file-ignore-extensions
      '(;; LaTeX
        "aux"
        "ptc"
        "fdb_latexmk"
        "fls"
        "synctex.gz"
        "toc"
        ;; LaTeX - glossary
        "glg"
        "glo"
        "gls"
        "glsdefs"
        "ist"
        "acn"
        "acr"
        "alg"
        ;; LaTeX - pgfplots
        "mw"
        ;; LaTeX - pdfx
        "pdfa.xmpi"
        ))
(setq treemacs-file-ignore-globs
      '(;; LaTeX
        "*/_minted-*"
        ;; AucTeX
        "*/.auctex-auto"
        "*/_region_.log"
        "*/_region_.tex"))
#+end_src
* Completions
** Consult
*** consult conf
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/setup-consult.el

;; -*- lexical-binding: t -*-
;; Consult
(use-package consult
  :ensure t
  :hook (minibuffer-setup . consult-completion-enable-in-minibuffer)
  ;; :hook ((shell-mode eshell-mode) . (lambda () (setq completion-in-region-function
  ;;                                               #'consult-completion-in-region)))
  :init
  (defun consult-completion-enable-in-minibuffer ()
    "Enable consult-completion-in-region in the minibuffer if
`completion-at-point' is bound."
    (when (where-is-internal #'completion-at-point (list (current-local-map)))
      ;; (setq-local corfu-auto nil) Enable/disable auto completion
      (setq completion-in-region-function #'consult-completion-in-region)))
  :after minibuffer
  :config
  (setq consult-narrow-key "<")
  (setq consult-line-numbers-widen t)
  (setq consult-preview-buffer nil)
  (setq consult-preview-mark nil)
  (setq consult-preview-line 'any)
  (setq consult-preview-outline nil)
  (setq consult-preview-key 'any)
  (consult-customize
   consult-ripgrep consult-git-grep consult-grep
   consult-bookmark consult--source-buffer consult-recent-file consult-xref
   consult--source-recent-file consult--source-project-recent-file
   consult--source-bookmark consult--source-project-buffer
   :preview-key (kbd "C-M-m"))
  ;; (setq consult-project-root-function (lambda () "Return current project root"
  ;;                                       (project-root (project-current))))
  ;; (setq consult-find-args
  ;;       "fd --color=never --hidden -t f -t d -t l --follow")
  (when (executable-find "plocate")
    (setq consult-locate-args "plocate --ignore-case --existing --regexp"))
  (defun consult-buffer-other-tab ()
    "Variant of `consult-buffer' which opens in other frame."
    (interactive)
    (let ((consult--buffer-display #'switch-to-buffer-other-tab))
      (consult-buffer)))

  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref)

  (setq register-preview-delay 0
        register-preview-function #'consult-register-format)



  (defvar consult--fd-command nil)
  (defun consult--fd-builder (input)
    (unless consult--fd-command
      (setq consult--fd-command
            (if (eq 0 (call-process-shell-command "fdfind"))
                "fdfind"
              "fd")))
    (pcase-let* ((`(,arg . ,opts) (consult--command-split input))
                 (`(,re . ,hl) (funcall consult--regexp-compiler
                                        arg 'extended)))
      (when re
        (list :command (append
                        (list consult--fd-command
                              "--color=never" "--full-path"
                              (consult--join-regexps re 'extended))
                        opts)
              :highlight hl))))

  (defun consult-fd (&optional dir initial)
    (interactive "P")
    (let* ((prompt-dir (consult--directory-prompt "Fd" dir))
           (default-directory (cdr prompt-dir)))
      (find-file (consult--find (car prompt-dir) #'consult--fd-builder initial))))

  ;; (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

  (defcustom my/consult-ripgrep-or-line-limit 300000
    "Buffer size threshold for `my/consult-ripgrep-or-line'.
When the number of characters in a buffer exceeds this threshold,
`consult-ripgrep' will be used instead of `consult-line'."
    :type 'integer)

  ;; Combine `consult-imenu' and `consult-project-imenu'
  (defun consult-imenu-all (&optional arg)
    "Call `consult-imenu'. With prefix-command ARG, call
    `consult-project-imenu'."
    (interactive "P")
    (if arg (consult-imenu-multi) (consult-imenu)))

  ;; From https://github.com/minad/consult/wiki
  (defun my/consult-ripgrep-or-line (&optional initial start)
    "Call `consult-line' for small buffers or `consult-ripgrep' for large files."
    (interactive (list nil (not (not current-prefix-arg))))
    (if (or (not buffer-file-name)
            (buffer-narrowed-p)
            (ignore-errors
              (file-remote-p buffer-file-name))
            (jka-compr-get-compression-info buffer-file-name)
            (<= (buffer-size)
                (/ my/consult-ripgrep-or-line-limit
                   (if (eq major-mode 'org-mode) 4 1))))
        (consult-line initial start)
      (when (file-writable-p buffer-file-name)
        (save-buffer))
      (let ((consult-ripgrep-args
             (concat "rg "
                     "--null "
                     "--line-buffered "
                     "--color=ansi "
                     "--max-columns=250 "
                     "--no-heading "
                     "--line-number "
                     ;; adding these to default
                     "--smart-case "
                     "--hidden "
                     "--max-columns-preview "
                     ;; add back filename to get parsing to work
                     "--with-filename "
                     ;; defaults
                     "-e "
                     (shell-quote-argument buffer-file-name))))
        (consult-ripgrep default-directory initial))))

  (defun consult-line-symbol-at-point ()
    (interactive)
    (my/consult-ripgrep-or-line (thing-at-point 'symbol)))
  (dolist (func '(consult-fd consult-git-grep
                             consult-ripgrep consult-grep))
    (advice-add func :before (defun my/mark-jump-point (&rest _)
                               (xref-push-marker-stack)
                               (push-mark))))

  (use-package consult-flymake
    :bind ("M-g f" . consult-flymake)
    ;; :config
    ;; (advice-add 'consult-flymake :before
    ;;             #'my/consult-flymake-ensure)
    ;; (defun my/consult-flymake-ensure ()
    ;;   (interactive)
    ;;   (flymake-mode 1))
    )

  (use-package org
    :defer
    :bind (:map org-mode-map
                ("C-c C-j" . consult-org-heading)
                ("M-s M-j" . consult-org-heading)))

  :bind (("C-x b"   . consult-buffer)
         ("C-x H-r" . consult-recent-file)
         ("C-x M-:" . consult-complex-command)
         ("M-s M-o" . consult-multi-occur)
         ("M-X" . consult-mode-command)
         ("C-h C-m" . consult-minor-mode-menu)
         ("C-c C-j" . consult-outline)
         ("M-s M-j" . consult-outline)
         ("M-s l"   . consult-line-symbol-at-point)
         ("M-s f"   . consult-fd)
         ("M-s M-l" . consult-locate)
         ("M-s g"   . consult-ripgrep)
         ("M-s G"   . consult-git-grep)
         ("C-x C-r" . consult-recent-file)
         ("<help> a" . consult-apropos)
         ("M-s i" . consult-imenu-all)
         ("s-b" . consult-buffer)
         ("M-g j" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ;; ("H-b" . consult-buffer)
         ("M-m" . consult-register-store)
         ("M-s k l" . consult-focus-lines)
         ("M-'" . consult-register-load)
         ("M-y" . consult-yank-pop)
         :map ctl-x-r-map
         ("b" . consult-bookmark)
         ("x" . consult-register)
         :map ctl-x-4-map
         ("b" . consult-buffer-other-window)
         :map ctl-x-5-map
         ("b" . consult-buffer-other-frame)
         :map tab-prefix-map
         ("b" . consult-buffer-other-tab)))
         ;; :map space-menu-file-map
         ;; ("l" . consult-locate)
         ;; :map minibuffer-local-map
         ;; ("M-r" . consult-history)))

;; Library support for consult-buffer
(use-package consult
  :defer
  :config
  (defvar consult--source-library nil
    "Emacs libary candidate source for `consult-buffer'.")

  (defvar consult--library-hash nil
    "Hash table of all library names.")

  (defun consult--library-make-hash ()
    "Return hash table of all library names."
    (require 'find-func)
    (setq consult--library-hash
          (consult--string-hash
           (let ((suffix-regexp (mapconcat
                                 (lambda (suffix)
                                   (concat (regexp-quote suffix) "\\'"))
                                 (find-library-suffixes)
                                 "\\|")))

             (cl-loop for dir in (or find-function-source-path load-path)
                      when (file-readable-p dir)
                      append (mapcar
                              (lambda (file)
                                (replace-regexp-in-string suffix-regexp
                                                          "" file))
                              (directory-files dir nil
                                               suffix-regexp)))))))

  (defvar consult--library-history nil)

  (consult--define-state library)
  (defun consult--library-action (lib)
    "Find library via `consult--library-action'."
    (consult--buffer-action
     (find-file-noselect
      (find-library-name lib)))
    (run-hooks 'find-function-after-hook))
  (defun consult--library-preview ()
    "Create preview function for libraries."
    (let ((open (consult--temporary-files))
          (preview (consult--buffer-preview)))
      (lambda (cand restore)
        (if restore
            (progn
              (funcall preview nil t)
              (funcall open))
          (funcall
           preview
           (and cand (funcall open (find-library-name cand)))
           nil)))))

  (setq consult--source-library
    `(:name  "Library"
      :narrow ?l
      :category library
      :face consult-buffer
      :history 'consult--library-history
      :hidden t
      :items ,(lambda ()
                (let ((ht consult--library-hash))
                  (unless ht (setq ht (consult--library-make-hash)))
                  (hash-table-keys ht)))
      :state ,#'consult--library-state))
  (add-to-list 'consult-buffer-sources 'consult--source-library)
  (consult-customize consult--source-library :preview-key (kbd "C-M-m")))

(use-package consult-dir
  ;; :load-path "plugins/consult-dir/"
  :defer 2
  :after (consult bookmark marginalia)
  :bind (("C-x C-d" . consult-dir)
         :map minibuffer-local-completion-map
         ("C-M-d" . consult-dir-maybe)
         ("H-M-d" . consult-dir-maybe)
         ("C-M-j" . consult-dir-jump-file)
         ("H-M-j" . consult-dir-jump-file)
         ("M-s f" . consult-dir-jump-file)
         :map embark-become-file+buffer-map
         ("d" . consult-dir))
  :config
  (setq consult-dir-shadow-filenames nil)
  (defun consult-dir-maybe ()
    (interactive)
    (let* ((full-category (completion-metadata-get (embark--metadata) 'category))
           (category (pcase full-category
                       ('consult-multi (car (get-text-property
                                             0 'consult-multi
                                             (vertico--candidate))))
                       (_ full-category))))
      (if (member category '(file))
          (call-interactively #'consult-dir)
        (call-interactively (lookup-key global-map (kbd "C-M-d"))))))
  (use-package vertico
    :defer
    :bind (:map vertico-map
                ("C-M-d" . consult-dir-maybe)
                ("H-M-d" . consult-dir-maybe)
                ("M-s f" . consult-dir-jump-file)
                ("C-M-j" . consult-dir-jump-file)
                ("H-M-j" . consult-dir-jump-file))))

(use-package affe
  :ensure t
  :bind (("M-s M-f" . affe-find)
         ("M-s M-g" . affe-grep))
  :config
  ;; Configure Orderless
  (setq affe-regexp-function #'orderless-pattern-compiler
        affe-highlight-function #'orderless--highlight)
    ;; Manual preview key for `affe-grep'
  (consult-customize affe-grep :preview-key (kbd "C-M-m")))

(use-package consult
  :when (executable-find "ff-cache")
  :bind ("M-s /" . consult-dff)
  :config
  (defvar dff-cache-file "/tmp/dmenufindfile.cache")
  (defvar dff-file-name-history nil)
  (defvar dff-cache nil)
  (defun consult-dff (&optional arg)
    (interactive "P")
    (when-let
        ((default-directory (getenv "HOME"))
         (file-name
           (consult--read
            (if (or arg (not dff-cache))
                (setq dff-cache
                      (progn
                        (shell-command "ff-cache -r")
                        (with-temp-buffer
                          (insert-file-contents dff-cache-file)
                          (split-string (buffer-substring (point-min) (point-max)) "\n"))))
              dff-cache)
            :prompt "Find file: "
            :require-match t
            :history 'dff-file-name-history
            :category 'file)))
      (find-file file-name))))

(provide 'setup-consult)
;; setup-consult.el ends here
#+end_src

#+RESULTS:
: setup-consult

*** Enhanced minibuffer commands (consult.el)
**** desc
Daniel Mendler's Consult is a welcome addition to the ecosystem of
modular, extensible tools that work with the standard minibuffer
completion mechanisms and, by extension, with every user interface that
largely conforms with them (Icomplete, Selectrum) or fully respects them
(Embark and [[https://github.com/minad/vertico][Daniel's own Vertico]]).  For my case, this means that it
works with everything included in [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]].

Consult's value proposition is two-fold: (1) remain aligned with the
Emacs completion paradigm, and (2) offer minibuffer-centric commands
that either enhance aspects of interactivity and functionality found in
existing commands or outright provide them from scratch.

Some Consult commands are drop-in replacements for built-in options.
For example =consult-complex-command= offers an improved interactive
experience over the default =repeat-complex-command=.  Same principle for
=consult-goto-line= which displays the line numbers and offers a live
preview of where you are about to land.

Other commands enhance the defaults with a filtering mechanism that
targets candidates by their type.  A case in point is =consult-imenu=
which recognises syntactic constructs that are variables, functions,
macros (configurable via =consult-imenu-narrow=, =consult-imenu-toplevel=).

This "filtering" mechanism, which is internally known as "narrowing",
can be accessed via a key binding for all commands that support it.  In
my case, that key is the right angled bracket, or greater than sign (=>=)
from inside the minibuffer (configure =consult-narrow-key=).  So you type
the narrow key and follow it up with another key that matches the
relevant targets.  Hit backspace to remove the narrowing.  As for the
available keys, type =?= which calls =consult-narrow-help=.

This narrowing-by-type mechanism can also be used without inputting the
=consult-narrow-key=, just by typing in the appropriate character and
inserting a space.  For instance, to search only for functions in
=consult-imenu=, you type =f= and then a space.  Consult will add an
indicator to the minibuffer prompt describing the active filter.

In general, commands that involve multiple groups can benefit from this
type of narrowing.  The prime example is =consult-buffer= which combines
sources of recently visited files, bookmarks, and buffers (those are
configurable via the variable =consult-buffer-sources=).  Though others
follow the same principle, such as the aforementioned =consult-imenu= and
=consult-bookmark=.

Another intriguing facility of Consult is its asynchronous call to
external processes, such as =grep= and =find=.  Those calls can be
configured to return some output based on a minimum number of
characters, while they also allow for tweaks to their update delays.
Interactivity is already a given, meaning that you can continue typing
and see the results pop up.  Furthermore, they implement a two-stage
input scheme, separated by a configurable delimiter (=#= by default and
controlled with =consult-async-default-split=):

+ First you type in the pattern that should be sent to the external
  program.  This is what triggers the asynchronous call.  So your input
  looks like this: =#PATTERN=.  The pattern will typically consist of some
  text or a regular expression, but can also include command line flags
  for the underlying CLI program (check Consult's documentation for the
  technicalities).

+ Then you can add another field delimiter to instruct Consult to (i)
  keep the results that =#PATTERN= gave you and (ii) leverage Emacs' own
  mechanisms to further narrow the list.  Now your input looks like
  this: =#PATTERN#MORE-PATTERNS=.  The =#MORE-PATTERNS= will use whatever
  completion styles you have configured (check my =completion-styles=).

As already suggested, Consult provides previews for its commands.  This
feature should work without any further intervention.

Consult can shine when used in tandem with Embark to produce buffers
that hold all the candidates of any given minibuffer completion command
([[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]]).
For example, =embark-export= can be called from inside =consult-grep= (and
variants) to deliver a dedicated =grep-mode= buffer, which can then be
edited with the help of the =wgrep= package (check [[#h:42624165-f4cb-4318-abce-c11232426880][wgrep (writable grep)]]).
Use that to quickly refactor some pattern across your files.

Other nice extensions of Consult are (i) its ability to work as a
generic front-end for completion, and (ii) its preview facility for
registers.  The former is done by =consult-completion-in-region= which
provides completion for commands such as =dabbrev-completion= or the TAB
key in programming buffers (see [[#h:d51d37df-4e58-4e0b-85a1-019ceda342f6][Tabs, indentation, and the TAB key]]).
While the latter is an overall prettier presentation for the familiar
register preview window (watch: [[https://protesilaos.com/codelog/2020-03-08-emacs-registers/][Primer on Emacs “registers”]]
(2020-03-08)).

As for registers themselves, Consult furnishes three commands, one
focused on minibuffer completion and two as do-what-I-mean alternatives
to the built-in facilities of storing and inserting---or jumping
to---registered data.

+ =consult-register= is what you use for completion.  It searches through
  the contents of the registered compartments and, thus, works well when
  you have text-heavy registers that you need to filter through before
  inserting one at point.

+ =consult-register-store= will save a "thing" to the specified key.  What
  the thing is depends on the context:

  + If the region is active, it will operate on the affected text.
  + If you call it with a numeric argument, it will store that number.
  + If no region is active and no numeric prefix is supplied, it will
    let you select between the current position (point), window
    configuration (window), set of frames with their window
    configurations (frameset), or keyboard macro (kmacro).

  This do-what-I-mean facility is complemented by an actions' menu that
  offers hints on the keys you can use to specify the desired step
  forward.  For example, if you are operating on a region, =M-a= will let
  you append the text to the given register.

+ =consult-register-load= simplifies the mental workload of actually using
  a register.  Unlike the Emacs default where you need to know in
  advance what type of data does the register holds in order to use the
  right action for it, Consult's version just handles that for you.  All
  you have to do is instruct it to use the given register and it will
  know whether it should insert some text or jump to a point/frameset,
  etc.

In practice, I only ever use =consult-register= because I have already
developed muscle memory for the register-related actions.  Though using
all three of the above is easier to learn and more consistent overall.

**** code
#+begin_src emacs-lisp
;;; Enhanced minibuffer commands (consult.el)
(use-package consult
  :config
  (setq consult-line-numbers-widen t)
  ;; (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (setq consult-imenu-config
        '((emacs-lisp-mode :toplevel "Functions"
                           :types ((?f "Functions" font-lock-function-name-face)
                                   (?m "Macros"    font-lock-keyword-face)
                                   (?p "Packages"  font-lock-constant-face)
                                   (?t "Types"     font-lock-type-face)
                                   (?v "Variables" font-lock-variable-name-face)))))
  ;; Search C-h f for more "bookmark jump" handlers.
  (setq consult-bookmark-narrow
        `((?d "Docview" ,#'doc-view-bookmark-jump)
          (?e "Eshell" ,#'eshell-bookmark-jump)
          (?f "File" ,#'bookmark-default-handler)
          (?h "Help" ,#'help-bookmark-jump)
          (?i "Info" ,#'Info-bookmark-jump)
          (?m "Man" ,#'Man-bookmark-jump)
          ;; (?p "PDF" ,#'pdf-view-bookmark-jump)
          (?v "VC Dir" ,#'vc-dir-bookmark-jump)
          (?w "EWW" ,#'prot-eww-bookmark-jump)))
  (setq register-preview-delay 0.8
        register-preview-function #'consult-register-format)
  (setq consult-find-args "find . -not ( -wholename */.* -prune )")
  (setq consult-preview-key 'any)

  (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)

  (require 'consult-imenu) ; the `imenu' extension is in its own file

  (let ((map global-map))
    (define-key map (kbd "C-x r b") #'consult-bookmark) ; override `bookmark-jump'
    (define-key map (kbd "C-x M-:") #'consult-complex-command)
    (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
    (define-key map (kbd "C-x M-k") #'consult-kmacro)
    (define-key map [remap goto-line] #'consult-goto-line)
    (define-key map (kbd "M-K") #'consult-keep-lines) ; M-S-k is similar to M-S-5 (M-%)
    (define-key map (kbd "M-F") #'consult-focus-lines) ; same principle
    (define-key map (kbd "M-s M-b") #'consult-buffer)
    (define-key map (kbd "M-s M-f") #'consult-find)
    (define-key map (kbd "M-s M-g") #'consult-grep)
    (define-key map (kbd "M-s M-h") #'consult-history)
    (define-key map (kbd "M-s M-i") #'consult-imenu)
    (define-key map (kbd "M-s M-l") #'consult-line)
    (define-key map (kbd "M-s M-m") #'consult-mark)
    (define-key map (kbd "M-s M-s") #'consult-outline)
    (define-key map (kbd "M-s M-y") #'consult-yank-pop)
    (define-key map (kbd "C-x r r") #'consult-register)) ; Use the register's prefix
  (define-key consult-narrow-map (kbd "?") #'consult-narrow-help)

  ;; see my `pulsar' package, which is declared further above:
  ;; <https://protesilaos.com/emacs/pulsar>
  (setq consult-after-jump-hook nil) ; reset it to avoid conflicts with my function
  (dolist (fn '(pulsar-recenter-top pulsar-reveal-entry))
    (add-hook 'consult-after-jump-hook fn)))
#+end_src

#+RESULTS:
: t

*** Consult gen
#+begin_src emacs-lisp :tangle no
;; Consult enhances various command by using the minibuffer.

(use-package consult
  :bind (("C-c h" . consult-history)
         ("C-c m" . consult-mode-command)
         ("C-c b" . consult-bookmark)
         ("C-c k" . consult-kmacro)
         ("C-x M-;" . consult-complex-command)
         ("C-x b" . consult-buffer)
         ("C-x 4 b" . consult-buffer-other-window)
         ("C-x 5 b" . consult-buffer-other-frame)
         ("M-#" . consult-register-load)
         ("M-'" . consult-register-store)
         ("C-M-#" . consult-register)
         ("M-g e" . consult-compile-error)
         ("M-g g" . consult-goto-line)
         ("M-g M-g" . consult-goto-line)
         ("M-g o" . consult-outline)
         ("M-g m" . consult-mark)
         ("M-g k" . consult-global-mark)
         ("M-g i" . consult-imenu)
         ("M-g I" . consult-project-imenu)
         ("M-s f" . op/consult-find)
         ("M-s g" . consult-grep)
         ("M-s l" . consult-line)
         ("M-s k" . consult-keep-lines)
         ("M-s u" . consult-focus-lines)
         ("M-s e" . consult-isearch))
  :custom ((register-preview-delay 0)
           (register-preview-function #'consult-register-format)
           ;; use consult to select xref locations with preview
           (xref-show-xrefs-function #'consult-xref)
           (xref-show-definitions-function #'consult-xref)
           (consult-narrow-key "<")
           (consult-project-root #'project-roots)
  (completion-in-region-function #'consult-completion-in-region)
           (consult-find-args "find .")
           (consult-grep-args "grep --null --line-buffered --ignore-case -RIn"))

  :init
  (advice-add #'register-preview :override #'consult-register-window)

  :config
  ;; make narrowing help available in the minibuffer.
  (define-key consult-narrow-map (vconcat consult-narrow-key "?")
              #'consult-narrow-help)

  ;; a find-builder that works with OpenBSD' find
  (defun op/consult--find-builder (input)
  "Build command line given INPUT."
  (pcase-let* ((cmd (split-string-and-unquote consult-find-args))
               (type (consult--find-regexp-type (car cmd)))
               (`(,arg . ,opts) (consult--command-split input))
               (`(,re . ,hl) (funcall consult--regexp-compiler arg type)))
    (when re
      (list :command
            (append cmd
                    (cdr (mapcan
                          (lambda (x)
                            `("-and" "-iname"
                              ,(format "*%s*" x)))
                          re))
                    opts)
            :highlight hl))))

  (defun op/consult-find (&optional dir)
    (interactive "P")
    (let* ((prompt-dir (consult--directory-prompt "Find" dir))
           (default-directory (cdr prompt-dir)))
      (find-file (consult--find (car prompt-dir) #'op/consult--find-builder "")))))
#+end_src

#+RESULTS:
: consult-isearch

*** Consult dir
#+begin_src emacs-lisp :tangle no
(use-package consult-dir
  ;; :straight t
  :bind (("C-x C-d" . consult-dir)
         :map vertico-map
         ("C-x C-d" . consult-dir)
         ("C-x C-j" . consult-dir-jump-file))
  :custom
  (consult-dir-project-list-function nil))

;; Thanks Karthik!
(with-eval-after-load 'eshell-mode
  (defun eshell/z (&optional regexp)
    "Navigate to a previously visited directory in eshell."
    (let ((eshell-dirs (delete-dups (mapcar 'abbreviate-file-name
                                            (ring-elements eshell-last-dir-ring)))))
      (cond
       ((and (not regexp) (featurep 'consult-dir))
        (let* ((consult-dir--source-eshell `(:name "Eshell"
                                                   :narrow ?e
                                                   :category file
                                                   :face consult-file
                                                   :items ,eshell-dirs))
               (consult-dir-sources (cons consult-dir--source-eshell consult-dir-sources)))
          (eshell/cd (substring-no-properties (consult-dir--pick "Switch directory: ")))))
       (t (eshell/cd (if regexp (eshell-find-previous-directory regexp)
                       (completing-read "cd: " eshell-dirs))))))))
#+end_src
** marganalia

This is a utility jointly developed by Daniel Mendler and Omar Antolín
Camarena that provides annotations to completion candidates.  It is
meant to be framework-agnostic, so it works with Selectrum, Icomplete
vertical, Embark's completions buffer, as well as the default
completions' buffer (as of 2021-04-02, the latter is my choice for
visualising the standard minibuffer completion candidates---refer to
[[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/setup-marginalia.el

;; -*- lexical-binding: t -*-
;; Prefer richer, more heavy, annotations over the lighter default variant.
;; E.g. M-x will show the documentation string additional to the keybinding. By
;; default only the keybinding is shown as annotation. Note that there is the
;; command `marginalia-cycle-annotators` to switch between the annotators.

(use-package marginalia
  :ensure t
  :after setup-minibuffer
  :init (marginalia-mode 1)
  ;; :bind (:map vertico-map
  ;;        ("M-]" . marginalia-cycle))
  :config
  (add-to-list 'marginalia-prompt-categories '("\\burl\\b" . url))
  (setq marginalia-max-relative-age 0)  ; time is absolute here!
  (setq marginalia-annotators
        '(marginalia-annotators-heavy marginalia-annotators-light)))

(provide 'setup-marginalia)
;; setup-marginalia.el ends here

#+end_src

#+RESULTS:
: setup-marginalia

** orderless
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/setup-orderless.el

;; -*- lexical-binding: t -*-
(use-package orderless
  :after setup-minibuffer
  :ensure t
  :demand
  :config
  (setq orderless-component-separator #'split-string-and-unquote)
  (setq completion-styles '(orderless partial-completion))
  (setq orderless-matching-styles
        '(orderless-regexp
          orderless-initialism
          ;; orderless-strict-leading-initialism
          )
        orderless-style-dispatchers
        '(my/orderless-flex-dispatcher
          my/orderless-literal-dispatcher
          my/orderless-initialism-dispatcher
          my/orderless-exclude-dispatcher
          my/orderless-dollar-dispatcher))

  (defun my/orderless-dollar-dispatcher (pattern _index _total)
    (when (string-suffix-p "$" pattern)
      `(orderless-regexp . ,(concat (substring pattern 0 -1)
                                    "[\x100000-\x10FFFD]*$"))))

  (defun my/orderless-flex-dispatcher (pattern _index _total)
    (when (or (string-suffix-p "`" pattern)
              (string-suffix-p "~" pattern))
      `(orderless-flex . ,(substring pattern 0 -1))))

  (defun my/orderless-literal-dispatcher (pattern _index _total)
    (when (string-suffix-p "=" pattern)
      `(orderless-literal . ,(substring pattern 0 -1))))

  (defun my/orderless-initialism-dispatcher (pattern _index _total)
    (when (string-suffix-p "," pattern)
      `(orderless-strict-full-initialism . ,(substring pattern 0 -1))))

  (defun my/orderless-exclude-dispatcher (pattern _index _total)
    (when (string-prefix-p "!" pattern)
      `(orderless-without-literal . ,(substring pattern 1))))

  ;; These were removed from Orderless, I use them.
  (defun orderless--strict-*-initialism (component &optional anchored)
    "Match a COMPONENT as a strict initialism, optionally ANCHORED.
The characters in COMPONENT must occur in the candidate in that
order at the beginning of subsequent words comprised of letters.
Only non-letters can be in between the words that start with the
initials.
If ANCHORED is `start' require that the first initial appear in
the first word of the candidate.  If ANCHORED is `both' require
that the first and last initials appear in the first and last
words of the candidate, respectively."
    (orderless--separated-by
     '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)))
     (cl-loop for char across component collect `(seq word-start ,char))
     (when anchored '(seq (group buffer-start) (zero-or-more (not alpha))))
     (when (eq anchored 'both)
       '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)) eol))))

  (defun orderless-strict-initialism (component)
    "Match a COMPONENT as a strict initialism.
This means the characters in COMPONENT must occur in the
candidate in that order at the beginning of subsequent words
comprised of letters.  Only non-letters can be in between the
words that start with the initials."
    (orderless--strict-*-initialism component))

  (defun orderless-strict-leading-initialism (component)
    "Match a COMPONENT as a strict initialism, anchored at start.
See `orderless-strict-initialism'.  Additionally require that the
first initial appear in the first word of the candidate."
    (orderless--strict-*-initialism component 'start))

  (defun orderless-strict-full-initialism (component)
    "Match a COMPONENT as a strict initialism, anchored at both ends.
See `orderless-strict-initialism'.  Additionally require that the
first and last initials appear in the first and last words of the
candidate, respectively."
    (orderless--strict-*-initialism component 'both))

  :bind (:map minibuffer-local-completion-map
              ("SPC" . self-insert-command)))

(provide 'setup-orderless)
;; setup-orderless.el ends here
#+end_src

#+RESULTS:
: setup-orderless

** vertico
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/setup-vertico.el

;; -*- lexical-binding: t -*-
;; Vertico
(use-package vertico
  ;; :commands vertico-mode
  ;; :load-path "~/.local/share/git/vertico/"
  :after minibuffer
  :commands vertico-mode
  :init (vertico-mode 1)
  :bind (:map vertico-map
              ("M-s"     . nil)
              ("M-i"     . vertico-insert)
              ("C-M-n"   . vertico-next-group)
              ("C-M-p"   . vertico-previous-group)
              ("C-j"     . (lambda () (interactive)
	        	     (if minibuffer--require-match
	        	         (minibuffer-complete-and-exit)
	        	       (exit-minibuffer))))
              ("C->"     . embark-become)
              (">"       . embark-become)
              ("C-<tab>"   . embark-act-with-completing-read)
              ("C-o"     . embark-minimal-act)
              ("C-M-o"   . embark-minimal-act-noexit)
              ("M-s o"   . embark-export)
              ("C-c C-o" . embark-export)
              ("C-l"     . embark-export))
  :config
  (setq vertico-count 15
        vertico-cycle t
        vertico-resize t)
  (advice-add #'tmm-add-prompt :after #'minibuffer-hide-completions))

(use-package vertico-multiform
  :load-path "~/.config/doom/lisp/"
  :commands vertico-multiform-mode
  :after vertico-flat
  :bind (:map vertico-map
              ("M-q" . vertico-multiform-grid)
              ("C-l" . vertico-multiform-unobtrusive)
              ("C-M-l" . embark-export))
  :init (vertico-multiform-mode 1)
  :config
  (setq vertico-multiform-categories
         '((file my/vertico-grid-mode reverse)
           (project-file my/vertico-grid-mode reverse)
           (imenu buffer)
           (consult-location buffer)
           (consult-grep buffer)
           (notmuch-result reverse)
           (minor-mode reverse)
           (reftex-label reverse)
           (citar-reference reverse)
           (xref-location reverse)
           (t unobtrusive)))
   (setq vertico-multiform-commands
         '((load-theme my/vertico-grid-mode reverse)
           (my/toggle-theme my/vertico-grid-mode reverse)
           (consult-dir-maybe reverse)
           (consult-dir reverse)
           (consult-history reverse)
           (consult-completion-in-region reverse)
           (completion-at-point reverse)
           (org-roam-node-find reverse)
           (embark-completing-read-prompter reverse)
           (embark-act-with-completing-read reverse)
           (embark-prefix-help-command reverse)
           (embark-bindings reverse)
           (consult-org-heading reverse)
           (consult-dff unobtrusive)
           (my/eshell-previous-matching-input reverse)
           (tmm-menubar reverse)))

   (defun vertico-multiform-unobtrusive ()
     "Toggle the quiet display."
     (interactive)
     (vertico-multiform--display-toggle 'vertico-unobtrusive-mode)
     (if vertico-unobtrusive-mode
         (vertico-multiform--temporary-mode 'vertico-reverse-mode -1)
       (vertico-multiform--temporary-mode 'vertico-reverse-mode 1))))

(use-package vertico-unobtrusive
  :load-path "~/.config/doom/lisp/"
  :after vertico-flat)

(use-package vertico-grid
  :load-path "~/.config/doom/lisp/"
  :after vertico
  ;; :bind (:map vertico-map ("M-q" . vertico-grid-mode))
  :config
  (defvar my/vertico-count-orig vertico-count)
  (define-minor-mode my/vertico-grid-mode
    "Vertico-grid display with modified row count."
    :global t :group 'vertico
    (cond
     (my/vertico-grid-mode
      (setq my/vertico-count-orig vertico-count)
      (setq vertico-count 4)
      (vertico-grid-mode 1))
     (t (vertico-grid-mode 0)
        (setq vertico-count my/vertico-count-orig))))
  (setq vertico-grid-separator "    ")
  (setq vertico-grid-lookahead 50))

(use-package vertico-quick
  :load-path "~/.config/doom/lisp/"
  :after vertico
  :bind (:map vertico-map
         ("M-i" . vertico-quick-insert)
         ("C-'" . vertico-quick-exit)
         ("C-o" . vertico-quick-embark))
  :config
  (defun vertico-quick-embark (&optional arg)
    "Embark on candidate using quick keys."
    (interactive)
    (when (vertico-quick-jump)
      (embark-act arg))))

(use-package vertico-directory
  :load-path "~/.config/doom/lisp/"
  ;; :hook (rfn-eshadow-update-overlay vertico-directory-tidy)
  :after vertico
  :bind (:map vertico-map
         ("DEL"   . vertico-directory-delete-char)
         ("M-DEL" . vertico-directory-delete-word)
         ("C-w"   . vertico-directory-delete-word)
         ("RET"   . vertico-directory-enter)))

(use-package vertico-repeat
  :load-path "~/.config/doom/lisp/"
  :after vertico
  :bind (("C-x ." . vertico-repeat)
         ("H-."   . vertico-repeat)))

(use-package vertico-reverse
  ;; :disabled
  :load-path "~/.config/doom/lisp/"
  :after vertico)

(use-package vertico-flat
  :load-path "~/.config/doom/lisp/"
  ;; :bind (:map vertico-map
  ;;             ("M-q" . vertico-flat-mode))
  :after vertico)

(use-package vertico-buffer
  :load-path "~/.config/doom/lisp/"
  :after vertico
  ;; :hook (vertico-buffer-mode . vertico-buffer-setup)
  :config
  (setq vertico-buffer-display-action 'display-buffer-reuse-window))

(provide 'setup-vertico)
;; setup-vertico.el ends here
#+end_src

#+RESULTS:
: t

** Embark
*** embark
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/setup-embark.el

;; -*- lexical-binding: t -*-
;; Embark for actions
(use-package embark
  :demand
  :ensure t
  :after minibuffer
  :bind (("M-s RET"  . embark-act)
         ("s-o"      . embark-act)
         ("s-C-o"    . embark-act-noexit)
         ("H-SPC" . embark-act)
         ("C-h b" . embark-bindings)
         ("C-h C-b" . describe-bindings)
         :map minibuffer-local-completion-map
         ("s-o"      . embark-act)
         ("s-C-o"    . embark-act-noexit)
         ("C-o"      . embark-minimal-act)
         ("C-M-o"    . embark-minimal-act-noexit)
         ("C-c C-o"  . embark-export)
         ("M-s o"    . embark-export)
         ("H-SPC"    . embark-act)
         ("C->"      . embark-become)
         :map completion-list-mode-map
         ("C-o"      . embark-minimal-act)
         :map embark-collect-mode-map
         ("H-SPC" . embark-act)
         ("o"        . embark-act)
         ("O"        . embark-act-noexit)
         ("C-o"      . embark-act)
         ("M-t"      . toggle-truncate-lines)
         ("M-q"      . embark-collect-toggle-view)
         :map embark-file-map
         ("j"        . my/find-file-dir)
         ("S"        . sudo-find-file)
         ("4"        . find-file-other-window)
         ("5"        . find-file-other-frame)
         ("C-="      . diff)
         :map embark-buffer-map
         ("d"        . diff-buffer-with-file) ;FIXME
         ("l"        . eval-buffer)
         ("4"        . switch-to-buffer-other-window)
         ("5"        . switch-to-buffer-other-frame)
         ("C-="      . diff-buffers)
         :map embark-bookmark-map
         ("4"        . bookmark-jump-other-window)
         ("5"        . bookmark-jump-other-frame)
         :map embark-url-map
         ("f"        . browse-url-firefox)
         ("m"        . browse-url-umpv)
         ("M"        . browse-url-mpv))
  :config
  (setq embark-cycle-key (kbd "s-o"))
  (setq embark-quit-after-action t)
  ;; Use Embark instead of `describe-prefix-bindings'
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Embark indicators
  (setq embark-indicators '(embark-which-key-indicator
                            ;; embark-minimal-indicator
                            embark-highlight-indicator
                            embark-isearch-highlight-indicator))
  ;; (add-to-list 'embark-indicators 'embark-mixed-indicator)
  ;; (setq embark-mixed-indicator-delay 0.5)
  (setq embark-verbose-indicator-display-action
        '(display-buffer-at-bottom
          (window-height . (lambda (win) (fit-window-to-buffer
                                     win (floor (frame-height)
                                                3))))))

  ;; Utility commands
  (defun embark-minimal-act (&optional arg)
    (interactive "P")
    (let ((embark-indicators
           '(embark-which-key-indicator
             embark-highlight-indicator
             embark-isearch-highlight-indicator)))
      (embark-act arg)))

  (defun embark-minimal-act-noexit ()
    (interactive)
    (embark-minimal-act 4))

  (defun embark-act-noexit ()
    (interactive)
    (embark-act 4))

  (defun my/find-file-dir (file)
    (interactive (list (read-file-name "Jump to dir of file: ")))
                         (dired (file-name-directory file)))

  ;; Extra embark actions
  (eval-when-compile
    (defmacro my/embark-ace-action (fn)
      `(defun ,(intern (concat "my/embark-ace-" (symbol-name fn))) ()
         (interactive)
         (with-demoted-errors "%s"
           (require 'ace-window)
           (aw-switch-to-window (aw-select nil))
           (call-interactively (symbol-function ',fn)))))

    (defmacro my/embark-split-action (fn split-type)
      `(defun ,(intern (concat "my/embark-"
                               (symbol-name fn)
                               "-"
                               (car (last  (split-string
                                            (symbol-name split-type) "-"))))) ()
         (interactive)
         (funcall #',split-type)
         (call-interactively #',fn))))

    (define-key embark-file-map (kbd "o") (my/embark-ace-action find-file))
    (define-key embark-file-map (kbd "2") (my/embark-split-action find-file my/split-window-below))
    (define-key embark-file-map (kbd "3") (my/embark-split-action find-file my/split-window-right))
    (define-key embark-buffer-map (kbd "o") (my/embark-ace-action switch-to-buffer))
    (define-key embark-buffer-map (kbd "2") (my/embark-split-action switch-to-buffer my/split-window-below))
    (define-key embark-buffer-map (kbd "3") (my/embark-split-action switch-to-buffer my/split-window-right))
    (define-key embark-bookmark-map (kbd "o") (my/embark-ace-action bookmark-jump))
    (define-key embark-bookmark-map (kbd "2") (my/embark-split-action bookmark-jump my/split-window-below))
    (define-key embark-bookmark-map (kbd "3") (my/embark-split-action bookmark-jump my/split-window-right))
    (define-key embark-file-map (kbd "U") '0x0-upload-file)
    (define-key embark-region-map (kbd "U") '0x0-upload-text)
    (define-key embark-buffer-map (kbd "U") '0x0-dwim)

    ;; Embark actions for this buffer/file
    (defun embark-target-this-buffer-file ()
      (cons 'this-buffer-file (buffer-name)))

    (add-to-list 'embark-target-finders #'embark-target-this-buffer-file 'append)
    (unless (member 'embark-target-this-buffer-file embark-target-finders)
      (setq embark-target-finders
            (append (butlast embark-target-finders 2)
                    '(embark-target-this-buffer-file)
                    (last embark-target-finders 2))))

    ;; Embark keymaps
    (add-to-list 'embark-keymap-alist
                 '(project-file . embark-file-map))
    (add-to-list 'embark-exporters-alist
                 '(project-file . embark-export-dired))

    (embark-define-keymap this-buffer-file-map
      "Commands to act on current file or buffer."
      ("l" load-file)
      ("b" byte-compile-file)
      ("S" sudo-find-file)
      ("r" rename-file-and-buffer)
      ("d" my/diff-buffer-dwim)
      ("=" ediff-buffers)
      ("C-=" ediff-files)
      ("!" shell-command)
      ("&" async-shell-command)
      ("x" consult-file-externally)
      ("C-a" mml-attach-file)
      ("c" copy-file)
      ("k" kill-buffer)
      ("#" recover-this-file)
      ("z" bury-buffer)
      ("|" embark-shell-command-on-buffer)
      ;; ("l" org-store-link)
      ("U" 0x0-dwim)
      ("g" revert-buffer))

    (add-to-list 'embark-keymap-alist '(this-buffer-file . this-buffer-file-map))
    ;; (cl-pushnew 'revert-buffer embark-allow-edit-actions)
    ;; (cl-pushnew 'rename-file-and-buffer embark-allow-edit-actions)

    (use-package helpful
      :defer
      :bind (:map embark-become-help-map
                  ("f" . helpful-callable)
                  ("v" . helpful-variable)
                  ("C" . helpful-command)))

    ;; Embark-collect display
    (setf (alist-get "^\\*Embark \\(?:Export\\|Collect\\).*\\*"
                     display-buffer-alist nil nil 'equal)
            '((display-buffer-in-direction)
              (window-height . (lambda (win) (fit-window-to-buffer
                                         win
                                         (floor (frame-height) 3))))
              (direction . below)
              (window-parameters . ((split-window . #'ignore)))))

    (setf (alist-get "^\\*Embark \\(?:Export\\|Collect\\).*Variables\\*"
                     display-buffer-alist nil nil 'equal)
            '((+select-buffer-in-side-window)
              (window-width . 74)
              (side . right)
              (slot . 5)
              (window-parameters . ((split-window . #'ignore)))))

    ;; Helm style prompter
    (defun with-minibuffer-keymap (keymap)
      (lambda (fn &rest args)
        (minibuffer-with-setup-hook
            (:append (lambda ()
                       (use-local-map
                        (make-composed-keymap keymap (current-local-map)))))
          (apply fn args))))

    (defvar embark-completing-read-prompter-map
      (let ((map (make-sparse-keymap)))
        (define-key map (kbd "C-<tab>") 'abort-recursive-edit)
        (define-key map (kbd "H-<tab>") 'abort-recursive-edit)
        map))

    (advice-add 'embark-completing-read-prompter :around
                (with-minibuffer-keymap embark-completing-read-prompter-map))

    (defun embark-act-with-completing-read (&optional arg)
      (interactive "P")
      (let* ((embark-prompter 'embark-completing-read-prompter)
             (act (propertize "Act" 'face 'highlight))
             (embark-indicators '(embark-minimal-indicator)))
        (embark-act arg)))

    ;; Which-key style indicator
    (use-package which-key
      :after which-key
      :config
      ;; From the embark wiki
      (defun embark-which-key-indicator ()
        "An embark indicator that displays keymaps using which-key.
The which-key help message will show the type and value of the
current target followed by an ellipsis if there are further
targets."
        (lambda (&optional keymap targets prefix)
          (if (null keymap)
              (which-key--hide-popup-ignore-command)
            (which-key--show-keymap
             (if (eq (caar targets) 'embark-become)
                 "Become"
               (format "Act on %s '%s'%s"
                       (plist-get (car targets) :type)
                       (embark--truncate-target (plist-get (car targets) :target))
                       (if (cdr targets) "…" "")))
             (if prefix
                 (pcase (lookup-key keymap prefix 'accept-default)
                   ((and (pred keymapp) km) km)
                   (_ (key-binding prefix 'accept-default)))
               keymap)
             nil nil t)))))

    ;; Vertico highlight indicator
    (use-package vertico
      :defer
      :config
      (defun embark-vertico-indicator ()
        (let ((fr face-remapping-alist))
          (lambda (&optional keymap _targets prefix)
            (when (bound-and-true-p vertico--input)
              (setq-local face-remapping-alist
                          (if keymap
                              (cons '(vertico-current . embark-target) fr)
                            fr))))))
      (add-to-list 'embark-indicators #'embark-vertico-indicator)))

(use-package embark-consult
  :ensure t
  :after (embark consult)
  :demand
  :bind (:map embark-become-file+buffer-map
         ("m" . consult-bookmark)
         ("b" . consult-buffer)
         ("j" . consult-find))
  :config

;; (setq embark-collect-initial-view-alist
;;       '((file           . list)
;;         (project-file   . list)
;;         (virtual-buffer . list)
;;         (buffer         . list)
;;         (consult-multi  . list)
;;         (consult-location . list)
;;         (consult-compile-error . list)
;;         (consult-flymake-error . list)
;;         (symbol         . grid)
;;         (command        . grid)
;;         (imenu          . grid)
;;         (line           . list)
;;         (xref-location  . list)
;;         (kill-ring      . zebra)
;;         (face           . list)
;;         (t              . grid)))

  (add-to-list
   'embark-exporters-alist
   '(consult-flymake-error . embark-export-flymake))

  (defun embark-export-flymake (_errors)
    (flymake-show-buffer-diagnostics))

  (dolist (pair '((consult-fd . list)))
    (add-to-list 'embark-collect-initial-view-alist
                 pair))
  :bind (:map embark-file-map
              ("x" . consult-file-externally)))

;;; Embark-Collect overlays
;; Disabled - don't need this with embark-live-mode (elm) active
(use-package embark
  :hook ((embark-collect-mode . my/embark-collect--live-setup))
  :disabled
  :config
   ;; Highlighting selections in embark-collect buffers
  (defvar-local my/embark-collect--overlay nil
    "Text overlay for embark-collect buffers.")

  (defun my/embark--live-completions-p ()
  "Determine whether current collection is for live completions."
  (and (derived-mode-p 'embark-collect-mode)
       (eq embark-collect--kind :completions)))

  (defun my/embark-collect--live-setup ()
    "Remove mode-line from live embark-collect buffers and set up
highlighting."
    ;; (when (my/embark--live-completions-p)
    ;;   (my/mode-line-hidden-mode 1))
    (setq my/embark-collect--overlay (make-overlay 1 1))
    (overlay-put my/embark-collect--overlay 'face 'highlight)
    (add-hook 'post-command-hook 'my/embark-collect--live-overlay-update nil t))

  (defun my/embark-collect--live-overlay-update ()
    "Update the overlay in the embark-collect buffer."
    (pcase embark-collect-view
      ('list (hl-line-mode 1))
      ('grid (when (and (overlayp my/embark-collect--overlay)
                        (get-text-property (point) 'mouse-face))
               (hl-line-mode 0)
               (let ((beg (previous-single-property-change
                           (if (eobp) (point-max) (1+ (point)))
                           'mouse-face nil (point-min)))
                     (end (next-single-property-change (point) 'mouse-face nil (point-max))))
                 (move-overlay my/embark-collect--overlay beg end)))))))

;;; Embark-avy
(use-package avy-embark-collect
  :disabled
  :after embark
  :bind (:map minibuffer-local-completion-map
              ("M-j" . avy-embark-collect-choose)
              ("M-RET" . avy-embark-collect-choose)
              ("C-M-o" . avy-embark-collect-act)
              ("C-M-j" . avy-embark-collect-act)))

(provide 'setup-embark)
;; setup-embark.el ends here
#+end_src

#+RESULTS:
: setup-embark

*** Extended minibuffer actions and more (embark.el and prot-embark.el)
:PROPERTIES:
:CUSTOM_ID: h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984
:END:

Video introduction: [[https://protesilaos.com/codelog/2021-01-09-emacs-embark-extras/][Embark and my extras]] (2021-01-09).  Also read
[[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen ways to use Embark]] (2021-10-06) by Karthik Chikmagalur.

[ NOTE 2021-04-02: the part in that video that deals with cycling
  through the completion candidates has been moved to the file
  =prot-minibuffer.el=, though the effect is practically the same.  UPDATE
  2021-10-22: It now is its own standalone package, called
  =mct.el=---[[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]. ]

Embark provides a unified framework of regular Emacs keymaps which let
you carry out /contextually relevant actions/ on *targets* through a common
*point of entry*, typically a /prefix key/.

+ "Actions" are standard Emacs commands, such as =describe-symbol= or some
  interactive command you have defined that reads an argument from the
  minibuffer.

+ "Targets" are semantically sensitive constructs, such as the symbol at
  point, a URL, a file name, the active region, or the current
  completion candidate in the minibuffer (or the completions'
  buffer---more on that in the next section).  Embark has mechanisms
  which help it determine the category that the target belongs to.

+ The "contextually relevant [actions]" are defined in keymaps whose
  scope matches the category of the target.  So =embark-file-map= holds
  all key and command associations for when Embark recognises a file
  name as its target.  =embark-region-map= is for actions pertaining to
  the active region; =embark-buffer-map= for buffer names that you access
  through, say, =switch-to-buffer= (=C-x b=).  And so on.

+ As for the "point of entry" or "prefix key", it is an Embark command,
  such as =embark-act= or =embark-become=.  Those activate the appropriate
  keymap, thus granting you access to the relevant commands.

Embark can act on individual targets (e.g. the region) or sets of
targets (e.g. the list of minibuffer completion candidates).

Emacs users are already familiar with this contextuality of Embark, even
though they may not realise it.  Think, for example, that hitting the =j=
key in an =org-mode= buffer performs the action of inserting that letter
in the buffer: you type something.  While the same =j= key performs a
different action in, say, a =dired-mode= buffer.  There is no conflict
between those actions because each of them is bound to a distinct
keymap, and only one of those keymaps applies in their respective
context.

The beauty of Embark's design is that you configure its contextuality in
the exact same way you define all of your Emacs key bindings.  So you
can bind any command to whatever key you want and confine that action to
a context you specify.

On Emacs 28, learn more about the keymaps with =M-x describe-keymap= and
then search for =embark=.

Now a few things about actions that you can gain access to by invoking
either of =embark-act= (most cases), or =embark-become= (where appropriate):

+ Embark has two ways to help you learn about its actions, though you
  will probably only ever need one of them.  The first one, which is the
  default, is to display a detailed buffer when the variable
  =embark-indicators= includes the symbol =embark-mixed-indicator= or
  =embark-verbose-indicator=.  Either of those will produce a buffer that
  shows the available actions, the keys they are bound to, and a
  description of what each action does.  The other method, which is only
  really useful if =embark-indicator= is set to =embark-minimal-indicator=
  is to follow up the =embark-act= with =C-h=.  That will produce a
  minibuffer prompt showing all available key bindings.

  - Keymaps aside, you can call /any command/ after invoking =embark-act=.
    This can be either with =M-x= or via its key binding.  For example, if
    you want to grep for the symbol at point in the current project, you
    can do =embark-act= and then =C-x p g= (=project-find-regexp=) (also read
    [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  This will, of course,
    work as expected for commands that typically prompt you for
    something to operate on.

  - Using the =C-h= as a suffix is a standard procedure in Emacs to get a
    Help buffer that contains references to all commands+keys that
    extend a give key chord.  So, for example, =C-x r C-h= will show you
    all commands under the =C-x r= prefix (see [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).
    While the generic =C-h= is fine in its own right, Embark offers an
    alternative that leverages minibuffer completion: the
    =embark-prefix-help-command=.  You can either select an action from
    there or type =@= and the corresponding key.

+ You will often be targeting individual items, such as the current
  completion candidate in the minibuffer, or the symbol at point.  You
  can, however, collect the entire set of targets and store it in a
  buffer, which you can then re-use at your convenience or save it on
  disk (with =write-file= bound to =C-x C-w= by default).  This is done by
  the =embark-collect-snapshot= command, which you can always access
  through =embark-act=.

  - The "Embark Collect" buffer can be presented as a grid or a list,
    with the possibility to manually switch between the two by means of
    the =embark-collect-toggle-view= command.  The list view offers more
    room to the side of each candidate.  It can be used to display
    annotations (see [[#h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40][Completion annotations (marginalia)]]), such as the
    first line of a variable's doc string and current value, a command's
    key binding, the buffer's underlying file system path if it is
    visiting a file, and so on.

  - Embark's "collect" buffer also has a live-updating version, which
    can be use to filter the list of targets.  This particular feature
    can, in fact, be used as a medium for visualising the list of
    candidates in the active minibuffer session.  I used that setup for
    several months together with the default minibuffer as part my
    bespoke completion framework, though as of 2021-04-02 I handle the
    live-updating completions' buffer independently of Embark
    ([[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

  - Other than producing a snapshot, Embark can also collect the targets
    and present them in a buffer whose major-mode is specialised to work
    on the category those targets belong to.  This is done with the
    =embark-export= command.  If you are targeting files, then the export
    takes you to a =dired-mode= buffer (also refer to this document's
    section on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]); buffers go to
    =ibuffer-mode= (check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer and extras]]); grep results in a =grep-mode=
    buffer, and so on.

Finally, the =prot-embark.el= that is reproduced after the following block
contains a few keymaps that integrate Embark with packages like =consult=
([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).  The =embark-consult= package
provides glue code that allows Embark to produce a correct export buffer
while using relevant Consult commands, such as =consult-grep=.

#+begin_src emacs-lisp :tangle no
;;; Extended minibuffer actions and more (embark.el and prot-embark.el)
(use-package embark :config (setq prefix-help-command
#'embark-prefix-help-command) ;; (setq prefix-help-command
#'describe-prefix-bindings) ; the default of the above (setq
embark-collect-initial-view-alist '((t . list))) (setq embark-quit-after-action
t) ; XXX: Read the doc string! (setq embark-cycle-key (kbd "C-.")) ; see the
`embark-act' key (setq embark-collect-live-update-delay 0.5) (setq
embark-collect-live-initial-delay 0.8) (setq embark-indicators
'(embark-mixed-indicator embark-highlight-indicator)) ;; NOTE 2021-07-31: The
mixed indicator starts out with a minimal view ;; and then pops up the verbose
buffer, so those variables matter. (setq
embark-verbose-indicator-excluded-actions '("\\`embark-collect-" "\\`customize-"
"\\(local\\|global\\)-set-key" set-variable embark-cycle embark-export
embark-keymap-help embark-become embark-isearch)) (setq
embark-verbose-indicator-buffer-sections `(target "\n" shadowed-targets " "
cycle "\n" bindings)) (setq embark-mixed-indicator-both nil) (setq
embark-mixed-indicator-delay 1.2) ;; NOTE 2021-07-28: This is used when
`embark-indicator' is set to ;; `embark-mixed-indicator' or
`embark-verbose-indicator'. We can ;; specify the window parameters here, but I
prefer to do that in my ;; `display-buffer-alist' (search this document) because
it is easier ;; to keep track of all my rules in one place. (setq
embark-verbose-indicator-display-action nil)

  (define-key global-map (kbd "C-,") #'embark-act) (let ((map
  minibuffer-local-completion-map)) (define-key map (kbd "C-,") #'embark-act)
  (define-key map (kbd "C->") #'embark-become) (define-key map (kbd "M-q")
  #'embark-collect-toggle-view)) ; parallel of `fill-paragraph' (let ((map
  embark-collect-mode-map)) (define-key map (kbd "C-,") #'embark-act)
  (define-key map (kbd "M-q") #'embark-collect-toggle-view)) (let ((map
  embark-region-map)) (define-key map (kbd "a") #'align-regexp) (define-key map
  (kbd "i") #'epa-import-keys-region) (define-key map (kbd "r")
  #'repunctuate-sentences) ; overrides `rot13-region' (define-key map (kbd "s")
  #'sort-lines) (define-key map (kbd "u") #'untabify)) (let ((map
  embark-symbol-map)) (define-key map (kbd ".") #'embark-find-definition)
  (define-key map (kbd "k") #'describe-keymap)))

;; Needed for correct exporting while using Embark with Consult commands.
;; (use-package embark-consult) (load "embark") (use-package prot-embark :config
;; (prot-embark-keymaps 1) (prot-embark-setup-packages 1))
#+end_src

#+RESULTS:
: t

** Minibuffer history (savehist-mode)
:PROPERTIES:
:CUSTOM_ID: h:2733674b-51f9-494e-b34d-e8842ac4ef96
:END:

The built-in =savehist-mode= keeps a record of actions involving the
minibuffer.  You can access previous inputs with =M-p= and =M-n=.  Well
designed commands that use completion will have their own history, so
those key bindings will only cycle through relevant results.  You can
also search backwardly through them with =M-r=.

This kind of functionality is of paramount importance to a fast and
efficient workflow involving any completion framework that leverages the
built-in mechanisms.

Emacs will remember your input and choices so it will prioritise the
desired results when trying to force complete a given input.  Make sure
to also read the [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]] for
the minibuffer-specific setup.

#+begin_src emacs-lisp
;;; Minibuffer history (savehist-mode)
(use-package savehist
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-hook 'after-init-hook #'savehist-mode))
#+end_src

#+RESULTS:
: t

** Selection candidates and search methods
** In-buffer completions
:PROPERTIES:
:CUSTOM_ID: h:98876022-57cc-40de-936e-4ee42cefd69a
:END:
*** CAPE (extra completion-at-point backends)
:PROPERTIES:
:CUSTOM_ID: h:5c227fea-189a-43a2-bf1e-70aeececfcb8
:END:

The =cape= package, by Daniel Mendler (developer of Consult, Vertico,
Corfu, ...), adds more backends to the =completion-at-point-functions=
(CAPF) facility.  This practically means that you can use in-buffer
completion in more scenaria and with relevant candidates.

A package such as Daniel's own Corfu is used to visualise in-buffer
completion.

#+begin_src emacs-lisp :tangle no
;;; CAPE (extra completion-at-point backends)
(use-package cape
  :config
  (setq cape-dabbrev-min-length 3)
  (dolist (backend '( cape-symbol cape-keyword cape-file cape-dabbrev))
    (add-to-list 'completion-at-point-functions backend)))
#+end_src

*** Dabbrev (dynamic word completion)
:PROPERTIES:
:CUSTOM_ID: h:57dcf193-0c4e-4ee6-9b2d-6892558b0a84
:END:

This is Emacs' own approach to dynamic/arbitrary text completion inside
the buffer: "dynamic abbreviation" or else =dabbrev=.  This mechanism
works by reading all text before point to find a suitable match.
Different scenaria determine whether it should also look forward and in
other buffers.  In essence, Dabbrev helps you re-type what you already
have.

With =dabbrev-expand= we make an attempt to complete the text at point.
Repeated invocations will cycle through the candidates.  No feedback is
provided, much in the same way yanking from the kill-ring works (though
for Emacs28 =yank-pop= on =M-y= will use completion if the previous command
was not =yank= on =C-y=).  To complete a phrase, matching the last succesful
=dabbrev-expand=, you need to supply an empty space and call the command
again.  This will match the next word, and so on for N words.

Whereas =dabbrev-completion= benefits from minibuffer interactivity and
the pattern matching styles in effect ([[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).
With the help of Corfu, the completion candidates are displayed in a
pop-up window near point ([[#h:675ebef4-d74d-41af-808d-f9579c2a5ec4][Corfu for in-buffer completion]]).

The =dabbrev-abbrev-char-regexp= is configured to match both regular words
and symbols (e.g. words separated by hyphens).  This makes it equally
suitable for code and ordinary language.

While the =dabbrev-abbrev-skip-leading-regexp= is instructed to also
expand words and symbols that start with any of these: =$=, =*=, =/=, ===, =~=, ='=.
This regexp may be expanded in the future, but the idea is to be able to
perform completion in contexts where the known word/symbol is preceded
by a special character.  For example, in the =org-mode= version of this
document, all inline code must be placed between the equals sign.  So
now typing the ===, then a letter, will still allow me to expand text
based on that input.

To check what I have on regular expressions, see further below my
configurations and documentation for [[#h:6c6759c8-3ae3-40b0-8356-05cc0975e12a][re-builder (regexp-builder)]].

#+begin_src emacs-lisp :tangle no
;;; Dabbrev (dynamic word completion)
(use-package dabbrev
  :config
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)
  (let ((map global-map))
    (define-key map (kbd "M-/") #'dabbrev-expand)
    (define-key map (kbd "C-x M-/") #'dabbrev-completion)))
#+end_src

#+RESULTS:
: t

* Buffers
** snails
  #+begin_src emacs-lisp
    (add-to-list 'load-path "~/.config/doom/lisp/snails") ; add snails to your load-path
    (require 'snails)

  #+end_src

  #+RESULTS:
  : snails

** Helper functions to clean up the gazillion buffers

When switching projects in Emacs, it can be prudent to clean up every
once in a while. Deleting all buffers except the current one is one of
the things I often do (especially in the long-running =emacsclient=).

#+BEGIN_SRC emacs-lisp :tangle no
  (defun kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC

=dired= will create buffers for every visited folder. This is a helper
to clear them out once you're done working with those folders.

#+BEGIN_SRC emacs-lisp :tangle no

  (defun kill-dired-buffers ()
    "Kill all open dired buffers."
    (interactive)
    (mapc (lambda (buffer)
            (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
              (kill-buffer buffer)))
          (buffer-list)))
#+END_SRC
** Bufler
I'd much rather have my new buffers in ~org-mode~ than ~fundamental-mode~, hence
#+begin_src emacs-lisp
;; (setq-default major-mode 'org-mode)
#+end_src
For some reason this + the mixed pitch hook causes issues with hydra and so I'll
just need to resort to =SPC b o= for now.

#+begin_src emacs-lisp
(use-package bufler
  ;; :disabled
  :ensure nil
  ;; :straight t
  :bind (("C-c d" . bufler-switch-buffer)
         ("C-c w" . bufler-workspace-frame-set))
  :config
  (evil-collection-define-key 'normal 'bufler-list-mode-map
    (kbd "RET")   'bufler-list-buffer-switch
    (kbd "M-RET") 'bufler-list-buffer-peek
    (kbd "C-d") 'bufler-list-buffer-kill)

  (setf bufler-groups
        (bufler-defgroups
          ;; Subgroup collecting all named workspaces.
          (group (auto-workspace))
          ;; Subgroup collecting buffers in a projectile project.
          (group (auto-projectile))
          ;; Grouping browser windows
          (group
           (group-or "Browsers"
                     (name-match "Vimb" (rx bos "vimb"))
                     (name-match "qutebrowser" (rx bos "Qutebrowser"))
                     (name-match "F# " (rx bos "Qutebrowser"))
                     (name-match "firefoxdeveloperedition" (rx bos "firefoxdeveloperedition"))
                     (name-match "Chromium" (rx bos "Chromium"))))
          (group
           (group-or "Chat"
                     (mode-match "Telega" (rx bos "telega-"))))
          (group
           ;; Subgroup collecting all `help-mode' and `info-mode' buffers.
           (group-or "Help/Info"
                     (mode-match "*Help*" (rx bos (or "help-" "helpful-")))
                     ;; (mode-match "*Helpful*" (rx bos "helpful-"))
                     (mode-match "*Info*" (rx bos "info-"))))
          (group
           ;; Subgroup collecting all special buffers (i.e. ones that are not
           ;; file-backed), except `magit-status-mode' buffers (which are allowed to fall
           ;; through to other groups, so they end up grouped with their project buffers).
           (group-and "*Special*"
                      (name-match "**Special**"
                                  (rx bos "*" (or "Messages" "Warnings" "scratch" "Backtrace" "Pinentry") "*"))
                      (lambda (buffer)
                        (unless (or (funcall (mode-match "Magit" (rx bos "magit-status"))
                                             buffer)
                                    (funcall (mode-match "Dired" (rx bos "dired"))
                                             buffer)
                                    (funcall (auto-file) buffer))
                          "*Special*"))))
          ;; Group remaining buffers by major mode.
          (auto-mode))))
#+end_src

#+RESULTS:
: bufler-workspace-frame-set

** better buffers.ui
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/better-buffers.el

;; -*- lexical-binding: t -*-
;;######################################################################
;; * BETTER BUFFERS
;;######################################################################

;;----------------------------------------------------------------------
;; ** KEYBINDINGS
;;----------------------------------------------------------------------

(global-set-key (kbd "C-x k") 'my/kill-this-buffer)
(global-set-key (kbd "C-a")
                (defun my/switch-to-other-buffer (&optional _arg)
                  (interactive)
                  (switch-to-buffer (other-buffer))))

;; Keys to traverse buffers
;; (global-set-key (kbd "<C-M-return>") 'ido-display-buffer)
(global-set-key (kbd "C-<prior>") 'previous-buffer) ; Ctrl+PageDown
(global-set-key (kbd "C-<next>") 'next-buffer) ; Ctrl+PageUp

;; (global-set-key (kbd "<C-tab>") 'other-window)  ; Ctrl+Tab
;; (global-set-key (kbd "<C-S-iso-lefttab>")
;;                 (lambda () (interactive) (other-window -1)))
                                        ;Ctrl+Shift+Tab

;;; Cycle buffers forward. (Backward with prefix arg)
;; (global-set-key (kbd "M-`")
;;                 (lambda (&optional arg)
;;                   (interactive "P")
;;                   (if arg (next-user-buffer) (previous-user-buffer))))

;;; Set keys to scroll buffer while centering
;;; location on screen.
(global-set-key "\M-]" 'scroll-buffer-down)
;; ;; (global-set-key "\M-[" 'scroll-buffer-up)


;;; Toggle window split between horizontal and vertical
;; (define-key ctl-x-4-map "t" 'toggle-window-split)
;; (define-key ctl-x-4-map "|" 'toggle-window-split)

(defun my/split-window-right (&optional size)
  "Split the selected window into two windows, one above the other.
The selected window is below.  The newly split-off window is
below and displays the same buffer.  Return the new window."
  (interactive "P")
  (split-window-right size)
  (other-window 1)
  (when (interactive-p)
    (if (featurep 'consult)
        (consult-buffer)
      (call-interactively #'switch-to-buffer))))

(defun my/split-window-below (&optional size)
  "Split the selected window into two side-by-side windows.
The selected window is on the left.  The newly split-off window
is on the right and displays the same buffer.  Return the new
window."
  (interactive "P")
  (split-window-below size)
  (other-window 1)
  (when (interactive-p)
    (if (featurep 'consult)
        (consult-buffer)
      (call-interactively #'switch-to-buffer))))

(defun my/delete-window-or-delete-frame (&optional window)
      "Delete WINDOW using `delete-window'.
If this is the sole window run `delete-frame' instead. WINDOW
must be a valid window and defaults to the selected one. Return
nil."
      (interactive)
      (condition-case nil
          (delete-window window)
        (error (if (and tab-bar-mode
                        (> (length (funcall tab-bar-tabs-function)) 1))
                   (tab-bar-close-tab)
                 (delete-frame)))))

(global-set-key [remap split-window-below] 'my/split-window-below) ;: C-x 2
(global-set-key [remap split-window-right] 'my/split-window-right);: C-x 3
(global-set-key [remap delete-window] 'my/delete-window-or-delete-frame) ;;C-x 0
;; (global-set-key (kbd "s-Q") 'my/delete-window-or-delete-frame)
;; (global-set-key (kbd "s-q") 'delete-other-windows);; SPC-w C-o
;; (global-set-key (kbd "s-z") 'my/split-window-below)
;; (global-set-key (kbd "s-v") 'my/split-window-right)
(global-set-key (kbd "s-o") ctl-x-4-map)
(global-set-key (kbd "s-d") ctl-x-5-map)
;; (global-set-key (kbd "H-k") 'my/kill-this-buffer) C-x k
;; (global-set-key (kbd "H-q") 'kill-buffer-and-window) C-x q
(global-set-key (kbd "<f7>") '+make-frame-floating-with-current-buffer)
;;----------------------------------------------------------------------
;; ** UTILITY FUNCTIONS
;;----------------------------------------------------------------------

;; (defun iswitchb-local-keys ()
;;   (mapc (lambda (K)
;;           (let* ((key (car K)) (fun (cdr K)))
;;             (define-key iswitchb-mode-map (edmacro-parse-keys key) fun)))
;;         '(("C-n" . iswitchb-next-match)
;;           ("C-p"  . iswitchb-prev-match)
;;           ("<up>"    . ignore             )
;;           ("<down>"  . ignore             ))))

;; (add-hook 'iswitchb-define-mode-map-hook 'iswitchb-local-keys)

;;;###autoload
(defun my/kill-this-buffer (&optional arg)
  (interactive "P")
  (pcase arg
    ('4 (call-interactively #'kill-buffer))
    (_ (kill-buffer (current-buffer)))))



;;;###autoload
(defun toggle-window-split ()
  (interactive)
  "Toggles the window split between horizontal and vertical when
the fram has exactly two windows."
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
	     (next-win-buffer (window-buffer (next-window)))
	     (this-win-edges (window-edges (selected-window)))
	     (next-win-edges (window-edges (next-window)))
	     (this-win-2nd (not (and (<= (car this-win-edges)
					 (car next-win-edges))
				     (<= (cadr this-win-edges)
					 (cadr next-win-edges)))))
	     (splitter
	      (if (= (car this-win-edges)
		     (car (window-edges (next-window))))
		  'split-window-horizontally
		'split-window-vertically)))
	(delete-other-windows)
	(let ((first-win (selected-window)))
	  (funcall splitter)
	  (if this-win-2nd (other-window 1))
	  (set-window-buffer (selected-window) this-win-buffer)
	  (set-window-buffer (next-window) next-win-buffer)
	  (select-window first-win)
	  (if this-win-2nd (other-window 1))))))

;; Swap windows if there are two of them
;;;###autoload
(defun swap-windows ()
 "If you have 2 windows, it swaps them." (interactive) (cond ((not (= (count-windows) 2)) (message "You need exactly 2 windows to do this."))
 (t
 (let* ((w1 (first (window-list)))
	 (w2 (second (window-list)))
	 (b1 (window-buffer w1))
	 (b2 (window-buffer w2))
	 (s1 (window-start w1))
	 (s2 (window-start w2)))
 (set-window-buffer w1 b2)
 (set-window-buffer w2 b1)
 (set-window-start w1 s2)
 (set-window-start w2 s1)))))

;; Skip to next/previous user buffer
;;;###autoload
(defun next-user-buffer ()
  "Switch to the next user buffer in cyclic order.\n
User buffers are those not starting with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    ;; (cond ((and (string-equal "*scratch*" (buffer-name))
    ;;             (buffer-modified-p))
    ;;        (setq i (1+ i))
    ;;        (next-buffer)))
    (while (and (not (and (string-equal "*scratch*" (buffer-name))
                          (buffer-modified-p)))
                (string-match "^*" (buffer-name))
                (< i 50))
      (setq i (1+ i)) (next-buffer) )))

;;;###autoload
(defun previous-user-buffer ()
  "Switch to the previous user buffer in cyclic order.\n
User buffers are those not starting with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-equal "*scratch*" (buffer-name)))
                (string-match "^*" (buffer-name))
                (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(global-set-key (kbd "s-n") 'next-buffer)
;; (global-set-key (kbd "s-p") 'previous-buffer)
;;; scroll-buffer: Functions to do exactly that.

;;;###autoload
(defun scroll-buffer-down (&optional arg)
  "Scroll buffer by (optional) ARG paragraphs."
  (interactive "p")
  (forward-paragraph arg)
  (recenter))

;;;###autoload
(defun scroll-buffer-up (&optional arg)
  "Scroll buffer by (optional) ARG paragraphs."
  (interactive "p")
  (backward-paragraph arg)
  (recenter))

;;;###autoload
(defun rename-file-and-buffer (new-name)
  "Renames both current buffer and file it's visiting to NEW-NAME."
  (interactive "sNew name: ")
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (if (get-buffer new-name)
          (message "A buffer named '%s' already exists!" new-name)
        (if (vc-registered filename)
            (vc-rename-file name new-name)
          (rename-file name new-name 1))
        (rename-buffer new-name)
        (set-visited-file-name new-name)
        (set-buffer-modified-p nil)))))

;;;###autoload
(defun move-buffer-file (dir)
  "Moves both current buffer and file it's visiting to DIR."
  (interactive "DNew directory: ")
  (let* ((name (buffer-name))
         (filename (buffer-file-name))
         (dir
          (if (string-match dir "\\(?:/\\|\\\\)$")
              (substring dir 0 -1) dir))
         (newname (concat dir "/" name)))
    (if (not filename)
        (message "Buffer '%s' is not visiting a file!" name)
      (progn (copy-file filename newname 1)
             (delete-file filename)
             (set-visited-file-name newname)
             (set-buffer-modified-p nil) t))))

;;;###autoload
(defun +make-frame-floating-with-current-buffer ()
  "Display the current buffer in a new floating frame.

This passes certain parameters to the newly created frame:

- use a different name than the default;
- use a graphical frame;
- do not display the minibuffer.

The name is meant to be used by the external rules of a tiling
window manager to present the frame in a floating state."
  (interactive)
  (let ((buf (current-buffer)))
    (if (not (one-window-p t))
        (delete-window))
    (make-frame '((name . "dropdown_emacs-buffer")
                  (window-system . x)
                  (minibuffer . nil)))
    (with-selected-frame (get-other-frame)
      (switch-to-buffer buf))))

(provide 'better-buffers)

#+end_src

#+RESULTS:
: better-buffers

** ibuffer.tes
#+begin_src emacs-lisp :tangle ~/.config/doom/lisp/setup-ibuffer.el

;; -*- lexical-binding: t -*-
(use-package ibuffer
  :defer t
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (add-to-list 'ibuffer-help-buffer-modes 'helpful-mode)
  (add-to-list 'ibuffer-help-buffer-modes 'Man-mode)
  ;; (setq ibuffer-use-header-line t)
  ;; (setq ibuffer-display-summary nil)
  ;; (setq ibuffer-use-other-window nil)
  ;; (setq ibuffer-movement-cycle nil)
  ;; (setq ibuffer-default-shrink-to-minimum-size t)
  ;; (setq ibuffer-saved-filter-groups nil)

  (defun ibuffer-visit-buffer-other-window (&optional noselect)
  "In ibuffer, visit this buffer. If `ace-window' is available, use
it to select window for visiting this buffer.`"
  (interactive "P")
  (let ((buf (ibuffer-current-buffer t))
        (window
         (if (fboundp 'aw-select)
             (aw-select "Select Window")
           (next-window))))
    (bury-buffer (current-buffer))
    (if noselect
        (save-window-excursion (select-window window)
                               (switch-to-buffer buf))
      (select-window window) (switch-to-buffer buf))))

  (defun my/buffers-major-mode (&optional arg)
    "Select buffers that match the current buffer's major mode.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion."
    (interactive "P")
    (let* ((major major-mode)
           (prompt "Buffers for ")
           (mode-string (format "%s" major))
           (mode-string-pretty (propertize mode-string 'face 'success)))
      (if arg
          (ibuffer t (concat "*" prompt mode-string "*")
                   (list (cons 'used-mode major)))
        (switch-to-buffer
         (read-buffer
          (concat prompt mode-string-pretty ": ") nil t
          (lambda (pair) ; pair is (name-string . buffer-object)
            (with-current-buffer (cdr pair) (derived-mode-p major))))))))

  (defun my/buffers-vc-root (&optional arg)
    "Select buffers that match the present `vc-root-dir'.
With \\[universal-argument] produce an `ibuffer' filtered
accordingly.  Else use standard completion.

When no VC root is available, use standard `switch-to-buffer'."
    (interactive "P")
    (let* ((root (vc-root-dir))
           (prompt "Buffers for VC ")
           (vc-string (format "%s" root))
           (vc-string-pretty (propertize vc-string 'face 'success)))
      (if root
          (if arg
              (ibuffer t (concat "*" prompt vc-string "*")
                       (list (cons 'filename (expand-file-name root))))
            (switch-to-buffer
             (read-buffer
              (concat prompt vc-string-pretty ": ") nil t
              (lambda (pair) ; pair is (name-string . buffer-object)
                (with-current-buffer (cdr pair) (string= (vc-root-dir) root))))))
        (call-interactively 'switch-to-buffer))))

  :hook ((ibuffer-mode . hl-line-mode)
         ;; (ibuffer-mode . my/ibuffer-project-generate-filter-groups)
         ;; (ibuffer-mode . ibuffer-vc-set-filter-groups-by-vc-root)
         )
  :bind (:map ibuffer-mode-map
              ("M-o" . nil))
  :general
  (:keymaps 'space-menu-buffer-map
   :wk-full-keys nil
   "i" '(ibuffer :wk "ibuffer"))
  ("C-x C-b" 'ibuffer)
  ("M-s b" 'my/buffers-major-mode)
  ("M-s v" 'my/buffers-vc-root)
  ;; :bind (("C-x C-b" . ibuffer))
         ;; :map ibuffer-mode-map
         ;; ("* f" . ibuffer-mark-by-file-name-regexp)
         ;; ("* g" . ibuffer-mark-by-content-regexp) ; "g" is for "grep"
         ;; ("* n" . ibuffer-mark-by-name-regexp)
         ;; ("s n" . ibuffer-do-sort-by-alphabetic)  ; "sort name" mnemonic
         ;; ("/ g" . ibuffer-filter-by-content)
         )

;; (use-package ibuffer-project
;;   :ensure t
;;   :after (ibuffer project)
;;   :hook ((ibuffer ibuffer-mode) . my/ibuffer-project-generate-filter-groups)
;;   :config
;;   (setq ibuffer-project-use-cache t
;;         ibuffer-project-root-functions
;;         '(((lambda (dir)
;;              (project-root (project-current nil dir))) . "Project")))
;;   (defun my/ibuffer-project-generate-filter-groups ()
;;     (setq ibuffer-filter-groups
;;           (ibuffer-project-generate-filter-groups))))

;; ;; Superceded by =ibuffer-project=, since it covers vc repositories and more
;; ;; besides.
;; (use-package ibuffer-vc
;;   :disabled
;;   :after (ibuffer vc)
;;   :general
;;   (:keymaps 'ibuffer-mode-map
;;    :states 'normal
;;    "s V" 'ibuffer-vc-set-filter-groups-by-vc-root
;;    "s <backspace>" 'ibuffer-clear-filter-groups)
;;   (:keymaps 'ibuffer-mode-map
;;    "/ V" 'ibuffer-vc-set-filter-groups-by-vc-root
;;    "/ <backspace>" 'ibuffer-clear-filter-groups))

(provide 'setup-ibuffer)
;;; setup-ibuffer.el ends here
#+end_src

#+RESULTS:
: setup-ibuffer

** Working with buffers
*** Keymap for buffers (Emacs28)
:PROPERTIES:
:CUSTOM_ID: h:17933226-27a8-47c0-80f9-3cc609aacae0
:END:

Starting with Emacs version 28, there is a keymap that can be accessed
with the =C-x x= sequence.  This new keymap (=ctl-x-x-map=), is meant to be
used for commands that pertain to the current buffer.  What I have here
are just some tweaks to make it work the way I prefer.

#+begin_src emacs-lisp :tangle no
;;; Keymap for buffers (Emacs28)
(let ((map ctl-x-x-map))              ; Emacs 28
  (define-key map "e" #'eval-buffer)
  (define-key map "f" #'follow-mode)  ; override `font-lock-update'
  (define-key map "r" #'rename-uniquely))

(with-eval-after-load 'org
  (define-key ctl-x-x-map "i" #'prot-org-id-headlines)
  (define-key ctl-x-x-map "h" #'prot-org-ox-html))
#+end_src

* window managment
** golden ratio
  #+begin_src emacs-lisp :tangle no
    (use-package golden-ratio
      :ensure t)
    (golden-ratio-mode 1)

  #+end_src
** Window configuration
:PROPERTIES:
:CUSTOM_ID: h:12591f89-eeea-4b12-93e8-9293504e5a12
:END:

I believe that Emacs' true power lies in its buffer management rather
than its multiplexing.  The latter becomes inefficient at scale, since
it tries to emulate the limitations of the real world, namely, the
placement of things on a desk.

By leveraging the power of the computer, we can use search methods to
easily reach any item.  There is no need to remain confined to the idea
of a finite space (screen real estate) that needs to be carefully
managed.

That granted, Emacs' multiplexing can be turned into a powerhouse as
well, covering everything from window placement rules, to the recording
of history and layouts, as well as directional or direct window
navigation.

*** Window rules and basic tweaks (window.el)
:PROPERTIES:
:CUSTOM_ID: h:3d8ebbb1-f749-412e-9c72-5d65f48d5957
:END:

The =display-buffer-alist= is intended as a rule-set for controlling the
placement of windows.  This is mostly needed for ancillary buffers, such
as shells, compilation output, and the like.  The objective is to create
a more intuitive workflow where targeted buffer groups or types are
always shown at a given location, on the premise that predictability
improves usability.

For each buffer action in =display-buffer-alist= we can define several
functions for selecting the appropriate window.  These are executed in
sequence, but my usage thus far suggests that a simpler method is just
as effective for my case.

Everything pertaining to buffer actions is documented at length in the
GNU Emacs Lisp Reference Manual (evaluate =(elisp) Displaying Buffers=).
Information can also be found at all times via =C-h f display-buffer= and,
for my particular settings, with =C-h f display-buffer-in-side-window=.

With regard to the key bindings you will find here, most combinations
are complementary to the standard ones, such as =C-x 1= being aliased as
=s-1=, =C-x o= turning into =s-o= and the like.  They *do not replace* the
defaults: they just provide more convenient access to their
corresponding functions.  Some involve the Super key, in accordance with
the norms described in the relevant [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][note on the matter]].  Concerning the
=balance-windows-area= I find that it is less intrusive than the original
=balance-windows= normally bound to the same =C-x +=.  Lastly, the
=resize-window-repeat-map= is for repeatable key chords that work with the
=repeat-mode= for Emacs28 (read my description of what it is and how to
set it up: [[#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0][Repeatable key chords (repeat-mode)]]).

Make sure to also review the other window-related keys in those
sections:

+ [[#h:6b4f7792-6ccd-45d5-b262-01d200639072][Window history (winner-mode)]].
+ [[#h:230d96c8-a955-4b82-844d-9de9a1b7c531][Directional window motions (windmove)]].

For a demo of the =display-buffer-alist= and the functions that
accompany it, watch my [[https://protesilaos.com/codelog/2020-01-07-emacs-display-buffer/][video on rules for buffer placement]]
(2020-01-07).

#+begin_src emacs-lisp :tangle no
;;; Window rules and basic tweaks (window.el)
(use-package window
  :config
  (setq display-buffer-alist
        `(;; no window
          ("\\`\\*Async Shell Command\\*\\'"
           (display-buffer-no-window))
          ;; top side window
          ("\\**prot-elfeed-bongo-queue.*"
           (display-buffer-reuse-window display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -2))
          ("\\*\\(prot-elfeed-mpv-output\\|world-clock\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . -1))
          ("\\*\\(Flymake diagnostics\\|Package-Lint\\).*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 0))
          ("\\*Messages.*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 1))
          ("\\*\\(Backtrace\\|Warnings\\|Compile-Log\\|Flymake log\\)\\*"
           (display-buffer-in-side-window)
           (window-height . 0.16)
           (side . top)
           (slot . 2))
          ;; left side window
          ("\\*\\(.* # Help.*\\|Help\\)\\*"    ; See the hooks for `visual-line-mode'
           (display-buffer-reuse-mode-window display-buffer-in-side-window)
           (window-width . 0.25)
           (side . left)
           (slot . 0))
          ;; right side window
          ("\\*keycast\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (window-width . 0.25)
           (side . right)
           (slot . -1)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; bottom side window
          ("\\*Org Select\\*"
           (display-buffer-in-side-window)
           (dedicated . t)
           (side . bottom)
           (slot . 0)
           (window-parameters . ((mode-line-format . none))))
          ;; bottom buffer (NOT side window)
          ("\\*Embark Actions\\*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom)
           (window-height . fit-window-to-buffer)
           (window-parameters . ((no-other-window . t)
                                 (mode-line-format . none))))
          ;; ("\\*\\(Embark\\)?.*Completions.*"
          ;;  (display-buffer-reuse-mode-window display-buffer-at-bottom)
          ;;  (window-parameters . ((no-other-window . t))))
          ("\\*\\(Output\\|Register Preview\\).*"
           (display-buffer-reuse-mode-window display-buffer-at-bottom))
          ;; below current window
          ("\\*.*\\(e?shell\\|v?term\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected))
          ("\\*\\vc-\\(incoming\\|outgoing\\|git : \\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           ;; NOTE 2021-10-06: we cannot `fit-window-to-buffer' because
           ;; the height is not known in advance.
           (window-height . 0.2))
          ("\\*\\(Calendar\\|Bookmark Annotation\\).*"
           (display-buffer-reuse-mode-window display-buffer-below-selected)
           (window-height . fit-window-to-buffer))))
  (setq window-combination-resize t)
  (setq even-window-sizes 'height-only)
  (setq window-sides-vertical nil)
  (setq switch-to-buffer-in-dedicated-window 'pop)

  (add-hook 'help-mode-hook #'visual-line-mode)
  (add-hook 'custom-mode-hook #'visual-line-mode)

  (let ((map global-map))
    (define-key map (kbd "C-x <down>") #'next-buffer)
    (define-key map (kbd "C-x <up>") #'previous-buffer)
    (define-key map (kbd "C-x C-n") #'next-buffer)     ; override `set-goal-column'
    (define-key map (kbd "C-x C-p") #'previous-buffer) ; override `mark-page'
    (define-key map (kbd "C-x !") #'delete-other-windows-vertically)
    (define-key map (kbd "C-x _") #'balance-windows)      ; underscore
    (define-key map (kbd "C-x -") #'fit-window-to-buffer) ; hyphen
    (define-key map (kbd "C-x +") #'balance-windows-area)
    (define-key map (kbd "C-x }") #'enlarge-window)
    (define-key map (kbd "C-x {") #'shrink-window)
    (define-key map (kbd "C-x >") #'enlarge-window-horizontally) ; override `scroll-right'
    (define-key map (kbd "C-x <") #'shrink-window-horizontally)) ; override `scroll-left'
  (let ((map resize-window-repeat-map))
    (define-key map ">" #'enlarge-window-horizontally)
    (define-key map "<" #'shrink-window-horizontally)))
#+end_src

*** Directional window motions (windmove)
:PROPERTIES:
:CUSTOM_ID: h:230d96c8-a955-4b82-844d-9de9a1b7c531
:END:

Windmove is also built into Emacs.  It provides functions for selecting
a window in any of the cardinal directions: a decent addition to the
simpler =other-window= command (=C-x o= by default).  It also has commands
for deleting a window in the given direction as well as for switching
the current window with the one in the given direction.  I do not need
the directional deletion motions, as they require extra key bindings
while I feel that it is easy enough to select a window and delete it
outright with =delete-window= (on =C-x 0= by default).

The =windmove-create-window= variable specifies what should happen when
trying to move past the edge of the frame.  The idea with this is to
allow it to create a new window with the contents of the current buffer.
I tried it for a while but felt that the times it would interfere with
my layout by mistake where more than those it would actually speed up my
workflow.

Also read: [[#h:6b4f7792-6ccd-45d5-b262-01d200639072][Window history (winner-mode)]].

#+begin_src emacs-lisp :tangle no
;;; Directional window motions (windmove)
(use-package windmove
  :config
  (setq windmove-create-window nil)     ; Emacs 27.1
  (let ((map global-map))
    ;; Those override some commands that are already available with
    ;; C-M-u, C-M-f, C-M-b.
    (define-key map (kbd "C-M-<up>") #'windmove-up)
    (define-key map (kbd "C-M-<right>") #'windmove-right)
    (define-key map (kbd "C-M-<down>") #'windmove-down)
    (define-key map (kbd "C-M-<left>") #'windmove-left)
    (define-key map (kbd "C-M-S-<up>") #'windmove-swap-states-up)
    (define-key map (kbd "C-M-S-<right>") #'windmove-swap-states-right) ; conflicts with `org-increase-number-at-point'
    (define-key map (kbd "C-M-S-<down>") #'windmove-swap-states-down)
    (define-key map (kbd "C-M-S-<left>") #'windmove-swap-states-left)))
#+end_src

#+RESULTS:
: t

*** Transposition and rotation of windows
:PROPERTIES:
:CUSTOM_ID: h:753ea060-57e4-4dba-9bf9-b6337e478839
:END:

The =transpose-frame= library defines a set of commands for shifting the
layout of Emacs windows.  Rather than me describing how these work, I
strongly encourage you to read the "Commentary" section in the source
code.  Do it with =M-x find-library transpose-frame=.

Remember that you can always repeat a command with =C-x z=.  And if you
have the right settings, you can repeat again just by pressing another =z=
(see [[#h:33d9a35a-54ed-4f9d-8f30-5c99c1a45ad0][Repeatable key chords (repeat-mode)]]).

#+begin_src emacs-lisp :tangle no
;;; Transposition and rotation of windows
(use-package transpose-frame
  :config
  (let ((map global-map))
    (define-key map (kbd "C-x M-r") #'rotate-frame-clockwise)))
#+end_src
** tab bar mode
#+begin_src emacs-lisp
;; Inherit the face of `doom-modeline-panel` for better appearance
(set-face-attribute 'tab-bar-tab nil :inherit 'doom-modeline-panel :foreground nil :background nil)

;; Totally customize the format of the tab bar name
(defun my/tab-bar-format (tab i)
  (propertize
   (format
    (concat
      (if (eq (car tab) 'current-tab)
          "🔥 " "")
      "%s")
    (alist-get 'name tab))
   'face (list (append
                  '(:foreground "#FFFFFF")
                  (if (eq (car tab) 'current-tab)
                      '(:box t)
                      '())))))

;; Replace the default tab bar function
(setq tab-bar-tab-name-format-function #'my/tab-bar-format)

(defun my/tab-bar-tab-name-function ()
  (let ((project (project-current)))
    (if project
        (project-root project)
        (tab-bar-tab-name-current))))

(setq tab-bar-tab-name-function #'my/tab-bar-tab-name-function)

;; Only show the tab bar if there are 2 or more tabs
(setq tab-bar-show 1)

(defun my/tab-bar-string () "HELLO")

;; Customize the tab bar format to add the global mode line string
(setq tab-bar-format '(tab-bar-format-tabs tab-bar-separator tab-bar-format-align-right tab-bar-format-global))

(add-to-list 'global-mode-string "HELLO")

;; Make sure mode line text in the tab bar can be read
(set-face-attribute 'tab-bar nil :foreground "#FFFFFF")

(defun my/project-create-tab ()
  (interactive)
  (tab-bar-new-tab)
  (magit-status))

(setq project-switch-commands #'my/project-create-tab)

(defun my/switch-to-tab-buffer ()
  (interactive)
  (if (project-current)
      (call-interactively #'project-switch-to-buffer)
    (call-interactively #'switch-to-buffer)))

(global-set-key (kbd "C-x b") #'my/switch-to-tab-buffer)

;; Turn on tab bar mode after startup
;; (tab-bar-mode 1)

;; Save the desktop session
(desktop-save-mode 1)

#+end_src

** Rotate (window management)
The =rotate= package just adds the ability to rotate window layouts, but that
sounds nice to me.

#+begin_src emacs-lisp :tangle packages.el
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src

** Shackle
Shackle is an easy way to customise the display rules for windows rather than messing up with display-buffer-alist.

#+begin_src emacs-lisp :tangle no
(use-package shackle
  :custom
  ((shackle-rules
    (let ((repls "\\*\\(cider-repl\\|sly-mrepl\\|ielm\\)")
          (godot "\\*godot - .*\\*")
          (vcs   "\\*\\(Flymake\\|Package-Lint\\|vc-\\(git\\|got\\) :\\).*")
          (elfeed "\\*elfeed-entry\\*")
          (vmd    "\\*vmd console .*"))
      `((compilation-mode :noselect t
                          :align above
                          :size 0.2)
        ("*Async Shell Command*" :ignore t)
        (,repls :regexp t
                :align below
                :size 0.3)
        (,godot :regexp t
                :align t
                :size 0.3)
        (occur-mode :select t
                    :align right
                    :size 0.3)
        (diff-mode :select t)
        (help-mode :select t
                   :align left
                   :size 0.3)
        (,vcs :regexp t
              :align above
              :size 0.15
              :select t)
        (,elfeed :regexp t
                 :align t
                 :select t
                 :size 0.75)
        (,vmd :regexp t
              :align below
              :select t
              :size 0.3))))
   (shackle-default-rule nil ; '(:inhibit-window-quit t)
                         ))
  :config (shackle-mode))
#+end_src

#+RESULTS:
: t

** Window placement
#+begin_src emacs-lisp :tangle no
(use-package window
  ;; :straight nil
  :bind (("C-x +" . balance-windows-area))
  :custom
  ((window-combination-resize t)
   (even-window-sizes 'heigth-only)
   (window-sides-vertical nil)
   (switch-to-buffer-in-dedicated-window 'pop)
   (split-height-threshold 160)
   (split-width-threshold 110)
   (split-window-preferred-function #'op/split-window-sensibly))
  :config
  (defun op/split-window-prefer-horizontal (&optional window)
    "Based on `split-window-sensibly', but designed to prefer a horizontal split.
It prefers windows tiled side-by-side.  Taken from
emacs.stackexchange.com.  Optional argument WINDOW is the current
window."
    (let ((window (or window (select-window))))
      (or (and (window-splittable-p window t)
               ;; split window horizontally
               (with-selected-window window
                 (split-window-right))))
      (and (window-splittable-p window)
           ;; split window vertically
           (with-selected-window window
             (split-window-below)))
      (and
       ;; if window is the only usable window on its frame and is not
       ;; the minibuffer window, try to split it horizontally
       ;; disregarding the value of `split-height-threshold'.
       (let ((frame (window-frame window)))
         (or (eq window (frame-root-window frame))
             (catch 'done
               (walk-window-tree (lambda (w)
                                   (unless (or (eq w window)
                                               (window-dedicated-p w))
                                     (throw 'done nil)))
                                 frame)
               t)))
       (not (window-minibuffer-p window))
       (let ((split-width-threshold 0))
         (when (window-splittable-p window t)
           (with-selected-window window
             (split-window-right)))))))

  (defun op/split-window-sensibly (&optional window)
    "Splitting window function.
Intended to use as `split-window-preferred-function'.  Also taken
from stackexchange with edits.  Optional argument WINDOW is the
window."
    (let ((window (or window (selected-window))))
      (with-selected-window window
        (if (> (window-total-width window)
               (* 2 (window-total-width window)))
            (op/split-window-sensibly window)
          (split-window-sensibly window))))))
#+end_src

#+RESULTS:
: balance-windows-area

** Transpose Frame
transpose-frame provides various function to change the window layout in the current frame. Since my memory is pretty limited, an hydra is needed.

#+begin_src emacs-lisp :tangle no
(use-package transpose-frame
  :bind ("C-c a" . my/hydra-window/body)
  :commands (transpose-frame flip-frame flop-frame
                             rotate-frame rotate-frame-clockwise
                             rotate-frame-anti-anticlockwise)
  :config
  (defhydra hydra-window (:hint nil)
    "
^File/Buffer^      ^Movements^        ^Misc^              ^Transpose^
^^^^^^^^------------------------------------------------------------------------------
_b_ switch buffer  ^ ^ hjkl           _0_   delete        _t_     transpose frame
_f_ find file      _o_ other window   _1_   delete other  _M-f_   flip frame
_s_ save conf      _O_ OTHER window   _2_   split below   _M-C-f_ flop frame
_r_ reload conf    ^ ^                _3_   split right   _M-s_   rotate frame
^ ^                ^ ^                _SPC_ balance       _M-r_   rotate clockw.
^^^^-------------------------------   _v_   split horiz.  _M-C-r_ rotate anti clockw.
_?_ toggle help    ^ ^                _-_   split vert.
^ ^                ^ ^                _C-l_ recenter line
"
    ("?" (hydra-set-property 'hydra-window :verbosity
                             (if (= (hydra-get-property 'hydra-window :verbosity) 1)
                                 0 1)))

    ("b" switch-to-buffer)
    ("f" (call-interactively #'find-file))

    ("s" window-configuration-to-register)
    ("r" jump-to-register)

    ("k" windmove-up)
    ("j" windmove-down)
    ("h" windmove-left)
    ("l" windmove-right)

    ("o" (other-window 1))
    ("O" (other-window -1))

    ("C-l" recenter-top-bottom)

    ("0" delete-window)
    ("1" delete-other-windows)
    ("2" split-window-below)
    ("3" split-window-right)

    ;; v is like a |, no?
    ("v" split-window-horizontally)
    ("-" split-window-vertically)

    ("SPC" balance-windows)

    ("t" transpose-frame)
    ("M-f" flip-frame)
    ("M-C-f" flop-frame)
    ("M-s" rotate-frame)
    ("M-r" rotate-frame-clockwise)
    ("M-C-r" rotate-frame-anti-anticlockwise)

    ("q" nil :exit nil)
    ("RET" nil :exit nil)
    ("C-g" nil :exit nil))

  (defun my/hydra-window/body ()
    (interactive)
    (hydra-set-property 'hydra-window :verbosity 0)
    (hydra-window/body)))
#+end_src

#+RESULTS:
: my/hydra-window/body

** Transpose Frame

This is an idea that I stole from prot' dotemacs. It augments the various transpose-* commands so they respect the region: if (use-region-p) then transpose the thing at the extremes of the region, otherwise operates as usual.

(the code is somewhat different from prot, but the idea is the same)

#+begin_src emacs-lisp :tangle no
(defmacro op/deftranspose (name scope key doc)
  "Macro to produce transposition functions.
NAME is the function's symbol.  SCOPE is the text object to
operate on.  Optional DOC is the function's docstring.

Transposition over an active region will swap the object at
mark (region beginning) with the one at point (region end).

It can optionally define a key for the defined function in the
`global-map' if KEY is passed.

Originally from protesilaos' dotemacs."
  (declare (indent defun))
  `(progn
     (defun ,name (arg)
       ,doc
       (interactive "p")
       (let ((x (intern (format "transpose-%s" ,scope))))
         (if (use-region-p)
             (funcall x 0)
           (funcall x arg))))
     ,(when key
        `(define-key global-map (kbd ,key) #',name))))

(op/deftranspose op/transpose-lines "lines" "C-x C-t"
  "Transpose lines or swap over active region.")

(op/deftranspose op/transpose-paragraphs "paragraphs" "C-S-t"
  "Transpose paragraph or swap over active region.")

(op/deftranspose op/transpose-sentences "sentences" "C-x M-t"
  "Transpose sentences or swap over active region.")

(op/deftranspose op/transpose-sexps "sexps" "C-M-t"
  "Transpose sexps or swap over active region.")

(op/deftranspose op/transpose-words "words" "M-t"
  "Transpose words or swap over active region.")
;; A command I have to try to use more is transpose-regions

(define-key global-map (kbd "C-x C-M-t") #'transpose-regions)

#+end_src

#+RESULTS:
: transpose-regions
** Side Window
Side windows are an interesting concept. Emacs reserve an optional space at the top, bottom, left and right of the frame for these side windows. You can think of them as a dockable space, akin to the panels in IDEs.

I'm finding useful to keep an IRC buffer at the bottom of the frame, to avoid jumping from the "code" frame to the "chat" frame or switch buffers continuously.

The following functions helps achieve this:

#+begin_src emacs-lisp
(defun op/buffer-to-side-window (place)
  "Place the current buffer in the side window at PLACE."
  (interactive (list (intern
                      (completing-read "Which side: "
                                       '(top left right bottom)))))
  (let ((buf (current-buffer)))
    (display-buffer-in-side-window
     buf `((window-height . 0.15)
           (side . ,place)
           (slot . -1)
           (window-parameters . ((no-delete-other-windows . t)
                                 (no-other-window t)))))
    (delete-window)))
#+end_src

#+RESULTS:
: op/buffer-to-side-window

** all in one setup
#+begin_src emacs-lisp

;; (load "better-buffers")
;; (load "setup-ibuffer")

;; * WINDOW MANAGEMENT
;;;################################################################

;;;----------------------------------------------------------------
;; ** +SHACKLE+
;;;----------------------------------------------------------------

;; Wasamasa's Shackle package simplifies Emacs' rather arcane display-buffer
;; rules so you don't have to tear your hair out understanding how to configure
;; it. Unfortunately I did, see [[*SETUP-WINDOWS][setup-windows]].
;; (use-package shackle
;;   :disabled t
;;   :init (shackle-mode))

;;;----------------------------------------------------------------
;; ** SETUP-WINDOWS
;;;----------------------------------------------------------------

;; Setup-windows defines window rules for displaying various kinds of buffers.
(load "setup-windows")
(use-package setup-windows
  :demand t
  :hook ((help-mode . visual-line-mode)
         (Custom-mode . visual-line-mode)
         (helpful-mode . visual-line-mode))
  ;; :bind (;; ("C-x +" . balance-windows-area)
  ;;        ("<f8>" . +make-frame-floating-with-current-buffer)
  ;;        ("C-M-`" . window-toggle-side-windows))
  :bind
  ("<f9>" . +make-frame-floating-with-current-buffer)
  ;; "C-M-`" 'window-toggle-side-windows
  :general
  (:keymaps 'space-menu-window-map
            :wk-full-keys nil
            "w" '(window-toggle-side-windows :wk "toggle side windows")))

(use-package window
  :bind (("H-+" . balance-windows-area)
         ("C-x +" . balance-windows-area)
         ("C-x q" . my/kill-buffer-and-window))
  :config
  (defun my/kill-buffer-and-window ()
    "Kill buffer.

Also kill this window, tab or frame if necessary."
    (interactive)
    (cl-letf ((symbol-function 'delete-window)
              (symbol-function 'my/delete-window-or-delete-frame))
      (kill-buffer-and-window))))

;; setup-windows:
;; #+INCLUDE: "./lisp/setup-windows.org" :minlevel 2

;;;----------------------------------------------------------------
;; ** POPUPS
;;;----------------------------------------------------------------

;; Designate buffers to popup status and toggle or cycle through them
(use-package popper
  :after (setup-windows setup-project)
  :commands popper-mode
  :bind (("C-`" . popper-toggle-latest)
         ("C-M-`" . popper-cycle)
         ("H-`" . popper-toggle-latest)
         ("H-M-`" . popper-cycle)
         ("H-6" . popper-toggle-type)
         ("H-M-k" . popper-kill-latest-popup))
  :init
  (setq popper-group-function
        (defun my/popper-group-by-heuristic ()
          "Group popups according to heuristic rules suitable for
          my usage."
          (let ((dd (abbreviate-file-name default-directory)))
            (cond
             ((string-match-p "\\(?:~/\\.config/\\|~/dotfiles/\\)" dd)
              'config)
             ((or (string-match-p "local/share/git" dd)
                  (string-match-p "plugins/" dd))
              'projects)
             ((string-match-p "\\(?:KarthikBa\\|research/\\)" dd)
              'research)
             ((string-match-p "karthinks" dd) 'website)
             ((locate-dominating-file dd "research") 'documents)
             ((locate-dominating-file dd "init.el") 'emacs)
             (t (popper-group-by-project))))))
  (setq ;; popper-mode-line nil
        popper-reference-buffers
        (append my/help-modes-list
                my/repl-modes-list
                my/occur-grep-modes-list
                ;; my/man-modes-list
                '(Custom-mode
                  (compilation-mode . hide)
                  messages-buffer-mode)
                '(("^\\*Warnings\\*$" . hide)
                  ("^\\*Compile-Log\\*$" . hide)
                  "^\\*Matlab Help\\*"
                  ;; "^\\*Messages\\*$"
                  "^\\*Backtrace\\*"
                  "^\\*evil-registers\\*"
                  "^\\*Apropos"
                  "^Calc:"
                  "^\\*eldoc\\*"
                  "^\\*TeX errors\\*"
                  "^\\*ielm\\*"
                  "^\\*TeX Help\\*"
                  "\\*Shell Command Output\\*"
                  ("\\*Async Shell Command\\*" . hide)
                  "\\*Completions\\*"
                  ;; "\\*scratch\\*"
                  "[Oo]utput\\*")))

  (use-package popper-echo
    :config
    (defun popper-message-shorten (name)
      (cond
       ((string-match "^\\*[hH]elpful.*?: \\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                "(H)"))
       ((string-match "^\\*Help:?\\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                "(H)"))
       ((string-match "^\\*eshell:? ?\\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                (if (string-empty-p (match-string 1 name)) "shell(E)" "(E)")))
       ((string-match "^\\*\\(.*?\\)\\(?:Output\\|Command\\)\\*$" name)
        (concat (match-string 1 name)
                "(O)"))
       ((string-match "^\\*\\(.*?\\)[ -][Ll]og\\*$" name)
        (concat (match-string 1 name)
                "(L)"))
       ((string-match "^\\*[Cc]ompil\\(?:e\\|ation\\)\\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                "(C)"))
       (t name)))
    (setq popper-echo-transform-function #'popper-message-shorten)
    (setq popper-echo-dispatch-keys '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9)
          popper-echo-dispatch-actions t)
    (advice-add 'popper-echo :around
                (defun my/popper-echo-no-which-key (orig-fn)
                  (let ((which-key-show-transient-maps nil))
                    (funcall orig-fn))))
    (popper-echo-mode +1))

  :config
  (setq popper-display-control 'user)
  (defun my/popup-raise-popup ()
    "Choose a popup-window to raise as a regular window"
    (interactive)
    (popper-raise-popup
     (completing-read "Raise popup: "
                      (mapcar (lambda (win-and-buf) (buffer-name (cdr win-and-buf)))
                              (cl-mapcan (lambda (group) )
                                         (append popper-open-popup-alist
                                                popper-buried-popup-alist)))
                      nil t)))

  (defun my/popup-lower-to-popup ()
    "Choose a regular window to make a popup"
    (interactive)
    (let ((window-list (cl-set-difference
                        (window-list)
                        (mapcar 'car popper-open-popup-alist))))
      (if (< (length window-list) 2)
          (message "Only one main window!")
        (popper-lower-to-popup
         (get-buffer
          (completing-read "Lower to popup: "
                           (mapcar (lambda (win) (buffer-name (window-buffer win)))
                                   window-list)
                           nil t))))))
  :general
  (:states 'motion
           "C-w ^" '(popper-raise-popup :wk "raise popup")
           "C-w _" '(popper-lower-to-popup :wk "lower to popup"))
  (:keymaps 'space-menu-window-map
            "^" '(my/popup-raise-popup :wk "raise popup")
            "_" '(my/popup-lower-to-popup :wk "lower to popup")))

;;----------------------------------------------------------------
;; ** WINUM
;;----------------------------------------------------------------

;; Add window numbers and use them to switch windows
;; (use-package winum
;;   :ensure
;;   :init
;;   (defun my/winum-select (num)
;;     (lambda (&optional arg) (interactive "P")
;;       (if arg
;;           (winum-select-window-by-number (- 0 num))
;;         (if (equal num (winum-get-number))
;;             (winum-select-window-by-number (winum-get-number (get-mru-window t)))
;;           (winum-select-window-by-number num)))))

;;   (setq winum-keymap
;;         (let ((map (make-sparse-keymap)))
;;           (define-key map (kbd "C-M-0") 'winum-select-window-0-or-10)
;;           (dolist (num '(1 2 3 4 5 6 7 8 9) nil)
;;             (define-key map (kbd (concat "C-M-" (int-to-string num)))
;;               (my/winum-select num)))
;;           map))

  ;; If evil-mode is enabled further mode-line customization is needed before
  ;; enabling winum:
  ;; (unless (bound-and-true-p evil-mode)
  ;;   (winum-mode 1)))

;;----------------------------------------------------------------
;; ** +WINNER+
;;----------------------------------------------------------------

;; Winner mode is disabled in favor of =tab-bar-history-mode=, which does the
;; same but with a separate window configuration history for each tab. This is
;; usually what I want.
(use-package winner
  :disabled
  :commands winner-undo
  :bind (("C-c <left>" . winner-undo)
         ("C-x C-/" . winner-undo)
         ("H-/" . winner-undo)
         ("s-u" . winner-undo))
  :general
  (:keymaps 'space-menu-window-map
            :wk-full-keys nil
            "u" 'winner-undo
            "r" 'winner-redo)
  :config
  (winner-mode +1))

;;----------------------------------------------------------------
;; ** Ace-window
;;----------------------------------------------------------------

;; (use-package ace-window
;;   :ensure t
;;   :bind
;;   (("C-x o" . ace-window)
;;    ("H-o"   . ace-window)
;;    ("M-o" . other-window)
;;    ("M-O" . my/other-window-prev))
;;   :general
;;   (:keymaps 'space-menu-map
;;             "`" 'ace-window)
;;   ;; :custom-face
;;   ;; (aw-leading-char-face ((t (:height 2.5 :weight normal))))
;;   :config
;;   (setq aw-dispatch-always t
;;         aw-scope 'global
;;         aw-background nil
;;         aw-keys '(?q ?w ?e ?r ?t ?y ?u ?i ?p))
;;   (setq aw-dispatch-alist
;;         '((?k aw-delete-window "Delete Window")
;;           (?m aw-swap-window "Swap Windows")
;;           (?M aw-move-window "Move Window")
;;           (?c aw-copy-window "Copy Window")
;;           (?j aw-switch-buffer-in-window "Select Buffer")
;;           (?\t aw-flip-window)
;;           (?b aw-switch-buffer-other-window "Switch Buffer Other Window")
;;           (?c aw-split-window-fair "Split Fair Window")
;;           (?s aw-split-window-vert "Split Vert Window")
;;           (?v aw-split-window-horz "Split Horz Window")
;;           (?o delete-other-windows "Delete Other Windows")
;;           (?? aw-show-dispatch-help)))
;;   (defun my/other-window-prev (&optional arg all-frames)
;;     (interactive "p")
;;     (other-window (if arg (- arg) -1) all-frames)))

;; (use-package emacs
;;   :config
;;   (defun my/enlarge-window-horizontally (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame width."
;;     (interactive "p")
;;     (enlarge-window-horizontally (* (or repeat 1)
;;                                     (floor (frame-width) 20))))
;;   (defun my/shrink-window-horizontally (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame width."
;;     (interactive "p")
;;     (shrink-window-horizontally (* (or repeat 1)
;;                                    (floor (frame-width) 20))))
;;   (defun my/shrink-window (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame height."
;;     (interactive "p")
;;     (shrink-window (* (or repeat 1)
;;                       (floor (frame-height) 20))))
;;   (defun my/enlarge-window (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame height."
;;     (interactive "p")
;;     (enlarge-window (* (or repeat 1)
;;                        (floor (frame-height) 20))))
;;   :bind
;;   (("<C-S-right>" . my/enlarge-window-horizontally)
;;    ("<C-S-left>"  . my/shrink-window-horizontally)
;;    ("<C-S-up>"    . my/enlarge-window)
;;    ("<C-S-down>"  . my/shrink-window)))

;;----------------------------------------------------------------
;; ** Windmove
;;----------------------------------------------------------------

(use-package windmove
  :bind
  (("H-<right>" . windmove-swap-states-right)
   ("H-<down>" . windmove-swap-states-down)
   ("H-<up>" . windmove-swap-states-up)
   ("H-<left>" . windmove-swap-states-left)))
  ;; :config
  ;; (use-package emacs-i3))

;;----------------------------------------------------------------
;; ** Transpose-frame
;;----------------------------------------------------------------

(use-package transpose-frame
  :ensure t
  :bind (("H-\\" . rotate-frame-anticlockwise)
         :map ctl-x-4-map
         ("|" . flop-frame)
         ("_" . flip-frame)
         ("\\" . rotate-frame-anticlockwise)))

;;----------------------------------------------------------------
;; ** Auto-revert
;;----------------------------------------------------------------

(use-package autorevert
  :hook ((prog-mode
          text-mode
          tex-mode
          org-mode
          conf-mode) . auto-revert-mode))

;;----------------------------------------------------------------
;; ** Re-Builder
;;----------------------------------------------------------------
(use-package re-builder
  :bind (("C-M-5" . re-builder)
         ("C-M-%" . re-builder)
         :map reb-mode-map
         ("C-c C-k" . reb-quit)
         ("RET" . reb-replace-regexp)
         :map reb-lisp-mode-map
         ("RET" . reb-replace-regexp))
  :config
  ;; reb-fix modifies reb-update-overlays to restrict matches to region
  (load "reb-fix")
  (use-package reb-fix)
  (defvar my/re-builder-positions nil
    "Store point and region bounds before calling re-builder")
  (advice-add 're-builder
              :before
              (defun my/re-builder-save-state (&rest _)
                "Save into `my/re-builder-positions' the point and region
positions before calling `re-builder'."
                (setq my/re-builder-positions
                      (cons (point)
                            (when (region-active-p)
                              (list (region-beginning)
                                    (region-end)))))))
  (defun reb-replace-regexp (&optional delimited)
  "Run `query-replace-regexp' with the contents of re-builder. With
non-nil optional argument DELIMITED, only replace matches
surrounded by word boundaries."
  (interactive "P")
  (reb-update-regexp)
  (let* ((re (reb-target-binding reb-regexp))
         (replacement (query-replace-read-to
                       re
                       (concat "Query replace"
		               (if current-prefix-arg
		                   (if (eq current-prefix-arg '-) " backward" " word")
		                 "")
		               " regexp"
		               (if (with-selected-window reb-target-window
                                     (region-active-p)) " in region" ""))
                       t))
         (pnt (car my/re-builder-positions))
         (beg (cadr my/re-builder-positions))
         (end (caddr my/re-builder-positions)))
    (with-selected-window reb-target-window
      (goto-char pnt)
      (setq my/re-builder-positions nil)
      (reb-quit)
      (query-replace-regexp re replacement delimited beg end)))))

#+end_src

#+RESULTS:
: reb-replace-regexp

** Edwina
#+begin_src emacs-lisp :tangle no
(use-package edwina
  :ensure t
  :config
  (setq display-buffer-base-action '(display-buffer-below-selected))
  ;; (edwina-setup-dwm-keys)
  (edwina-mode 1))

#+end_src

#+RESULTS:
: t
** transient
#+begin_src emacs-lisp :tangle no

(use-package transient
  :defines toggle-modes
  :bind (("<f8>"  . toggle-modes)
         ("C-c t" . toggle-modes))
  :config
  (transient-bind-q-to-quit)
  (setq transient-display-buffer-action '(display-buffer-below-selected))
  (setq transient-history-file (dir-concat user-cache-directory "transient/history.el")
        transient-levels-file (dir-concat user-cache-directory "transient/levels.el")
        transient-values-file (dir-concat user-cache-directory "transient/values.el"))
  (transient-define-prefix toggle-modes ()
    "Turn on and off various frequently used modes."

    [:pad-keys t
     ["Appearance"
      ("t" "color theme" my/toggle-theme)
      ("B" "BIG mode"    presentation-mode)
      ;; ("M" "smart modeline" ignore)
      ("8" "pretty symbols" (lambda () (interactive)
                              (if (derived-mode-p 'org-mode)
                                  (org-toggle-pretty-entities)
                                (call-interactively
                                 #'prettify-symbols-mode))))
      ("vl" "visual lines" visual-line-mode)
      ("vt" "trunc lines" toggle-truncate-lines)]

     ["Editing"
      ("r" "read only" read-only-mode)
      ("n" "line numbers" display-line-numbers-mode)
      ("M-q" "auto fill" auto-fill-mode)
      (";" "flyspell" (lambda ()
                        (interactive)
                        (call-interactively
                         (if (derived-mode-p 'prog-mode)
                             #'flyspell-prog-mode
                           #'flyspell-mode))))
      ("V" "view mode" view-mode)
      ("o" "outline" outline-minor-mode)]

     ["Highlight"
      ("hl" "line" hl-line-mode)
      ("hp" "paren" show-paren-mode)
      ("hw" "whitespace" whitespace-mode)
      ("hd" "delimiters" rainbow-delimiters-mode)
      ("hr" "rainbow" rainbow-mode)]

     ["Code"
      ("c" "completion" corfu-mode)
      ("a" "autocomp" (lambda () (interactive)
                        (setq-local corfu-auto (not corfu-auto))
                        (message "corfu-auto is now %s" corfu-auto))
       :transient t)
      ;; ("a"
      ;;  :description "autocomp?"
      ;;  :class transient-lisp-variable
      ;;  :variable corfu-auto
      ;;  :reader (lambda () (interactive)
      ;;            (setq corfu-auto
      ;;                  (not corfu-auto))))
      ("g" "vc gutter" diff-hl-mode)
      ("f" "flymake" flymake-mode)
      ("e" "elec pair" electric-pair-mode)
      ("p" "smartparens" smartparens-mode)]]))
#+end_src

** Pop-win
#+begin_src emacs-lisp :tangle no
(use-package popwin
  ;; :ensure t
  :config
  (popwin-mode 1)
  (setq popwin:popup-window-height 35
        popwin:special-display-config
        '(("*Miniedit Help*" :noselect t)
          (help-mode :noselect nil)
          (completion-list-mode :noselect t)
          (compilation-mode :noselect nil)
          (grep-mode :noselect t)
          (occur-mode :noselect t)
          ("*Pp Macroexpand Output*" :noselect t)
          ("*Shell Command Output*")
          ("*Async Shell Command*")
          ("*vc-diff*")
          ("*vc-change-log*")
          (" *undo-tree*" :width 60 :position left)
          ("^\\*anything.*\\*$" :regexp t)
          ("*slime-apropos*")
          ("*slime-macroexpansion*")
          ("*slime-description*")
          ("*slime-compilation*" :noselect t)
          ("*slime-xref*")
          ("*Flycheck errors*")
          ("*Warnings*")
          ("*Error*")
          ("*Process List*")
          ("*Smex: Unbound Commands*")
          ("*Paradox Report*" :noselect nil)
          ("*Package Commit List*" :noselect nil)
          ("*Diff*" :noselect nil)
          ("*Messages*" :noselect nil)
          ("*Google Maps*" :noselect nil)
          ("*ag search*" :noselect nil)
          ("*PDF-Occur*" :noselect nil)
          ("*PDF-Metadata*" :noselect nil)
          ("^\\*Outline .*\\.pdf\\*$" :regexp t :noselect nil)
          ("*MULTI-TERM-DEDICATED*" :noselect nil :stick t)
          (sldb-mode :stick t)
          (slime-repl-mode)
          (slime-connection-list-mode)))

  (add-hook 'popwin:after-popup-hook 'turn-off-evil-mode)
  (bind-keys :map popwin:window-map
             ((kbd "<escape>") . popwin:close-popup-window)))
#+end_src

#+RESULTS:
: t

* General interface and interactions
This section contains configurations for all aspects of the Emacs user
interface, as well lots of small or self-contained tweaks that cover a
wide range of built-in libraries.

** Go to last change
:PROPERTIES:
:CUSTOM_ID: h:ac889a76-1092-449e-a184-9092093f3103
:END:

I could not find any built-in method of /reliably/ moving back to the
last change.  Using the mark ring is always an option, but does not fill
the exact same niche.

The =C-z= binding is [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][disabled elsewhere in this document]].  It minimises
the Emacs GUI by default.  A complete waste of an extremely valuable key
binding!

Already included in doom emacs
#+begin_src emacs-lisp :tangle no
;;; Go to last change
(prot-emacs-elpa-package 'goto-last-change
  (define-key global-map (kbd "C-z") #'goto-last-change))
#+end_src

** Window divider mode
:PROPERTIES:
:CUSTOM_ID: h:6fb900e3-49db-4bc3-8a9e-cd88e020f15b
:END:

This is a built-in mode that can draw both vertical and horizontal
borders.  It can be particularly helpful when used with windows that do
not have a modeline, such as what happens when I enable my custom
=prot-tab-status-line= on Emacs28, which moves all the relevant
information to the tab bar (in effect, it creates a universal status
line---see [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts (tab-bar.el and prot-tab.el)]]).

#+begin_src emacs-lisp :tangle no
;;; Window divider mode
(setq window-divider-default-right-width 1)
(setq window-divider-default-bottom-width 1)
(setq window-divider-default-places 'right-only)
#+end_src

#+RESULTS:
: right-only

** Fringe mode
:PROPERTIES:
:CUSTOM_ID: h:26a4fac6-33e2-4f6c-8589-9463df8525c9
:END:

The fringes are areas to the right and left side of an Emacs frame.
They can be used to show status-related or contextual feedback such as
line truncation indicators, continuation lines, code linting markers,
etc.

The default fringe width (=nil=) is 8 pixels on either side, which I
approve of.  It is possible to set the value of the =fringe-mode= to
something like ='(10 . 5)= which applies the varied width to the left and
right side respectively.  Otherwise, we can use a single integer that
controls both sides.

The use of =setq-default= is necessary, otherwise these values become
buffer-local.

#+begin_src emacs-lisp :tangle no
;;; Fringe mode
(use-package fringe
  :config
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t))
#+end_src

#+RESULTS:
: t

** Rainbow mode for colour previewing (rainbow-mode.el)
:PROPERTIES:
:CUSTOM_ID: h:9061c694-5f45-46b0-a878-6bcfb018e18d
:END:

The following package reads a colour value, such as hexadecimal RGB,
and sets the background for the value in that colour.  Quite useful
when reviewing my themes (=rainbow-mode= is activated manually).

#+begin_src emacs-lisp :tangle no
;;; Rainbow mode for colour previewing (rainbow-mode.el)
(use-package rainbow-mode
  :config
  (setq rainbow-ansi-colors nil)
  (setq rainbow-x-colors nil))
#+end_src

#+RESULTS:
: t

** Depth-based code colourisation (prism.el)
:PROPERTIES:
:CUSTOM_ID: h:6478350b-b89b-406e-9b08-2dc9e93cc5b4
:END:

Adam Porter's (aka alphapapa) =prism.el= colourises programming code based
on the level of depth, rather than targeting syntactic constructs like
keywords, strings, variables.  This can be useful when working with
highly-nested and/or unfamiliar code.  It has two modes that are
intended for specific types of programming languages:

1. =prism-mode= is good for Lisp and languages that look like C (I only
   code in Elisp);
2. =prism-whitespace-mode= is for languages that are more sensitive to
   indentation.

The degree of colouration for each level of depth is configurable, as
are the colours to be used.  Consult Prism's documentation for the
technicalities.

My =prot-prism.el= (reproduced after the following configurations)
provides a few extras that help me set the desired style of colouration.
It provides an alist of palette presets.  Those can be applied through
minibuffer completion with the command =prot-prism-set-colors=.  All the
presets are designed to extract colour values from the active Modus
theme ([[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).  Those range from a
minimalist style of drawing only four colours, to a more expansive
sixteen-colour gamout.

The =prot-prism-set-colors= command also takes care to activate the
appropriate Prism mode for languages whose major mode is declared as
"indentation-sensitive".  Those are added as a list to the variable
=prot-prism-negative-space-sensitive-modes=.

To disable the effect, just do =M-x prot-prism-disable=.

#+begin_src emacs-lisp :tangle no
;;; Depth-based code colourisation (prism.el)
(use-package prism
  (setq prism-comments 't))

(load "prot-prism")
(use-package prot-prism
  (setq prot-prism-negative-space-sensitive-modes
        '(sh-mode yaml-mode))

  (setq prot-prism-presets-function #'prot-prism--colors))
#+end_src

#+RESULTS:

** Outline mode, outline minor mode, and extras (prot-outline.el)
:PROPERTIES:
:CUSTOM_ID: h:a8e737b8-7c90-4c68-8814-acf2f637ffa1
:END:

The =outline.el= library defines a major mode (=outline-mode=) that is
similar to =org-mode= in that it consists of headings which can be
expanded or contracted individually or as a group (actually Outline
predates Org).  The major mode is meant to work with plain text files,
or be leveraged by other packages that need to have some structure and
the accompanying benefits of outline folding.  In practice, however, I
never found a dedicated use for it that would justify it over the more
featureful Org.

Where =outline.el= truly shines, in my experience, is in the minor mode it
defines (=outline-minor-mode=), which provides the familiar structured,
heading-folding facilities in other major modes, like =emacs-lisp-mode= or
any arbitrary mode, like =diff-mode= and the =diary=.

Also read:

+ [[#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9][Calendar and Diary (and prot-diary.el)]].
+ [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]].

With some careful tweaks you can continue to work on your code while
also benefitting from a more effective means of organising and reviewing
what you have.

In practice, to make an outline for Elisp buffers, you need to start a
comment line /without leading spaces/ and make it at least three comment
delimiters long (=;;;=) followed by a space and then the text of the
heading, such as =;;; Code:=.  That is considered a heading level 1.
Every extra delimiter will increase heading levels accordingly.  The
buffer-local variable =outline-regexp= determines what constitutes a
heading for this purpose.

Now on to my custom library, =prot-outline.el= which builds on those
concepts:

+ Provide several new commands and minor extras for working with
  outlines.

+ Define a =prot-outline-minor-mode-safe= command that checks whether the
  current buffer's major mode is not a member of a blocklist.  The idea
  is to not run =outline-minor-mode= with major modes that already provide
  its functionality: =org-mode=, =outline-mode=, =markdown-mode=.

Watch my [[https://protesilaos.com/codelog/2020-07-20-emacs-outline-imenu/][video demo of outline-minor-mode and imenu]] (2020-07-20), though
note that it was recorded long before I wrote =prot-outline.el=.  In
particular, older versions of my code would establish bindings for
=imenu.el=.  This was done via bespoke entry and exit hooks and was
intended to complement the standard Imenu headings with those of the
Outline.  This is no longer needed because =consult-outline= does exactly
that ([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).

A quick reminder of why this matters: you can navigate the outline using
minibuffer completion, which is my favourite way to browse a file.  You
can, in the same spirit, use Embark to produce a buffer with the
completion candidates, i.e. the headings, or a subset you have narrowed
to, and navigate therefrom.  It really is an efficient workflow:
[[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]].

#+begin_src emacs-lisp :tangle no
;;; Outline mode, outline minor mode, and extras (prot-outline.el)
(use-package outline
  :config
  (setq outline-minor-mode-highlight 'override) ; emacs28
  (setq outline-minor-mode-cycle t)             ; emacs28
  (let ((map outline-minor-mode-map))
    ;; ;; NOTE 2021-07-25: Those two are already defined (emacs28).
    ;; (define-key map (kbd "TAB") #'outline-cycle)
    ;; (define-key map (kbd "<backtab>") #'outline-cycle-buffer) ; S-TAB
    (define-key map (kbd "C-c C-n") #'outline-next-visible-heading)
    (define-key map (kbd "C-c C-p") #'outline-previous-visible-heading)
    (define-key map (kbd "C-c C-f") #'outline-forward-same-level)
    (define-key map (kbd "C-c C-b") #'outline-backward-same-level)
    (define-key map (kbd "C-c C-a") #'outline-show-all)
    (define-key map (kbd "C-c C-o") #'outline-hide-other)
    (define-key map (kbd "C-c C-u") #'outline-up-heading)))
(load "prot-outline")
(use-package prot-outline
  :config
  (let ((map outline-minor-mode-map))
    (define-key map (kbd "C-c C-v") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "M-<down>") #'prot-outline-move-major-heading-down)
    (define-key map (kbd "C-c M-v") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "M-<up>") #'prot-outline-move-major-heading-up)
    (define-key map (kbd "C-x n s") #'prot-outline-narrow-to-subtree))
  (define-key global-map (kbd "<f10>") #'prot-outline-minor-mode-safe))
#+end_src

#+RESULTS:
: t

** Cursor and mouse settings
:PROPERTIES:
:CUSTOM_ID: h:a75d07c3-22a8-4e0f-aa88-1e2e1579d820
:END:
*** Cursor appearance and tweaks (prot-cursor.el)
:PROPERTIES:
:CUSTOM_ID: h:cf9086c1-1b33-4127-a716-de94259e14a0
:END:

=prot-cursor.el= defines a set of presets that control the overall style
of the cursor.  There presuppose the =blink-cursor-mode=.  The properties
we pass to those presets mirror those we can pass for the various
built-in variables for the cursor.  Check the =prot-cursor.el= code, which
is reproduced right after the following package configurations.

#+begin_src emacs-lisp :tangle no
;;; Cursor appearance and tweaks (prot-cursor.el)
(load "prot-cursor")
(use-package prot-cursor
  :config
  (setq prot-cursor-presets
        '((bar . ( :cursor-type (bar . 2)
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (box . ( :cursor-type box
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (underscore . ( :cursor-type (hbar . 3)
                          :cursor-no-selected hollow
                          :blinks 50
                          :blink-interval 0.2
                          :blink-delay 0.2))))
  (setq prot-cursor-last-state-file
        (locate-user-emacs-file "prot-cursor-last-state"))

  (prot-cursor-restore-last-preset)

  ;; Sets my style on startup.
  (if prot-cursor--recovered-preset
      (prot-cursor-set-cursor prot-cursor--recovered-preset)
    (prot-cursor-set-cursor 'underscore))

  ;; The other side of `prot-cursor-restore-last-preset'.
  (add-hook 'kill-emacs-hook #'prot-cursor-store-last-preset)

  ;; We have to use the "point" mnemonic, because C-c c is for
  ;; `org-capture'.
  (define-key global-map (kbd "C-c p") #'prot-cursor-set-cursor))
#+end_src

#+RESULTS:
: t

*** Mouse wheel behaviour
:PROPERTIES:
:CUSTOM_ID: h:02572210-eb26-4941-8f7c-666a0314877b
:END:

The value of =mouse-wheel-scroll-amount= means the following:

+ By default scroll by one line.
+ Hold down Shift to do so by five lines.
+ Hold down Meta to scroll half a screen.
+ Hold down Control to adjust the size of the text.  This was added in
  Emacs 27.

The other options in short:

+ Hide mouse pointer while typing.
+ Enable mouse scroll.
+ Faster wheel movement means faster scroll.
+ Scroll window under mouse pointer regardless of whether it is the
  current one or not.

Note that if we enable =mouse-drag-copy-region= we automatically place the
mouse selection to the kill ring.  This is the same behaviour as
terminal emulators that place the selection to the clipboard (or the
primary selection).  I choose not to use this here.

=tear-off-window= places the current window in a new frame.  On my generic
mouse, =<mouse-3>= is the right click.  Normally I call that command with
=M-x=, though it does not hurt to rely on the mouse from time to time.

#+begin_src emacs-lisp :tangle no
;;; Mouse wheel behaviour
(use-package mouse
  ;; In Emacs 27+, use Control + mouse wheel to scale text.
  :config
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 5)
          ((meta) . 0.5)
          ((control) . text-scale)))
  (setq mouse-drag-copy-region nil)
  (setq make-pointer-invisible t)
  (setq mouse-wheel-progressive-speed t)
  (setq mouse-wheel-follow-mouse t)
  (add-hook 'after-init-hook #'mouse-wheel-mode)
  (define-key global-map (kbd "C-M-<mouse-3>") #'tear-off-window))
#+end_src

#+RESULTS:
: t

*** Scrolling behaviour
:PROPERTIES:
:CUSTOM_ID: h:0c44b318-813a-4f4a-b596-75df4a86476b
:END:

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following, the point will stay at the top/bottom
of the screen while moving in that direction (use =C-l= to reposition
it).

The =next-screen-context-lines= ensures that when moving by screenfulls
(with either =C-v= or =M-v=) we do not get any continuation lines from the
previous screen.  I find this more intuitive.

#+begin_src emacs-lisp :tangle no
;;; Scrolling behaviour
;; These four come from the C source code.
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default scroll-margin 0)
(setq-default next-screen-context-lines 0)
#+end_src

#+RESULTS:
: 0

*** Delete selection
:PROPERTIES:
:CUSTOM_ID: h:d53b7b54-924a-443b-955a-3c5b222e3a90
:END:

This is a very helpful mode.  It kills the marked region when inserting
directly to it.  It also has checks to ensure that yanking over a
selected region will not insert itself when =mouse-drag-copy-region= is in
effect (see the section on the [[#h:02572210-eb26-4941-8f7c-666a0314877b][mouse wheel behaviour]]).

#+begin_src emacs-lisp :tangle no
;;; Delete selection
(use-package delsel
  :config
  (add-hook 'after-init-hook #'delete-selection-mode))
#+end_src

#+RESULTS:
: t

*Pro tip*: On Emacs 27.1 or higher you can create a rectangular region by
holding down Ctrl and Meta while dragging the mouse with the left click
pressed.

*** Tooltips (tooltip-mode)
:PROPERTIES:
:CUSTOM_ID: h:9f492949-70fb-4fba-a0ea-569d4a240be8
:END:

These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:

+ I just want to make sure that the GTK theme is /not used/ for those: I
  prefer the generic display which follows my current theme's styles.
+ The delay is slightly reduced for the initial pop-up, while it has
  been increased for immediate pop-ups thereafter.

#+begin_src emacs-lisp :tangle no
;;; Tooltips (tooltip-mode)
(use-package tooltip
  :config
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq tooltip-frame-parameters
        '((name . "tooltip")
          (internal-border-width . 6)
          (border-width . 0)
          (no-special-glyphs . t)))
  (add-hook 'after-init-hook #'tooltip-mode))
#+end_src

#+RESULTS:
: t

** Dired-like list for registers (rlist)
:PROPERTIES:
:CUSTOM_ID: h:aad79917-cd80-491b-9020-db27867ab132
:END:

This package by Sévère Durand implements a Dired-like interface for the
purpose of deleting an entry from the list.  I feel this is the one
major feature that is missing from the registers' toolkit: it provides
you with the means to remain in control of the data you accumulate in
those compartments, so nothing ever gets out of hand.

Note that this is a fairly new project (as of 2021-02-05), so things are
likely to change over the near term.

#+begin_src emacs-lisp :tangle no
;;; Dired-like list for registers (rlist)
;; Project repo: <https://gitlab.com/mmemmew/rlist>.  This is one of the
;; packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(use-package rlist
  :config
  (setq rlist-expert t)
  (setq rlist-verbose t)
  (let ((map global-map))
    (define-key map (kbd "C-x r <backspace>") #'rlist-list-registers)
    (define-key map (kbd "C-x r <delete>") #'rlist-list-registers)))
#+end_src

** Conveniences and minor extras
:PROPERTIES:
:CUSTOM_ID: h:271c9122-280b-424e-98f0-af9e4f09bbdb
:END:
*** Automatic time stamps for files (time-stamp.el)
:PROPERTIES:
:CUSTOM_ID: h:24c2ac42-a537-4658-8a08-9aebb0de1a73
:END:

The built-in =time-stamp.el= provides the means to automatically update a
predefined header with the time its file was last edited/saved.  This
is, in my experience, particularly useful for packages that have a
stable version but also need to disambiguate their latest tagged release
from their current development state.

By default, this is done by checking the first eight lines of the file
for the =Time-stamp: <>= entry.  Though that is configurable.  To properly
utilise this library, you need to implement file-local variables.  Those
should control the exa
ct format of the time stamp.  For examples, this
is what I have in my =modus-themes.el=:

#+begin_example
;; Local Variables:
;; time-stamp-start: "Last-Modified:[ \t]+\\\\?[\"<]"
;; time-stamp-end: "\\\\?[\">]"
;; time-stamp-format: "%Y-%02m-%02d %02H:%02M:%02S %5z"
;; End:
#+end_example

Check =M-x find-library RET time-stamp RET= for all variables you may want
to control.

All we do here is enable the package and add a hook to insert a time
stamp upon save, where relevant.  It works seamlessly.

#+begin_src emacs-lisp
;;; Automatic time stamps for files (time-stamp.el)
(use-package time-stamp
  :config
  (add-hook 'before-save-hook #'time-stamp))
#+end_src

#+RESULTS:
: t

*** Auto revert mode
:PROPERTIES:
:CUSTOM_ID: h:7a8422e6-86d1-40f3-add4-0a1c826e44a3
:END:

This mode ensures that the buffer is updated whenever the file changes.
A change can happen externally or by some other tool inside of Emacs
(e.g. kill a Magit diff).

#+begin_src emacs-lisp
;;; Auto revert mode
(use-package autorevert
  :config
  (setq auto-revert-verbose t)
  (add-hook 'after-init-hook #'global-auto-revert-mode))
#+end_src

#+RESULTS:
: t

*** Preserve contents of system clipboard
:PROPERTIES:
:CUSTOM_ID: h:9eae0d2a-eef1-4b14-b883-39094be4de71
:END:

Say you copied a link from your web browser, then switched to Emacs to
paste it somewhere.  Before you do that, you notice something you want
to kill.  Doing that will place the last kill to the clipboard, thus
overriding the thing you copied earlier.  We can have a kill ring
solution to this with the following:

#+begin_src emacs-lisp  :tangle no
;;; Preserve contents of system clipboard
(setq save-interprogram-paste-before-kill t)
#+end_src

Now the contents of the clipboard are stored in the kill ring and can
be retrieved from there (e.g. with =M-y=).

*** Newline characters for file ending
:PROPERTIES:
:CUSTOM_ID: h:c0f0a2c1-1920-4bcf-8eb4-45f80cf1b874
:END:

For some major modes, such as =diff-mode=, a final newline is of paramount
importance.  Without it you cannot, for instance, apply a patch cleanly.
As such, the =mode-require-final-newline= will add a newline character
when visiting or saving a buffer of relevance.

#+begin_src emacs-lisp
;;; Newline characters for file ending
(setq mode-require-final-newline 'visit-save)
#+end_src

#+RESULTS:
: visit-save

*** Zap characters
:PROPERTIES:
:CUSTOM_ID: h:5f6ffe61-f0cc-41ad-9d2f-46ad181c3a00
:END:

There are two kinds of "zap" functionality:

+ =zap-up-to-char= will delete everything from point up to the character
  you provide it with.  Think of how you may want to remove a file name
  but keep its file type extension, so =M-x zap-up-to-char RET .= will do
  just that.
+ =zap-to-char=, which is bound to =M-z= by default, will delete the target
  character as well.

I bind the former to =M-z= as I use it more often and leave its
counterpart on =M-Z= (=M-S-z=).

#+begin_src emacs-lisp :tangle no
;;; Zap characters
(let ((map global-map))
  (define-key map (kbd "M-z") #'zap-up-to-char)
  (define-key map (kbd "M-Z") #'zap-to-char)) ; M-S-z
#+end_src

*** Package lists
:PROPERTIES:
:CUSTOM_ID: h:0d36996d-c12d-42e6-a388-b67c548c4a4b
:END:

With this I just want to enable line highlighting when browsing the list
of packages.  I generally use =hl-line-mode= on all interfaces where the
current line is more important than the exact column of the point.

#+begin_src emacs-lisp :tangle no
;;; Package lists
(use-package package
  :config
  ;; All variables are for Emacs 28+
  (setq package-name-column-width 40)
  (setq package-version-column-width 14)
  (setq package-status-column-width 12)
  (setq package-archive-column-width 8)
  (add-hook 'package-menu-mode-hook #'hl-line-mode))
#+end_src

#+RESULTS:
: t

* Language settings for prose and code
** Tabs, indentation, and the TAB key
:PROPERTIES:
:CUSTOM_ID: h:d51d37df-4e58-4e0b-85a1-019ceda342f6
:END:

I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which /can actually lead to misalignments/
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
;;; Tabs, indentation, and the TAB key
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src

:PROPERTIES:
:CUSTOM_ID: h:8fc1f9ca-f5ae-407a-b721-aab414ca657b
:END:

This section is all about configurations and/or packages that deal with
natural or programming language enhancements.

** Configure 'electric' behaviour
:PROPERTIES:
:CUSTOM_ID: h:ed95ef3e-75e6-4e53-b3bc-4aee540fe3d9
:END:

Emacs labels as "electric" any behaviour that involves contextual
auto-insertion of characters.  while the idea is neat, I generally
dislike it because of its false positives.  This is a summary of my
settings:

+ If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs.  Only do so if there is no alphabetic
  character after the cursor.
+ The cryptic numbers in the pairs set, correspond to curly single and
  double quotes and these =«»=.  The contents of this set are always
  inserted in pairs, regardless of major mode.  To get those numbers,
  evaluate =(string-to-char CHAR)= where CHAR is the one you are
  interested in.  For example, get the literal tab's character with
  =(string-to-char "\t")=.
+ While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one.  So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
+ Do not skip over whitespace when operating on pairs.  Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over.  I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
+ The whitespace characters are space (=\s=), tab (=\t=), and newline (=\n=).
+ The rest concern the conditions for transforming quotes into their
  curly equivalents.  I keep this disabled, because curly quotes are
  distinct characters.  It is difficult to search for them.  Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.

#+begin_src emacs-lisp :tangle no
;;; Configure 'electric' behaviour
(use-package electric
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-pair-mode -1)
  (electric-quote-mode -1)
  ;; I don't like auto indents in Org and related.  They are okay for
  ;; programming.
  (electric-indent-mode -1)
  (add-hook 'prog-mode-hook #'electric-indent-local-mode))
#+end_src

#+RESULTS:

** Parentheses (show-paren-mode)
:PROPERTIES:
:CUSTOM_ID: h:3d374354-843f-4efa-aa38-1ba2c9ccc14c
:END:

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

+ Activate the mode upon startup.
+ Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
+ =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
+ Do not highlight a match when the point is on the inside of the
  parenthesis.

#+begin_src emacs-lisp :tangle no
;;; Parentheses (show-paren-mode)
(use-package paren
  :ensure nil
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (setq show-paren-context-when-offscreen 'child-frame) ; Emacs 29
  (add-hook 'after-init-hook #'show-paren-mode))
#+end_src

#+RESULTS:
: t

** Code and text linters
:PROPERTIES:
:CUSTOM_ID: h:20448ad8-9371-4e00-b88b-6b93f4c654d9
:END:
*** Flymake
:PROPERTIES:
:CUSTOM_ID: h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a
:END:

This is a built-in linter interface.  It visualises in a buffer what you
would otherwise get on the command-line prompt (or compilation log),
while it also marks the line[s] where the note, warning, or error
occurs.  In short, it is quite a nice tool to have.

Several extensions to Flymake are already available, mostly targeted at
programmers.  For my case, there is no need for any of those, while
Flymake can lint Elisp without any further configuration.

The external =flymake-diagnostic-at-point= package provides a simple and
effective interface to displaying information about the warning at
point.

#+begin_src emacs-lisp
;;; Flymake
(use-package flymake
    :ensure nil
  :config
  (setq flymake-fringe-indicator-position 'left-fringe)
  (setq flymake-suppress-zero-counters t)
  (setq flymake-start-on-flymake-mode t)
  (setq flymake-no-changes-timeout nil)
  (setq flymake-start-on-save-buffer t)
  (setq flymake-proc-compilation-prevents-syntax-check t)
  (setq flymake-wrap-around nil)
  (setq flymake-mode-line-format
        '("" flymake-mode-line-exception flymake-mode-line-counters))
  (setq flymake-mode-line-counter-format
        '(" " flymake-mode-line-error-counter
          flymake-mode-line-warning-counter
          flymake-mode-line-note-counter ""))

  (let ((map flymake-mode-map))
    (define-key map (kbd "C-c ! s") #'flymake-start)
    (define-key map (kbd "C-c ! d") #'flymake-show-buffer-diagnostics) ; Emacs28
    (define-key map (kbd "C-c ! n") #'flymake-goto-next-error)
    (define-key map (kbd "C-c ! p") #'flymake-goto-prev-error)))

  (let ((map flymake-mode-map))
    (define-key map (kbd "C-c ! s") #'flymake-start)
    (define-key map (kbd "C-c ! d") #'flymake-show-buffer-diagnostics) ; Emacs28
    (define-key map (kbd "C-c ! n") #'flymake-goto-next-error)
    (define-key map (kbd "C-c ! p") #'flymake-goto-prev-error))

(use-package flymake-diagnostic-at-point
  :config
  (setq flymake-diagnostic-at-point-display-diagnostic-function
        'flymake-diagnostic-at-point-display-minibuffer))
#+end_src

#+RESULTS:
: flymake-goto-prev-error


**** Flymake + Shellcheck
:PROPERTIES:
:CUSTOM_ID: h:a45fd661-8cd7-4ee7-bff0-5f738d82b73b
:END:

The =flymake-shellcheck= package simply adds support for Shellcheck, the
linter for shell scripts.  It otherwise relies on the standard utilities
of =flymake-mode= (see [[#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a][main Flymake configs]]).

#+begin_src emacs-lisp
;;; Flymake + Shellcheck
(use-package flymake-shellcheck
  :config
  (add-hook 'sh-mode-hook 'flymake-shellcheck-load))
#+end_src

#+RESULTS:

**** Flymake + Proselint
:PROPERTIES:
:CUSTOM_ID: h:2a954862-c532-43e9-afdf-4bacd152295f
:END:

Manuel Uberti has published [[https://github.com/manuel-uberti/flymake-proselint][flymake-proselint on Github]] and MELPA.  It
offers a Flymake interface to the external =proselint= executable (see
[[#h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b][Proselint configuration]]).

This comes in handy when I need to review some long-form text for common
inconsistencies and stylistic irregularities.  Errors will be marked on
the fringe, while you can quickly get an overview with pointers to the
precise line number by invoking =flymake-show-diagnostics-buffer= (check
my [[#h:b8bfcc05-c0d3-4093-b3fe-f06187d22c6a][configurations for Flymake]] and then also review what I have to
spelling in [[#h:3f1b2856-c6b7-418a-9d7d-464bd1ebe69c][Flyspell and prot-spell.el (spell check)]]).

To run the program, you just need to hook it to whatever major-mode you
use for prose.  Then you need to enable =flymake-mode= to start using it.
I prefer to do the final step manually, as I normally do not run a
linter while writing: it is too distracting.

#+begin_src emacs-lisp
;;; Flymake + Proselint
(use-package flymake-proselint
  :ensure nil
  :config
  (add-hook 'markdown-mode-hook #'flymake-proselint-setup)
  (add-hook 'org-mode-hook #'flymake-proselint-setup)
  (add-hook 'text-mode-hook #'flymake-proselint-setup))
#+end_src

#+RESULTS:
: t

***** Proselint configuration
:PROPERTIES:
:CUSTOM_ID: h:6dff70a8-7eba-4b5d-982c-f13d13ed3b3b
:END:

This is my configuration for the external =proselint= executable (check
[[https://github.com/amperser/proselint][that project's README]]).  The following should be made available at
=~/.config/proselint/config=.

See [[#h:2a954862-c532-43e9-afdf-4bacd152295f][Flymake + Proselint]] for how I use this tool to review my long-form
writing.

#+include: ../../proselint/.config/proselint/config src conf :tangle no

*** Elisp packaging requirements
:PROPERTIES:
:CUSTOM_ID: h:d03342da-3035-409f-a5e7-5df1e614d507
:END:

With this in place we can perform checks that pertain to Emacs lisp
packaging.  I use it for my themes but also for any elisp library I may
want to send patches to.

#+begin_src emacs-lisp
;;; Elisp packaging requirements
(use-package package-lint-flymake
  :ensure nil
  :config
  (add-hook 'flymake-diagnostic-functions #'package-lint-flymake))
#+end_src

#+RESULTS:

* BOOKMARKS AND BUFFERS
Doom Emacs uses 'SPC b' for keybindings related to bookmarks and buffers.


=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.  For this
reason I bind it to =C-x C-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= or =query-replace-regexp= on marked buffers.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package configurations, these are my tweaks
to the default behaviour and presentation:

+ Prompt for confirmation only when deleting a modified buffer.
+ Hide the summary.
+ Do not open on the other window; use the current one.
+ Do not show empty filter groups.
+ Do not cycle movements.  So do not go to the top when moving downward
  at the last item on the list.

** Bookmarks
Bookmarks are somewhat like registers in that they record positions you can jump to.  Unlike registers, they have long names, and they persist automatically from one Emacs session to the next. The prototypical use of bookmarks is to record where you were reading in various files.

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("b". "buffer")
       :desc "List bookmarks" "L" #'list-bookmarks
       :desc "Save current bookmarks to bookmark file" "w" #'bookmark-save))
#+END_SRC

#+RESULTS:
: bookmark-save

** Buffers
Regarding /buffers/, the text you are editing in Emacs resides in an object called a /buffer/. Each time you visit a file, a buffer is used to hold the file’s text. Each time you invoke Dired, a buffer is used to hold the directory listing.  /Ibuffer/ is a program that lists all of your Emacs /buffers/, allowing you to navigate between them and filter them.

| COMMAND         | DESCRIPTION          | KEYBINDING |
|-----------------+----------------------+------------|
| ibuffer         | Launch ibuffer       | SPC b i    |
| kill-buffer     | Kill current buffer  | SPC b k    |
| next-buffer     | Goto next buffer     | SPC b n    |
| previous-buffer | Goto previous buffer | SPC b p    |
| save-buffer     | Save current buffer  | SPC b s    |

** Keybindings within ibuffer mode
| COMMAND                           | DESCRIPTION                            | KEYBINDING |
|-----------------------------------+----------------------------------------+------------|
| ibuffer-mark-forward              | Mark the buffer                        | m          |
| ibuffer-unmark-forward            | Unmark the buffer                      | u          |
| ibuffer-do-kill-on-deletion-marks | Kill the marked buffers                | x          |
| ibuffer-filter-by-content         | Ibuffer filter by content              | f c        |
| ibuffer-filter-by-directory       | Ibuffer filter by directory            | f d        |
| ibuffer-filter-by-filename        | Ibuffer filter by filename (full path) | f f        |
| ibuffer-filter-by-mode            | Ibuffer filter by mode                 | f m        |
| ibuffer-filter-by-name            | Ibuffer filter by name                 | f n        |
| ibuffer-filter-disable            | Disable ibuffer filter                 | f x        |
| ibuffer-do-kill-lines             | Hide marked buffers                    | g h        |
| ibuffer-update                    | Restore hidden buffers                 | g H        |

#+begin_src emacs-lisp

(use-package ibuffer
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 40 40 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook #'hl-line-mode)
  (define-key global-map (kbd "C-x C-b") #'ibuffer)
(evil-define-key 'normal ibuffer-mode-map
  (kbd "f c") 'ibuffer-filter-by-content
  (kbd "f d") 'ibuffer-filter-by-directory
  (kbd "f f") 'ibuffer-filter-by-filename
  (kbd "f m") 'ibuffer-filter-by-mode
  (kbd "f n") 'ibuffer-filter-by-name
  (kbd "f x") 'ibuffer-filter-disable
  (kbd "g h") 'ibuffer-do-kill-lines
  (kbd "g H") 'ibuffer-update))
#+end_src

#+RESULTS:
: t

* CALENDAR
Let's make a 12-month calendar available so we can have a calendar app that, when we click on time/date in xmobar, we get a nice 12-month calendar to view.

This is a modification of: http://homepage3.nifty.com/oatu/emacs/calendar.html
See also: https://stackoverflow.com/questions/9547912/emacs-calendar-show-more-than-3-months

#+begin_src emacs-lisp
;; https://stackoverflow.com/questions/9547912/emacs-calendar-show-more-than-3-months
(defun dt/year-calendar (&optional year)
  (interactive)
  (require 'calendar)
  (let* (
      (current-year (number-to-string (nth 5 (decode-time (current-time)))))
      (month 0)
      (year (if year year (string-to-number (format-time-string "%Y" (current-time))))))
    (switch-to-buffer (get-buffer-create calendar-buffer))
    (when (not (eq major-mode 'calendar-mode))
      (calendar-mode))
    (setq displayed-month month)
    (setq displayed-year year)
    (setq buffer-read-only nil)
    (erase-buffer)
    ;; horizontal rows
    (dotimes (j 4)
      ;; vertical columns
      (dotimes (i 3)
        (calendar-generate-month
          (setq month (+ month 1))
          year
          ;; indentation / spacing between months
          (+ 5 (* 25 i))))
      (goto-char (point-max))
      (insert (make-string (- 10 (count-lines (point-min) (point-max))) ?\n))
      (widen)
      (goto-char (point-max))
      (narrow-to-region (point-max) (point-max)))
    (widen)
    (goto-char (point-min))
    (setq buffer-read-only t)))

(defun dt/scroll-year-calendar-forward (&optional arg event)
  "Scroll the yearly calendar by year in a forward direction."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     last-nonmenu-event))
  (unless arg (setq arg 0))
  (save-selected-window
    (if (setq event (event-start event)) (select-window (posn-window event)))
    (unless (zerop arg)
      (let* (
              (year (+ displayed-year arg)))
        (dt/year-calendar year)))
    (goto-char (point-min))
    (run-hooks 'calendar-move-hook)))

(defun dt/scroll-year-calendar-backward (&optional arg event)
  "Scroll the yearly calendar by year in a backward direction."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     last-nonmenu-event))
  (dt/scroll-year-calendar-forward (- (or arg 1)) event))

(map! :leader
      :desc "Scroll year calendar backward" "<left>" #'dt/scroll-year-calendar-backward
      :desc "Scroll year calendar forward" "<right>" #'dt/scroll-year-calendar-forward)

(defalias 'year-calendar 'dt/year-calendar)
#+end_src

Let's also play around with calfw.
#+begin_src emacs-lisp
(use-package! calfw)
(use-package! calfw-org)
#+end_src

#+RESULTS:
: calfw-org

* CENTAUR-TABS
To use tabs in Doom Emacs, be sure to uncomment "tabs" in Doom's init.el.  Displays tabs at the top of the window similar to tabbed web browsers such as Firefox.  I don't actually use tabs in Emacs.  I placed this in my config to help others who may want tabs.  In the default configuration of Doom Emacs, 'SPC t' is used for "toggle" keybindings, so I choose 'SPC t c' to toggle centaur-tabs.  The "g" prefix for keybindings is used for a bunch of evil keybindings in Doom, but "g" plus the arrow keys were not used, so I thought I would bind those for tab navigation.  But I did leave the default "g t" and "g T" intact if you prefer to use those for centaur-tabs-forward/backward.

| COMMAND                     | DESCRIPTION               | KEYBINDING       |
|-----------------------------+---------------------------+------------------|
| centaur-tabs-mode           | /Toggle tabs globally/      | SPC t c          |
| centaur-tabs-local-mode     | /Toggle tabs local display/ | SPC t C          |
| centaur-tabs-forward        | /Next tab/                  | g <right> or g t |
| centaur-tabs-backward       | /Previous tab/              | g <left> or g T  |
| centaur-tabs-forward-group  | /Next tab group/            | g <down>         |
| centaur-tabs-backward-group | /Previous tab group/        | g <up>           |

#+BEGIN_SRC emacs-lisp
(setq centaur-tabs-set-bar 'over
      centaur-tabs-set-icons t
      centaur-tabs-gray-out-icons 'buffer
      centaur-tabs-height 24
      centaur-tabs-set-modified-marker t
      centaur-tabs-style "bar"
      centaur-tabs-modified-marker "•")
(map! :leader
      :desc "Toggle tabs globally" "t c" #'centaur-tabs-mode
      :desc "Toggle tabs local display" "t C" #'centaur-tabs-local-mode)
(evil-define-key 'normal centaur-tabs-mode-map (kbd "g <right>") 'centaur-tabs-forward        ; default Doom binding is 'g t'
                                               (kbd "g <left>")  'centaur-tabs-backward       ; default Doom binding is 'g T'
                                               (kbd "g <down>")  'centaur-tabs-forward-group
                                               (kbd "g <up>")    'centaur-tabs-backward-group)
#+END_SRC

* DIRED
Dired is the file manager within Emacs.  Below, I setup keybindings for image previews (peep-dired).  Doom Emacs does not use 'SPC d' for any of its keybindings, so I've chosen the format of 'SPC d' plus 'key'.

** Dired file manager (and prot-dired.el extras)
*** desc
The directory editor abbreviated as "Dired" (which I pronounce like
"tired", "mired", etc.) is a built-in tool that performs file management
operations inside of an Emacs buffer.  It is simply superb!  I use it
daily for a number of tasks.

You can interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run shell
commands, combine Dired with regular editing capabilities as part of a
keyboard macro, search[+replace] across multiple files, encrypt/decrypt
files, start an email with the current or marked files attached to the
message, and more.  Combine that with the possibility of matching items
with regular expressions, such as for marking files or narrowing the
list, or creating an editable Dired buffer to bulk rename entries, and
you have everything you need to maximise your productivity.

Watch some of my older videos:

+ [[https://protesilaos.com/codelog/2019-08-12-emacs-dired-tweaks/][Dired tweaks and refinements]] (2019-08-12).
+ [[https://protesilaos.com/codelog/2019-09-03-emacs-dired-macros/][Use Dired and keyboard macros]] (2019-09-03).
+ [[https://protesilaos.com/codelog/2019-09-19-dired-narrow/][Techniques to narrow Dired]] (2019-09-19).
+ [[https://protesilaos.com/codelog/2019-11-16-emacs-dired-chmod/][Change multi-file permissions with Dired]] (2019-11-16).
+ [[https://protesilaos.com/codelog/2019-11-13-emacs-bongo-music/][Music management with Dired and Bongo]] (2019-11-13).
+ [[https://protesilaos.com/codelog/2019-11-18-emacs-dired-bongo/][Dired+Bongo and macros to handle music playlists]] (2019-11-18).
+ [[https://protesilaos.com/codelog/2019-12-08-emacs-multi-replace/][Search and replace across multiple files (not Dired-specific)]] (2019-12-08).

The following package configurations are fairly comprehensive.  First an
overview of the options I specify for Dired proper:

+ Copy and delete recursively.  No need to be prompted about each
  action.

+ While in detailed view, search only file names when point is on one of
  them, else apply the query to the rest of the data.

+ Deletion sends items to the system's Trash, making it safer than the
  standard =rm=.  The trash can be a life-saver, as it lets you restore
  deleted files (check: [[#h:954adfb4-8f2c-4665-bb5b-e098926341b0][dired-like mode for the trash (trashed.el)]]).

+ Reformat output.  Sort directories first.  Show dotfiles and place
  them before anything else.  Omit implicit directories (the single and
  double dots).  Use human-readable size units.  To learn everything
  about these switches, you need to read the manpage of =ls=.  You can do
  so with =M-x man RET ls= or =M-x woman=.

  - Note that =dired-listing-switches= and =find-ls-option= are configured
    to show hidden directories and files /before/ their non-hidden
    counterparts.  If you want to reverse this order, you must include
    the =-X= option (such as =-AFXhlv --group-directories-first=).

+ Hide all the details by default (permissions, size, etc.).  Those can
  easily be toggled on with the left parenthesis.  Also enable
  highlighting of the current line (=hl-line-mode=), which makes it even
  easier to spot the current item (I do not enable this globally,
  because I only want it for line-oriented interfaces, such as Dired's,
  but not for text editing).

+ While having two dired buffers open, the rename and copy operations
  will place the path of the inactive one as the target destination.
  When multiple dired buffers are present, this works between the
  current and most recently used ones, with =M-n= and =M-p= on the
  minibuffer prompt allowing you to switch between all possible targets.

+ For Emacs 27.1 or higher, Dired can automatically create destination
  directories for its copy and rename operations.  So you can, for
  example, move (copy or rename) =file= to =/non-existent-path/file= and you
  will get what you want right away.

+ For Emacs 27.1 or higher, renaming a file of a version-controlled
  repository (git) will be done using the appropriate VC mechanism.
  This is to ensure that file name changes are tracked correctly (also
  check my detailed: [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]).

And here are a few words about the more specialised parts of the Dired
ecosystem:

+ Dired subtree :: This third-party package which is part of the
  [[https://github.com/Fuco1/dired-hacks][dired-hacks project by Matus Goljer]] offers tree-style navigation,
  meaning that the subdirectories of the current Dired buffer can be
  expanded and contracted in place.  It is possible to perform the same
  kind of folding on their subdirectories, and so on.

  Tree-style navigation is useful in my workflow when all I want is a
  quick peek at a directory's contents.

+ Dired extras (dired-x) :: These are some additional features that are
  shipped with Emacs.  The one I need the most is =dired-jump= and its
  "other window" variant.  These are among my favourite commands.  They
  will always take you to the directory that contains the current
  buffer. (Note for Emacs 28 users: =dired-jump= is now part of =dired.el=).

  'Jumping' works even when you are inside buffers that do not visit
  files, such as Magit, Diff, or Eshell: it just takes you to the
  =default-directory=.  This is its most valuable quality!  Edit a file
  then proceed to do some file management, then invoke =previous-buffer=
  or =winner-undo= to go back to where you were (I have a few key bindings
  for those in the [[#h:12591f89-eeea-4b12-93e8-9293504e5a12][Window configuration section]]).  Everything happens
  naturally.  Emacs' interconnectedness at its best!

  The other neat features of =dired-x= are (1) its ability to open Info
  files in place (=dired-info= command, bound to =I=), and (2) to open all
  marked files at once (=dired-do-find-marked-files= bound to =F= by
  default).

+ Writable Dired (wdired) :: This is the standard editable state of a
  dired buffer.  You can access it with =C-x C-q=.  Write changes to files
  or directories, as if it were a regular buffer, then confirm them with
  =C-c C-c=.  This practically means that you can rename files and change
  permissions (when the detailed list is available).  Note that while
  renaming a file, any forward slash is treated like a directory and *is
  created directly* upon successful exit.  Combine this utility with
  keyboard macros, rectangle edits, or =query-replace= (and its regexp
  variant---[[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, grep, and extras (prot-search.el)]]) and you
  have one potent tool at your disposal.

+ Image dired :: This built-in library offers facilities for generating
  thumbnails out of a selection of images and displaying them in a
  separate buffer.  An external program is needed to convert the images
  into thumbnails: =imagemagick=.  Other useful external packages are
  =optipng= and =sxiv= (or equivalent).  The former is for operating on PNG
  files, while the latter is a lightweight image viewer.  I feel this
  process is a bit cumbersome and can be very slow if you try to
  generate lots of images at once.  The culprit is the image converter.
  As such, only use this for smaller collections.  Besides, Emacs can
  open an image in a buffer and that works well for viewing individual
  items (else use =!= or =&= to run an external process, with the latter
  being asynchronous).  I don't keep a lot of images around, so I am not
  the best person to comment on this feature.  Instead, I recommend you
  view the video of [[https://www.youtube.com/watch?v=NrY3t3W0_cM][image-dired by Emacs Elements (Raoul Comninos)]].

+ prot-dired.el :: This file (reproduced in its entirety below those
  configurations) contains a few custom extensions for streamlining some
  repetitive tasks.  The video on [[https://protesilaos.com/codelog/2021-07-21-emacs-dired-custom-extras/][my custom Dired extras]] (2021-07-21)
  may also be of help.

  1. It contains methods for opening media files using an external
     program.  The idea is to provide a default option when invoking
     either =!= or =&= on a given file.  So if, for example, you try to open
     an image, it will search the system for the first program matching
     the elements in the =prot-dired-image-viewers= variable.  Same
     principle for media players.

  2. The =prot-dired-limit-regexp= command is a convenience wrapper around
     built-in capabilities of narrowing the listing to the files that
     match (or don't) a given regular expression.  When called directly,
     it prompts for a regexp and removes everything that does not match
     it.  This operation does not delete files.  It just hides them
     (restore the view either with =g= or by using the =undo= command).
     When the command is invoked with a universal prefix argument (=C-u=)
     it inverts the meaning of the regular expression so that it hides
     the matching entries.

  3. The =prot-dired-insert-subdir= is a general purpose command for
     inserting the contents of a subdirectory in the current Dired
     buffer.  It basically provides a superset of features found in the
     standard =dired-maybe-insert-subdir= (bound to =i= by default).  When
     items are marked, it searches among them for the subdirectories to
     the current directory and inserts them in the buffer, while
     ignoring invalid entries.  If no marks are active and point is on a
     subdirectory line, it inserts it directly.  If no marks are active
     and point is not on a subdirectory, then it prompts for minibuffer
     completion and inserts the selected item.  When invoked with a
     single prefix argument (=C-u=) it first asks for the command-line
     flags to pass to the underlying =ls= program, which can be helpful if
     you want to get some more verbose information or pass the =-R= flag
     to directly insert a tree recursively.  And when the command is
     called with a double prefix argument (=C-u C-u=) it removes all
     inserted subdirectories in one go.  As always, the =undo= command can
     help you manage each step.

     Tip: to remove a single subdirectory, you can still use =C-u k= over
     its heading (=dired-do-kill-lines= with its ARG).

     Another tip: to update the =ls= switches for the whole buffer, type
     =C-u s= (=dired-sort-toggle-or-edit= with its ARG).

  4. An Imenu index is set up which lets you jump to the headers of all
     inserted directories using minibuffer completion (either with the
     generic =M-x imenu= or some third-party variant).  The are commands
     which provide directional motions to move between such headings:
     =prot-dired-subdirectory-next= and =prot-dired-subdirectory-previous=.

  5. The command =prot-dired-grep-marked-files= streamlines a common
     workflow I have of using =find= on the command line to grep for file
     contents.  It performs a search in the marked files.  When no items
     are marked, it goes through all files in the current directory
     (non-recursive).  Its doc string covers the technicalities.  The
     command serves as a specialised variant of =prot-search-grep=
     ([[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, grep, and extras (prot-search.el)]]).

*** code
#+begin_src emacs-lisp :tangle no
;;; Dired file manager (and prot-dired.el extras)
(use-package dired
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p) ; also see `dired-do-revert-buffer'
  (setq dired-make-directory-clickable t) ; Emacs 29.1
  (setq dired-free-space nil) ; Emacs 29.1

  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode))

(use-package dired-aux
  :config
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)
  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))

  (let ((map dired-mode-map))
    (define-key map (kbd "C-+") #'dired-create-empty-file)
    (define-key map (kbd "M-s f") #'nil)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action))) ; Emacs 28

;; ;; NOTE 2021-05-10: I do not use `find-dired' and related commands
;; ;; because there are other tools that offer a better interface, such
;; ;; as `consult-find', `consult-grep', `project-find-file',
;; ;; `project-find-regexp', `prot-vc-git-grep'.
;; (prot-emacs-builtin-package 'find-dired
;;   (setq find-ls-option
;;         '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
;;   (setq find-name-arg "-iname"))

(use-package dired-x
  :config
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  (define-key dired-mode-map (kbd "I") #'dired-info))

(load "prot-dired")
(use-package prot-dired
  :config
  (setq prot-dired-image-viewers '("feh" "sxiv"))
  (setq prot-dired-media-players '("mpv" "vlc"))
  (setq prot-dired-media-extensions
        "\\.\\(mp[34]\\|ogg\\|flac\\|webm\\|mkv\\)")
  (setq prot-dired-image-extensions
        "\\.\\(png\\|jpe?g\\|tiff\\)")
  (setq dired-guess-shell-alist-user ; those are the defaults for ! and & in Dired
        `((,prot-dired-image-extensions (prot-dired-image-viewer))
          (,prot-dired-media-extensions (prot-dired-media-player))))

  (add-hook 'dired-mode-hook #'prot-dired-setup-imenu)

  (let ((map dired-mode-map))
    (define-key map (kbd "i") #'prot-dired-insert-subdir) ; override `dired-maybe-insert-subdir'
    (define-key map (kbd "/") #'prot-dired-limit-regexp)
    (define-key map (kbd "C-c C-l") #'prot-dired-limit-regexp)
    (define-key map (kbd "M-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "C-c C-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "M-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "C-c C-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "M-s G") #'prot-dired-grep-marked-files))) ; M-s g is `prot-search-grep'

(use-package dired-subtree
  :config
  (setq dired-subtree-use-backgrounds nil)
  (let ((map dired-mode-map))
    (define-key map (kbd "<tab>") #'dired-subtree-toggle)
    (define-key map (kbd "<backtab>") #'dired-subtree-remove))) ; S-TAB

(use-package wdired
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(use-package image-dired
  :config
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  (define-key image-dired-thumbnail-mode-map
    (kbd "<return>") #'image-dired-thumbnail-display-external))
#+end_src

#+RESULTS:
: t

*** dired-like mode for the trash (trashed.el)
:PROPERTIES:
:CUSTOM_ID: h:954adfb4-8f2c-4665-bb5b-e098926341b0
:END:

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp
;;; dired-like mode for the trash (trashed.el)
(use-package trashed
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

** dired commands and keybindings
 Keybindings To Open Dired

| COMMAND    | DESCRIPTION                        | KEYBINDING |
|------------+------------------------------------+------------|
| dired      | /Open dired file manager/            | SPC d d    |
| dired-jump | /Jump to current directory in dired/ | SPC d j    |

*Basic dired commands*
| COMMAND                | DESCRIPTION                                 | KEYBINDING |
|------------------------+---------------------------------------------+------------|
| dired-view-file        | /View file in dired/                          | SPC d v    |
| dired-up-directory     | /Go up in directory tree/                     | h          |
| dired-find-file        | /Go down in directory tree (or open if file)/ | l          |
| dired-next-line        | Move down to next line                      | j          |
| dired-previous-line    | Move up to previous line                    | k          |
| dired-mark             | Mark file at point                          | m          |
| dired-unmark           | Unmark file at point                        | u          |
| dired-do-copy          | Copy current file or marked files           | C          |
| dired-do-rename        | Rename current file or marked files         | R          |
| dired-hide-details     | Toggle detailed listings on/off             | (          |
| dired-git-info-mode    | Toggle git information on/off               | )          |
| dired-create-directory | Create new empty directory                  | +          |
| dired-diff             | Compare file at point with another          | =          |
| dired-subtree-toggle   | Toggle viewing subtree at point             | TAB        |
|                        |                                             |            |
 *Dired commands using regex*
| COMMAND                 | DESCRIPTION                | KEYBINDING |
|-------------------------+----------------------------+------------|
| dired-mark-files-regexp | Mark files using regex     | % m        |
| dired-do-copy-regexp    | Copy files using regex     | % C        |
| dired-do-rename-regexp  | Rename files using regex   | % R        |
| dired-mark-files-regexp | Mark all files using regex | * %        |

 *File permissions and ownership*
| COMMAND         | DESCRIPTION                      | KEYBINDING |
|-----------------+----------------------------------+------------|
| dired-do-chgrp  | Change the group of marked files | g G        |
| dired-do-chmod  | Change the mode of marked files  | M          |
| dired-do-chown  | Change the owner of marked files | O          |
| dired-do-rename | Rename file or all marked files  | R          |

*Keybindings Within Dired With Peep-Dired-Mode Enabled*
*If peep-dired is enabled, you will get image previews as you go up/down with 'j' and 'k'*

| COMMAND              | DESCRIPTION                              | KEYBINDING |
|----------------------+------------------------------------------+------------|
| peep-dired           | /Toggle previews within dired/             | SPC d p    |
| peep-dired-next-file | /Move to next file in peep-dired-mode/     | j          |
| peep-dired-prev-file | /Move to previous file in peep-dired-mode/ | k          |

** Davi dir
#+begin_src emacs-lisp
;; C-u s for flags
;; (use-package all-the-icons-dired)

(use-package dired
  :ensure nil
  ;; :straight nil
  :defer 1
  :commands (dired dired-jump)
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p)
                                        ; also see `dired-do-revert-buffer'
  ;; (setq dired-listing-switches "-agho --group-directories-first"
  ;;       ;; dired-omit-files "^\\.[^.].*"
  ;;       dired-omit-verbose nil
  ;;       dired-hide-details-hide-symlink-targets nil
  ;;       delete-by-moving-to-trash t)

  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode)
  ;; (autoload 'dired-omit-mode "dired-x")

  (add-hook 'dired-load-hook
            (lambda ()
              (interactive)
              (dired-collapse)))

  (add-hook 'dired-mode-hook
            (lambda ()
              (interactive)
              ;; (dired-omit-mode 1)
              (dired-hide-details-mode 1)
              ;; (unless (or dw/is-termux
                          ;; (s-equals? "/home/shiva/" (expand-file-name default-directory)
                (all-the-icons-dired-mode 1))
              (hl-line-mode 1))

(use-package dired-aux
  :config
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)
  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))

  (let ((map dired-mode-map))
    (define-key map (kbd "C-+") #'dired-create-empty-file)
    (define-key map (kbd "M-s f") #'nil)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action))) ; Emacs 28

;; ;; NOTE 2021-05-10: I do not use `find-dired' and related commands
;; ;; because there are other tools that offer a better interface, such
;; ;; as `consult-find', `consult-grep', `project-find-file',
;; ;; `project-find-regexp', `prot-vc-git-grep'.
;; (prot-emacs-builtin-package 'find-dired
;;   (setq find-ls-option
;;         '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
;;   (setq find-name-arg "-iname"))

(use-package dired-x
  :config
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  (define-key dired-mode-map (kbd "I") #'dired-info))

(load "prot-dired")
(use-package prot-dired
  :config
  (setq prot-dired-image-viewers '("feh" "sxiv"))
  (setq prot-dired-media-players '("mpv" "vlc"))
  (setq prot-dired-media-extensions
        "\\.\\(mp[34]\\|ogg\\|flac\\|webm\\|mkv\\)")
  (setq prot-dired-image-extensions
        "\\.\\(png\\|jpe?g\\|tiff\\)")
  (setq dired-guess-shell-alist-user ; those are the defaults for ! and & in Dired
        `((,prot-dired-image-extensions (prot-dired-image-viewer))
          (,prot-dired-media-extensions (prot-dired-media-player))))

  (add-hook 'dired-mode-hook #'prot-dired-setup-imenu)

  (let ((map dired-mode-map))
    (define-key map (kbd "i") #'prot-dired-insert-subdir) ; override `dired-maybe-insert-subdir'
    (define-key map (kbd "/") #'prot-dired-limit-regexp)
    (define-key map (kbd "C-c C-l") #'prot-dired-limit-regexp)
    (define-key map (kbd "M-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "C-c C-n") #'prot-dired-subdirectory-next)
    (define-key map (kbd "M-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "C-c C-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "M-s G") #'prot-dired-grep-marked-files))) ; M-s g is `prot-search-grep'

(use-package dired-subtree
  :config
  (setq dired-subtree-use-backgrounds nil)
  (let ((map dired-mode-map))
    (define-key map (kbd "<tab>") #'dired-subtree-toggle)
    (define-key map (kbd "<backtab>") #'dired-subtree-remove))) ; S-TAB

(use-package wdired
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(use-package image-dired
  :config
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  (define-key image-dired-thumbnail-mode-map
    (kbd "<return>") #'image-dired-thumbnail-display-external))
  (use-package dired-rainbow
    :defer 2
    :config
    (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
    (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
    (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
    (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
    (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
    (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
    (dired-rainbow-define media "#de751f" ("webm" "mp3" "mp4" "mkv" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
    (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
    (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
    (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
    (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
    (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
    (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
    (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
    (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*"))

  (use-package dired-single
    :defer t)

  (use-package dired-ranger
    :defer t)

  (use-package dired-collapse
    :defer t)

(evil-define-key 'normal dired-mode-map
  (kbd "M-RET") 'dired-display-file
  (kbd "h") 'dired-single-up-directory
  ;; (kbd "H") 'dired-omit-mode
  (kbd "l") 'dired-single-buffer ; use dired-find-file instead of dired-open.
  (kbd "m") 'dired-mark
  (kbd "RET") 'dired-open-file
  (kbd "t") 'dired-toggle-marks
  (kbd "u") 'dired-unmark
  (kbd "C") 'dired-do-copy
  (kbd "D") 'dired-do-delete
  (kbd "J") 'dired-goto-file
  (kbd "M") 'dired-do-chmod
  (kbd "O") 'dired-do-chown
  (kbd "P") 'dired-do-print
  (kbd "R") 'dired-do-rename
  (kbd "T") 'dired-do-touch
  (kbd "y") 'dired-ranger-copy
  (kbd "X") 'dired-ranger-move
  (kbd "p") 'dired-ranger-paste
  (kbd "Y") 'dired-copy-filenamecopy-filename-as-kill ; copies filename to kill ring.
  (kbd "+") 'dired-create-directory
  (kbd "-") 'dired-up-directory
  (kbd "% l") 'dired-downcase
  (kbd "% u") 'dired-upcase
  (kbd "; d") 'epa-dired-do-decrypt
  (kbd "; e") 'epa-dired-do-encrypt))
  ;; (evil-collection-define-key 'normal 'dired-mode-map
  ;;   "h" 'dired-single-up-directory
  ;;   "H" 'dired-omit-mode
  ;;   "l" 'dired-single-buffer
  ;;   "y" 'dired-ranger-copy
  ;;   "X" 'dired-ranger-move
  ;;   "p" 'dired-ranger-paste))
(map! :leader
      (:prefix ("d" . "dired")
       :desc "Open dired" "d" #'dired
       :desc "Dired jump to current" "j" #'dired-jump)
      (:after dired
       (:map dired-mode-map
        :desc "Peep-dired image previews" "d p" #'peep-dired
        :desc "Dired view file" "d v" #'dired-view-file
        :desc "Find name dired " "d N" #'find-name-dired)))

(setq dired-open-extensions '(("gif" . "sxiv")
                              ("jpg" . "sxiv")
                              ("png" . "sxiv")
                              ("mkv" . "mpv")
                              ("webm" . "mpv")
                              ("mp4" . "mpv")))
;; (defun dw/dired-link (path)
;;   (lexical-let ((target path))
;;     (lambda () (interactive) (message "Path: %s" target) (dired target))))

;; (dw/leader-key-def
;;   "d"   '(:ignore t :which-key "dired")
;;   "dd"  '(dired :which-key "Here")
;;   "dh"  `(,(dw/dired-link "~") :which-key "Home")
;;   "dn"  `(,(dw/dired-link "~/Notes") :which-key "Notes")
;;   "do"  `(,(dw/dired-link "~/Downloads") :which-key "Downloads")
;;   "dp"  `(,(dw/dired-link "~/Pictures") :which-key "Pictures")
;;   "dv"  `(,(dw/dired-link "~/Videos") :which-key "Videos")
;;   "d."  `(,(dw/dired-link "~/.dotfiles") :which-key "dotfiles")
;;   "de"  `(,(dw/dired-link "~/.emacs.d") :which-key ".emacs.d"))

(evil-define-key 'normal peep-dired-mode-map
  (kbd "j") 'peep-dired-next-file
  (kbd "k") 'peep-dired-prev-file)
(add-hook 'peep-dired-hook 'evil-normalize-keymaps)

(setq delete-by-moving-to-trash t
      trash-directory "~/.local/share/Trash/files/")
#+end_src

#+RESULTS:
: ~/.local/share/Trash/files/

** open with
#+begin_src emacs-lisp
(use-package openwith
  :config
  (setq openwith-associations
        (list
          (list (openwith-make-extension-regexp
                '("webm" "mpg" "mpeg" "mp3" "mp4"
                  "avi" "wmv" "wav" "mov" "flv"
                  "ogm" "ogg" "mkv"))
                "mpv"
                '(file))
          (list (openwith-make-extension-regexp
                '("xbm" "pbm" "pgm" "ppm" "pnm"
                  "png" "gif" "bmp" "tif" "jpeg")) ;; Removed jpg because Telega was
                  ;; causing feh to be opened...
                  "feh"
                  '(file))
          (list (openwith-make-extension-regexp
                '("pdf"))
                "zathura"
                '(file)))))

#+end_src

#+RESULTS:
: t

** general dired
#+begin_src emacs-lisp :tangle no
(use-package dired
  :ensure nil
  :custom
  (dired-listing-switches "-NGalhv --group-directories-first")
  (dired-auto-revert-buffer t)
  (dired-kill-when-opening-new-dired-buffer t))

(use-package dired-subtree
  :bind (:map dired-mode-map
              ([tab] . dired-subtree-toggle)
              ([C-tab] . dired-subtree-cycle))
  :custom
  (dired-subtree-line-prefix "  |-")
  (dired-subtree-use-backgrounds nil))

(use-package dired-aux
  :ensure nil
  :defer t
  :config
  (add-to-list 'dired-compress-file-suffixes
               '("\\.txz\\'" "" "xz -dc %i | tar -xf -")))


(map! :leader
      (:prefix ("d" . "dired")
       :desc "Open dired" "d" #'dired
       :desc "Dired jump to current" "j" #'dired-jump)
      (:after dired
       (:map dired-mode-map
        :desc "Peep-dired image previews" "d p" #'peep-dired
        :desc "Dired view file" "d v" #'dired-view-file
        :desc "Find name dired " "d N" #'find-name-dired)))

(evil-define-key 'normal dired-mode-map
  (kbd "M-RET") 'dired-display-file
  (kbd "h") 'dired-up-directory
  (kbd "l") 'dired-open-file ; use dired-find-file instead of dired-open.
  (kbd "m") 'dired-mark
  (kbd "t") 'dired-toggle-marks
  (kbd "u") 'dired-unmark
  (kbd "C") 'dired-do-copy
  (kbd "D") 'dired-do-delete
  (kbd "J") 'dired-goto-file
  (kbd "M") 'dired-do-chmod
  (kbd "O") 'dired-do-chown
  (kbd "P") 'dired-do-print
  (kbd "R") 'dired-do-rename
  (kbd "T") 'dired-do-touch
  (kbd "Y") 'dired-copy-filenamecopy-filename-as-kill ; copies filename to kill ring.
  (kbd "+") 'dired-create-directory
  (kbd "-") 'dired-up-directory
  (kbd "% l") 'dired-downcase
  (kbd "% u") 'dired-upcase
  (kbd "; d") 'epa-dired-do-decrypt
  (kbd "; e") 'epa-dired-do-encrypt)
;; Get file icons in dired
(add-hook 'dired-mode-hook 'all-the-icons-dired-mode)
;; With dired-open plugin, you can launch external programs for certain extensions
;; For example, I set all .png files to open in 'sxiv' and all .mp4 files to open in 'mpv'
(setq dired-open-extensions '(("gif" . "sxiv")
                              ("jpg" . "sxiv")
                              ("png" . "sxiv")
                              ("mkv" . "mpv")
                              ("webm" . "mpv")
                              ("mp4" . "mpv")))
#+end_src

#+RESULTS:
: ((gif . sxiv) (jpg . sxiv) (png . sxiv) (mkv . mpv) (webm . mpv) (mp4 . mpv))

* IVY
Ivy is a generic completion mechanism for Emacs.
** IVY-POSFRAME
Ivy-posframe is an ivy extension, which lets ivy use posframe to show its candidate menu.  Some of the settings below involve:
+ ivy-posframe-display-functions-alist -- sets the display position for specific programs
+ ivy-posframe-height-alist -- sets the height of the list displayed for specific programs

Available functions (positions) for 'ivy-posframe-display-functions-alist'
+ ivy-posframe-display-at-frame-center
+ ivy-posframe-display-at-window-center
+ ivy-posframe-display-at-frame-bottom-left
+ ivy-posframe-display-at-window-bottom-left
+ ivy-posframe-display-at-frame-bottom-window-center
+ ivy-posframe-display-at-point
+ ivy-posframe-display-at-frame-top-center

=NOTE:= If the setting for 'ivy-posframe-display' is set to 'nil' (false), anything that is set to 'ivy-display-function-fallback' will just default to their normal position in Doom Emacs (usually a bottom split).  However, if this is set to 't' (true), then the fallback position will be centered in the window.

#+BEGIN_SRC emacs-lisp :tangle no

(ivy-posframe-mode 1) ; 1 enables posframe-mode, 0 disables it.
(setq ivy-posframe-display-functions-alist
      '((swiper                     . ivy-posframe-display-at-point)
        (complete-symbol            . ivy-posframe-display-at-point)
        (counsel-M-x                . ivy-display-function-fallback)
        (counsel-esh-history        . ivy-posframe-display-at-window-center)
        (counsel-describe-function  . ivy-display-function-fallback)
        (counsel-describe-variable  . ivy-display-function-fallback)
        (counsel-find-file          . ivy-posframe-display-at-window-center)
        (counsel-recentf            . ivy-display-function-fallback)
        (counsel-register           . ivy-posframe-display-at-frame-bottom-window-center)
        (dmenu                      . ivy-posframe-display-at-frame-top-center)
        (nil                        . ivy-posframe-display))
      ivy-posframe-height-alist
      '((swiper . 20)
        (dmenu . 20)
        (t . 10)))

(use-package ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1))

(use-package ivy-rich
  :after ivy
  :init
  (ivy-rich-mode 1))

(use-package counsel
  :bind (("s-a" . 'counsel-switch-buffer)
         :map minibuffer-local-map
         :map minibuffer-local-map
         ("C-c r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (counsel-mode 1))
#+END_SRC

#+RESULTS:
: counsel-minibuffer-history

** IVY
#+begin_src emacs-lisp :tangle no
;;; Auto completion
;;;; Ivy-Counsel-Swiper
(use-package all-the-icons-ivy
  :init (add-hook 'after-init-hook 'all-the-icons-ivy-setup)
  :config
  (add-to-list 'all-the-icons-mode-icon-alist
               '('puppet-mode all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-extension-icon-alist
               '("pp" all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-extension-icon-alist
               '("epp" all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-blue))
  (add-to-list 'all-the-icons-extension-icon-alist
               '("erb" all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-orange))
  ;; Pending https://github.com/domtronn/all-the-icons.el/pull/267
  (add-to-list 'all-the-icons-mode-icon-alist
               '(exwm-mode
                 all-the-icons-octicon "browser"
                 :v-adjust 0.2 :face all-the-icons-purple)))

;;               ([C-return] . ivy-restrict-to-matches))
(use-package ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ;; ([C-return] . ivy-restrict-to-matches)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (defun my/ivy-switch-buffer-by-prefix (prefix)
    "Use ivy to select a buffer prefixed by PREFIX#."
    (minibuffer-with-setup-hook
        (lambda ()
          (insert (concat "^" prefix "# ")))
      (ivy-switch-buffer)))
  (defun my/ivy-switch-buffer-firefox ()
    "Use ivy to select a Firefox window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "F"))
  (defun my/ivy-switch-buffer-urxvt ()
    "Use ivy to select an URXVT window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "u"))
  (defun my/ivy-switch-buffer-detached-command ()
    "Use ivy to select a compilation buffer."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "d"))
  (setcdr (assoc t ivy-format-functions-alist) #'ivy-format-function-line)
  (ivy-mode 1)
  :custom
  (ivy-use-virtual-buffers 'recentf)
  (ivy-virtual-abbreviate 'abbreviate)
  (ivy-use-selectable-prompt t)
  (ivy-re-builders-alist '((t . ivy--regex-ignore-order))))

(use-package ivy-posframe
  :config
  (ivy-posframe-mode 1)
  (defun my/ivy-posframe-get-size ()
    (let ((height (or ivy-posframe-height ivy-height))
          (width (round (* .70 (frame-width)))))
      (list :height height :width width :min-height height :min-width width)))
  :custom
  (posframe-mouse-banish-function #'posframe-mouse-banish-simple)
  (ivy-posframe-display-functions-alist
   '((swiper . ivy-display-function-fallback)
     (t      . ivy-posframe-display)))
  (ivy-posframe-height-alist '((counsel-yank-pop . 40)
                               (t                . 20)))
  (ivy-posframe-size-function 'my/ivy-posframe-get-size))

(use-package all-the-icons-ivy-rich
  :init (all-the-icons-ivy-rich-mode 1))

(use-package ivy-rich
  :after (ivy counsel)
  :config
  (ivy-rich-mode 1)
  (ivy-rich-project-root-cache-mode)
  (ivy-rich-set-columns
   'counsel-find-file
   '((all-the-icons-ivy-rich-file-icon)
     (ivy-read-file-transformer)))
  (ivy-rich-set-columns
   'counsel-fzf
   '((all-the-icons-ivy-rich-file-icon)
     (all-the-icons-ivy-rich-file-name)))
  (ivy-rich-modify-columns
   'ivy-switch-buffer
   '((ivy-rich-switch-buffer-project (:width 30))
     (ivy-rich-switch-buffer-major-mode (:width 20)))))

(use-package amx
  :after (ivy)
  :custom
  (amx-backend 'ivy)
  (amx-history-length 50))

(use-package counsel
  ;; :after (helpful)
  :bind (("M-x" . counsel-M-x)
         ("s-a" . counsel-switch-buffer)
         ;; ("C-SPC" . counsel-M-x)
         ;; ("s-@" . consult-buffer)
         ("s-@" . ivy-switch-buffer)
         ("M-b" . ivy-switch-buffer-other-window)
         ("C-x f" . my/counsel-find-file-no-tramp)
         ("C-x F" . counsel-find-file)
         ("C-h v" . counsel-describe-variable)
         ("C-h f" . counsel-describe-function)
         ("C-h k" . helpful-key)
         ("C-x r b" . counsel-bookmark)
         ("M-y" . counsel-yank-pop))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (defun my/counsel-find-file-no-tramp (&optional initial-input initial-directory)
    (interactive)
    (if (string-prefix-p "/ssh:" default-directory)
        (counsel-find-file "" "~/")
      (counsel-find-file initial-input initial-directory)))
  ;; Pending https://github.com/abo-abo/swiper/pull/2844/
  (defun counsel--esh-dir-history-action-cd (pair)
    "Change the current working directory to the selection.
This function is the default action for `counsel-esh-dir-history'
and changes the working directory in Eshell to the selected
candidate which must be provided as the `car' of PAIR."
    (eshell/cd (car pair)))
  (defun counsel--esh-dir-history-action-edit (pair)
    "Insert the selection to the Eshell buffer prefixed by \"cd \".
This function is an action for `counsel-esh-dir-history' to
insert the selected directory (provided as the `car' of PAIR) to
the Eshell buffer prefixed by \"cd \", allowing the caller to
modify parts of the directory before switching to it."
    (insert (format "cd %s" (car pair))))
  (defun counsel-esh-dir-history ()
    "Use Ivy to browse Eshell's directory stack."
    (interactive)
    (require 'em-dirs)
    (defvar eshell-last-dir-ring)
    (ivy-read "Directory to change to: " (ivy-history-contents eshell-last-dir-ring)
              :keymap ivy-reverse-i-search-map
              :action #'counsel--esh-dir-history-action-cd
              :caller #'counsel-esh-dir-history))
  (ivy-set-actions
   'counsel-esh-dir-history
   '(("e" counsel--esh-dir-history-action-edit "edit")))
  (defun counsel-fzf-action (x)
    (with-ivy-window
      (let ((default-directory counsel--fzf-dir))
        (find-file-other-window x)))
    (other-window -1))
  :custom
  (counsel-yank-pop-separator "\n-------------------\n")
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
(use-package swiper
  :bind (("s-s" . swiper)
         ("s-C-s" . swiper-thing-at-point)))


#+end_src

#+RESULTS:
: swiper-thing-at-point

** IVY push and switch view
By default, Doom Emacs does not use 'SPC v', so the format I use for these bindings is 'SPC v' plus 'key'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("v" . "Ivy")
       :desc "Ivy push view" "v p" #'ivy-push-view
       :desc "Ivy switch view" "v s" #'ivy-switch-view))



#+END_SRC

#+RESULTS:
: ivy-switch-view

** Davivil ivy mode
#+begin_src emacs-lisp
;; Better Completions with Ivy
;; I currently use Ivy, Counsel, and Swiper to navigate around files, buffers, and projects super quickly. Here are some workflow notes on how to best use Ivy:

;; While in an Ivy minibuffer, you can search within the current results by using S-Space.
;; To quickly jump to an item in the minibuffer, use C-' to get Avy line jump keys.
;; To see actions for the selected minibuffer item, use M-o and then press the action's key.
;; Super useful: Use C-c C-o to open ivy-occur to open the search results in a separate buffer. From there you can click any item to perform the ivy action.

(use-package ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-f" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-r" . ivy-reverse-i-search-kill))
  ;; :init
  ;; (ivy-mode 1)
  :config
  (defun my/ivy-switch-buffer-by-prefix (prefix)
    "Use ivy to select a buffer prefixed by PREFIX#."
    (minibuffer-with-setup-hook
        (lambda ()
          (insert (concat "^" prefix "# ")))
      (ivy-switch-buffer)))
  (defun my/ivy-switch-buffer-firefox ()
    "Use ivy to select a Firefox window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "F"))
  (defun my/ivy-switch-buffer-urxvt ()
    "Use ivy to select an URXVT window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "u"))
  (defun my/ivy-switch-buffer-detached-command ()
    "Use ivy to select a compilation buffer."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "d"))

  (setcdr (assoc t ivy-format-functions-alist) #'ivy-format-function-line)
  ;; (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  (setq ivy-wrap t)
  (setq ivy-count-format "(%d/%d) ")
  (setq enable-recursive-minibuffers t)

  ;; Use different regex strategies per completion command
  (push '(completion-at-point . ivy--regex-fuzzy) ivy-re-builders-alist) ;; This doesn't seem to work...
  (push '(swiper . ivy--regex-ignore-order) ivy-re-builders-alist)
  (push '(counsel-M-x . ivy--regex-ignore-order) ivy-re-builders-alist)

  ;; Set minibuffer height for different commands
  (setf (alist-get 'counsel-projectile-ag ivy-height-alist) 15)
  (setf (alist-get 'counsel-projectile-rg ivy-height-alist) 15)
  (setf (alist-get 'swiper ivy-height-alist) 15)
  (setf (alist-get 'counsel-switch-buffer ivy-height-alist) 7))
  ;; (setf (alist-get '+default/search-emacsd ivy-height-alist) 7)
  ;; (setf (alist-get '+vertico/project-search-from-cwd ivy-height-alist) 7))
(use-package ivy-hydra
  :defer t
  :after hydra)

(use-package ivy-rich
  :init
  ;; (ivy-rich-mode 1)
  :after counsel
  :config
  (setq ivy-format-function #'ivy-format-function-line)
  (setq ivy-rich-display-transformers-list
        (plist-put ivy-rich-display-transformers-list
                   'ivy-switch-buffer
                   '(:columns
                     ((ivy-rich-candidate (:width 40))
                      (ivy-rich-switch-buffer-indicators (:width 4 :face error :align right)); return the buffer indicators
                      (ivy-rich-switch-buffer-major-mode (:width 12 :face warning))          ; return the major mode info
                      (ivy-rich-switch-buffer-project (:width 15 :face success))             ; return project name using `projectile'
                      (ivy-rich-switch-buffer-path (:width (lambda (x) (ivy-rich-switch-buffer-shorten-path x (ivy-rich-minibuffer-width 0.3))))))  ; return file path relative to project root or `default-directory' if project is nil
                     :predicate
                     (lambda (cand)
                       (if-let ((buffer (get-buffer cand)))
                           ;; Don't mess with EXWM buffers
                           (with-current-buffer buffer
                             (not (derived-mode-p 'exwm-mode)))))))))

(use-package counsel
  :demand t
  ;; :bind (("M-x" . counsel-M-x)
  ;;        ("C-c a" . counsel-ibuffer)
  ;;        ("C-x C-f" . counsel-find-file)
         ;; ("C-M-j" . counsel-switch-buffer)
         ;; ("C-c l" . counsel-imenu)
         ;; :map minibuffer-local-map
         ;; ("C-c r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (setq ivy-initial-inputs-alist nil) ;; Don't start searches with ^

  (defun my/counsel-find-file-no-tramp (&optional initial-input initial-directory)
    (interactive)
    (if (string-prefix-p "/ssh:" default-directory)
        (counsel-find-file "" "~/")
      (counsel-find-file initial-input initial-directory)))
  ;; Pending https://github.com/abo-abo/swiper/pull/2844/
  (defun counsel--esh-dir-history-action-cd (pair)
    "Change the current working directory to the selection.
This function is the default action for `counsel-esh-dir-history'
and changes the working directory in Eshell to the selected
candidate which must be provided as the `car' of PAIR."
    (eshell/cd (car pair)))
  (defun counsel--esh-dir-history-action-edit (pair)
    "Insert the selection to the Eshell buffer prefixed by \"cd \".
This function is an action for `counsel-esh-dir-history' to
insert the selected directory (provided as the `car' of PAIR) to
the Eshell buffer prefixed by \"cd \", allowing the caller to
modify parts of the directory before switching to it."
    (insert (format "cd %s" (car pair))))
  (defun counsel-esh-dir-history ()
    "Use Ivy to browse Eshell's directory stack."
    (interactive)
    (require 'em-dirs)
    (defvar eshell-last-dir-ring)
    (ivy-read "Directory to change to: " (ivy-history-contents eshell-last-dir-ring)
              :keymap ivy-reverse-i-search-map
              :action #'counsel--esh-dir-history-action-cd
              :caller #'counsel-esh-dir-history))
  (ivy-set-actions
   'counsel-esh-dir-history
   '(("e" counsel--esh-dir-history-action-edit "edit")))
  (defun counsel-fzf-action (x)
    (with-ivy-window
      (let ((default-directory counsel--fzf-dir))
        (find-file-other-window x)))
    (other-window -1))
  :custom
  (counsel-yank-pop-separator "\n-------------------\n")
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
(use-package swiper
  :bind (("C-s" . isearch-forward)
         ("C-M-s" . swiper-thing-at-point)))
;; (use-package flx  ;; Improves sorting for fuzzy-matched results
;;   :after ivy
;;   :defer t
;;   :init
;;   (setq ivy-flx-limit 10000))

;; (use-package wgrep)

;; (use-package ivy-posframe
;;   ;; :disabled
;;   :custom
;;   (ivy-posframe-width      115)
;;   (ivy-posframe-min-width  115)
;;   (ivy-posframe-height     10)
;;   (ivy-posframe-min-height 10)
;;   :config
;;   (setq ivy-posframe-display-functions-alist '((t . ivy-posframe-display-at-frame-center)))
;;   (setq ivy-posframe-parameters '((parent-frame . nil)
;;                                   (left-fringe . 8)
;;                                   (right-fringe . 8)))
;;   (ivy-posframe-mode nil))

;; (use-package prescient
;;   :after counsel
;;   :config
;;   (prescient-persist-mode 1))

;; (use-package ivy-prescient
;;   :after prescient
;;   :config
;;   (ivy-prescient-mode 1))

;; (dw/leader-key-def
;;   "r"   '(ivy-resume :which-key "ivy resume")
;;   "f"   '(:ignore t :which-key "files")
;;   "ff"  '(counsel-find-file :which-key "open file")
;;   "C-f" 'counsel-find-file
;;   "fr"  '(counsel-recentf :which-key "recent files")
;;   "fR"  '(revert-buffer :which-key "revert file")
;;   "fj"  '(counsel-file-jump :which-key "jump to file"))
#+end_src

#+RESULTS:
: swiper-thing-at-point

** corfu
#+begin_src emacs-lisp
(use-package corfu
  ;; :straight '(corfu :host github
  ;;                   :repo "minad/corfu")
  :bind (:map corfu-map
         ("C-j" . corfu-next)
         ("C-k" . corfu-previous)
         ("C-f" . corfu-insert))
  :custom
  (corfu-cycle t)
  :config
  (corfu-global-mode))
;; (load "setup-corfu")

#+end_src
* hydra
** Hydra
#+begin_src emacs-lisp
(use-package hydra
  ;; :ensure t
  :defer 0.1
  :init
  (bind-key "\\" 'hydra-master/body)
  :config
  (setq lv-use-separator t)
  (set-face-attribute 'hydra-face-blue nil :foreground "deep sky blue" :weight 'bold)

  (eval-and-compile
    (defhydra hydra-common (:color blue)
      ("<ESC>" nil "quit")))

  (defhydra hydra-master (:color blue :idle 0.4)
    "
                                                                       ╭───────┐
                                                                       │ Index │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_a_] bookmarks    [^h^]               [_o_] organization  [^v^]
  [_b_] buffers      [_i_] internet      [_p_] project       [_w_] window
  [_c_] flycheck     [_j_] jump          [_q_] exit          [_x_] shell
  [_d_] development  [_k_] spell         [_r_] register      [^y^]
  [_e_] emacs        [_l_] lisp          [_s_] search        [^z^]
  [_f_] file         [_m_] media         [_t_] text
  [_g_] git          [_n_] narrow        [^u^]
--------------------------------------------------------------------------------
    "
    ("<SPC>" joe-alternate-buffers "alternate buffers")
    ("<ESC>" nil "quit")
    ("\\" (insert "\\") "\\")
    ("a"     hydra-bookmarks/body nil)
    ("b"     hydra-buffers/body nil)
    ("c"     hydra-flycheck/body nil)
    ("d"     hydra-development/body nil)
    ("e"     hydra-emacs/body nil)
    ("f"     hydra-file/body nil)
    ("g"     hydra-git/body nil)
    ("i"     hydra-internet/body nil)
    ("j"     hydra-jump/body nil)
    ("k"     hydra-spell/body nil)
    ("l"     hydra-lisp/body nil)
    ("m"     hydra-media/body nil)
    ("n"     hydra-narrow/body nil)
    ("o"     hydra-organization/body nil)
    ("p"     hydra-project/body nil)
    ("q"     hydra-exit/body nil)
    ("r"     hydra-register/body nil)
    ("s"     hydra-search/body nil)
    ("t"     hydra-text/body nil)
    ("w"     ace-window nil)
    ("x"     hydra-system/body nil))

  (defhydra hydra-bookmarks (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
    "
                                                                   ╭───────────┐
       List                          Do                            │ Bookmarks │
╭──────────────────────────────────────────────────────────────────┴───────────╯
  [_l_] list bookmarks            [_j_] jump to a bookmark
   ^ ^                            [_m_] set bookmark at point
   ^ ^                            [_s_] save bookmarks
--------------------------------------------------------------------------------
    "
    ("l" consult-bookmark)
    ("j" bookmark-jump)
    ("m" bookmark-set)
    ("s" bookmark-save))

  (defhydra hydra-buffers (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
    "
                                                                     ╭─────────┐
  Switch                 Do                                          │ Buffers │
╭────────────────────────────────────────────────────────────────────┴─────────╯
  [_b_] switch             [_d_] kill the buffer
  [_i_] ibuffer            [_r_] toggle read-only mode
  [_a_] alternate          [_u_] revert buffer changes
   ^ ^                     [_w_] save buffer
--------------------------------------------------------------------------------
    "
    ("a" joe-alternate-buffers)
    ;; ("b" ivy-switch-buffer)
    ("b" consult-buffer)
    ("d" kill-this-buffer)
    ("i" ibuffer)
    ("r" read-only-mode)
    ("u" joe-revert-buffer)
    ("w" save-buffer))

    (defhydra hydra-flycheck (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                    ╭──────────┐
   Navigate          Show Errors                  Do                │ Flycheck │
╭───────────────────────────────────────────────────────────────────┴──────────╯
   ^_p_^revious     [_l_] list errors           [_t_] toggle Flycheck
      ^^↑^^         [_d_] clear all errors      [_c_] select checker
    ^_f_^irst        ^ ^                        [_r_] run via compile
      ^^↓^^          ^ ^                        [_h_] describe checker
    ^_n_^ext
--------------------------------------------------------------------------------
      "
      ("c" flycheck-select-checker)
      ("h" flycheck-describe-checker)
      ("d" flycheck-clear)
      ("f" flycheck-first-error)
      ("l" flycheck-list-errors)
      ("n" flycheck-next-error :color red)
      ("p" flycheck-previous-error :color red)
      ("r" flycheck-compile)
      ("t" flycheck-mode))

    (defhydra hydra-development (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                 ╭─────────────┐
     Code                   Web                 Quickrun         │ Development │
╭────────────────────────────────────────────────────────────────┴─────────────╯
  [_d_] search docs (at point) [_c_] Web Colors          [_q_] buffer
   ^ ^                         [_h_] HTTP header         [_v_] region
   ^ ^                         [_m_] HTTP method         [_x_] shell
   ^ ^                         [_r_] HTTP relation       [_p_] with arg
   ^ ^                         [_s_] HTTP status code    [_o_] only compile
   ^ ^                         [_t_] Media types         [_R_] replace
   ^ ^                         [_g_] RESTclient          [_e_] eval/print
   ^ ^                         [_f_] RFC doc
  [_l_] lines of code          [_F_] RFC index
--------------------------------------------------------------------------------
      "
      ("d" devdocs-search)
      ("c" counsel-colors-web)
      ("g" restclient-mode)
      ("f" irfc-visit)
      ("F" irfc-index)
      ("q" quickrun)
      ("v" quickrun-region)
      ("x" quickrun-shell)
      ("p" quickrun-with-arg)
      ("o" quickrun-compile-only)
      ("R" quickrun-replace-region)
      ("e" quickrun-eval-print)
      ("h" http-header)
      ("m" http-method)
      ("r" http-relation)
      ("s" http-status-code)
      ("t" media-type)
      ("l" cloc))

  (defhydra hydra-emacs (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                       ╭───────┐
   Execute       Packages         Help                     Misc        │ Emacs │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_x_] counsel M-x [_p_] list      [_f_] describe function [_t_] change theme
   ^ ^              [_i_] install   [_v_] describe variable [_l_] list emacs process
   ^ ^              [_u_] upgrade   [_m_] info manual       [_c_] init time
   ^ ^               ^ ^            [_k_] bindings          [_e_] benchmark init
   ^ ^               ^ ^            [_b_] personal bindings [_o_] unbound commands
   ^ ^               ^ ^             ^ ^                    [_y_] emacs colors
   ^ ^               ^ ^             ^ ^                    [_z_] list faces
--------------------------------------------------------------------------------
      "
      ("C-h b" counsel-descbinds "bindings")
      ("f" counsel-describe-function)
      ("v" counsel-describe-variable)
      ("b" describe-personal-keybindings)
      ("c" emacs-init-time)
      ("i" package-install)
      ("k" counsel-descbinds)
      ("l" list-processes)
      ("m" info-display-manual)
      ("p" paradox-list-packages)
      ("t" counsel-load-theme)
      ("u" paradox-upgrade-packages)
      ("e" esup)
      ("o" smex-show-unbound-commands)
      ("y" counsel-colors-emacs)
      ("z" counsel-faces)
      ("x" counsel-M-x))

  (defhydra hydra-file (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
     Ivy                    Dired        Ztree                          │ File │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_o_] open file        [_d_] dired         [_z_] diff dirs
  [_e_] open file extern [_r_] ranger
--------------------------------------------------------------------------------
      "
      ("o" counsel-find-file)
      ("e" counsel-find-file-extern)
      ("z" ztree-diff)
      ("d" dired)
      ("r" ranger))


  (defhydra hydra-text (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
 Size  Toggle              Unicode                        Do            │ Text │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  _k_  [_f_] fill column     [_d_] unicode character           [_a_] align with regex
  ^↑^  [_h_] hidden chars    [_e_] evil digraphs table         [_w_] remove trailing ' '
  ^ ^  [_l_] line numbers    [_s_] specific code block         [_n_] count words
  ^↓^  [_t_] trailing ' '    [_u_] unicode character           [_i_] lorem ipsum
  _j_  [_v_] font space      [_p_] character code              [_x_] comment box
  ^ ^  [_c_] comment          ^ ^                              [_q_] boxquote
  ^ ^  [_b_] multibyte chars  ^ ^                              [_m_] iedit (multiple)
  ^ ^   ^ ^                   ^ ^                              [_r_] expand region
  ^ ^   ^ ^                   ^ ^                              [_U_] tabs to spaces
--------------------------------------------------------------------------------
      "
      ("a" align-regexp)
      ("b" toggle-enable-multibyte-characters)
      ("c" comment-line)
      ("d" insert-char)
      ("e" evil-ex-show-digraphs)
      ("f" fci-mode)
      ("h" whitespace-mode)
      ("i" lorem-ipsum-insert-paragraphs)
      ("k" text-scale-increase :color red)
      ("j" text-scale-decrease :color red)
      ("l" linum-mode)
      ("n" count-words)
      ("m" iedit)
      ("p" describe-char)
      ("r" er/expand-region)
      ("s" charmap)
      ("t" joe-toggle-show-trailing-whitespace)
      ("u" counsel-unicode-char)
      ("v" variable-pitch-mode)
      ("w" whitespace-cleanup)
      ("U" untabify)
      ("q" hydra-boxquote/body)
      ("x" comment-box))

  (defhydra hydra-git (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                         ╭─────┐
   Magit                          VC                    Timemachine      │ Git │
╭────────────────────────────────────────────────────────────────────────┴─────╯
  [_s_] status              [_d_] diffs between revisions  [_t_] timemachine
  [_B_] blame mode          [_b_] edition history
  [_l_] file log
--------------------------------------------------------------------------------
      "
      ("B" magit-blame-mode)
      ("b" vc-annotate)
      ("d" vc-diff)
      ("l" magit-file-log)
      ("s" magit-status)
      ("t" git-timemachine))

  (defhydra hydra-internet (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                    ╭──────────┐
    Browse       Search              Social               Post      │ Internet │
╭───────────────────────────────────────────────────────────────────┴──────────╯
  [_w_] eww      [_b_] DuckDuckGo       [_f_] elfeed            [_i_] imgur
  [_u_] url      [_e_] DuckDuckGo (eww) [_x_] stack overflow
   ^ ^           [_m_] google maps
   ^ ^           [_d_] wordnik
--------------------------------------------------------------------------------
      "
      ("w" eww)
      ("u" browse-url-at-point)
      ("b" (joe-duckduckgo-search t))
      ("e" (joe-duckduckgo-search nil))
      ("m" google-maps)
      ("d" define-word-at-point)
      ("f" elfeed)
      ("x" sx-tab-newest)
      ("i" imgur-post))

  (defhydra hydra-jump (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
  Window          Word/Char        Line         iSearch                 │ Jump │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_w_] jump        [_j_] word         [_l_] jump     [_i_] jump
  [_d_] close       [_p_] all words    [_y_] copy
  [_z_] maximize    [_b_] subword      [_m_] move
  [_s_] swap        [_c_] char         [_v_] copy region
   ^ ^              [_a_] two chars
--------------------------------------------------------------------------------
      "
      ("w" ace-window)
      ("d" ace-delete-window)
      ("z" ace-maximize-window)
      ("s" ace-swap-window)
      ("j" avy-goto-word-1)
      ("p" avy-goto-word-0)
      ("b" avy-goto-subword-0)
      ("c" avy-goto-char)
      ("a" avy-goto-char-2)
      ("l" avy-goto-line)
      ("y" avy-copy-line)
      ("m" avy-move-line)
      ("v" avy-copy-region)
      ("i" avy-isearch))

  (defhydra hydra-spell (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                       ╭───────┐
    Flyspell               Ispell                      Gtranslate      │ Spell │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_k_] correct word       [_w_] check word            [_g_] en ⇆ es
  [_n_] next error         [_t_] toggle dictionary     [_G_] any lang
  [_f_] toggle flyspell    [_d_] change dictionary
  [_p_] toggle prog mode
--------------------------------------------------------------------------------
      "
      ("w" ispell-word)
      ("d" ispell-change-dictionary)
      ("t" joe-switch-dictionary)
      ("g" google-translate-smooth-translate)
      ("G" google-translate-query-translate)
      ("f" flyspell-mode)
      ("p" flyspell-prog-mode)
      ("k" flyspell-correct-word-generic)
      ("n" flyspell-goto-next-error))

  (defhydra hydra-lisp (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
    Elisp              Bug hunter                                       │ Lisp │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_r_] eval region    [_f_] file
  [_s_] eval sexp      [_i_] init-file
  [_b_] eval buffer
--------------------------------------------------------------------------------
      "
      ("f" bug-hunter-file)
      ("i" bug-hunter-init-file)
      ("r" eval-region)
      ("b" eval-buffer)
      ("s" eval-last-sexp))

  (defhydra hydra-narrow (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                      ╭────────┐
    Narrow                                                            │ Narrow │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_f_] narrow to defun
  [_p_] narrow to page
  [_r_] narrow to region
  [_w_] widen
--------------------------------------------------------------------------------
      "
      ("f" narrow-to-defun)
      ("p" narrow-to-page)
      ("r" narrow-to-region)
      ("w" widen))

  (defhydra hydra-project (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                  ╭────────────┐
  Files             Search          Buffer             Do         │ Projectile │
╭─────────────────────────────────────────────────────────────────┴────────────╯
  [_f_] file          [_a_] ag          [_b_] switch         [_g_] magit
  [_l_] file dwim     [_A_] grep        [_v_] show all       [_p_] commander
  [_r_] recent file   [_s_] occur       [_V_] ibuffer        [_i_] info
  [_d_] dir           [_S_] replace     [_K_] kill all
  [_o_] other         [_t_] find tag
  [_u_] test file     [_T_] make tags
  [_h_] root
                                                                      ╭────────┐
  Other Window      Run             Cache              Do             │ Fixmee │
╭──────────────────────────────────────────────────╯ ╭────────────────┴────────╯
  [_F_] file          [_U_] test        [_kc_] clear         [_x_] TODO & FIXME
  [_L_] dwim          [_m_] compile     [_kk_] add current   [_X_] toggle
  [_D_] dir           [_c_] shell       [_ks_] cleanup
  [_O_] other         [_C_] command     [_kd_] remove
  [_B_] buffer
--------------------------------------------------------------------------------
      "
      ("a"   projectile-ag)
      ("A"   projectile-grep)
      ("b"   projectile-switch-to-buffer)
      ("B"   projectile-switch-to-buffer-other-window)
      ("c"   projectile-run-async-shell-command-in-root)
      ("C"   projectile-run-command-in-root)
      ("d"   projectile-find-dir)
      ("D"   projectile-find-dir-other-window)
      ("f"   projectile-find-file)
      ("F"   projectile-find-file-other-window)
      ("g"   projectile-vc)
      ("h"   projectile-dired)
      ("i"   projectile-project-info)
      ("kc"  projectile-invalidate-cache)
      ("kd"  projectile-remove-known-project)
      ("kk"  projectile-cache-current-file)
      ("K"   projectile-kill-buffers)
      ("ks"  projectile-cleanup-known-projects)
      ("l"   projectile-find-file-dwim)
      ("L"   projectile-find-file-dwim-other-window)
      ("m"   projectile-compile-project)
      ("o"   projectile-find-other-file)
      ("O"   projectile-find-other-file-other-window)
      ("p"   projectile-commander)
      ("r"   projectile-recentf)
      ("s"   projectile-multi-occur)
      ("S"   projectile-replace)
      ("t"   projectile-find-tag)
      ("T"   projectile-regenerate-tags)
      ("u"   projectile-find-test-file)
      ("U"   projectile-test-project)
      ("v"   projectile-display-buffer)
      ("V"   projectile-ibuffer)
      ("X"   fixmee-mode)
      ("x"   fixmee-view-listing))

  (defhydra hydra-exit (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
   Quit                                                                 │ Exit │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_c_] exit emacs (standalone or client)
  [_s_] shutdown the emacs daemon
--------------------------------------------------------------------------------
      "
      ("c" save-buffers-kill-terminal)
      ("s" save-buffers-kill-emacs))

  (defhydra hydra-register (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                    ╭──────────┐
   Logs                        Registers                Undo        │ Register │
╭───────────────────────────────────────────────────────────────────┴──────────╯
  [_c_] commands history       [^e^] emacs registers    [_u_] undo tree
  [_o_] messages               [_r_] evil registers
  [_l_] lossage (keystrokes)   [_m_] evil marks
  [_d_] diff buffer with file  [_k_] kill ring
--------------------------------------------------------------------------------
      "
      ("d" joe-diff-buffer-with-file)
      ("k" counsel-yank-pop)
      ("l" view-lossage)
      ("c" counsel-command-history)
      ("m" evil-show-marks)
      ("o" view-echo-area-messages)
      ("r" evil-show-registers)
      ("u" undo-tree-visualize))

  (defhydra hydra-search (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                      ╭────────┐
   Files                             Buffer                           │ Search │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_a_] regex search (Ag)           [_b_] by word
  [_r_] regex search (rg)           [_o_] by word (opened buffers)
  [_p_] regex search (pt)           [_w_] by word (multi)
  [_g_] regex search (grep)         [_h_] by word (grep or swiper)
  [^f^] find                        [_t_] tags & titles
  [_l_] locate                      [_s_] semantic
--------------------------------------------------------------------------------
      "
      ("a" (let ((current-prefix-arg "-."))
             (call-interactively 'counsel-ag)))
      ("r" (let ((current-prefix-arg "-."))
             (call-interactively 'counsel-rg)))
      ("p" (let ((current-prefix-arg "-."))
             (call-interactively 'counsel-pt)))
      ("g" rgrep)
      ("l" counsel-locate)
      ("b" swiper)
      ("o" swiper-all)
      ("h" counsel-grep-or-swiper)
      ("t" counsel-imenu)
      ("s" counsel-semantic)
      ("w" swiper-multi))

  (defhydra hydra-system (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                      ╭────────┐
   Terminals                     System                               │ System │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_s_] new multi-term           [_c_] shell command
  [_n_] next multi-term          [_a_] aync shell command
  [_p_] previous multi-term      [_m_] man page
  [_d_] dedicated multi-term     [_l_] list system process
  [_e_] eshell
--------------------------------------------------------------------------------
      "
      ("a" async-shell-command)
      ("c" shell-command)
      ("e" eshell)
      ("m" man)
      ("l" proced)
      ("s" multi-term)
      ("n" multi-term-next)
      ("p" multi-term-previous)
      ("d" multi-term-dedicated-toggle))

  (defhydra hydra-media (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                       ╭───────┐
   Mingus              Mpd                     Volume                  │ Media │
╭──────────────────────────────────────────────────────────────────────┴───────╯
 [_m_] mingus         [_n_] next song          [_-_] volume down
 [_f_] search         [_p_] previous song      [_+_] volume up
 [_l_] playlist       [_c_] clear playlist
 [_a_] All            [_t_] pause
  ^ ^                 [_s_] stop
  ^ ^                 [_d_] start daemon
--------------------------------------------------------------------------------
      "
      ("m" mingus)
      ("f" mingus-search)
      ("c" mingus-clear)
      ("n" mingus-next)
      ("p" mingus-prev)
      ("t" mingus-toggle)
      ("s" mingus-stop)
      ("d" mingus-start-daemon)
      ("l" mingus-load-playlist)
      ("a" mingus-load-all)
      ("-" mingus-vol-down)
      ("\+" mingus-vol-up))

  (defhydra hydra-organization (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                ╭──────────────┐
     Tasks            Org mode               Comms      Others  │ Organization │
╭───────────────────────────────────────────────────────────────┴──────────────╯
  [_a_] agenda      [_c_] capture             [_m_] mail      [_x_] speed type
  [_l_] agenda list [_p_] pomodoro            [_t_] contacts
  [_d_] calendar    [_s_] search headings     [_h_] add location
   ^ ^              [_g_] open location gmaps
   ^ ^              [_f_] archive subtree
--------------------------------------------------------------------------------
      "
      ("a" org-agenda)
      ("c" org-capture)
      ("s" counsel-org-agenda-headlines)
      ("d" cfw:open-org-calendar)
      ("g" org-location-google-maps)
      ("h" org-address-google-geocode-set)
      ("l" org-agenda-list)
      ("f" org-archive-subtree)
      ("m" mu4e)
      ("p" org-pomodoro)
      ("t" org-contacts)
      ("x" speed-type-text))

   (defhydra hydra-leader ( :color blue :hint nil :idle 0.4)
       "
                                                                      ╭────────┐
   Toggle                        Do                                   │ Leader │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_c_] comment                  [_a_] align with regex
  [_f_] fill column              [_p_] show character code
  [_h_] hidden chars             [_i_] insert unicode character
  [_e_] trailing whitespace      [_<SPC>_] remove trailing whitespaces
  [_v_] font space               [_u_] undo tree
   ^ ^                           [_j_] jump word
   ^ ^                           [_x_] comment box
   ^ ^                           [_r_] expand region
   ^ ^                           [_m_] iedit (multiple edit)
   ^ ^                           [_g_] google translate
   ^ ^                           [_s_] swiper
   ^ ^                           [_t_] counsel imenu
   ^ ^                           [_q_] quick-calc
--------------------------------------------------------------------------------
      "
      ("<escape>" nil "quit")
      ("a" align-regexp)
      ("c" comment-line)
      ("r" er/expand-region)
      ("f" fci-mode)
      ("g" google-translate-smooth-translate)
      ("h" whitespace-mode)
      ("i" counsel-unicode-char)
      ("j" avy-goto-word-1)
      ("m" iedit-mode)
      ("n" count-words)
      ("p" describe-char)
      ("e" joe-toggle-show-trailing-whitespace)
      ("u" undo-tree-visualize)
      ("v" variable-pitch-mode)
      ("<SPC>" whitespace-cleanup)
      ("s" joe-swiper)
      ("t" counsel-imenu)
      ("q" (quick-calc t))
      ("x" comment-box)))
#+end_src

#+RESULTS:
: t

** pdf-tool
#+begin_src emacs-lisp
(use-package pdf-tools
  ;; :ensure t
  :config
  (pdf-tools-install)
  (setq-default pdf-view-display-size 'fit-page
                pdf-view-use-imagemagick t
                pdf-view-midnight-colors '("white smoke" . "gray5"))
  (bind-keys :map pdf-view-mode-map
      ("\\" . hydra-pdftools/body)
      ("<s-spc>" .  pdf-view-scroll-down-or-next-page)
      ("g"  . pdf-view-first-page)
      ("G"  . pdf-view-last-page)
      ("l"  . image-forward-hscroll)
      ("h"  . image-backward-hscroll)
      ("j"  . pdf-view-next-line-or-next-page)
      ("k"  . pdf-view-previous-line-or-previous-page)
      ("e"  . pdf-view-goto-page)
      ("t"  . pdf-view-goto-label)
      ("u"  . pdf-view-revert-buffer)
      ("al" . pdf-annot-list-annotations)
      ("ad" . pdf-annot-delete)
      ("aa" . pdf-annot-attachment-dired)
      ("am" . pdf-annot-add-markup-annotation)
      ("at" . pdf-annot-add-text-annotation)
      ("y"  . pdf-view-kill-ring-save)
      ("i"  . pdf-misc-display-metadata)
      ("s"  . pdf-occur)
      ("b"  . pdf-view-set-slice-from-bounding-box)
      ("r"  . pdf-view-reset-slice))

  (when (package-installed-p 'hydra)
    (bind-keys :map pdf-view-mode-map
               ("\\" . hydra-pdftools/body))
    (defhydra hydra-pdftools (:color blue :hint nil)
        "
                                                                      ╭───────────┐
       Move  History   Scale/Fit     Annotations  Search/Link    Do   │ PDF Tools │
   ╭──────────────────────────────────────────────────────────────────┴───────────╯
      ^^^_g_^^^       _B_    ^↧^    _+_    ^ ^     [_al_] list    [_s_] search      [_u_] revert buffer
      ^^^^↑^^^^       ^↑^    _H_    ^↑^  ↦ _W_ ↤   [_am_] markup  [_o_] outline     [_i_] info
      ^^^_p_^^^       ^ ^    ^↥^    _0_    ^ ^     [_at_] text    [_F_] link        [_d_] midgnight mode
      ^^^^↑^^^^       ^↓^  ╭─^─^─┐  ^↓^  ╭─^ ^─┐   [_ad_] delete  [_f_] search link [_D_] print mode
 _h_ ← _e_/_t_ → _l_  _N_  │ _P_ │  _-_    _b_     [_aa_] dired
      ^^^^↓^^^^       ^ ^  ╰─^─^─╯  ^ ^  ╰─^ ^─╯   [_y_]  yank
      ^^^_n_^^^       ^ ^  _r_eset slice box
      ^^^^↓^^^^
      ^^^_G_^^^
   --------------------------------------------------------------------------------
        "
        ("\\" hydra-master/body "back")
        ("<ESC>" nil "quit")
        ("al" pdf-annot-list-annotations)
        ("ad" pdf-annot-delete)
        ("aa" pdf-annot-attachment-dired)
        ("am" pdf-annot-add-markup-annotation)
        ("at" pdf-annot-add-text-annotation)
        ("y"  pdf-view-kill-ring-save)
        ("+" pdf-view-enlarge :color red)
        ("-" pdf-view-shrink :color red)
        ("0" pdf-view-scale-reset)
        ("H" pdf-view-fit-height-to-window)
        ("W" pdf-view-fit-width-to-window)
        ("P" pdf-view-fit-page-to-window)
        ("n" pdf-view-next-page-command :color red)
        ("p" pdf-view-previous-page-command :color red)
        ("d" pdf-view-midnight-minor-mode)
        ("D" pdf-view-printer-minor-mode)
        ("b" pdf-view-set-slice-from-bounding-box)
        ("r" pdf-view-reset-slice)
        ("g" pdf-view-first-page)
        ("G" pdf-view-last-page)
        ("e" pdf-view-goto-page)
        ("t" pdf-view-goto-label)
        ("o" pdf-outline)
        ("s" pdf-occur)
        ("i" pdf-misc-display-metadata)
        ("u" pdf-view-revert-buffer)
        ("F" pdf-links-action-perfom)
        ("f" pdf-links-isearch-link)
        ("B" pdf-history-backward :color red)
        ("N" pdf-history-forward :color red)
        ("l" image-forward-hscroll :color red)
        ("h" image-backward-hscroll :color red)))

   (use-package org-pdfview
     :ensure t))
#+end_src

** karthydra
#+begin_src emacs-lisp :tangle no

;; ** HYDRAS
;;;----------------------------------------------------------------
(use-package hydra
  :defer
  :ensure t
  :config
  (with-eval-after-load 'ediff
    (defhydra hydra-ediff (:color blue :hint nil)
      "
^Buffers           Files           VC                     Ediff regions
----------------------------------------------------------------------
_b_uffers           _f_iles (_=_)       _r_evisions              _l_inewise
_B_uffers (3-way)   _F_iles (3-way)                          _w_ordwise
                  _c_urrent file
"
      ("b" ediff-buffers)
      ("B" ediff-buffers3)
      ("=" ediff-files)
      ("f" ediff-files)
      ("F" ediff-files3)
      ("c" ediff-current-file)
      ("r" ediff-revision)
      ("l" ediff-regions-linewise)
      ("w" ediff-regions-wordwise)))

  (with-eval-after-load 'smerge-mode
    (defhydra hydra-smerge
      (:color pink :hint nil :post (smerge-auto-leave))
      "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
      ("n" smerge-next)
      ("p" smerge-prev)
      ("b" smerge-keep-base)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("RET" smerge-keep-current)
      ("\C-m" smerge-keep-current)
      ("<" smerge-diff-base-upper)
      ("=" smerge-diff-upper-lower)
      (">" smerge-diff-base-lower)
      ("R" smerge-refine)
      ("E" smerge-ediff)
      ("C" smerge-combine-with-next)
      ("r" smerge-resolve)
      ("k" smerge-kill-current)
      ("ZZ" (lambda ()
              (interactive)
              (save-buffer)
              (bury-buffer))
       "Save and bury buffer" :color blue)
      ("q" nil "cancel" :color blue)))

  (with-eval-after-load 'outline
    (defhydra hydra-outline (:color pink :hint nil)
      "
^Hide^             ^Show^           ^Move
^^^^^^------------------------------------------------------
_q_: sublevels     _a_: all         _u_: up
_t_: body          _e_: entry       _n_: next visible
_o_: other         _i_: children    _p_: previous visible
_c_: entry         _k_: branches    _f_: forward same level
_l_: leaves        _s_: subtree     _b_: backward same level
_d_: subtree

"
      ;; Hide
      ("q" outline-hide-sublevels)    ; Hide everything but the top-level headings
      ("t" outline-hide-body)         ; Hide everything but headings (all body lines)
      ("o" outline-hide-other)        ; Hide other branches
      ("c" outline-hide-entry)        ; Hide this entry's body
      ("l" outline-hide-leaves)       ; Hide body lines in this entry and sub-entries
      ("d" outline-hide-subtree)      ; Hide everything in this entry and sub-entries
      ;; Show
      ("a" outline-show-all)          ; Show (expand) everything
      ("e" outline-show-entry)        ; Show this heading's body
      ("i" outline-show-children)     ; Show this heading's immediate child sub-headings
      ("k" outline-show-branches)     ; Show all sub-headings under this heading
      ("s" outline-show-subtree)      ; Show (expand) everything in this heading & below
      ;; Move
      ("u" outline-up-heading)                ; Up
      ("n" outline-next-visible-heading)      ; Next
      ("p" outline-previous-visible-heading)  ; Previous
      ("f" outline-forward-same-level)        ; Forward - same level
      ("b" outline-backward-same-level)       ; Backward - same level
      ("z" nil "leave")))

  :general
  (:keymaps 'smerge-mode-map
            "C-c s" 'hydra-smerge/body)
  (:keymaps 'space-menu-window-map
            "u" '(hydra-winner/body
                  :wk "winner-mode"))
  (:states '(motion)
           "C-w u" 'hydra-winner/body)
  ("C-c <tab>" 'hydra-outline/body)
  (:keymaps 'space-menu-map
            "t" 'hydra-toggle-menu/body)
  (:keymaps 'space-menu-map
            :prefix "f"
            "=" 'hydra-ediff/body))
#+end_src

#+RESULTS:

** git-time-machine
#+begin_src emacs-lisp :tangle no
(use-package git-timemachine
  ;; :ensure t
  :commands git-timemachine
  :config
  (progn
    (bind-keys :map git-timemachine-mode
               ("c" . git-timemachine-show-current-revision)
               ("b" . git-timemachine-switch-branch))
    (when (package-installed-p 'hydra)
        (bind-keys :map git-timemachine-mode
                ("\\" . hydra-timemachine/body))
        (defhydra hydra-timemachine (:hint nil :color blue)
                "
                                                                        ╭──────────────────┐
              Rev.   Do                                                 │ Git time-machine │
            ╭───────────────────────────────────────────────────────────┴──────────────────╯
              _n_      [_w_] abbrv hash
              ^↑^      [_W_] full hash
              ^|^      [_g_] go to revision
              ^↓^      [_c_] show current
              _p_      [_b_] switch branch
              ^ ^      [_q_] quit
            --------------------------------------------------------------------------------
                "
                ("\\" hydra-master/body "back")
                ("<ESC>" nil "quit")
                ("q"       git-timemachine-quit)
                ("n"       git-timemachine-show-next-revision)
                ("p"       git-timemachine-show-previous-revision)
                ("g"       git-timemachine-show-nth-revision)
                ("c"       git-timemachine-show-current-revision)
                ("w"       git-timemachine-kill-abbreviated-revision)
                ("W"       git-timemachine-kill-revision)
                ("b"       git-timemachine-switch-branch)))
    (defadvice git-timemachine-mode (after toggle-evil activate)
      "Turn off `evil-local-mode' when enabling `git-timemachine-mode',
      and turn it back on when disabling `git-timemachine-mode'."
      (evil-local-mode (if git-timemachine-mode -1 1)))))
#+end_src

* Avy
** general avy
I definitely need to use it more. It allows to quickly jump around, both in the same and in other buffers.

The =avy= package by Oleh Krehel lets you select a location on the screen
to move the cursor to.  It does so by producing an overlay with
characters that need to be typed to specify the location.  By default,
the overlay covers the candidate, though I change the =avy-style= to have
it appear as a prefix instead.

There are several commands on offer which narrow down the candidates.
My favourite is =avy-goto-char-timer= (closely followed by =avy-goto-char-2=
and =avy-goto-word-1=).  It prompts for a character and then has a time
window lasting =avy-timeout-seconds= during which it can read more
characters.  Once Avy receives the input, it overlays every word that
contains those characters in succession.  If there is a single match, it
jumps directly to it.

Avy has the ability to act on the candidate rather than simply jump to
it.  Karthik Chikmagalur has a comprehensive essay on the matter, which
I consider essential reading for anyone wanting to make best use of this
package: [[https://karthinks.com/software/avy-can-do-anything/][Avy can do anything]] (2021-10-21).  I still am not sure whether
I need all that power though, as in my workflow I jump to a point and
then invoke =embark-act= (see [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions (embark.el)]]).

Finally, we can use Avy to select a candidate from the =*Completions*=
buffer (see [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

#+begin_src emacs-lisp :tangle no

(use-package avy
  :config
  (setq avy-all-windows nil) ; only the current window
  (setq avy-all-windows-alt t) ; all windows with C-u
  (setq avy-single-candidate-jump t)
  (setq avy-background nil)
  (setq avy-case-fold-search nil) ; case is significant
  (setq avy-timeout-seconds 0.5)
  (setq avy-style 'pre) ; prefixes candidate; otherwise use `at-full'
  ;; (define-key global-map (kbd "C-.") #'avy-goto-char-timer))
  :bind (("C-c s" . avy-goto-char-timer)
        ("M-g c" . avy-goto-char)
         ("M-g C" . avy-goto-char-2)
         ("M-g w" . avy-goto-word-1)
         ("M-g f" . avy-goto-line)
         :map isearch-mode-map
         ("C-'" . avy-isearch))

  :custom
  (avy-keys '(?h ?a ?t ?e ?i ?s ?c ?n))
  (avy-dispatch-alist
   '((?k . avy-action-kill-move)
     (?K . avy-action-kill-stay)
     (?t . avy-action-teleport)
     (?m . avy-action-mark)
     (?w . avy-action-copy)
     (?y . avy-action-yank)
     (?Y . avy-action-yank-Line)
     (?z . avy-action-zap-to-char)))
            (avy-background t)
            (avy-all-windows t)
            (avy-style 'at-full)
            (avy-case-fold-search nil)
  (avy-single-candidate-jump t))
#+end_src

#+RESULTS:
: avy-isearch

** pro avy
#+begin_src emacs-lisp
;; ** AVY
;;;----------------------------------------------------------------
(use-package avy
  :ensure t
  :commands (avy-goto-word-1 avy-goto-char-2 avy-goto-char-timer)
  :config
  (setq avy-timeout-seconds 0.24)
  (setq avy-keys '(?a ?s ?d ?f ?g ?j ?l ;?x
                   ?v ?b ?n ?, ?/ ?u ?p ?e ?.
                   ?c ?q ?2 ?3 ?' ?\;))
  (setq avy-dispatch-alist '((?m . avy-action-mark)
                             (?  . avy-action-mark-to-char)
                             (?i . avy-action-ispell)
                             (?z . avy-action-zap-to-char)
                             (?o . avy-action-embark)
                             (?= . avy-action-define)
                             (67108925 . avy-action-tuxi)
                             ;; (?W . avy-action-tuxi)
                             (?h . avy-action-helpful)
                             (?x . avy-action-exchange)

                             (11 . avy-action-kill-line)
                             (25 . avy-action-yank-line)

                             (?w . avy-action-easy-copy)
                             ;; (134217847  . avy-action-easy-copy)
                             (?k . avy-action-kill-stay)
                             (?y . avy-action-yank)
                             (?t . avy-action-teleport)

                             (?W . avy-action-copy-whole-line)
                             (?K . avy-action-kill-whole-line)
                             (?Y . avy-action-yank-whole-line)
                             (?T . avy-action-teleport-whole-line)))

  (defun avy-action-easy-copy (pt)
        (require 'easy-kill)
        (goto-char pt)
        (cl-letf (((symbol-function 'easy-kill-activate-keymap)
                   (lambda ()
                     (let ((map (easy-kill-map)))
                       (set-transient-map
                        map
                        (lambda ()
                          ;; Prevent any error from activating the keymap forever.
                          (condition-case err
                              (or (and (not (easy-kill-exit-p this-command))
                                       (or (eq this-command
                                               (lookup-key map (this-single-command-keys)))
                                           (let ((cmd (key-binding
                                                       (this-single-command-keys) nil t)))
                                             (command-remapping cmd nil (list map)))))
                                  (ignore
                                   (easy-kill-destroy-candidate)
                                   (unless (or (easy-kill-get mark) (easy-kill-exit-p this-command))
                                     (easy-kill-save-candidate))))
                            (error (message "%s:%s" this-command (error-message-string err))
                                   nil)))
                        (lambda ()
                          (let ((dat (ring-ref avy-ring 0)))
                            (select-frame-set-input-focus
                             (window-frame (cdr dat)))
                            (select-window (cdr dat))
                            (goto-char (car dat)))))))))
          (easy-kill)))

  (defun avy-action-exchange (pt)
  "Exchange sexp at PT with the one at point."
  (set-mark pt)
  (transpose-sexps 0))

  (defun avy-action-helpful (pt)
    (save-excursion
      (goto-char pt)
      (helpful-at-point))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-define (pt)
    (cl-letf (((symbol-function 'keyboard-quit)
            #'abort-recursive-edit))
      (save-excursion
        (goto-char pt)
        (dictionary-search-dwim))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)

  (defun avy-action-tuxi (pt)
    (cl-letf (((symbol-function 'keyboard-quit)
            #'abort-recursive-edit))
      (save-excursion
        (goto-char pt)
        (google-search-at-point))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)

  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act)))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-kill-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-line))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-copy-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (cl-destructuring-bind (start . end)
          (bounds-of-thing-at-point 'line)
        (copy-region-as-kill start end)))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)

  (defun avy-action-kill-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-whole-line))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)

  (defun avy-action-yank-whole-line (pt)
    (avy-action-copy-whole-line pt)
    (save-excursion (yank))
    t)

  (defun avy-action-teleport-whole-line (pt)
    (avy-action-kill-whole-line pt)
    (save-excursion (yank)) t)

  (defun avy-action-mark-to-char (pt)
    (activate-mark)
    (goto-char pt))

  (defun my/avy-goto-char-this-window (&optional arg)
    "Goto char in this window with hints."
    (interactive "P")
    (let ((avy-all-windows t)
          (current-prefix-arg (if arg 4)))
      (call-interactively 'avy-goto-word-1)))

  (defun my/avy-isearch (&optional arg)
    "Goto isearch candidate in this window with hints."
    (interactive "P")
    (let ((avy-all-windows)
          (current-prefix-arg (if arg 4)))
      (call-interactively 'avy-isearch)))

  (defun my/avy--read-char-2 (char1 char2)
    "Read two characters from the minibuffer."
    (interactive (list (let ((c1 (read-char "char 1: " t)))
                         (if (memq c1 '(? ?\b))
                             (keyboard-quit)
                           c1))
                       (let ((c2 (read-char "char 2: " t)))
                         (cond ((eq c2 ?)
                                (keyboard-quit))
                               ((memq c2 '(8 127))
                                (keyboard-escape-quit)
                                (call-interactively 'my/avy-next-char-2))
                               (t
                                c2)))))

    (when (eq char1 ?) (setq char1 ?\n))
    (when (eq char2 ?) (setq char2 ?\n))
    (string char1 char2))

  (defun my/avy-next-char-2 (&optional str2 arg)
    "Go to the next occurrence of two characters"
    (interactive (list
                  (call-interactively 'my/avy--read-char-2)
                  current-prefix-arg))
    (let* ((ev last-command-event)
           (echo-keystrokes nil))
      (push-mark (point) t)
      (if (search-forward str2 nil t
                           (+ (if (looking-at (regexp-quote str2))
                                  1 0)
                              (or arg 1)))
           (backward-char 2)
        (pop-mark)))

    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (define-key map (kbd ";") (lambda (&optional arg) (interactive)
                                   (my/avy-next-char-2 str2 arg)))
       (define-key map (kbd ",") (lambda (&optional arg) (interactive)
                                   (my/avy-previous-char-2 str2 arg)))
       map)))

  (defun my/avy-previous-char-2 (&optional str2 arg)
    "Go to the next occurrence of two characters"
       (interactive (list
                  (call-interactively 'my/avy--read-char-2)
                  current-prefix-arg))
       (let* ((ev last-command-event)
              (echo-keystrokes nil))
         (push-mark (point) t)
         (unless (search-backward str2 nil t (or arg 1))
           (pop-mark)))

    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (define-key map (kbd ";") (lambda (&optional arg) (interactive)
                                   (my/avy-next-char-2 str2 arg)))
       (define-key map (kbd ",") (lambda (&optional arg) (interactive)
                                   (my/avy-previous-char-2 str2 arg)))
       map)))

  (defun my/avy-copy-line-no-prompt (arg)
    (interactive "p")
    (avy-copy-line arg)
    (beginning-of-line)
    (zap-to-char 1 32)
    (delete-forward-char 1)
    (move-end-of-line 1))

  :general
  ("C-'"        '(my/avy-goto-char-this-window :wk "Avy goto char")
   "M-s j"      '(avy-goto-char-2            :wk "Avy goto char 2")
   "M-s y"      '(avy-copy-line              :wk "Avy copy line above")
   "M-s M-y"    '(avy-copy-region            :wk "Avy copy region above")
   "M-s M-k"    '(avy-kill-whole-line        :wk "Avy copy line as kill")
   "M-j"        '(avy-goto-char-timer        :wk "Avy goto char timer")
   "M-s C-w"    '(avy-kill-region            :wk "Avy kill region")
   "M-s M-w"    '(avy-kill-ring-save-region  :wk "Avy copy as kill")
   "M-s t"      '(avy-move-line              :wk "Avy move line")
   "M-s M-t"    '(avy-move-region            :wk "Avy move region")
   "M-s s"      '(my/avy-next-char-2         :wk "Avy snipe forward")
   "M-s r"      '(my/avy-previous-char-2     :wk "Avy snipe backward")
   "M-g l"      '(avy-goto-end-of-line       :wk "Avy goto line")
   "M-s z"      '(my/avy-copy-line-no-prompt :wk "Avy copy and zap"))
  ;; (:states '(normal visual)
  ;;  :prefix "g"
  ;;  "s" 'avy-goto-char-timer)
  :bind (:map isearch-mode-map
         ("C-'" . my/avy-isearch)
         ("M-j" . my/avy-isearch)))
#+end_src

#+RESULTS:
: my/avy-isearch
* keychord
I don’t use Evil (Vim emulation), which would add an extra layer of complexity to everything. Instead, I heavily leverage key-chord.el, which enables binding simultaneous key presses (chords) to commands.

I have some custom code to bind chords to Doom’s leaders. Many commonly used commands are bound in these “key chord maps”.

Enable the key chord package
Set hardware-specific delay. Tweak this if:

there are false keychords triggered when typing fast (delay too large)
if expected keychords don’t register (delay too small)
there’s a noticable lag when typing normally (delay too large)
#+begin_src emacs-lisp
(use-package! key-chord
  :config
  ;; (key-chord-mode 1)
  (setq key-chord-one-key-delay 0.20 ; same key (e.g. xx)
        key-chord-two-keys-delay 0.05))
#+end_src

#+begin_src emacs-lisp

  (key-chord-define-global ",." 'end-of-buffer)
  ;; FIXME: accidentally triggered too often
  (key-chord-define-global "zx" 'beginning-of-buffer)

  (key-chord-define-global "qw" 'delete-window)
  (key-chord-define-global "qp" 'delete-other-windows)
  (key-chord-define-global ",," 'doom/open-scratch-buffer)

  (key-chord-define-global "fk" 'other-window)
  (key-chord-define-global "jd" 'rev-other-window)

  (key-chord-define-global "JJ" 'previous-buffer)
  (key-chord-define-global "KK" 'next-buffer)


  (key-chord-define-global "hh" 'helpful-at-point)
  (key-chord-define-global "hk" 'helpful-key)
  (key-chord-define-global "hv" 'helpful-variable)

  ;; no bueno: e.g. "pathfinder", "highfidelity"
  ;; (key-chord-define-global "hf" 'helpful-function)

  (key-chord-define-global "vn" 'split-window-vertically-and-switch)
  (key-chord-define-global "vm" 'split-window-vertically-and-switch) ; ergodox
  (key-chord-define-global "hj" 'split-window-horizontally-and-switch)

  (key-chord-define-global "jm" 'my/duplicate-line-or-region)
  (key-chord-define-global "fv" 'comment-line)

  (key-chord-define-global "kl" 'er/expand-region)

  (key-chord-define-global "xx" 'execute-extended-command)
  (key-chord-define-global "xf" 'find-file)

  (key-chord-define-global "jp" 'my/insert-jupyter-python-block)
#+end_src
* internet & services
** Network Manager

#+begin_src emacs-lisp

(defvar counsel-network-manager-history nil
  "Network manager history.")

(defun counsel-network-manager (&optional initial-input)
  "Connect to wifi network."
  (interactive)
  (shell-command "nmcli device wifi rescan")
  (let ((networks-list (s-split "\n" (shell-command-to-string "nmcli device wifi list"))))
    (ivy-read "Select network" networks-list
              :initial-input initial-input
              :require-match t
              :history counsel-network-manager-history
              :sort nil
              :caller 'counsel-network-manager
              :action (lambda (line)
                        (let ((network (car (s-split " " (s-trim (s-chop-prefix "*" line)) t))))
                          (message "Connecting to \"%s\".." network)
                          (async-shell-command
                           (format "nmcli device wifi connect %s" (shell-quote-argument network))))))))
#+end_src

#+RESULTS:
: counsel-network-manager

** url util
#+begin_src emacs-lisp
;;; URLs
(require 'url-util)
(use-package goto-addr
  :hook ((compilation-mode . goto-address-mode)
          (prog-mode . goto-address-prog-mode)
          (magit-mode . goto-address-mode)
          (yaml-mode . goto-address-prog-mode)
          (mu4e-view-mode . goto-address-mode))
  :commands (goto-address-prog-mode
             goto-address-mode))


#+end_src
** Mentor (rtorrent)
#+begin_src emacs-lisp
(require 'mentor)
(autoload 'mentor "mentor" nil t)
(setq mentor-rtorrent-external-rpc "~/.rtorrent-rpc.socket")
#+end_src

#+RESULTS:
: ~/.rtorrent-rpc.socket

** Wolfram alpha
#+BEGIN_SRC emacs-lisp
;; wolfram alpha queries (M-x wolfram-alpha)
(use-package wolfram
  :defer t
  :config
  (setq wolfram-alpha-app-id "KTKV36-2LRW2LELV8"))
#+END_SRC
** Webpaste
#+begin_src emacs-lisp
;; It's useful to send a buffer, or part of it, to a bin online and then send the corresponding link to someone. The clbin package does that, in a DWIM manner: send the current region (if any) or the whole buffer, and save the corresponding url in the kill-ring.
;; (use-package clbin
;;   ;; :straight nil
;;   :bind ("C-c w" . clbin-dwim))
(use-package webpaste
  ;; :ensure t
  :bind (("C-c C-p C-b" . webpaste-paste-buffer)
         ("C-c C-p C-r" . webpaste-paste-region)
         ("C-c C-p C-p" . webpaste-paste-buffer-or-region))
  :config
  (progn
    ;; (setq webpaste-provider-priority '("ix.io" "dpaste.org"))))
;; Choosing githup gist only
(setq webpaste-provider-priority '("gist.github.com"))

;; Choosing ix.io as first provider and dpaste.org as second
(setq webpaste-provider-priority '("ix.io" "dpaste.org"))

;; Choosing 1) ix.io, 2) dpaste.org, 3) dpaste.com
(setq webpaste-provider-priority '("ix.io" "dpaste.org" "dpaste.com"))))

;; You can always append this list as much as you like, and which providers
;; that exists is documented below in the readme.
;; Require confirmation before doing paste
(setq webpaste-paste-confirmation t)
;; Do maximum 13 retries instead of standard 10
(setq webpaste-max-retries 13)
(setq webpaste-add-to-killring nil);; Simple hook to just message the URL, this is more or less the default
;; already. But if you disable the default and still want a message, this
;; would work fine.
(add-hook 'webpaste-return-url-hook 'message)

;; To build your own send-to-browser hook, you could do like this:
(add-hook 'webpaste-return-url-hook
          (lambda (url)
            (message "Opened URL in browser: %S" url)
            (browse-url-generic url)))

;; Simple hook to replicate the `webpaste-copy-to-clipboard' option
(add-hook 'webpaste-return-url-hook 'simpleclip-set-contents)
#+end_src

#+RESULTS:
| simpleclip-set-contents | (lambda (url) (message Opened URL in browser: %S url) (browse-url-generic url)) | message |

** Google Translate
#+begin_src emacs-lisp
     (use-package google-translate
       :demand t
       :init
            (require 'google-translate)

       :functions (my-google-translate-at-point google-translate--search-tkk)
       :custom
       (google-translate-backend-method 'curl)
       :config
       (defun google-translate--search-tkk () "Search TKK." (list 430675 2721866130))
       (defun my-google-translate-at-point()
         "reverse translate if prefix"
         (interactive)
         (if current-prefix-arg
             (google-translate-at-point)
           (google-translate-at-point-reverse)))
       :bind
       ("C-c t". my-google-translate-at-point))
#+end_src

#+RESULTS:
: my-google-translate-at-point

** Youtube
#+begin_src emacs-lisp

;; YouTube Download
;; yt-dlp
;; python-pycryptodome
;; atomicparsley
;; mpv
(use-package youtube-dl
  :defer t
  :init
  (setq youtube-dl-directory "~/Downloads/")
  :config
  (setq youtube-dl-program "yt-dlp")
  (setq youtube-dl-arguments
        '("--no-mtime" "--restrict-filenames" "--format" "best" "--mark-watched")))
#+end_src

** google answer
#+begin_src emacs-lisp

;; *** GOOGLE ANSWERS
;; Query Google's knowledge graph. This is the answer that shows up before the
;; first result in Google searches. For this purpose we use tuxi, an external
;; tool that queries Google.
(use-package emacs
  :config
  (defvar google-search-history nil
    "List of queries to google-search-string.")
  (defun google-search-string (search-string)
    "Read SEARCH-STRING from the minibuffer and call the shell
command tuxi on it."
    (interactive (list (read-string "Google: " nil
                                    google-search-history
                                    (thing-at-point 'sexp))))
    (unless (executable-find "tuxi")
      (user-error "Cannot find shell command: tuxi"))
    (let ((search-output (string-trim-right
                          (shell-command-to-string
                           (concat
                            "tuxi -r "
                            (shell-quote-argument search-string))))))
      (with-current-buffer (get-buffer-create "*Tuxi Output*")
        (goto-char (point-max))
        (unless (bobp) (insert "\n\n* * *\n"))
        (insert (capitalize search-string) ":\n\n")
        (push-mark)
        (insert search-output)
        (let ((lines (count-lines (or (mark) (point-min)) (point-max))))
          (if (<= lines 1)
              (message search-output)
            (let ((win (display-buffer (current-buffer))))
              (set-window-start win (mark))
              (set-window-parameter win 'window-height (min lines 10))
              (goto-address-mode 1)))))))
  (defun google-search-at-point (&optional beg end)
    "Call the shell command tuxi on the symbol at point. With an
active region use it instead."
    (interactive "r")
    (if-let ((search-string (if (use-region-p)
                                (buffer-substring-no-properties beg end)
                              (thing-at-point 'symbol))))
        (google-search-string search-string)
      ;; (message "No symbol to search for at point!")
      (call-interactively #'google-search-string)))
  :bind (:map help-map
              ("g" . google-search-string)
              ("C-=" . google-search-at-point)))

#+end_src

#+RESULTS:
: google-search-at-point

** ELFEED
*** elfeed
#+begin_src emacs-lisp :tangle no

;;; Elfeed  -*- lexical-binding: t; -*-

;; Elfeed, the feed reader for emacs, is the best feed reading experience I've
;; had since Google reader in the late 2000s. Not the best feed reading
;; experience in Emacs. Best, period.
;;
;; Part of the reason is that it's eminently hackable, see [[https://karthinks.com/software/declickbaiting-elfeed][Declickbaiting Elfeed]] and [[https://karthinks.com/software/lazy-elfeed][Lazy Elfeed]].
;;
;; Customizations below include
;; - Date oriented browsing (browse by date with "f" and "b"). This mimics how
;;   you move by day in =org-agenda=.
;; - Single key browsing (space to keep reading)
;; - Send entries to mpv
;; - Easy taggers
;; - De-clickbait title entires
;; - tag completion

(use-package elfeed
  :commands (elfeed elfeed-update elfeed-search-bookmark-handler)
  :load-path ("~/.local/share/git/elfeed/"
              "~/.local/share/git/elfeed/web")
  :config
  (setq-default elfeed-db-directory (dir-concat user-cache-directory "elfeed")
                elfeed-save-multiple-enclosures-without-asking t
                elfeed-search-clipboard-type 'CLIPBOARD
                elfeed-search-filter "#50 +unread "
                elfeed-show-entry-switch #'elfeed-display-buffer)
  ;;----------------------------------------------------------------------
  ;;*** Helper functions
  ;;----------------------------------------------------------------------


  (defun elfeed-search-show-entry-pre (&optional lines)
  "Returns a function to scroll forward or back in the Elfeed
  search results, displaying entries without switching to them."
    (lambda (times)
      (interactive "p")
      (forward-line (* times (or lines 0)))
      (recenter)
      (call-interactively #'elfeed-search-show-entry)
      (select-window (previous-window))
      (unless elfeed-search-remain-on-entry (forward-line -1))))

  (general-def :keymaps 'elfeed-search-mode-map
               :states  '(normal visual)
               "gj" (elfeed-search-show-entry-pre 1)
               "gk" (elfeed-search-show-entry-pre -1)
               "]]" (elfeed-search-show-entry-pre 1)
               "[[" (elfeed-search-show-entry-pre -1))
  (general-def :keymaps 'elfeed-search-mode-map
               "M-RET" (elfeed-search-show-entry-pre)
               "w" 'elfeed-search-yank
               "M-n" (elfeed-search-show-entry-pre 1)
               "M-p" (elfeed-search-show-entry-pre -1))

  (defun elfeed-display-buffer (buf &optional act)
    (pop-to-buffer buf '((display-buffer-reuse-window display-buffer-in-direction)
                         (direction . above)
                         (window-height . 0.7)))
    ;; (set-window-text-height (get-buffer-window) (round (* 0.7 (frame-height))))
    )

  (advice-add 'elfeed-kill-buffer :after 'delete-window-if-not-single)
  (advice-add 'elfeed-show-entry :after (defun elfeed-visual-lines-a (_entry)
                                          (visual-line-mode 1)))

  (defun elfeed-scroll-up-command (&optional arg)
    "Scroll up or go to next feed item in Elfeed"
    (interactive "^P")
    (let ((scroll-error-top-bottom nil))
      (condition-case-unless-debug nil
          (scroll-up-command arg)
        (error (elfeed-show-next)))))

  (defun elfeed-scroll-down-command (&optional arg)
    "Scroll up or go to next feed item in Elfeed"
    (interactive "^P")
    (let ((scroll-error-top-bottom nil))
      (condition-case-unless-debug nil
          (scroll-down-command arg)
        (error (elfeed-show-prev)))))

  (defun elfeed-search-tag-as (mytag)
    "Returns a function that tags an elfeed entry or selection as
MYTAG"
    (lambda ()
      "Toggle a tag on an Elfeed search selection"
      (interactive)
      (elfeed-search-toggle-all mytag)))

  (general-def :keymaps 'elfeed-search-mode-map
    :states  '(normal visual emacs)
    "l"      (elfeed-search-tag-as 'later)
    "d"      (elfeed-search-tag-as 'junk)
    "a"      (elfeed-search-tag-as 'listen))
  (bind-key "l" (elfeed-search-tag-as 'later) elfeed-search-mode-map)
  (bind-key "u" (elfeed-search-tag-as 'unread) elfeed-search-mode-map)
  (bind-key "a" (elfeed-search-tag-as 'listen) elfeed-search-mode-map)

  (defun elfeed-show-tag-as (mytag)
    "Returns a function that tags an elfeed entry or selection as
MYTAG"
    (lambda ()
      "Toggle a tag on an Elfeed entry being displayed"
      (interactive)
      (elfeed-tag elfeed-show-entry mytag)
      (elfeed-search-update-entry elfeed-show-entry)
      (unless elfeed-search-remain-on-entry (elfeed-show-next))))

  (general-def :keymaps 'elfeed-show-mode-map
    :states '(normal visual emacs)
    "l"     (elfeed-show-tag-as 'later)
    "d"     (elfeed-show-tag-as 'junk))

  (bind-key "l" (elfeed-show-tag-as 'later)  elfeed-show-mode-map)
  (bind-key "u" (elfeed-show-tag-as 'unread) elfeed-show-mode-map)
  (bind-key "a" (elfeed-show-tag-as 'listen) elfeed-show-mode-map)

  (setq elfeed-feeds my-elfeed-feeds)

  (defun elfeed-show-eww-open (&optional use-generic-p)
    "open with eww"
    (interactive "P")
    (let ((browse-url-browser-function #'eww-browse-url))
      (elfeed-show-visit use-generic-p)
      (add-hook 'eww-after-render-hook 'eww-readable nil t)))

  (defun elfeed-search-eww-open (&optional use-generic-p)
    "open with eww"
    (interactive "P")
    (let ((browse-url-browser-function #'eww-browse-url))
      (elfeed-search-browse-url use-generic-p)
      (add-hook 'eww-after-render-hook 'eww-readable nil t)))

  (defun elfeed-mpv-url (&optional use-single-p)
    "Visit the current entry in umpv or (with prefix arg
USE-SINGLE-P) with mpv."
    (interactive "P")
    (let ((browse-url-browser-function (if use-single-p
                                           (lambda (url &optional _) (browse-url-umpv url t))
                                           #'browse-url-umpv)))
      (pcase major-mode
        ('elfeed-search-mode (elfeed-search-browse-url))
        ('elfeed-show-mode (elfeed-show-visit)))))

  (bind-key "m" #'elfeed-mpv-url elfeed-search-mode-map)
  (bind-key "m" #'elfeed-mpv-url elfeed-show-mode-map)

  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :feed-title "The Linux Experiment"
                                :entry-title "Linux News"
                                :add '(news listen)))

  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :feed-title "Skill Up"
                                :entry-title "This Week"
                                :add '(news listen)))

  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :feed-title "TechLinked"
                                :add '(news listen)))

  (add-hook 'elfeed-new-entry-hook
            (elfeed-make-tagger :feed-title "ACG"
                                :entry-title "\\(?:Roundup\\|Gaming News\\)"
                                :add '(news listen)))

  (add-hook 'elfeed-new-entry-hook #'elfeed-declickbait-entry)

  (defun elfeed-declickbait-entry (entry)
    (when-let ((title (elfeed-entry-title entry))
               (feed (elfeed-entry-feed entry))
               (feed-url (elfeed-feed-url feed))
               (youtube-p (string-match-p "youtube\\.com" feed-url)))
      (setf (elfeed-meta entry :title)
            (elfeed-title-transform title))))

  (defun elfeed-title-transform (title)
    "Declickbait string TITLE."
    (let* ((trim "\\(?:\\(?:\\.\\.\\.\\|[!?]\\)+\\)")
           (arr (split-string title nil t trim))
           (s-table (copy-syntax-table)))
      (modify-syntax-entry ?\' "w" s-table)
      (with-syntax-table s-table
        (mapconcat (lambda (word)
                     (cond
                      ((member word '("AND" "OR" "IF" "ON" "IT" "TO"
                                      "A" "OF" "VS" "IN" "FOR" "WAS"
                                      "IS" "BE" "SO"))
                       (downcase word))
                      ((member word '("WE" "DAY" "HOW" "WHY" "NOW" "OLD"
                                      "NEW" "MY" "TOO" "GOT" "GET" "THE"
                                      "ONE" "DO" "YOU" "BAD" "ALL" "CAN"
                                      "HE" "EAT"))
                       (capitalize word))
                      ((and (> (length word) 3)
                            (string-match-p "\\`[A-Z\\.\\?\\!\\':,’\\-]*\\'"
                                            word))
                       (capitalize word))
                      (t word)))
                   arr " "))))

  (defun my/elfeed-search-by-day (dir)
    (lambda (&optional arg)
      (interactive "p")
      (let* ((entry (elfeed-search-selected :ignore-region))
             (this-day (or (and (string-match-p ".*@\\(.+\\)--.*" elfeed-search-filter)
                                (time-to-seconds
                                 (encode-time
                                  (parse-time-string
                                   (concat (replace-regexp-in-string
                                            ".*@.*?--\\([^[:space:]]+?\\)" "\\1"
                                            elfeed-search-filter)
                                           " 00:00:00 Z")))))
                           (and entry
                                (elfeed-entry-date entry))
                           (time-to-seconds
                            (current-time))))
             (next-day (time-add this-day (days-to-time (or arg 1))))
             (next-next-day (time-add next-day (days-to-time (or arg 1))))
             (prev-day (time-subtract this-day (days-to-time (or arg 1))))
             from to)
        (pcase dir
          ('next (setq from next-day
                       to   next-next-day))
          ('prev (setq from prev-day
                       to   this-day))
          (_     (setq from this-day
                       to   next-day)))
        (setq elfeed-search-filter (concat (replace-regexp-in-string
                                            "@[^[:space:]]*" ""
                                            elfeed-search-filter)
                                           "@"  (elfeed-search-format-date from)
                                           "--" (elfeed-search-format-date to)))
        (elfeed-search-update :force))))

  (define-key elfeed-search-mode-map (kbd ".") (my/elfeed-search-by-day 'this))
  (define-key elfeed-search-mode-map (kbd "b") (my/elfeed-search-by-day 'next))
  (define-key elfeed-search-mode-map (kbd "f") (my/elfeed-search-by-day 'prev))

  (defvar elfeed-search-filter-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "+") (lambda () (interactive) (my/elfeed-search-tag-filter "+")))
      (define-key map (kbd "-") (lambda () (interactive) (my/elfeed-search-tag-filter "-")))
      (define-key map (kbd "@") (lambda () (interactive) (my/elfeed-search-tag-filter "@")))
      (define-key map (kbd "RET") 'exit-minibuffer)
      (define-key map (kbd "<tab>") 'minibuffer-force-complete-and-exit)
      (define-key map (kbd "C-g") 'abort-recursive-edit)
      map)
    "Keymap active when entering filter terms in elfeed")

  (defun elfeed-search-live-filter ()
    "Filter the elfeed-search buffer as the filter is written."
    (interactive)
    (unwind-protect
        (let ((elfeed-search-filter-active :live))
          (setq elfeed-search-filter
                (read-from-minibuffer "Filter: " elfeed-search-filter elfeed-search-filter-map)))
      (elfeed-search-update :force)))

  (defun my/elfeed-search-tag-filter (plus-minus)
    "Filter `elfeed' by tags using completion."
    (let ((elfeed-search-filter-active nil))
      (if (equal plus-minus "@")
          (insert (format "@%s "
                          (replace-regexp-in-string
                           " +" "-"
                           (replace-regexp-in-string
                            " to " "--"
                            (read-from-minibuffer "Date range: ")))))
        (let* ((db-tags (elfeed-db-get-all-tags))
               (tag (completing-read (format "%s %s" elfeed-search-filter plus-minus) db-tags nil t)))
          (insert (concat plus-minus tag " ")))))
    (elfeed-search-update :force))

  (defun my/elfeed-quick-switch-filter ()
    (interactive)
    (bookmark-jump
     (consult--read
      (consult--bookmark-candidates)
      :prompt "Elfeed bookmark: "
      :initial "elfeed/")))
  ;;----------------------------------------------------------------------
  ;; Faces
  ;;----------------------------------------------------------------------
  ;; (defface elfeed-entry-read-later
  ;;   '((t :foreground "#b48ead"))
  ;;   "Marks a 'read-later' Elfeed entry.")
  ;; (push '(later elfeed-entry-read-later)
  ;;       elfeed-search-face-alist)
  :general
  (:states '(normal visual)
           :keymaps 'elfeed-search-mode-map
           "SPC" 'space-menu
           "gO"  'elfeed-search-eww-open
           "c"   'elfeed-search-clear-filter
           "gy"  'elfeed-search-yank
           )

  (:states '(normal visual)
           :keymaps 'elfeed-show-mode-map
           "SPC"   'elfeed-scroll-up-command
           "S-SPC" 'elfeed-scroll-down-command
           "gO"    'elfeed-show-eww-open
           "gy"    'elfeed-show-yank
           "<tab>" 'elfeed-show-next-link)
  (:keymaps 'elfeed-show-mode-map
            "SPC" 'elfeed-scroll-up-command
            "S-SPC" 'elfeed-scroll-down-command
            "W" 'elfeed-search-eww-open
            "w" 'elfeed-show-yank
            "B" 'elfeed-show-eww-open
            "x" 'elfeed-search-browse-url)
  (:keymaps 'elfeed-search-mode-map
            "C-<tab>" 'my/elfeed-quick-switch-filter
            "B" 'elfeed-search-eww-open
            "W" 'elfeed-search-eww-open
            "x" 'elfeed-search-browse-url))

;; * WALLABAG
(use-package wallabag
  :load-path "plugins/wallabag"
  :commands wallabag-post-entry
  :config
  (setq wallabag-data-dir "~/.cache/wallabag")
  (let ((creds (split-string (shell-command-to-string
                              "pass show api/wallabag/qutescript"))))
    (setq wallabag-credentials
          `((client-secret  . ,(nth 0 creds))
            (client-id      . ,(nth 2 creds))
            (host           . ,(nth 4 creds))))))

;; ** ELFEED + WALLABAG

;; More integration: Send Elfeed entries to my Wallabag instance to read later
(use-package elfeed
  :defer
  :config
  (use-package wallabag
    :config
    (defun elfeed-post-to-wallabag ()
      "Post current entry (or entry at point) to Wallabag"
      (interactive)
      (let ((entries (elfeed-search-selected))
            (links (pcase major-mode
                     ('elfeed-show-mode
                      (list (elfeed-entry-link elfeed-show-entry)))
                     ('elfeed-search-mode
                      (mapcar #'elfeed-entry-link (elfeed-search-selected))))))
        (dolist (link links nil)
          (wallabag-post-entry link)
          (when (eq major-mode 'elfeed-search-mode)
            (elfeed-untag entries 'unread)
            (mapc #'elfeed-search-update-entry entries)
            (unless (or elfeed-search-remain-on-entry
                        (use-region-p))
              (forward-line))))))
    :bind (:map elfeed-show-mode-map
                ("R" . elfeed-post-to-wallabag)
                :map elfeed-search-mode-map
                ("R" . elfeed-post-to-wallabag))))

;; ** ELFEED + ORG-LINK
;;
;; Org-Link handling for Elfeed buffers
(use-package ol
  :after (elfeed org)
  :config
  (org-link-set-parameters "elfeed"
                           :follow #'org-elfeed-open
                           :store  #'org-elfeed-store-link)

  (defun org-elfeed-store-link ()
    "Store a link to an Elfeed entry."
    (when-let* ((entry (pcase major-mode
                         ('elfeed-show-mode elfeed-show-entry)
                         ('elfeed-search-mode (elfeed-search-selected :ignore-region))))
           (entry-id (elfeed-entry-id entry))
           (title (elfeed-entry-title entry)))
      (let ((link))
        (org-link-store-props :type "elfeed")
        (setq link (concat "elfeed:id:" (car entry-id) "@@" (cdr entry-id)))
        (org-add-link-props :link link :description title)
        link)))

  (defun org-elfeed-open (link)
    "Follow an elfeed entry specified by LINK."
    (require 'elfeed)
    (let* ((url+title (split-string (substring link 3) "@@"))
                (url (nth 0 url+title))
                (title (nth 1 url+title))
                (entry (elfeed-db-get-entry (cons url title))))
      (elfeed-show-entry entry))))


;; ** +AUTOTAGGING SETUP+

;; Currently disabled: More Elfeed taggers
(use-package elfeed-custom
  :disabled
  :config
  (progn
    ;; Mark all YouTube entries
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :feed-url "youtube\\.com"
                                  :add '(video youtube)))
    ;; Avoiding tagging old entries as unread:

    ;; Entries older than 2 weeks are marked as read
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :before "2 weeks ago"
                                  :remove 'unread))

    ;; Or building your own subset feeds:
    (add-hook 'elfeed-new-entry-hook
              (elfeed-make-tagger :feed-url "example\\.com"
                                  :entry-title '(not "something interesting")
                                  :add 'junk
                                  :remove 'unread))))
;;; Use `M-x elfeed-apply-hooks-now' to apply elfeed-new-entry-hook to all
;;; existing entries. Otherwise hooks will only apply to new entries on
;;; discovery.
;;; ----------------------------------------------------------------------
 ;;
;;; (defun elfeed-search-eww-open (&optional use-generic-p)
;;;   "open with eww"
;;;   (interactive "P")
;;;   (let ((entries (elfeed-search-selected)))
;;;     (cl-loop for entry in entries
;;;              do (elfeed-untag entry 'unread)
;;;              when (elfeed-entry-link entry)
;;;              do (eww-browse-url it t))
;;;     (mapc #'elfeed-search-update-entry entries)
;;;     (unless (use-region-p) (forward-line))))
 ;;
;;; For quick tagging
;;; (defvar my-feeds nil)
;;; (let ((tags '("always" "rare" "sometimes" "junk"))
;;;       history)
;;;   (dolist (feed elfeed-feeds)
;;;     (let ((choices (completing-read-multiple (format "%s: " feed) tags nil nil nil)))
;;;       (add-to-list 'my-feeds (append (list feed) (mapcar 'make-symbol choices)))
;;;       (setq tags (delete-dups (append choices tags)))
;;;       )
;;;     ))

(provide 'setup-elfeed)
;; setup-elfeed.el ends here
#+end_src
*** Elfeed goodies
An RSS newsfeed reader for Emacs.


#+BEGIN_SRC emacs-lisp

(use-package! elfeed-goodies)
(elfeed-goodies/setup)
(setq elfeed-goodies/entry-pane-size 0.5)
(add-hook 'elfeed-show-mode-hook 'visual-line-mode)
(evil-define-key 'normal elfeed-show-mode-map
  (kbd "J") 'elfeed-goodies/split-show-next
  (kbd "K") 'elfeed-goodies/split-show-prev)
(evil-define-key 'normal elfeed-search-mode-map
  (kbd "J") 'elfeed-goodies/split-show-next
  (kbd "K") 'elfeed-goodies/split-show-prev)
(setq elfeed-feeds (quote
          (("https://www.reddit.com/r/linux.rss" reddit linux)
          ("https://www.reddit.com/r/commandline.rss" reddit commandline)
          ("https://www.reddit.com/r/distrotube.rss" reddit distrotube)
          ("https://www.reddit.com/r/emacs.rss" reddit emacs)
          ("https://www.gamingonlinux.com/article_rss.php" gaming linux)
          ("https://hackaday.com/blog/feed/" hackaday linux)
          ("https://opensource.com/feed" opensource linux)
          ("https://linux.softpedia.com/backend.xml" softpedia linux)
          ("https://itsfoss.com/feed/" itsfoss linux)
          ("https://www.zdnet.com/topic/linux/rss.xml" zdnet linux)
          ("https://www.phoronix.com/rss.php" phoronix linux)
          ("http://feeds.feedburner.com/d0od" omgubuntu linux)
          ("https://www.computerworld.com/index.rss" computerworld linux)
          ("https://www.networkworld.com/category/linux/index.rss" networkworld linux)
          ("https://www.techrepublic.com/rssfeeds/topic/open-source/" techrepublic linux)
          ("https://betanews.com/feed" betanews linux)
          ("http://lxer.com/module/newswire/headlines.rss" lxer linux)
          ("http://endlessparentheses.com/atom.xml" emacs)
          ("http://planet.emacsen.org/atom.xml" emacs)
          ("https://www.reddit.com/r/emacs/.rss" emacs)
          ("https://www.reddit.com/r/orgmode/.rss" emacs)
          ("http://www.blackhats.es/wordpress/?feed=rss2" emacs)
          ("http://www.howardism.org/index.xml" emacs)
          ("http://www.masteringemacs.org/feed/" emacs))))

#+END_SRC

#+RESULTS:
| https://www.reddit.com/r/linux.rss                       | reddit        | linux       |
| https://www.reddit.com/r/commandline.rss                 | reddit        | commandline |
| https://www.reddit.com/r/distrotube.rss                  | reddit        | distrotube  |
| https://www.reddit.com/r/emacs.rss                       | reddit        | emacs       |
| https://www.gamingonlinux.com/article_rss.php            | gaming        | linux       |
| https://hackaday.com/blog/feed/                          | hackaday      | linux       |
| https://opensource.com/feed                              | opensource    | linux       |
| https://linux.softpedia.com/backend.xml                  | softpedia     | linux       |
| https://itsfoss.com/feed/                                | itsfoss       | linux       |
| https://www.zdnet.com/topic/linux/rss.xml                | zdnet         | linux       |
| https://www.phoronix.com/rss.php                         | phoronix      | linux       |
| http://feeds.feedburner.com/d0od                         | omgubuntu     | linux       |
| https://www.computerworld.com/index.rss                  | computerworld | linux       |
| https://www.networkworld.com/category/linux/index.rss    | networkworld  | linux       |
| https://www.techrepublic.com/rssfeeds/topic/open-source/ | techrepublic  | linux       |
| https://betanews.com/feed                                | betanews      | linux       |
| http://lxer.com/module/newswire/headlines.rss            | lxer          | linux       |
| http://endlessparentheses.com/atom.xml                   | emacs         |             |
| http://planet.emacsen.org/atom.xml                       | emacs         |             |
| https://www.reddit.com/r/emacs/.rss                      | emacs         |             |
| https://www.reddit.com/r/orgmode/.rss                    | emacs         |             |
| http://www.blackhats.es/wordpress/?feed=rss2             | emacs         |             |
| http://www.howardism.org/index.xml                       | emacs         |             |
| http://www.masteringemacs.org/feed/                      | emacs         |             |

** EWW
*** general eww
EWW is the Emacs Web Wowser, the builtin browser in Emacs.  Below I set urls to open in a specific browser (eww) with browse-url-browser-function.  By default, Doom Emacs does not use 'SPC e' for anything, so I choose to use the format 'SPC e' plus 'key' for these (I also use 'SPC e' for 'eval' keybindings).  I chose to use 'SPC s w' for eww-search-words because Doom Emacs uses 'SPC s' for 'search' commands.

#+BEGIN_SRC emacs-lisp
;; (setq browse-url-browser-function 'eww-browse-url)
;; (map! :leader
;;       :desc "Search web for text between BEG/END"
;;       "s w" #'eww-search-words
;;       (:prefix ("e" . "evaluate/EWW")
;;        :desc "Eww web browser" "w" #'eww
;;        :desc "Eww reload page" "R" #'eww-reload))
(use-package eww
  :ensure nil
  :config
  ;; (setq browse-url-handlers
  ;;       '(("." . browse-url-firefox)))
  (setq browse-url-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser")

  :custom
  (eww-use-external-browser-for-content-type
   "\\`\\(video/\\|audio/\\|application/ogg\\|application/pdf\\)"))

(use-package engine-mode
  :config
  (defengine duckduckgo
    "https://duckduckgo.com/html?q=%s"
    :keybinding "d")
  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
:keybinding "g")
  (defengine cern-gitlab
    "https://gitlab.cern.ch/search?search=%s"
    :keybinding "l")
  (defengine google
    "http://www.google.com/search?hl=en&ie=utf-8&oe=utf-8&q=%s"
    :keybinding "O")
  (defengine duckduckgo-first
    "https://duckduckgo.com/html?q=\\%s"
    :keybinding "f")
  (defengine google-maps
    "https://www.google.com/maps/search/%s/"
    :keybinding "M")
  (defengine openstreetmap
    "https://www.openstreetmap.org/search?query=%s"
    :keybinding "m")
  (defengine wordreference
    "https://www.wordreference.com/es/translation.asp?tranword=%s"
    :keybinding "r")
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")
  (defengine youtube
    "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y")
  (defengine vidpuffy
    "https://vid.puffyan.us/search?q=%s"
    :keybinding "v")
  (defengine url
    "https:%s"
    :keybinding "u")


;; # Search Engines

;; websearch[bing]="https://www.bing.com/search?q="
  (defengine bing
"https://www.bing.com/search?q=%s"
:keybinding "b")
;; websearch[googlenews]="https://news.google.com/search?q="
  (defengine googlenews
"https://news.google.com/search?q=%s"
:keybinding "n")


;; websearch[wiktionary]="https://en.wiktionary.org/w/index.php?search="
  (defengine wiktionary
"https://en.wiktionary.org/w/index.php?search=%s"
:keybinding "D")

;; # Social Media
;; websearch[reddit]="https://www.reddit.com/search/?q="
  (defengine reddit
"https://www.reddit.com/search/?q=%s"
:keybinding "r")

;; # Online Shopping
;; websearch[amazon]="https://www.amazon.in/s?k="
  (defengine amazon
"https://www.amazon.in/s?k=%s"
:keybinding "a")

;; websearch[ebay]="https://www.ebay.com/sch/i.html?&_nkw="
  (defengine ebay
"https://www.ebay.com/sch/i.html?&_nkw=%s"
:keybinding "e")
;; # Linux
;; websearch[archaur]="https://aur.archlinux.org/packages/?O=0&K="
  (defengine archaur
"https://aur.archlinux.org/packages/?O=0&K=%s"
:keybinding "U")

;; websearch[archpkg]="https://archlinux.org/packages/?sort=&q="
  (defengine archpackages
"https://archlinux.org/packages/?sort=&q=%s"
:keybinding "P")

;; websearch[archwiki]="https://wiki.archlinux.org/index.php?search="
  (defengine archlinux
"https://wiki.archlinux.org/index.php?search=%s"
:keybinding "W")



;; websearch[gitlab]="https://gitlab.com/search?search="
  (defengine gitlab
"https://gitlab.com/search?search=%s"
:keybinding "G")

;; websearch[googleOpenSource]="https://opensource.google/projects/search?q="
  (defengine opensource
"https://opensource.google/projects/search?q=%s"
:keybinding "o")

;; websearch[sourceforge]="https://sourceforge.net/directory/?q="
  (defengine sourceforge
"https://sourceforge.net/directory/?q=%s"
:keybinding "S")

;; websearch[stackoverflow]="https://stackoverflow.com/search?q="
  (defengine stackoverflow
"https://stackoverflow.com/search?q=%s"
:keybinding "s")

;; websearch[craigslist]="https://www.craigslist.org/search/sss?query="
;;   (defengine craigslist
;; "https://www.craigslist.org/search/sss?query="
;; :keybinding "c")


;; websearch[gumtree]="https://www.gumtree.com/search?search_category=all&q="
;;   (defengine gumtree
;; "https://www.gumtree.com/search?search_category=all&q="
;; :keybinding "g")


;; websearch[debianpkg]="https://packages.debian.org/search?suite=default&section=all&arch=any&searchon=names&keywords="
;;   (defengine debian
;; "https://packages.debian.org/search?suite=default&section=all&arch=any&searchon=names&keywords="
;; :keybinding "D")

;; websearch[brave]="https://search.brave.com/search?q="
;;   (defengine brave
;; "https://search.brave.com/search?q="
;; :keybinding "b")


;; websearch[gemini search \(https\)]="https://portal.mozz.us/gemini/geminispace.info/search%3F"
;;   (defengine gemini
;; "https://portal.mozz.us/gemini/geminispace.info/search%3F"
;; :keybinding "G")


;; websearch[qwant]="https://www.qwant.com/?q="
;;   (defengine qwant
;; "https://www.qwant.com/?q="
;; :keybinding "q")

;; websearch[swisscows]="https://swisscows.com/web?query="
;;   (defengine swisscows
;; "https://swisscows.com/web?query="
;; :keybinding "s")

;; websearch[yandex]="https://yandex.com/search/?text="
;;   (defengine yandex
;; "https://yandex.com/search/?text="
;; :keybinding "Y")

;; # Information/News
;; websearch[bbcnews]="https://www.bbc.co.uk/search?q="
;;   (defengine bbc
;; "https://www.bbc.co.uk/search?q="
;; :keybinding "b")

;; websearch[cnn]="https://www.cnn.com/search?q="
;;   (defengine cnn
;; "https://www.cnn.com/search?q="
;; :keybinding "c")

  ;; (engine/set-keymap-prefix (kbd "C-c w s"))
  (engine/set-keymap-prefix (kbd "s-b"))
  (engine-mode t))
#+END_SRC

#+RESULTS:
: t

*** Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el
**** desc
TODO 2021-09-08: This section needs to be expanded to cover the
integration with the built-in =bookmark.el= framework as well as the
third-party =elpher= package (Elpher is an Internet browser for the Gopher
and Gemini protocols).


The following code block encompasses libraries that power Emacs' web
browsing experience.

+ =browse-url= determines what Emacs should do when the user follows a
  link to the Internet.  For my purposes, I configure it to open the web
  page inside of Emacs, while I let the Desktop Environment's default
  graphical browser be declared as a secondary option.  Put simply, when
  I click on a URL, I go to an EWW or Elpher buffer.  If the page is
  part of the World Wide Web (=https?= protocol) I can opt to open it in
  the GUI browser via =eww-browse-with-external-browser=, which is bound
  to =&= in =eww-mode-map=.  That is only ever needed for websites that do
  not work well in a text-centric interface.  For pages that implement
  the Gopher or Gemini protocols, there is no need whatsoever to open
  them externally as they are plain text anyway.

+ =shr= is the "Simple HTML Renderer", which basically means to interpret
  the underlying code of a web page and show it in the way it is
  intended for the end user.  Unlike graphical web browsers, =shr=
  capabilities are limited, because it does not use style sheets (CSS)
  and more demanding resources (javascript, embedded multimedia, etc.).

+ =eww= is what we use to browse the Web.  It effectively is the front-end
  to =shr=, adding on top of it the layer of interactivity that is
  expected of a basic browser, such as to keep a history of visited
  pages, handle bookmarks, navigate through links, and the like.  As
  always, remember to read the manual of EWW, such as by evaluating this
  form: =(info "(eww) Top")=.  It is short and should give you an idea of
  what its features are.

+ =prot-eww= adds commands that align EWW with my expectations and make it
  do what I want to achieve in a primarily text-based web browsing
  experience.  It also provides the layer of integration between EWW and
  Elpher, making the resulting browsing experience consistent as one
  follows links that are implemented in the relevant protocols.

My configurations for =browse-url= and =shr= are straightforward and are
meant to keep things simple.  I want EWW to behave like the rest of
Emacs, which means that it should not try to introduce random colours
from web pages, nor use its own fonts.  Both intefere with the
consistency I seek in my computing environment (and why I use Emacs to
begin with).

For =eww=, I repurpose some of its key bindings that I never plan to use,
such as the toggle for proportional fonts, while I move around a few
others.  Just to make things easier for me.

As for =prot-eww=, it includes functionality that makes EWW good enough
for my day-to-day needs.

In particular:

+ It includes an unconditional internal mechanism that renames EWW
  buffers based on the rendered web page's title or, when that is not
  available, the URL.  This ensures that I can maintain multiple buffers
  without getting lost in the noise of what would otherwise be an
  awkward naming scheme in the form of =*eww*=, =*eww<2>*= and so on.  Now
  it looks like =*Emacs - ArchWiki # eww*=, with a possible number
  identifier added only for duplicate entries.

+ The variable =prot-eww-visited-history= records the URL of every
  rendered page.  This is then used by =prot-eww-browse-dwim= (more
  below).  To keep things in check, =prot-eww-visited-history= is
  implemented as a minibuffer history which is ultimately limited to the
  value of =history-length= (read: [[#h:2733674b-51f9-494e-b34d-e8842ac4ef96][Minibuffer history (savehist-mode)]]).
  Remember that each command can have its own history and this is common
  in a lot of my extras.

+ The =prot-eww-browse-dwim= is my main point of entry to EWW.  When I
  call it from a random place inside of Emacs, it just offers a prompt
  that asks for a URL or search terms with which to query DuckDuckGo.
  In addition, it reads through a history of such inputs, so that =M-p=,
  =M-n= can quickly give me something I tried before.  Plus it supports
  completion (check the mega-section [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).
  When this command is called from inside an EWW buffer it retains the
  aforementioned functionality, but its prompt is pre-populated with the
  URL of the current page.  This is particularly useful for editing the
  path directly, such as to go from =https://protesilaos.com/contact= to
  =https://protesilaos.com=.  When called with a universal prefix argument
  (=C-u=), it opens a new EWW buffer instead of using the last one.

+ =prot-eww-search-engine= offers selection among the custom search
  commands I define, such as to query Wikipedia directly or search for a
  bug number in the Emacs issue tracker.  Those search engine commands
  can be invoked on their own, while each of them has its own minibuffer
  history (so if you searched for "elephant" in Wikipedia, you will not
  get that for the Arch Wiki).

+ =prot-eww-bookmark-page= does what its name suggests though, unlike the
  built-in equivalent, it first asks for how to name the bookmarked
  entry before storing it in the relevant memory compartment.

+ =prot-eww-visit-bookmark= prompts with completion to visit an entry in
  EWW's bookmark list.  A =C-u= prefix means to open it in a new EWW
  buffer.

+ =prot-eww-visit-url-on-page= traverses the entire web page to construct
  a list of all links and their anchor text.  The list can be narrowed
  with completion.  Selecting a item with visit its corresponding web
  page.

+ =prot-eww-jump-to-url-on-page= is similar to the above, with the major
  difference that it only stores buffer positions and jumps to them.
  This makes it ideal for generating an ad-hoc index of "points of
  interest" in the current buffer with the help of Embark's ability to
  collect a list of candidates into a bespoke buffer (make sure to check
  [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]]).
  Of course, it can be used on its own to jump around the web page.

+ =prot-eww-find-feed= inspects the source code of the current web page
  and produces an =occur= buffer with links that represent RSS or Atom
  feeds.  This command is quite useful for retrieving the feed of a
  website whose designers failed to provide a user-facing link for it
  (which is the norm nowadays).  I read feeds on a daily basis: it is
  the best way to keep track of updates to web pages (read section
  [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el]]).

+ =prot-eww-readable= is a more opinionated take on the built-in option.
  It specifies a narrower =shr-width=, specifically at the 72 character
  limit which is my =current-fill-column=.  Furthermore, it reduces images
  to a maximum of 0.35 of the window's width/height.  This is not always
  a good approach, though it works most of the time for the kind of
  content I am interested in: text-heavy articles.

+ =prot-eww-download-html= downloads the current web page as an =.html=
  file.  It asks for a name to give to it, defaulting to the title of
  the page, and it also prepends the current date and time.  To ensure
  that the file name is easily accessible with Unix tools, all
  punctuation marks and spaces are removed or replaced with hyphens.  So
  if the page is titled ="GNU Emacs manual | My ‘cool’ “website”!?"= the
  saved file will be processed and stored as a filesystem path like
  =~/Downloads/eww/20210324_185035--gnu-emacs-manual-my-cool-website.html=.
  I find that this is superior to the generic =eww-download= which neither
  asks for a name, nor adds a date and file type extension.  Where
  =eww-download= still excels is for downloading the link at point, when
  that is not an HTML file (e.g. a pdf or zip archive).

+ =prot-eww-open-in-other-window= is meant to open the link at point in a
  new buffer and in another window.  It complements the default =M-RET=
  (=eww-open-in-new-buffer=) which re-uses the same window.

Some final tips:

+ =g= reloads the web page by fetching it anew over the network, while its
  =C-u g= counterpart re-renders what has already been downloaded.  The
  latter is useful when, for example, you have a new window
  configuration and wish to fit the EWW buffer's contents in the window.

+ As already noted above, several commands that open an EWW buffer
  accept a =C-u= prefix to put their contents in a new buffer rather than
  re-use the existing one.  With =M-RET= over a link in an EWW buffer, you
  can do the same.

+ When point is over an image, the =shr-image-map= gets activated.  This
  allows you to run commands such as =image-increase-size=, bound to =+=,
  and =image-decrease-size= on =-=.  This means that you can always view an
  image at an appropriate size, regardless of whether its initial
  dimensions were affected by =shr-max-image-proportion= and the size of
  the window holding the EWW buffer.

Also watch [[https://protesilaos.com/codelog/2021-03-25-emacs-eww/][EWW and my extras]] (2021-03-25) for a video demonstration of
some of the above.

**** code
#+begin_src emacs-lisp
;;; Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el
(use-package browse-url
  :config
  (setq browse-url-browser-function 'eww-browse-url)
  (setq browse-url-secondary-browser-function 'browse-url-default-browser))

(use-package shr
  :config
  (setq shr-use-colors nil)             ; t is bad for accessibility
  (setq shr-use-fonts nil)              ; t is not for me
  (setq shr-max-image-proportion 0.6)
  (setq shr-image-animate nil)          ; No GIFs, thank you!
  (setq shr-width nil)                  ; check `prot-eww-readable'
  (setq shr-discard-aria-hidden t)
  (setq shr-cookie-policy nil))

(use-package url-cookie
  :config
  (setq url-cookie-untrusted-urls '(".*")))

(use-package eww
  :config
  (setq eww-restore-desktop t)
  (setq eww-desktop-remove-duplicates t)
  (setq eww-header-line-format nil)
  (setq eww-search-prefix "https://duckduckgo.com/html/?q=")
  (setq eww-download-directory (expand-file-name "~/Documents/eww-downloads"))
  (setq eww-suggest-uris
        '(eww-links-at-point
          thing-at-point-url-at-point))
  (setq eww-bookmarks-directory (locate-user-emacs-file "eww-bookmarks/"))
  (setq eww-history-limit 150)
  (setq eww-use-external-browser-for-content-type
        "\\`\\(video/\\|audio\\)") ; On GNU/Linux check your mimeapps.list
  (setq eww-browse-url-new-window-is-tab nil)
  (setq eww-form-checkbox-selected-symbol "[X]")
  (setq eww-form-checkbox-symbol "[ ]")
  ;; NOTE `eww-retrieve-command' is for Emacs28.  I tried the following
  ;; two values.  The first would not render properly some plain text
  ;; pages, such as by messing up the spacing between paragraphs.  The
  ;; second is more reliable but feels slower.  So I just use the
  ;; default (nil), though I find wget to be a bit faster.  In that case
  ;; one could live with the occasional errors by using `eww-download'
  ;; on the offending page, but I prefer consistency.
  ;;
  ;; '("wget" "--quiet" "--output-document=-")
  ;; '("chromium" "--headless" "--dump-dom")
  ;; (setq eww-retrieve-command nil)

;; list buffers gt

  (define-key eww-link-keymap (kbd "v") nil) ; stop overriding `eww-view-source'
  (define-key eww-mode-map (kbd "L") #'eww-list-bookmarks) ;g b
  (define-key dired-mode-map (kbd "E") #'eww-open-file) ; to render local HTML files
  (define-key eww-buffers-mode-map (kbd "d") #'eww-buffer-kill)   ; it actually deletes
  (define-key eww-bookmark-mode-map (kbd "d") #'eww-bookmark-kill)) ; same

(use-package elpher)    ; NOTE 2021-07-24: work-in-progress

(load "prot-eww")
(use-package prot-eww
  :config
  (setq prot-eww-save-history-file
        (locate-user-emacs-file "prot-eww-visited-history"))
  (setq prot-eww-save-visited-history t)
  (setq prot-eww-bookmark-link nil)

  (add-hook 'prot-eww-history-mode-hook #'hl-line-mode)

  (define-prefix-command 'prot-eww-map)
  ;; (define-key global-map (kbd "C-c w") 'prot-eww-map)
  (define-key global-map (kbd "s-B") 'prot-eww-map)
  (let ((map prot-eww-map))
    (define-key map (kbd "B") #'prot-eww-visit-bookmark)
    (define-key map (kbd "e") #'prot-eww-browse-dwim)
    (define-key map (kbd "s") #'prot-eww-search-engine)
    (define-key map (kbd "m") #'prot-eww-bookmark-page)
    (define-key map (kbd "d") #'prot-eww-download-html)
    (define-key map (kbd "F") #'prot-eww-find-feed)
    (define-key map (kbd "h") #'prot-eww-list-history) ;key fine
    (define-key map (kbd "e") #'prot-eww-browse-dwim)
    (define-key map (kbd "o") #'prot-eww-open-in-other-window)
    (define-key map (kbd "f") #'prot-eww-visit-url-on-page)
    (define-key map (kbd "j") #'prot-eww-jump-to-url-on-page)
    (define-key map (kbd "a") #'eaf-open-browser-with-history)
    (define-key map (kbd "A") #'eaf-open-browser-other-window)
    (define-key map (kbd "r") #'prot-eww-readable))
  (let ((map eww-mode-map))
    (define-key map (kbd "b") #'prot-eww-bookmark-page)
    (define-key map (kbd "C-d") #'prot-eww-download-html)
    (define-key map (kbd "C-f") #'prot-eww-find-feed)
    (define-key map (kbd "C-H") #'prot-eww-list-history) ;key fine
    (define-key map (kbd "C-B") #'prot-eww-visit-bookmark)
    (define-key map (kbd "C-e") #'prot-eww-browse-dwim)
    (define-key map (kbd "C-o") #'prot-eww-open-in-other-window)
    (define-key map (kbd "C-e") #'prot-eww-visit-url-on-page)
    (define-key map (kbd "C-j") #'prot-eww-jump-to-url-on-page)
    (define-key map (kbd "C-r") #'prot-eww-readable)
    (define-key map (kbd "C-q") #'prot-eww-quit)))
#+end_src

#+RESULTS:
: t

** email
#+begin_src emacs-lisp :tangle no

;; -*- lexical-binding: t -*-
;;
;; * SENDMAIL
;;
;; We use msmtp. Also of note is automatic selection of the
;; right from address when replying to email.
(use-package sendmail
  :after (message notmuch)
  :config
  (setq mail-host-address "gmail.com"
        send-mail-function 'sendmail-send-it
        message-send-mail-function 'message-send-mail-with-sendmail
        sendmail-program "/usr/bin/msmtp"
        mail-specify-envelope-from t
        message-sendmail-envelope-from 'header
        mail-envelope-from 'header)

  ;; Choose account label to feed msmtp -a option based on From header in Message buffer;
  ;; This function must be added to message-send-mail-hook for on-the-fly change of From address
  ;; before sending message since message-send-mail-hook is processed right before sending message.
  (defun cg-feed-msmtp ()
    (if (message-mail-p)
        (save-excursion
          (let* ((from
                  (save-restriction
                    (message-narrow-to-headers)
                    (message-fetch-field "from")))
                 (account
                  (cond
                   ;; I use email address as account label in ~/.msmtprc
                   ((string-match my-email-address from) my-email-dir)
                   ((seq-some (lambda (x) (string-match x from))
                              my-alt-email-addresses)
                    my-alt-email-dir))))
            (setq message-sendmail-extra-arguments (list '"-a" account))))))
  ;; the original form of this script did not have the ' before "a" which causes
  ;; a very difficult to track bug --frozencemetery
  (add-hook 'message-send-mail-hook #'cg-feed-msmtp)
  )

;;* NOTMUCH

(use-package notmuch
  :commands notmuch
  :bind (("C-x m" . notmuch-mua-new-mail)
         ("C-x M-m" . notmuch-jump-search))
  :hook ((notmuch-message-mode . turn-off-auto-fill)
         (notmuch-mua-send . notmuch-mua-attachment-check))
  :config
  (setq-default notmuch-search-oldest-first nil)
  (setq notmuch-show-logo nil
        notmuch-fcc-dirs nil
        notmuch-column-control 0.6
        notmuch-message-headers-visible nil
        notmuch-saved-searches my-notmuch-saved-searches
        message-kill-buffer-on-exit t
        ;; notmuch-search-result-format
        ;; '(("date" . "%12s ")
        ;;   ("count" . "%-7s ")
        ;;   ("authors" . "%-30s ")
        ;;   ("subject" . "%-72s ")
        ;;   ("tags" . "(%s)"))
        ;; notmuch-tag-formats
        ;; '(("unread" (propertize tag 'face 'notmuch-tag-unread)))
        notmuch-always-prompt-for-sender t
        notmuch-archive-tags '("-inbox" "-unread")
        notmuch-hello-sections
        '(notmuch-hello-insert-saved-searches
          notmuch-hello-insert-alltags))

  (setq notmuch-search-line-faces '(("flagged"   . (:inherit notmuch-search-flagged-face
                                                    :foreground "IndianRed"))
                                    ("ucsb"      . (:foreground "MediumPurple"))
				    ("important" . (:foreground "CornflowerBlue"))
                                    ("unread"    . (:inherit notmuch-search-unread-face
                                                    ;; :background "gray16"
                                                    ))))

  (defun notmuch-search-make-tagger (&rest tags)
    (lambda () (interactive)
      (let ((taglist (mapcar (lambda (tag)
                               (if (member tag (notmuch-search-get-tags))
                                   (concat "-" tag)
                                 (concat "+" tag)))
                             tags)))
        (notmuch-search-tag taglist)
        (message "Tagged: %s" (mapconcat #'identity taglist " "))
        (notmuch-search-next-thread))))

  (defun notmuch-show-make-tagger (&rest tags)
    (lambda () (interactive)
      (let ((taglist (mapcar (lambda (tag)
                               (if (member tag (notmuch-show-get-tags))
                                   (concat "-" tag)
                                 (concat "+" tag)))
                             tags)))
        (notmuch-show-tag taglist)
        (message "Tagged: %s" (mapconcat #'identity taglist " "))
        (notmuch-show-next-message))))

  (defun notmuch-tree-make-tagger (&rest tags)
    (lambda (&optional all) (interactive "P")
      (let ((taglist (mapcar (lambda (tag)
                               (if (member tag (notmuch-tree-get-tags))
                                   (concat "-" tag)
                                 (concat "+" tag)))
                             tags)))
        (if all
            (notmuch-tree-tag-thread taglist)
          (notmuch-tree-tag taglist))
        (message "Tagged: %s" (mapconcat #'identity taglist " "))
        (notmuch-tree-next-thread))))

  (define-key notmuch-search-mode-map (kbd "f") (notmuch-search-make-tagger "flagged"))
  (define-key notmuch-show-mode-map (kbd "f") (notmuch-show-make-tagger "flagged"))
  (define-key notmuch-tree-mode-map (kbd "f") (notmuch-tree-make-tagger "flagged"))

  (define-key notmuch-search-mode-map (kbd "d") (notmuch-search-make-tagger "trash" "inbox"))
  (define-key notmuch-show-mode-map (kbd "d") (notmuch-show-make-tagger "trash" "inbox"))
  (define-key notmuch-tree-mode-map (kbd "d") (notmuch-tree-make-tagger "trash" "inbox"))


  ;;; (define-key notmuch-show-mode-map "`" 'notmuch-show-apply-tag-macro)
  ;;; (define-key notmuch-search-mode-map "`" 'notmuch-show-apply-tag-macro)
    ;
  ;;; (define-prefix-command notmuch-tagger-map)
  ;;; (let ((map notmuch-tagger-map))
  ;;;   (define-key map "")
  ;;;   )
    ;
  ;;; (defun notmuch-show-apply-tag-macro (key)
  ;;;   (interactive "k")
  ;;;   (let ((macro (assoc key notmuch-show-tag-macro-alist)))
  ;;;     (apply 'notmuch-show-tag-message (cdr macro))))
    ;
  ;;; (defun +disable-C-tab (mode-map)
  ;;;   "Disable Control-Tab in mode-map"
  ;;;   (define-key mode-map (kbd "C-TAB") nil)
  ;;;   (define-key mode-map (kbd "C-<tab>") nil))
    ;
  ;;; (dolist (mode '((notmuch-hello-mode-hook . notmuch-hello-mode-map)
  ;;;                 (notmuch-show-mode-hook . notmuch-show-mode-map)
  ;;;                 (notmuch-message-mode-hook . notmuch-message-mode-map)
  ;;;                 (notmuch-tree-mode-hook . notmuch-tree-mode-map)
  ;;;                 (notmuch-search-mode-hook . notmuch-search-mode-map)))
  ;;;   (let ((mode-hook (car mode))
  ;;;         (mode-map (cdr mode)))
  ;;;     (add-hook mode-hook
  ;;;               (lambda ()
  ;;;                 (+disable-C-tab mode-map)))))
    ;
    ;
  ;;; (define-key notmuch-common-keymap (kbd "C-TAB") nil)
  ;;; (define-key notmuch-common-keymap (kbd "C-<tab>") nil)
    ;
    ;
  ;;; (add-hook 'notmuch-show-hook #'my-next-unread)
  ;;; (defun my-next-unread ()
  ;;;   (interactive)
  ;;;   (let ((init (point)))
  ;;;     (catch 'break
  ;;;       (while t
  ;;;         (when (member "unread" (notmuch-show-get-tags))
  ;;;           (let ((props (notmuch-show-get-message-properties)))
  ;;;             (notmuch-show-message-visible props t)
  ;;;             (notmuch-show-mark-read)
  ;;;             (throw 'break t)))
  ;;;         (when (not (notmuch-show-goto-message-next))
  ;;;           (message "No more unread messages.")
  ;;;           (goto-char init)
  ;;;           (throw 'break t))))))
  )

(use-package notmuch-bookmarks
:after notmuch
:config
(notmuch-bookmarks-mode))

;; * CONSULT-NOTMUCH

;; [[https://melpa.org/#/consult-notmuch][consult-notmuch]] provides consult
;; commands for live-searching a notmuch database.
;;
;; I use a couple of date-oriented custom notmuch search commands instead of the
;; default, bound to my "search map" (=M-s=) prefix:

(use-package consult-notmuch
  :load-path "~/.local/share/git/consult-notmuch/"
  :after consult
  :bind (("M-s M-m" . consult-notmuch-latest-tree)
         ("M-s m" . consult-notmuch-latest))
  :config
  (defun consult-notmuch-latest (&optional arg)
    (interactive "P")
    (let ((consult-async-input-debounce 0.6)
          (consult-async-input-throttle 0.7))
      (consult-notmuch
       (unless arg "tag:inbox date:1d.."))))
  (defun consult-notmuch-latest-tree (&optional arg)
    (interactive "P")
    (let ((consult-async-input-debounce 0.6)
          (consult-async-input-throttle 0.7))
      (consult-notmuch-tree
       (unless arg "tag:inbox date:1d..")))))

;; Add a notmuch buffer-source to =consult-buffer=. This is provided by
;; consult-notmuch.

(use-package consult
  :after (notmuch consult-notmuch)
  :config
  (add-to-list 'consult-buffer-sources 'consult-notmuch-buffer-source))

;; Embark actions on =consult-notmuch= search results to add/remove tags, and an
;; Embark exporter that displays search results in a =notmuch-search= buffer.
;;
;; This code [[https://codeberg.org/jao/consult-notmuch/pulls/6][will be part of
;; consult-notmuch]] soon.

(use-package embark
  :after (notmuch embark)
  :config
  (defun embark-notmuch-make-tagger (tags)
    "Make a function to tag a message with TAGS."
    (lambda (msg)
      "Tag a notmuch message using Embark."
      (when-let ((thread-id (consult-notmuch--thread-id msg)))
        (notmuch-tag (concat "(" thread-id ")")
                     (split-string tags)))))
  (defun embark-export-consult-notmuch (msgs)
    "Create a notmuch search buffer listing messages."
    (notmuch-search
     (concat "("
             (mapconcat #'consult-notmuch--thread-id msgs " ")
             ")")))

  (defun embark-notmuch-tag (msg)
    (when-let* ((thread-id (consult-notmuch--thread-id msg))
                (tags (get-text-property 0 'tags msg))
                (tag-changes (notmuch-read-tag-changes
                              tags "Tags: "
                             "+")))
      (notmuch-tag (concat "(" thread-id ")")
                   tag-changes)))

  (defvar embark-notmuch-map
    (let ((map (make-sparse-keymap)))
      (define-key map (kbd "d") (embark-notmuch-make-tagger "+trash -inbox"))
      (define-key map (kbd "a") (embark-notmuch-make-tagger "-inbox"))
      (define-key map (kbd "f") (embark-notmuch-make-tagger "+flagged"))
      (define-key map (kbd "+") 'embark-notmuch-tag)
      (define-key map (kbd "-") 'embark-notmuch-tag)
      map)
    "Keymap for actions on Notmuch entries.")
  (add-to-list 'embark-keymap-alist '(notmuch-result . embark-notmuch-map))
  (add-to-list 'embark-exporters-alist '(notmuch-result . embark-export-consult-notmuch)))

(provide 'setup-email)
#+end_src
* Applications and utilities
This section includes configurations for programs like email clients,
news reader, music players…  Anything you would normally see in a
standalone application.  The end goal is to eventually integrate every
aspect of my computing inside of Emacs.

** Ebooks
[[xkcd:548]]

For managing my ebooks, I'll hook into the well-established ebook library
manager [[https://calibre-ebook.com/][calibre]]. A number of Emacs clients for this exist, but this seems like a
good option.
#+begin_src emacs-lisp :tangle packages.el
(package! calibredb :pin "cb93563d0ec9e0c653210bc574f9546d1e7db437")
#+end_src

Then for reading them, the only currently viable options seems to be [[https://depp.brause.cc/nov.el/][nov.el]].
#+begin_src emacs-lisp :tangle packages.el
(package! nov :pin "2b4a7231aff6211a5a2f28719d830887aec6cc57")
#+end_src

Together these should give me a rather good experience reading ebooks.

=calibredb= lets us use calibre through Emacs, because who wouldn't want to use
something through Emacs?
#+begin_src emacs-lisp
(use-package! calibredb
  :commands calibredb
  :config
  (setq calibredb-root-dir "~/Desktop/Ebooks"
        calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
  (map! :map calibredb-show-mode-map
        :ne "?" #'calibredb-entry-dispatch
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "q" #'calibredb-entry-quit
        :ne "." #'calibredb-open-dired
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments)
  (map! :map calibredb-search-mode-map
        :ne [mouse-3] #'calibredb-search-mouse
        :ne "RET" #'calibredb-find-file
        :ne "?" #'calibredb-dispatch
        :ne "a" #'calibredb-add
        :ne "A" #'calibredb-add-dir
        :ne "c" #'calibredb-clone
        :ne "d" #'calibredb-remove
        :ne "D" #'calibredb-remove-marked-items
        :ne "j" #'calibredb-next-entry
        :ne "k" #'calibredb-previous-entry
        :ne "l" #'calibredb-virtual-library-list
        :ne "L" #'calibredb-library-list
        :ne "n" #'calibredb-virtual-library-next
        :ne "N" #'calibredb-library-next
        :ne "p" #'calibredb-virtual-library-previous
        :ne "P" #'calibredb-library-previous
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "S" #'calibredb-switch-library
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "v" #'calibredb-view
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "." #'calibredb-open-dired
        :ne "b" #'calibredb-catalog-bib-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "r" #'calibredb-search-refresh-and-clear-filter
        :ne "R" #'calibredb-search-clear-filter
        :ne "q" #'calibredb-search-quit
        :ne "m" #'calibredb-mark-and-forward
        :ne "f" #'calibredb-toggle-favorite-at-point
        :ne "x" #'calibredb-toggle-archive-at-point
        :ne "h" #'calibredb-toggle-highlight-at-point
        :ne "u" #'calibredb-unmark-and-forward
        :ne "i" #'calibredb-edit-annotation
        :ne "DEL" #'calibredb-unmark-and-backward
        :ne [backtab] #'calibredb-toggle-view
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-n" #'calibredb-show-next-entry
        :ne "M-p" #'calibredb-show-previous-entry
        :ne "/" #'calibredb-search-live-filter
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments))
#+end_src

Then, to actually read the ebooks we use =nov=.


#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 81
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)

    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)

    (setq-local mode-line-format
                `((:eval
                   (doom-modeline-segment--workspace-name))
                  (:eval
                   (doom-modeline-segment--window-number))
                  (:eval
                   (doom-modeline-segment--nov-info))
                  ,(propertize
                    " %P "
                    'face 'doom-modeline-buffer-minor-mode)
                  ,(propertize
                    " "
                    'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
                    'display `((space
                                :align-to
                                (- (+ right right-fringe right-margin)
                                   ,(* (let ((width (doom-modeline--font-width)))
                                         (or (and (= width 1) 1)
                                             (/ width (frame-char-width) 1.0)))
                                       (string-width
                                        (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
                  (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src
** Calculator
Emacs includes the venerable =calc=, which is a pretty impressive RPN (Reverse
Polish Notation) calculator. However, we can do a bit to improve the experience.

*** Defaults

Any sane person prefers radians and exact values.

#+begin_src emacs-lisp
(setq calc-angle-mode 'rad  ; radians are rad
      calc-symbolic-mode t) ; keeps expressions like \sqrt{2} irrational for as long as possible
#+end_src

*** CalcTeX

Everybody knows that mathematical expressions look best with LaTeX, so =calc='s
ability to create LaTeX representations of its expressions provides a lovely
opportunity which is taken advantage of in the CalcTeX package.

#+begin_src emacs-lisp :tangle packages.el
(package! calctex :recipe (:host github :repo "johnbcoughlin/calctex"
                           :files ("*.el" "calctex/*.el" "calctex-contrib/*.el" "org-calctex/*.el" "vendor"))
  :pin "67a2e76847a9ea9eff1f8e4eb37607f84b380ebb")
#+end_src


We'd like to use CalcTeX too, so let's set that up, and fix some glaring
inadequacies --- why on earth would you commit a hard-coded path to an executable
that /only works on your local machine/, consequently breaking the package for
everyone else!?

#+begin_src emacs-lisp
(use-package! calctex
  :commands calctex-mode
  :init
  (add-hook 'calc-mode-hook #'calctex-mode)
  :config
  (setq calctex-additional-latex-packages "
\\usepackage[usenames]{xcolor}
\\usepackage{soul}
\\usepackage{adjustbox}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{siunitx}
\\usepackage{cancel}
\\usepackage{mathtools}
\\usepackage{mathalpha}
\\usepackage{xparse}
\\usepackage{arevmath}"
        calctex-additional-latex-macros
        (concat calctex-additional-latex-macros
                "\n\\let\\evalto\\Rightarrow"))
  (defadvice! no-messaging-a (orig-fn &rest args)
    :around #'calctex-default-dispatching-render-process
    (let ((inhibit-message t) message-log-max)
      (apply orig-fn args)))
  ;; Fix hardcoded dvichop path (whyyyyyyy)
  (let ((vendor-folder (concat (file-truename doom-local-dir)
                               "straight/"
                               (format "build-%s" emacs-version)
                               "/calctex/vendor/")))
    (setq calctex-dvichop-sty (concat vendor-folder "texd/dvichop")
          calctex-dvichop-bin (concat vendor-folder "texd/dvichop")))
  (unless (file-exists-p calctex-dvichop-bin)
    (message "CalcTeX: Building dvichop binary")
    (let ((default-directory (file-name-directory calctex-dvichop-bin)))
      (call-process "make" nil nil nil))))
#+end_src
*** Embedded calc

Embedded calc is a lovely feature which let's us use calc to operate on LaTeX
maths expressions. The standard keybinding is a bit janky however (=C-x * e=), so
we'll add a localleader-based alternative.

#+begin_src emacs-lisp
(map! :map calc-mode-map
      :after calc
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Embedded calc (toggle)" "E" #'calc-embedded)
(map! :map latex-mode-map
      :after latex
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
#+end_src

Unfortunately this operates without the (rather informative) calculator and
trail buffers, but we can advice it that we would rather like those in a side
panel.

#+begin_src emacs-lisp
(defvar calc-embedded-trail-window nil)
(defvar calc-embedded-calculator-window nil)

(defadvice! calc-embedded-with-side-pannel (&rest _)
  :after #'calc-do-embedded
  (when calc-embedded-trail-window
    (ignore-errors
      (delete-window calc-embedded-trail-window))
    (setq calc-embedded-trail-window nil))
  (when calc-embedded-calculator-window
    (ignore-errors
      (delete-window calc-embedded-calculator-window))
    (setq calc-embedded-calculator-window nil))
  (when (and calc-embedded-info
             (> (* (window-width) (window-height)) 1200))
    (let ((main-window (selected-window))
          (vertical-p (> (window-width) 80)))
      (select-window
       (setq calc-embedded-trail-window
             (if vertical-p
                 (split-window-horizontally (- (max 30 (/ (window-width) 3))))
               (split-window-vertically (- (max 8 (/ (window-height) 4)))))))
      (switch-to-buffer "*Calc Trail*")
      (select-window
       (setq calc-embedded-calculator-window
             (if vertical-p
                 (split-window-vertically -6)
               (split-window-horizontally (- (/ (window-width) 2))))))
      (switch-to-buffer "*Calculator*")
      (select-window main-window))))
#+end_src

** Dictionary
Doom already loads =define-word=, and provides it's own definition service using
[[https://github.com/gromnitsky/wordnut][wordnut]]. However, using an offline dictionary possess a few compelling
advantages, namely:
+ speed
+ integration of multiple dictionaries
[[http://goldendict.org/][GoldenDict]] seems like the best option currently available, but lacks a CLI.
Hence, we'll fall back to [[https://dushistov.github.io/sdcv/][sdcv]] (a CLI version of StarDict) for now.
To interface with this, we'll use a my =lexic= package.


#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "packages.el" "no")
(package! lexic :recipe (:local-repo "lisp/lexic"))
#+end_src

Given that a request for a CLI is the [[https://github.com/goldendict/goldendict/issues/37][most upvoted issue]] on GitHub for
GoldenDict, it's likely we'll be able to switch from ~sdcv~ to that in the future.

Since GoldenDict supports StarDict files, I expect this will be a relatively
painless switch.

We start off by loading =lexic=, then we'll integrate it into pre-existing
definition functionality (like ~+lookup/dictionary-definition~).
#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "yes" "no")
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :config
  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "h" (cmd! (outline-hide-sublevels 3))
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

Now let's use this instead of wordnet.
#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "yes" "no")
(defadvice! +lookup/dictionary-definition-lexic (identifier &optional arg)
  "Look up the definition of the word at point (or selection) using `lexic-search'."
  :override #'+lookup/dictionary-definition
  (interactive
   (list (or (doom-thing-at-point-or-region 'word)
             (read-string "Look up in dictionary: "))
         current-prefix-arg))
  (lexic-search identifier nil nil t))
#+end_src

Lastly, I want to make sure I have some dictionaries set up. I've put a tarball
of dictionaries online which we can download if none seem to be present on the
system.
#+begin_src shell :tangle (if (and (executable-find "sdsv") (not (file-exists-p (concat (or (getenv "STARDICT_DATA_DIR") (concat (or "~/.local/share" (getenv "XDG_DATA_HOME")) "/stardict")) "/dic")))) "setup.sh" "no")
DIC_FOLDER=${STARDICT_DATA_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/stardict}/dic
if [ ! -d "$DIC_FOLDER" ]; then
    TMP="$(mktemp -d /tmp/dict-XXX)"
    cd "$TMP"
    curl -A "Mozilla/4.0" -o "stardict.tar.gz" "https://tecosaur.com/resources/config/stardict.tar.gz"
    tar -xf "stardict.tar.gz"
    rm "stardict.tar.gz"
    mkdir -p "$DIC_FOLDER"
    mv * "$DIC_FOLDER"
fi
#+end_src

** Custom extensions for "focus mode" (logos.el)
:PROPERTIES:
:CUSTOM_ID: h:77d14350-978d-4820-ab7f-4641706c445a
:END:

Also watch: [[https://protesilaos.com/codelog/2022-03-11-emacs-logos-demo/][Emacs: demonstration of logos.el]] (2022-03-11).

=logos= (or =logos.el=) is a new library of mine (as of 2022-03-02)
which provides a set of utilities for handling presentations and/or
focusing your attention on the current buffer's contents:
https://protesilaos.com/emacs/logos.  It supersedes the =prot-logos.el=
I had before and will soon be available via =M-x package-install=.

With all user options disabled (the out-of-the-box design), this package
provides a simple approach to handling presentations using nothing but
the =page-delimiter= together with some commands to move between pages
whether narrowing is in effect or not.

What constitutes a page delimiter is determined by the user options
=logos-outlines-are-pages= and =logos-outline-regexp-alist=.  By
default, this only corresponds to the =^L= character (which can be
inserted using the standard keys with =C-q C-l=).

Logos does not define any key bindings. Though I do so in the
configuration block further below.

Additionally, Logos provides some optional aesthetic tweaks which come
into effect when the buffer-local =logos-focus-mode= is enabled.  These
will hide the mode line (=logos-hide-mode-line=), enable
=scroll-lock-mode= (=logos-scroll-lock=), and use =variable-pitch-mode=
in non-programming buffers (=logos-variable-pitch=).  All these
variables are buffer-local.

To position the buffer in the center of the window, I install the
=olivetti= package by Paul W. Rankin.  =logos.el= does not need to
reinvent what already works well: all that is required is some glue code
to integrate the two packages.

"Logos" is the familiar word derived from Greek (watch my presentation
on philosophy about /Cosmos, Logos, and the living universe/:
https://protesilaos.com/books/2022-02-05-cosmos-logos-living-universe/),
though it also stands for these two perhaps equally insightful
backronyms about the mechanics of this package:

1. =^L= Only Generates Ostensible Slides
2. Logos Optionally Garners Outline Sections

Other potentially relevant parts of my dotemacs:

+ [[#h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3][Paragraphs and fill-mode (prot-fill.el)]]
+ [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]]

#+begin_src emacs-lisp :tangle no
;;; Custom extensions for "focus mode" (logos.el)
(use-package olivetti
  :config
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 80)
  (setq olivetti-recall-visual-line-mode-entry-state t))

(use-package logos
  :config
  (setq logos-outlines-are-pages t)
  (setq logos-outline-regexp-alist
        `((emacs-lisp-mode . ,(format "\\(^;;;+ \\|%s\\)" logos--page-delimiter))
          (org-mode . ,(format "\\(^\\*+ +\\|^-\\{5\\}$\\|%s\\)" logos--page-delimiter))
          (t . ,(or outline-regexp logos--page-delimiter))))

  ;; These apply when `logos-focus-mode' is enabled.  Their value is
  ;; buffer-local.
  (setq-default logos-hide-mode-line t)
  (setq-default logos-scroll-lock nil)
  (setq-default logos-variable-pitch nil)
  (setq-default logos-buffer-read-only nil)
  (setq-default logos-olivetti t)

  (let ((map global-map))
    (define-key map [remap narrow-to-region] #'logos-narrow-dwim)
    (define-key map [remap forward-page] #'logos-forward-page-dwim)
    (define-key map [remap backward-page] #'logos-backward-page-dwim)
    ;; I don't think I ever saw a package bind M-] or M-[...
    (define-key map (kbd "M-]") #'logos-forward-page-dwim)
    (define-key map (kbd "M-[") #'logos-backward-page-dwim)
    (define-key map (kbd "<f9>") #'logos-focus-mode)))

;;;; Extra tweaks
  ;; Read the logos manual: <https://protesilaos.com/emacs/logos>.

  ;; place point at the top when changing pages, but not in `prog-mode'
  ;; (defun prot/logos--recenter-top ()
  ;;   "Use `recenter' to reposition the view at the top."
  ;;   (unless (derived-mode-p 'prog-mode)
  ;;     (recenter 1))) ; Use 0 for the absolute top

  ;; (add-hook 'logos-page-motion-hook #'prot/logos--recenter-top))
#+end_src

#+RESULTS:
: t

** USLS --- Unassuming Sidenotes of Little Significance
:PROPERTIES:
:CUSTOM_ID: h:787df548-0d95-4512-a61d-27852198f561
:END:

NOTE 2021-12-29: USLS is subject to a rewrite.  I have been using it
daily since its inception, though the code needs to be refactored.  As a
proof-of-concept of its utility, check out my =invtr= (only for curious
hackers, not actual users): [[#h:c66a0f25-840a-49f0-a615-66dfca61890b][INVTR (toy inventory and client manager)]].

This is a library that I am developing to help me flesh out my
note-taking system.  In essence, =usls= is a set of helper functions
around standard Emacs tools, such as =find-file=, =dired=, and internal
libraries like =thingatpt=.  It has no external dependencies whatsoever.
This blog post of mine documents the principles and general ideas about
it: [[https://protesilaos.com/codelog/2020-10-08-intro-usls-emacs-notes/][My simple note-taking system for Emacs (without Org)]] (2020-10-08).

Because this is standard Emacs stuff, I can always benefit from the rest
of my setup, such as to search for file contents in the current
directory.  Study the entirety of my [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]].

In the =usls.el= code I wanted to respect key binding conventions, so I
did not bind any keys: this is a user-level customisation.  The other
options I have here are for the sake of visibility and are left to their
default values.

The code for this project is on the [[https://gitlab.com/protesilaos/usls][USLS Gitlab repo]] and reproduced in
the subsequent code block.

#+begin_src emacs-lisp :tangle no
;;; USLS --- Unassuming Sidenotes of Little Significance
(use-package usls
  :config
  (setq usls-directory (expand-file-name "~/Documents/notes/"))
  (setq usls-known-categories '("economics" "philosophy" "politics"))
  (setq usls-file-type-extension ".txt") ; {.txt,.org,.md}
  (setq usls-subdir-support nil)
  (setq usls-file-region-separator 'line) ; {'line,'heading, OR string of your choice}
  (setq usls-file-region-separator-heading-level 1)
  (setq usls-custom-header-function nil)

  (add-hook 'usls-mode-hook #'goto-address-mode)

  (let ((map global-map))               ; globally bound keys
    (define-key map (kbd "C-c n d") #'usls-dired)
    (define-key map (kbd "C-c n f") #'usls-find-file)
    (define-key map (kbd "C-c n a") #'usls-append-region-buffer-or-file)
    (define-key map (kbd "C-c n n") #'usls-new-note))
  (let ((map usls-mode-map))            ; only for usls buffers
    (define-key map (kbd "C-c n i") #'usls-id-insert)
    (define-key map (kbd "C-c n l") #'usls-follow-link)))
#+end_src

#+RESULTS:
: t

Here is the =usls.el= code, which is also part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as
with all my Elisp code):

#+include: prot-lisp/usls.el src emacs-lisp :tangle no

** INVTR (toy inventory and client manager)
:PROPERTIES:
:CUSTOM_ID: h:c66a0f25-840a-49f0-a615-66dfca61890b
:END:

I am intentionally not documenting this because it is not intended for
public use.  It is a *highly experimental proof-of-concept* of a nimble
inventory and client manager that extends the file-naming methodology of
my USLS (see [[#h:787df548-0d95-4512-a61d-27852198f561][USLS --- Unassuming Sidenotes of Little Significance]]).

#+begin_src emacs-lisp :tangle no
;;; INVTR (toy inventory and client manager)
;; DO NOT USE THIS!!!
;; (use-package invtr)
#+end_src

** tmr.el (TMR Must Recur)
:PROPERTIES:
:CUSTOM_ID: h:c90ba6fa-ebec-42a2-98a6-3ff9027b1ffa
:END:

Sometimes I need to set off a timer with a notification.  I used to rely
on a homegrown shell script for such a task, but where is the fun in
that?

This package of mine provides a single command for setting a timer: =tmr=.

The command prompts for a unit of time, which is represented as a string
that consists of a number and, optionally, a single character suffix
which specifies the unit of time.

Valid formats:

| Input | Meaning   |
|-------+-----------|
| 5     | 5 minutes |
| 5m    | 5 minutes |
| 5s    | 5 seconds |
| 5h    | 5 hours   |

If =tmr= is called with an optional prefix argument (=C-u=), it also asks
for a description which accompanies the given timer.  Preconfigured
candidates are specified in the user option =tmr-descriptions-list=,
though any arbitrary input is acceptable at the minibuffer prompt.

When the timer is set, a message is sent to the echo area recording the
current time and the point in the future when the timer elapses.  Echo
area messages can be reviewed with the =view-echo-area-messages= which is
bound to =C-h e= by default.

Once the timer runs its course, it produces a desktop notification and
plays an alarm sound.  The notification's message is practically the
same as that which is sent to the echo area.  The sound file for the
alarm is defined in =tmr-sound-file=, while the urgency of the
notification can be set through the =tmr-notification-urgency= option.

The =tmr-cancel= command cancels the last =tmr=.  Note that for the time
being it has no notion of multiple timers---just the last one.

#+begin_src emacs-lisp :tangle no
;;; TMR Must Recur (just my generic timer)
(use-package tmr
:config
  (setq tmr-sound-file
        "/usr/share/sounds/freedesktop/stereo/alarm-clock-elapsed.oga")
  (setq tmr-notification-urgency 'normal)
  (setq tmr-descriptions-list (list "Boil water" "Prepare tea" "Bake bread"))
  (let ((map global-map))
    (define-key map (kbd "C-c n t") #'tmr)
    (define-key map (kbd "C-c n c") #'tmr-cancel)))
#+end_src

** Version control tools
:PROPERTIES:
:CUSTOM_ID: h:0e2fe4c7-9d4b-4570-a293-9a9629021ff7
:END:
*** Diff-mode (and prot-diff.el extensions)
:PROPERTIES:
:CUSTOM_ID: h:2ff46d23-09d5-4d92-b0af-2339dc19719f
:END:

This covers the standard =diff-mode.el=, which I use quite often, such as
while interfacing with the built-in Version Control framework (see the
section on [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]), or while
browsing various code-related mailing lists through notmuch (refer to
the [[#h:5ad80664-3163-4d9d-be65-462637d77903][email settings]]).

Overview of my preferences for how diffs should look:

+ Always start the buffer in a read-only state.  A typo will mess things
  up when trying to apply a patch.
+ After applying a diff hunk (=diff-apply-hunk= with =C-c C-a=) move on to
  the next one.
+ Update hunk headers automatically following an edit to the diff.
+ Do not show word-wise ("refined") changes upon activation.  I prefer
  to do so manually.  All such highlights are removed if you generate
  the buffer again (with =g= as expected) and the default is to not show
  word-wise changes.
+ Do not prettify headers.  I like the standard "patch" looks.  It also
  makes it easier to copy the diff elsewhere.

Now some notes on my =prot-diff.el= extensions, combined with a
description of the basics of =diff-mode= (as always you can get
documentation about the current buffer's major mode with =C-h m=---read
[[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]] in the FAQ section appended to this document):

+ =prot-diff-buffer-dwim= will produce a diff that compares the current
  buffer to the last saved state of the underlying file.  If the buffer
  has no unsaved edits, the command will produce a diff that compares
  the file to its last registered version-controlled state.  Calling the
  command with an optional prefix argument (=C-u=) will enable word-wise
  highlighting across the diff.

+ =prot-diff-refine-cycle= is how I manually control word-wise diff
  highlights.  This command has a buffer-local cyclic behaviour.  The
  first time it is called, it acts on the diff hunk at point.  Upon
  second invocation, it operates on the entire buffer.  And on third
  call it removes the word-wise diffs altogether.

+ =prot-diff-narrow-dwim= narrows to the diff hunk at point.  If narrowing
  is already present, it widens the buffer.  When invoked with an
  optional prefix argument, it narrows to the current file.

+ =C-c C-c= or =M-o= takes you to the point of the changes in the source
  file.  If you run this of the diff hunk's heading, you go to the
  beginning of the context.  But if you place the point somewhere inside
  of the diff's added changes or context, you will visit that exact
  position in the original file (does not work for removed text because
  technically it does not exist).

+ When working with patches to source code, which are distributed
  e.g. through email, you can apply the current hunk with =C-c C-a= or
  test for compatibility with =C-c C-t=.  This is a nice way to easily
  merge contributions from others, without having to go through the
  workflow of some proprietary Git/Version-Control forge.

+ With =M-n= and =M-p= you move between hunks.  With =M-}= and =M-{= or =M-N=, =M-P=
  do the same between files.

The =prot-diff-*= commands are part of my =prot-diff.el= library, reproduced
in its entirety after this set of package configurations.

*Pro tip:* enable =outline-minor-mode= to make diff sections foldable.
Check [[#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1][Outline mode, outline minor mode, and extras (prot-outline.el)]].

Also read these sections:

+ [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]].
+ [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]].

Changes to all tracked files are optionally highlighted in the fringe
thanks to the =diff-hl= package by Dmitry Gutov (refer to the section on
[[#h:cb76fcee-e304-4b86-a764-6c3c6775da51][Line numbers and relevant indicators (prot-sideline.el)]]).  Any rules
that control the placement of VC-related (and other) buffers are defined
in the section on [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][window rules and basic tweaks]] (specifically, refer to
the variable =display-buffer-alist=).

#+begin_src emacs-lisp :tangle no
;;; Diff-mode (and prot-diff.el extensions)
(use-package diff-mode
  :config
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil)                ; I do it on demand
  (setq diff-font-lock-prettify nil)    ; better for patches
  ;; The following is further controlled by
  ;; `prot-diff-modus-themes-diffs'
  (setq diff-font-lock-syntax 'hunk-also))
(add-to-list 'load-path "~/.config/doom/lisp/")

(load "prot-diff")
 (use-package prot-diff
   :config
   ;; (prot-diff-modus-themes-diffs)
   (add-hook 'modus-themes-after-load-theme-hook #'prot-diff-modus-themes-diffs)

   (prot-diff-extra-keywords 1)

   ;; `prot-diff-buffer-dwim' replaces the default for `vc-diff' (which I
   ;; bind to another key---see VC section).
   (define-key global-map (kbd "C-x v =") #'prot-diff-buffer-dwim)
   (let ((map diff-mode-map))
     (define-key map (kbd "C-c C-b") #'prot-diff-refine-cycle) ; replace `diff-refine-hunk'
     (define-key map (kbd "C-c C-n") #'prot-diff-narrow-dwim)))
 #+end_src

#+RESULTS:
: t

*** Version control framework (vc.el and prot-vc.el)
:PROPERTIES:
:CUSTOM_ID: h:31deeff4-dfae-48d9-a906-1f3272f29bc9
:END:

VC consists of set of libraries that provide the means for working with
several version control systems, else "backends".  It is built into
Emacs.  Compared with =magit= (see section on [[#h:76d1b392-e693-40dc-b320-d4c1047115ab][Magit configs]]), =vc= offers a
more abstract, buffer-oriented paradigm that does a fine job at covering
all basic versioning needs.  It however never stands as Magit's peer
when it comes to the sheer coverage of Git features.

To my mind, VC and Magit can be used as part of the same setup.  Employ
the former for common tasks such as viewing diffs and logs, committing
changes in bulk, pushing and pulling from a remote.  And let Magit
handle the more involved and specialised cases of staging a partial
diff, rebasing commits interactively, writing a commit fixup, and so on.

Also refer to the section on [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]]
which includes various neat extras, such as extra fontification rules
for diff buffers.  And watch my videos on this topic:

1. [[https://protesilaos.com/codelog/2020-03-30-emacs-intro-vc/][Introduction to the Emacs Version Control framework]] (2020-03-30).
2. [[https://protesilaos.com/codelog/2021-01-22-emacs-vc-git-extras/][Extensions for Emacs' vc-git]] (2021-01-22).
3. [[https://protesilaos.com/codelog/2021-02-08-emacs-vc-workflow/][My workflow with VC for Git projects]] (2021-02-08).

Here is an overview of the keys I define, with only a few of them being
left to their default values (note that =prot-diff-buffer-dwim= is part of
the =prot-diff.el= that I linked to above):

| Command                          | C-x v prefix | Mnemonic          |
|----------------------------------+--------------+-------------------|
| vc-update                        | F            | Fetch and Fuse    |
| vc-push                          | P            |                   |
| vc-log-incoming                  | f            | Fetch only        |
| vc-log-outgoing                  | O            |                   |
| vc-create-tag                    | t            |                   |
| vc-retrieve-tag                  | b            | Branch/tag switch |
| vc-diff                          | d            | Diff current file |
| vc-root-diff                     | D            | Diff project      |
| prot-diff-buffer-dwim            | =            | Equality check    |
| prot-vc-project-or-dir           | p            | Project status    |
| prot-vc-custom-log               | SPC          |                   |
| prot-vc-git-patch-apply          | a            | Apply patch       |
| prot-vc-git-patch-create-dwim    | c            | Create patch      |
| prot-vc-git-show                 | s            | Show commit       |
| prot-vc-git-grep                 | g            |                   |
| prot-vc-git-log-grep             | G            |                   |
| prot-vc-git-find-revision        | r            | Revisit version   |
| prot-vc-git-blame-region-or-file | B            | Blame             |
| prot-vc-git-log-insert-commits   | i            | Insert commit log |
| prot-vc-git-reset                | R            | Reset (--soft)    |

My =prot-vc.el= library (reproduced after the package configurations)
defines several commands that extend VC to suit my needs as a Git user.
Check the key maps I assign those commands to, in order to further
appreciate the scope of each action.  In short:

+ =prot-vc-git-grep= is a simple wrapper around =vc-git-grep=.  Instead of
  asking for a directory and a file extension pattern, it just prompts
  for a regexp and performs the search across the entire VC-controlled
  directory tree.  All matches are placed directly in a buffer.

+ =prot-vc-git-log-edit-extract-file-name= is used in log-edit buffers to
  derive the file name of the item being committed.  For example, as I
  am writing this, I may want to compose a summary of my changes like
  "prot-emacs: expand VC section docs".  The "prot-emacs: " part comes
  directly from this command, which reads from the "prot-emacs.org"
  file.  If there are multiple files to be committed, then a minibuffer
  prompt asks to pick one among them.  This helps me write clean and
  meaningful summaries.

+ The commands =prot-vc-git-log-edit-{next,previous,complete}-comment= are
  used to access information about previous commit messages that are
  stored in the dedicated ring.  The next/previous operations will cycle
  through the ring in the given direction.  While the "complete" command
  will use minibuffer completion to insert the select item at point.

+ =prot-vc-git-log-insert-commits= will simply insert at point N number of
  commits starting from the HEAD of the current project.  The number is
  inserted at the minibuffer following a prompt.  This runs the =git log=
  shell command in the background.  If the command is not called from
  inside a version-controlled directory or if it is invoked with a
  prefix argument (=C-u=), it first asks for a project and eventually
  prints a log for it.  Again, this is useful while writing the message
  of a commit, as I occasionally need to reference earlier changes.

+ =prot-vc-git-patch-apply= prompts for a file system path to a patch
  file.  By default, it applies the patch directly to the current git
  repo.  If no such repository is found or if called with an optional
  prefix argument the command prompts for a project to use.  This makes
  it very simple to apply a patch from anywhere, such as while reading
  my email (also refer to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]]).  Arguments that are passed to
  it are those specified in =prot-vc-git-patch-apply-args=, unless the
  command is called from Lisp, in which case it accepts ARGS as a list
  of strings (read the =git am= man pages if you ever need this).

+ =prot-vc-git-patch-create-dwim= produces a properly formatted patch for
  a given commit.  The outputted file is saved in a directory that is
  selected via a minibuffer completion prompt: default candidates are
  stored in =prot-vc-patch-output-dirs= and are complemented by the root
  of the current project.

  - When browsing a =log-view= buffer, the commit is the one around point.

  - When the region is active in Log View buffers, the command will
    capture the included range of commits, instead of just the one at
    point.

  - With a prefix argument (=C-u=), a minibuffer completion prompt will
    ask for a commit to use as the base in a range against HEAD.  This
    will skip the check for the commit at point, though an active region
    in Log View buffers will still take precedence.

  - Beware of how Git interprets those ranges: the base commit is the
    one before the earliest in the range, so if you need to produce
    patches for the topmost 4 commits, you must include the last 5 in
    the region.

  - That granted, I also use [[#h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301][git-email.el for preparing patches]] that
    must be sent via email outright.

+ =prot-vc-git-checkout-remote= prompts for a remote branch and proceeds
  to checkout a local branch that is set up to track it.  So if you have
  a remote named =origin/dev= it will do =git checkout -b dev origin/dev=.
  I only use this command inside VC-dir buffers.

+ =prot-vc-custom-log= prints a log of commits that matches a custom file
  set.  This is of great value when you need to inspect the history of
  only some files rather than that of the entire repository.  What files
  to choose is determined in two ways: (1) the file-at-point in Dired
  buffers, or all marked files, and (2) files in the current directory
  selected with minibuffer completion.

+ =prot-vc-log-view-toggle-entry-all= will toggle the visibility of all
  commits in a compact log view.  I often employ this in tandem with
  =prot-vc-custom-log=.

+ =prot-vc-git-show= lets you read a given commit that you access with
  completion.  A simple and effective wrapper for =git show=.

+ =prot-vc-git-log-grep= provides a search utility for commit logs.  It
  accepts a regular expression, which may just be a string, and shows
  all commits whose message includes that pattern.  When called with a
  universal prefix argument (=C-u=), the log will also include the
  corresponding diff of each commit.

+ =prot-vc-git-find-revision= allows you to revisit a previous state of the
  current file, by selecting a commit with completion.  Quite powerful
  when you want to search, for example, my dotemacs from when I first
  introduced a certain package, say, =prot-vc.el=.

+ =prot-vc-git-reset= prompts for a commit to reset back to, using
  minibuffer completion.  This is a "soft" undo process in that all
  changes are kept in place while any commits are removed.  Remember to
  only do this for local logs as it is not good practice to reset
  publicly available histories: it will break the local copies of other
  users.

+ =prot-vc-git-log-reset= is like the above command, only that it is meant
  to be called from inside a Log View buffer (e.g.  =vc-print-root-log=
  which is bound to =C-x v L= by default).  The commit to reset back to is
  the one at point.  Calling the command with a prefix argument (=C-u=)
  will change the meaning of the reset operation from a soft to a hard
  one.  The latter deletes all commits up to the selected commit /and
  removes all changes/, so please be careful.

+ =prot-vc-project-or-dir= produces a =vc-dir= buffer for the current
  project (also see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  With a
  =C-u= prefix argument the command limits the matches to the present
  directory.

+ =prot-vc-log-kill-hash= appends to the kill-ring the hash of the commit
  around point.  It is meant to be used in =log-view= buffers.

+ =prot-vc-git-setup-mode= is a minor mode that refashions the log edit
  buffer while adding a small tweak to the log view buffers.

  - Normally the log edit buffer (what you use to write the commit
    message) will pop up in a window with a smaller window below it
    showing the files to be committed.  The window layout does not
    automatically show the corresponding diff, while there is no readily
    available information as to what branch we are about to commit the
    changes to.  So my minor mode removes the small window with the
    files and in its stead adds a comment block in the main message
    composition buffer (like the standard =git commit=).  It then displays
    the diff window on one side and the edit buffer on the other (yes,
    just like Magit, though the order of the windows is always the
    same).  The prior window configuration and the point are saved
    before entering the log edit session and immediately restored upon
    exit (either by committing the changes or aborting).

  - The behaviour of cycling the ring of prior commits is reworked to
    account for the custom git comment.  In addition to back/forth
    motions through the ring's items (=M-p=, =M-n=), a command for picking a
    commit message with minibuffer completion is also made available in
    the stead of the generic commands for searching through the ring,
    with =M-s= or =M-r= (the defaults lack visual feedback and are, in my
    opinion, not appropriate for the task).

  - The =Amend= pseudo header is displayed by default to make it easier to
    edit the last commit, if necessary, and to raise awareness about
    this possibility.

  - For the log view buffers (commit logs) the minor mode instructs the
    command that expands the message of a commit on the current line to
    include more information from =git log= than what it normally would.
    It shows diff stats and affected file names, while also creating
    some much needed negative space for better usability.  Those file
    names are not purely cosmetic, as they can now serve to power Emacs'
    contextuality and "future history" such as when you put point over
    the name and type =C-x p f= (=project-find-file=): the file at point
    becomes the default choice and the one you will also get with =M-n= in
    the minibuffer (=next-history-element=).

Finally, a few tips for acting in the log-edit buffer (remember to use
=C-h m= (=M-x describe-mode=) in every unfamiliar major mode and read the
manual for more on the matter):

+ Use =C-c C-d= (=log-edit-show-diff=) to produce a diff of the changes
  to-be-committed.  Of course this is of no use if my aforementioned
  minor mode is enabled.  Still, it is good to know (by the way, this
  command also works in Magit's commit composition buffers).

+ With =C-c C-w= (=log-edit-generate-changelog-from-diff=) generate an
  overview of documented changes to the given file set.  While this may
  not be useful for everyday commits, it is mandatory when preparing
  patches for upstream Emacs (and probably other GNU projects).

+ Normally the window layout is set up to include files for the given
  commit, but I disable that via my minor mode.  You can opt to display
  them with =C-c C-f= (=log-edit-show-files=).

+ =C-c C-k= (=log-edit-kill-buffer=) cancels the log editing process.

+ =M-n= (=log-edit-next-comment=) and =M-p= (=log-edit-previous-comment=) let
  you cycle through prior commit messages.

#+begin_src emacs-lisp :tangle no
;;; Version control framework (vc.el and prot-vc.el)
(prot-emacs-builtin-package 'vc
  ;; Those offer various types of functionality, such as blaming,
  ;; viewing logs, showing a dedicated buffer with changes to affected
  ;; files.
  (require 'vc-annotate)
  (require 'vc-dir)
  (require 'vc-git)
  (require 'add-log)
  (require 'log-view)

  ;; This one is for editing commit messages.
  (require 'log-edit)
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil)

  ;; Note that `prot-vc-git-setup-mode' will run the following when
  ;; activated:
  ;;
  ;;   (remove-hook 'log-edit-hook #'log-edit-show-files)
  ;;
  ;; If you need the window to pop back up, do it manually with C-c C-f
  ;; which calls `log-edit-show-files'.

  (setq vc-find-revision-no-save t)
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  ;; I use a different account for git commits
  (setq add-log-mailing-address "info@protesilaos.com")
  (setq add-log-keep-changes-together t)
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
        '("%d %h %ad %an: %s"
          ;; The first shy group matches the characters drawn by --graph.
          ;; We use numbered groups because `log-view-message-re' wants the
          ;; revision number to be group 1.
          "^\\(?:[*/\\|]+\\)\\(?:[*/\\| ]+\\)?\
\\(?2: ([^)]+) \\)?\\(?1:[0-9a-z]+\\) \
\\(?4:[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) \
\\(?3:.*?\\):"
          ((1 'log-view-message)
           (2 'change-log-list nil lax)
           (3 'change-log-name)
           (4 'change-log-date))))

  (add-hook 'log-view-mode-hook #'hl-line-mode)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v b") #'vc-retrieve-tag)  ; "branch" switch
    (define-key map (kbd "C-x v t") #'vc-create-tag)
    (define-key map (kbd "C-x v f") #'vc-log-incoming)  ; the actual git fetch
    (define-key map (kbd "C-x v o") #'vc-log-outgoing)
    (define-key map (kbd "C-x v F") #'vc-update)        ; "F" because "P" is push
    (define-key map (kbd "C-x v d") #'vc-diff))
  (let ((map vc-dir-mode-map))
    (define-key map (kbd "b") #'vc-retrieve-tag)
    (define-key map (kbd "t") #'vc-create-tag)
    (define-key map (kbd "O") #'vc-log-outgoing)
    (define-key map (kbd "o") #'vc-dir-find-file-other-window)
    (define-key map (kbd "f") #'vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
    (define-key map (kbd "F") #'vc-update)       ; symmetric with P: `vc-push'
    (define-key map (kbd "d") #'vc-diff)         ; parallel to D: `vc-root-diff'
    (define-key map (kbd "k") #'vc-dir-clean-files)
    (define-key map (kbd "G") #'vc-revert)
    (let ((prot-vc-git-branch-map (make-sparse-keymap)))
      (define-key map "B" prot-vc-git-branch-map)
      (define-key prot-vc-git-branch-map "n" #'vc-create-tag) ; new branch/tag
      (define-key prot-vc-git-branch-map "s" #'vc-retrieve-tag) ; switch branch/tag
      (define-key prot-vc-git-branch-map "c" #'prot-vc-git-checkout-remote) ; "checkout" remote
      (define-key prot-vc-git-branch-map "l" #'vc-print-branch-log))
    (let ((prot-vc-git-stash-map (make-sparse-keymap)))
      (define-key map "S" prot-vc-git-stash-map)
      (define-key prot-vc-git-stash-map "c" 'vc-git-stash) ; "create" named stash
      (define-key prot-vc-git-stash-map "s" 'vc-git-stash-snapshot)))
  (let ((map vc-git-stash-shared-map))
    (define-key map "a" 'vc-git-stash-apply-at-point)
    (define-key map "c" 'vc-git-stash) ; "create" named stash
    (define-key map "D" 'vc-git-stash-delete-at-point)
    (define-key map "p" 'vc-git-stash-pop-at-point)
    (define-key map "s" 'vc-git-stash-snapshot))
  (let ((map vc-annotate-mode-map))
    (define-key map (kbd "M-q") #'vc-annotate-toggle-annotation-visibility)
    (define-key map (kbd "C-c C-c") #'vc-annotate-goto-line)
    (define-key map (kbd "<return>") #'vc-annotate-find-revision-at-line))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<tab>") #'log-view-toggle-entry-display)
    (define-key map (kbd "<return>") #'log-view-find-revision)
    (define-key map (kbd "s") #'vc-log-search)
    (define-key map (kbd "o") #'vc-log-outgoing)
    (define-key map (kbd "f") #'vc-log-incoming)
    (define-key map (kbd "F") #'vc-update)
    (define-key map (kbd "P") #'vc-push)))

(prot-emacs-builtin-package 'prot-vc
  (setq prot-vc-log-limit 100)
  (setq prot-vc-log-bulk-action-limit 50)
  (setq prot-vc-git-log-edit-show-commits t)
  (setq prot-vc-git-log-edit-show-commit-count 10)
  (setq prot-vc-shell-output "*prot-vc-output*")
  (setq prot-vc-patch-output-dirs (list "~/" "~/Desktop/"))
  (add-to-list' log-edit-headers-alist '("Amend"))

  ;; This refashions log view and log edit buffers
  (prot-vc-git-setup-mode 1)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v i") #'prot-vc-git-log-insert-commits)
    (define-key map (kbd "C-x v p") #'prot-vc-project-or-dir)
    (define-key map (kbd "C-x v SPC") #'prot-vc-custom-log)
    (define-key map (kbd "C-x v g") #'prot-vc-git-grep)
    (define-key map (kbd "C-x v G") #'prot-vc-git-log-grep)
    (define-key map (kbd "C-x v a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "C-x v c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "C-x v s") #'prot-vc-git-show)
    (define-key map (kbd "C-x v r") #'prot-vc-git-find-revision)
    (define-key map (kbd "C-x v B") #'prot-vc-git-blame-region-or-file)
    (define-key map (kbd "C-x v R") #'prot-vc-git-reset))
  (let ((map vc-git-log-edit-mode-map))
    (define-key map (kbd "C-C C-n") #'prot-vc-git-log-edit-extract-file-name)
    (define-key map (kbd "C-C C-i") #'prot-vc-git-log-insert-commits)
    ;; Also done by `prot-vc-git-setup-mode', but I am putting it here
    ;; as well for visibility.
    (define-key map (kbd "C-c C-c") #'prot-vc-git-log-edit-done)
    (define-key map (kbd "C-c C-a") #'prot-vc-git-log-edit-toggle-amend)
    (define-key map (kbd "M-p") #'prot-vc-git-log-edit-previous-comment)
    (define-key map (kbd "M-n") #'prot-vc-git-log-edit-next-comment)
    (define-key map (kbd "M-s") #'prot-vc-git-log-edit-complete-comment)
    (define-key map (kbd "M-r") #'prot-vc-git-log-edit-complete-comment))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<C-tab>") #'prot-vc-log-view-toggle-entry-all)
    (define-key map (kbd "a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "R") #'prot-vc-git-log-reset)
    (define-key map (kbd "w") #'prot-vc-log-kill-hash)))
#+end_src


**** git-email.el for preparing patches
:PROPERTIES:
:CUSTOM_ID: h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301
:END:

This neat library by Xinglu Chen streamlines the process of formatting
and sending Git patches via email, all from the comfort of Emacs.  Its
main point of entry is the command =git-email-format-patch=, which prompts
you for a commit that is read as the range between the current HEAD and
the one you specify.  In doing so, it allows you to prepare a series of
patches, using the correct message headers.

=git-email.el= is meant to work with the standard message composition
buffer, such as the one you get when you call =M-x compose-email= (by
default that command is bound to =C-x m= and I keep it that way).  Email
clients like Gnus and Notmuch are also supported.  For my case as a user
of the latter, I just activate =git-email-notmuch-mode= in order to add
the relevant settings to the message composition buffers.  For more on
Notmuch and all related configurations, refer to the mega-section on
[[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]].

So here is the typical workflow with this package:

+ Visit a file and make some changes.
+ Commit those changes.
+ Invoke =git-email-format-patch= and select the base commit against which
  your commits are to be read.  So if your commit is the current HEAD,
  then just pick the one right before.
+ Pass any optional flags.  Multiple flags can be completed against
  using a comma as a separator (or whatever your =crm-separator= is).
+ Fill in the email details, which probably is just an email address
  (and a cover letter, if you use that option).
+ Send.  Done!

The maintainer of the project will then be able to apply your patch,
using standard git commands (read the manpages of =git-apply= for
attachments and =git-am= for mailbox-type patches).

Alternatively, you may already have a patch available and wish to email
it directly.  Visit its directory and with the point over it call the
command =git-email-send-email=.  This also works for the marked items of
the Dired buffer ([[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

Overall, =git-email.el= is a welcome addition to the ecosystem.  Apart
from also working with the built-in Version Control framework of Emacs
(consult [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]), it offers us
the means to conveniently implement a truly decentralised workflow for
collaboration: git and email empower you to utilise the tools you want,
instead of forcing you through some unwieldy pull/merge request process
that certain git forges encourage.  I prefer this approach and am eager
to see it getting more widespread adoption.

#+begin_src emacs-lisp :tangle no
;;; git-email.el for preparing patches
;; Project repo: <https://git.sr.ht/~yoctocell/git-email>.  This is one
;; of the packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'git-email
  (with-eval-after-load 'notmuch
    (require 'git-email-notmuch)
    (git-email-notmuch-mode 1))
  (define-key global-map (kbd "C-x v RET") #'git-email-format-patch) ; VC prefix and C-m
  (define-key dired-mode-map (kbd "C-x v RET") #'git-email-send-email))
#+end_src

*** Interactive and powerful git front-end (Magit)
:PROPERTIES:
:CUSTOM_ID: h:76d1b392-e693-40dc-b320-d4c1047115ab
:END:

As noted in the [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][section on the built-in Version Control framework]] I use
Magit for easy access to the /advanced features of Git/.  While I rely on
the built-in tools for all day-to-day operations.

Magit offers a modal interface where the full power of =git= is neatly
organised in sets of keys that are directly accessible without holding
down any modifiers.

While inside the =magit-status= buffer, hit =?= to produce a transient menu
with the possible vectors to action.  Do it again inside each of the
Magit buffers to view the keys that work for their context.

Consider viewing my [[https://protesilaos.com/codelog/2020-04-04-emacs-intro-magit/][Introduction to Magit]] (2020-04-04) for how to stage
diffs, commit changes, view logs, create branches, and so on.

Magit has great defaults and it should work admirably without any
further tweaks or extra setup.  That granted, the =git-commit= package
(part of Magit) is configured in accordance with the guidelines provided
by this article on [[https://chris.beams.io/posts/git-commit/][writing a Git commit message]].  The gist is to compose
commits that are clean and easy to read.  The =fill-column= is set
elsewhere in this document to 72 characters long.

#+begin_src emacs-lisp :tangle no
;;; Interactive and powerful git front-end (Magit)
(use-package magit
  :config
  (setq magit-define-global-key-bindings nil)
  (define-key global-map (kbd "C-c g") #'magit-status)

  (require 'git-commit)
  (setq git-commit-summary-max-length 50)
  (setq git-commit-known-pseudo-headers
        '("Signed-off-by"
          "Acked-by"
          "Modified-by"
          "Cc"
          "Suggested-by"
          "Reported-by"
          "Tested-by"
          "Reviewed-by"))
  (setq git-commit-style-convention-checks
        '(non-empty-second-line
          overlong-summary-line))

  (require 'magit-diff)
  (setq magit-diff-refine-hunk t)

  (require 'magit-repos)
  (setq magit-repository-directories
        '(("~/Git/Projects" . 1))))
#+end_src

*** Smerge and Ediff
:PROPERTIES:
:CUSTOM_ID: h:fb9e0507-5ab1-4ebd-8870-8c32cfe742c1
:END:

*Read this section, because it matters more than the code below it.*

Sometimes we face a situation where we have conflicting versions of a
file and the version control backend cannot solve them on its own.  This
can happen fairly often when collaborating with other people or, more
generally, when we keep our work spread across multiple feature branches
with diverging histories.  Whenever such conflicts arise, Emacs will
automatically annotate the offending files with special markers that
show the conflicting differences.  Visiting those files will then
activate =smerge-mode=.  At which point we are in control.

Smerge revolves around the concept of dividing the conflicting part into
an "upper" (red) and a "lower" section (green), possibly with their
common ancestor or last point of convergence in the middle (yellow).

With this in mind we can operate on the marked differences by relying on
the functions that Smerge provides, all of which are accessed by default
through the common prefix of =C-c ^=.  Start by typing the prefix followed
by =C-h= to see all possible key chords.  These are the commands I have
used the most:

+ =C-c ^ u= (=smerge-keep-upper=)
+ =C-c ^ l= (=smerge-keep-lower=)
+ =C-c ^ b= (=smerge-keep-base=)
+ =C-c ^ a= (=smerge-keep-all=)
+ =C-c ^ n= (=smerge-next=)
+ =C-c ^ p= (=smerge-prev=)

Proceed to edit the file the way you want until no more conflicts exist.
You can also do things through manual editing, with standard commands
and motions, but that can be prone to errors (which lead to more
conflicts).  At any moment in this process, you can switch to =ediff=,
which offers a more powerful way of working with differences.  Type the
key chord =C-c ^ E= (=smerge-ediff=).

Ediff is a powerhouse that is likely to cover all your needs in this
area (including those you are not aware of).  For our purposes, what
matters is to understand the basic concepts.

The way this tool works is that it starts by producing a layout of the
two conflicting versions with access to a "control panel" for operating
on them.  By default, the panel is positioned on a new frame, but I find
that rather awkward---my config puts it inside an Emacs window instead.
While focusing the control panel, you can move between each diff range
with =n= and =p=.  The focused section will be coloured using red, green,
and yellow, while all other diffs will be presented in gray.

On each diff, you have three options: to use the version of buffer A
(red), of buffer B (green), or a combination of the two.  The keys for
each of those are =a=, =b=, and =+= respectively.  Your choice will be
reflected in buffer C (the yellow one).  Use these to resolve all
conflicts and then quit the session with =q=.

Concerning the combination of versions between A and B, Ediff has the
behaviour of also inserting as plain text the annotation markers that
Smerge relied on.  As of this writing (2020-04-10), I am not aware of an
automatic or convenient way to omit those prior to confirming our edits.
To that end, I tweak the wording of the markers to some unique string
(see package below) and then run =flush-lines= to remove them before
saving the resulting buffer (so right after the =q=).  For more on this,
check =prot/ediff-flush-combination-pattern=.

For =git= users, to actually /reference the common ancestor/ (the point
before the branching paths started) we must run this command once in our
command-line prompt (writes to your global =.gitconfig= file):

#+begin_src sh :tangle no
# git config --global merge.conflictStyle diff3
#+end_src

This is optional, but I find that I like it.  At any rate, the
configurations I have below are straightforward (learn more about this
powerful tool by hitting =?= inside of its control panel and by consulting
its comprehensive manual):

+ Do not keep all the buffers after exiting the Ediff session.
+ Keep buffers in an editable state.  Otherwise it is impossible to
  perform the changes we are interested in.
+ Show the common ancestor in another buffer.  This helps provide
  further context of how things took their form.
+ Show only the conflicting parts.  This is not a review of all diffs.
+ Prefer putting windows side-by-side, rather than one below the other.
+ Do not enter the ediff session in a new frame.  This also means that
  the control panel will be inside an Emacs window (at the bottom part)
  rather than in a tiny frame of its own.

There actually is nothing in terms of Smerge-related configurations.
The package is small and does one thing well.

Also watch my video of [[https://protesilaos.com/codelog/2020-04-10-emacs-smerge-ediff/][Smerge and Ediff for git conflict resolution]]
(2020-04-10).

#+begin_src emacs-lisp :tangle no
;;; Smerge and Ediff
(use-package smerge-mode)

(use-package ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< prot-ediff-combine Variant A" A
          ">>>>>>> prot-ediff-combine Variant B" B
          "####### prot-ediff-combine Ancestor" Ancestor
          "======= prot-ediff-combine End"))

  ;; TODO automate process in a robust way, or at least offer a good key
  ;; binding.
  (defun prot/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*prot-ediff.*" (point-min) (point-max) nil)))
#+end_src

#+RESULTS:
: t

** Command-line shells
:PROPERTIES:
:CUSTOM_ID: h:2c1966a1-bf33-4fe3-ac45-9f31158efd9b
:END:
It should come to no surprise that Emacs can operate as both a /terminal
emulator for command line shells/ and /toolkit for terminal emulators/.
The present section covers only the former category as I never use the
likes of =ansi-term= or =vterm=.

*** Eshell and prot-eshell.el
:PROPERTIES:
:CUSTOM_ID: h:103a8795-c29c-474f-9ddf-ecafaa2f6775
:END:

Eshell is a strictly line-oriented command prompt written in Emacs Lisp.
This comes with its pros and cons: it can understand Elisp but does not
behave exactly like Unix shells, say, Bash.  Eshell cannot display the
kind of pseudo graphics a terminal emulator can, such as those you find
in =mutt=, =htop=, =ncmpcpp=, =newsboat= and so on.  As each user's needs are
different, you will have to determine whether Eshell can fit into your
workflow.  Start by reading its fairly short, yet insightful, manual.

For me this tool is one of the most promising in the Emacs milieu
because while it is a competent shell it can seamlessly integrate with
the rest of Emacs' capabilities.  This is best exemplified by its
extensibility, such as what I am doing with =prot-eshell.el=.  More on
that below.

The fact that Eshell cannot reproduce the artefacts of the ncurses
library does not pose a hindrance to my workflow, as I have replacements
for all such "graphical" programs within Emacs.  Notmuch has an Emacs
client which handles my email (yes, the CLI works as well), =M-x proced=
lets me interact with system processes, Bongo deals with media playback,
while Elfeed fills the niche of following RSS/Atom feed.

Read relevant sections:

+ [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].
+ [[#h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325][Proced (process monitor, similar to `top')]].
+ [[#h:758afe0d-bc7c-4afc-9c6b-b5e569901591][Bongo (music or media manager)]].
+ [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed (RSS/Atom feed reader)]].

Now an overview of =prot-eshell.el=, with the full code reproduced right
after the package configurations:

+ There are several =prot-eshell-ffap-*= commands that operate on the file
  at point.  Say you have called =ls= and wish to expand the contents of a
  file at the command prompt.  With point over the file name of
  interest, use =prot-eshell-ffap-insert=.  Wish to visit the file
  instead, so that you may edit it?  Try =prot-eshell-ffap-find-file=.
  The command =prot-eshell-ffap-kill-save= copies the file's full file
  system path, while =prot-eshell-ffap-dired-jump= opens a Dired buffer in
  that file's directory (see [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

+ =prot-eshell-export= takes the prompt and output of the last command and
  places it in a bespoke buffer.  The name of the buffer is controlled
  by the variable =prot-eshell-output-buffer=.  If that buffer does not
  exist, it is created.  Otherwise subsequent invocations of this
  "export" command will append their contents to the existing ones.
  This is good for keeping a record of something you are working on.
  And because this is a standard buffer, you can edit it at will as well
  as call =write-file= (=C-x C-w=) to save it permanently to a file.

+ =prot-eshell-redirect-to-buffer= provides a completion prompt to help
  you redirect the output of a command to a given buffer.  Simple and
  effective.

+ =prot-eshell-narrow-output-highlight-regexp= prompts for a regexp to
  highlight in the output of the last command.  It then narrows the
  Eshell buffer to the contents of that output and emphasises the
  matches of the regexp.  Very useful when you need to inspect some logs
  or other terse output.  Remember that to widen the view you use the
  standard =widen= command, bound to =C-x n w= by default.

+ =prot-eshell-complete-history= lets you pick a command from your history
  using minibuffer completion.  Forget about a non-interactive regexp
  search or, worse, consecutive calls to =M-p= and =M-n= to cycle through
  your recent inputs one at a time.

+ =prot-eshell-complete-recent-dir= provides a minibuffer prompt with
  completion that queries through all paths in your =cd= input history.
  This is much more convenient that standard actions like =cd -= or =cd -N=
  where =N= is the position of the item in the history of entries
  (retrieved with =cd ==).

+ =prot-eshell-find-subdirectory-recursive= uses completion to help you
  pick a subdirectory that extends the present working directory.  It
  does so recursively, which makes it powerful, but can cause problems
  when called from the root of some massive directory tree.  Exercise
  restraint.

+ =prot-eshell-root-dir= switches the present working directory to that of
  the current project's root directory, if one is found.

Here is a [[https://protesilaos.com/codelog/2020-05-08-emacs-eshell-demo/][video on Eshell and my extras]] (2020-05-08) which, however,
showcases older code than what I have here.

For further inspiration, check these valuable resources (in no
particular order):

+ [[https://cestlaz.github.io/post/using-emacs-66-eshell-elisp][Mike Zamansky's video demo]] that also shows how to program an Eshell
  switcher.
+ [[https://www.youtube.com/watch?v=RhYNu6i_uY4][Howard Abrahams' video]] that covers the features of Eshell.
+ [[https://ambrevar.xyz/emacs-eshell/][Pierre Neidhardt's detailed blog post]] on the pros and cons of Eshell.
+ [[https://git.spwhitton.name/dotfiles][Sean Whitton's comprehensive dotfiles repository]] which includes lots
  of useful snippets, including for Eshell.  Some commands/functions of
  mine are either copied or adapted from Sean's implementation,
  following the review that was done on 2022-01-04.

#+begin_src emacs-lisp :tangle no
;;; Eshell and prot-eshell.el
(use-package eshell
  :config
  (require 'esh-mode)
  (require 'esh-module)
  (setq eshell-modules-list             ; It works but may need review
        '(eshell-alias
          eshell-basic
          eshell-cmpl
          eshell-dirs
          eshell-glob
          eshell-hist
          eshell-ls
          eshell-pred
          eshell-prompt
          eshell-script
          eshell-term
          eshell-tramp
          eshell-unix))
  (setenv "PAGER" "cat") ; solves issues, such as with 'git log' and the default 'less'
  (require 'em-cmpl)
  (require 'em-dirs)
  (setq eshell-cd-on-directory t)

  (require 'em-tramp)
  (setq password-cache t)
  (setq password-cache-expiry 600)

  (require 'em-hist)
  (setq eshell-hist-ignoredups t)
  (setq eshell-save-history-on-exit t))
(load "prot-eshell")
(use-package prot-eshell
  :config
  (setq prot-eshell-output-buffer "*Exported Eshell output*")
  (setq prot-eshell-output-delimiter "* * *")
  (let ((map eshell-mode-map))
    (define-key map (kbd "M-k") #'eshell-kill-input)
    (define-key map (kbd "C-c C-f") #'prot-eshell-ffap-find-file)
    (define-key map (kbd "C-c C-j") #'prot-eshell-ffap-dired-jump)
    (define-key map (kbd "C-c C-w") #'prot-eshell-ffap-kill-save)
    (define-key map (kbd "C-c C->") #'prot-eshell-redirect-to-buffer)
    (define-key map (kbd "C-c C-e") #'prot-eshell-export)
    (define-key map (kbd "C-c C-r") #'prot-eshell-root-dir))
  (let ((map eshell-cmpl-mode-map))
    (define-key map (kbd "C-c TAB") #'prot-eshell-ffap-insert) ; C-c C-i
    (define-key map (kbd "C-c C-h") #'prot-eshell-narrow-output-highlight-regexp))
  (let ((map eshell-hist-mode-map))
    (define-key map (kbd "M-s") #'nil) ; I use this prefix for lots of more useful commands
    (define-key map (kbd "M-r") #'prot-eshell-complete-history)
    (define-key map (kbd "C-c C-d") #'prot-eshell-complete-recent-dir)
    (define-key map (kbd "C-c C-s") #'prot-eshell-find-subdirectory-recursive)))
#+end_src

*** Shell (M-x shell)
:PROPERTIES:
:CUSTOM_ID: h:98804f0d-f2dd-41a4-b8df-c1bd04ef7f7a
:END:

NOTE: I normally use Eshell.  Refer to the [[#h:103a8795-c29c-474f-9ddf-ecafaa2f6775][Eshell and prot-eshell.el]]
section.

This is a shell (Bash, in my case) that runs inside of Emacs.  Unlike
terminal emulators, this one can use standard Emacs keys and behaves
much like an ordinary buffer.  It also integrates nicely with the
built-in completion tools, which makes it particularly nice to work
with.

The one area where this Shell differs substantially from ordinary
buffers is with regard to the command prompt: you can re-run a command
on the scroll-back buffer by just hitting =RET= while point is on its line
(no need to go back to the end and cycle the command history with =M-p= or
=M-n=).

Another peculiarity relative to the standard commands in the terminal is
to search backward through your history with =M-r= (whereas in a terminal
emulator you use =C-r=).

Run =C-h m= inside of a shell buffer to learn about all the key bindings
and corresponding functions.

#+begin_src emacs-lisp :tangle no
;;; Shell (M-x shell)
(prot-emacs-builtin-package 'shell
  (setq shell-command-prompt-show-cwd t) ; Emacs 27.1
  (setq ansi-color-for-comint-mode t))
#+end_src

** Org-mode (personal information manager)
:PROPERTIES:
:CUSTOM_ID: h:4e8347de-415e-4804-b383-d61499e05ca1
:END:

Also watch: [[https://protesilaos.com/codelog/2021-08-31-emacs-second-brain-mindfulness/][Emacs as a 'second brain' and mindfulness]] (2021-08-31).

In its purest form, Org is a markup language that is similar to
Markdown: symbols are used to denote the meaning of a construct in its
context, such as what may represent a headline element or a phrase that
calls for emphasis.

What lends Org its super powers though is everything else built around
it: a rich corpus of Elisp functions that automate, link, combine,
enhance, structure, or otherwise enrich the process of using this rather
straightforward system of plain text notation.

Couched in those terms, Org is at once a distribution of well integrated
libraries and a vibrant ecosystem that keeps producing new ideas and
workflows on how to organise one's life with plain text.

The present document is written in =org-mode= while its website version is
outputted by a tool (also part of Org) that exports Org notation to its
HTML equivalent.

Regarding the following code block, I strongly encourage you to make
liberal use of Emacs' documentation facilities to learn more about
functions, variables, symbols provided herein.  And do not forget to
read Org's manual.

What follows in an exposition about each of the subsesctions of this
package configurations:

+ Org links :: The =org-store-link= is one of the commands I use the most,
  as it allows me to, inter alia, connect the various sections of this
  document.  Use it to store a direct link to the heading you are
  currently under.  Or to produce a properly formatted link to supported
  buffers you are visiting (e.g. another file).

  There are several ways to insert such links.  With =C-c C-l= (which
  calls =org-insert-link=) you will be prompted to select a stored link
  from the link.  It will be inserted at point, using the right markup,
  but will first ask you for a description text.  Otherwise you can
  invoke =C-c C-l= with an active region, to create a link to that
  location with the selected text becoming the description.  Else just
  call =org-insert-last-stored-link= to skip the interactive process and
  insert the last link outright.

  In addition to these, =org-insert-link= can be used to create references
  on demand.  Say you have a URL on the kill-ring: =C-c C-l=, then =C-y=
  followed by =RET= to confirm your input.  Complete the process with a
  description and you are good to go.

+ Org capture :: The =org-capture= tool is a powerful way to quickly
  produce some kind of structured information that gets stored in the
  appropriate place.  The type of data and the way to store is
  determined by a system of templates which accepts a series of possible
  specifiers as well as the evaluated part of arbitrary elisp code.

  Each template is accessed via a key.  These are listed in a temporary
  buffer when you call =org-capture=.  Unique keys give direct access to
  their template, whereas templates that share a common initial key will
  produce a second selection list with the remaining options.  In the
  latter case, the initial key entry has no call to an actual function,
  but is just written as a heading.

  The visibility of a template is explicitly controlled by the alist
  =org-capture-templates-contexts=.  This allows us to tell Org the
  context in which we want certain options to appear in.  Otherwise they
  remain concealed from our view.  Equipped with this piece of
  functionality, we can freely write highly specialised templates that
  capture structured text when viewing some particular item, but are not
  needed for more general purposes.  I do this for certain actions that
  only come into effect when reading email inside of the relevant
  buffers (also check my [[#h:5ad80664-3163-4d9d-be65-462637d77903][comprehensive configurations for email]]).

  Speaking of mail, you will notice some specifiers like =:fromname=.  This
  refers to the =From= field in emails and will capture the name part only.
  Other similar keywords are =:from= (name and email), =:fromaddress= (email
  only), =:subject=.

  Specifiers that start with the caret sign (=^=) represent prompts for
  further user input.  The pattern =^{TEXT}= is a prompt whose expression
  is =TEXT=.  To offer possible options, use =^{Initial|ONE|TWO|THREE}=,
  where the first entry is the text of the prompt and all the rest are
  the available choices (depending on your completion framework, you may
  need to add an empty option as well, with =||=, should you ever want to
  insert nothing).  In some templates I use the =^t= specifier, which is a
  built-in method to ask for a specific date.

  The text that goes into a template can be written as part of a string or
  inside a function that is then evaluated.  I generally prefer to use
  simple strings, though I might revise this approach going forward.  To
  insert a new line inside of a string, use =\n=.

  The =%?= specifier determines where the point shall end in once the
  template is parsed.  While =%i= will insert the contents of the active
  region, if any.

  As things currently stand, my capture templates always write to headings
  inside of files.  Note though that there are more possibilities, as
  described in the manual.

  A file can be specified by its absolute path or just a name.  In the
  latter case, its location is understood relative to =org-directory=.
  When using the =file+headline= pattern, non-existent files are created
  automatically once you call the relevant template.  Same for their
  respective headings.

  Finally, the =prot-org--capture-no-delete-windows= from my =prot-org.el=
  (reproduced after the Org configs) addresses a problem I have when
  =org-capture= fails to carry out its operations when it is called from
  inside of a side window (for more on those, refer to the section on
  [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).  The code is taken directly from this
  [[https://stackoverflow.com/a/54251825][Stack Overflow thread]].

  Consider watching my [[https://protesilaos.com/codelog/2020-02-04-emacs-org-capture-intro/][primer on org-capture]] (2020-02-04) which shows all
  of the above in action.

+ Org agenda :: The =org-agenda= is not just a single interface.  It
  rather is your conduit to a set of utilities for reading timestamped
  tasks.  From there you can keep track of all the relevant entries you
  have inserted in the files declared as part of =org-agenda-files= list.

  Running =org-agenda= will present you with a list of possible options:
  the "dispatcher" as it called.  Here is a primer (there are many more
  functions documented in the manual):

  - From the dispatcher, the =a= is where you keep track of all the items
    that have a date assigned to them, be it =SCHEDULED= or =DEADLINE=.  To
    assign such a value to a heading use =C-c C-s= or =C-c C-d= respectively.
    Run those commands with a universal prefix (=C-u=) to remove the
    timestamp.  Hit =/= to filter this view to match particular tags.

  - In the dispatcher's menu, the =t= will list all your tasks, regardless
    of whether they have a date assigned to them.  You can then filter by
    keyword, regular expression, etc.  Check the top of the buffer for
    information on how to do that.

  - And the =n= in the dispatcher will offer you a combined view of the
    above.

  - Those granted, I prefer to just use the Diary and Calendar for my
    simple needs: [[#h:b4040bc0-7a2a-4f17-824d-42de621bd1b9][Calendar and Diary (and prot-diary.el)]].  Though this
    may change going forward, as I am starting to experiment with more
    advanced workflows, including the creation of bespoke "block agenda"
    views (watch my [[https://protesilaos.com/codelog/2021-12-09-emacs-org-block-agenda/][Demo of my custom Org block agenda]] (2021-12-09)).

+ Org export :: I do not have much to offer here, apart from the setup
  that handles consistent heading IDs and anchor tags (the latter
  concerns the HTML output).  Everything in that segment, minus some
  minor tweaks from my part, is copied from this detailed tutorial on
  [[https://writequit.org/articles/emacs-org-mode-generate-ids.html][Org header IDs]].  Basically, the problem is that exported HTML does not
  have reliable anchor tags for the various sections of the document.
  This fixes the issue (read the article for more).

Finally, note that I sometimes deliver simple presentations using Org.
Refer to [[#h:77d14350-978d-4820-ab7f-4641706c445a][Custom extensions for "focus mode" (logos.el)]].

#+begin_src emacs-lisp :tangle no
;;; Org-mode (personal information manager)
;; Pro tip: If you are reading the source code, use C-c '
;; (`org-edit-special') to put the code block in a dedicated buffer and
;; then activate `prot-outline-minor-mode-safe' to conveniently browse
;; this massive code block.
(prot-emacs-builtin-package 'org
  (setq org-directory (convert-standard-filename "~/Documents/org"))
  (setq org-imenu-depth 7)
;;;; general settings
  (setq org-adapt-indentation nil)      ; No, non, nein, όχι!
  (setq org-special-ctrl-a/e nil)
  (setq org-special-ctrl-k nil)
  (setq org-M-RET-may-split-line '((default . nil)))
  (setq org-hide-emphasis-markers nil)
  (setq org-hide-macro-markers nil)
  (setq org-hide-leading-stars nil)
  (setq org-cycle-separator-lines 0)
  (setq org-structure-template-alist    ; CHANGED in Org 9.3, Emacs 27.1
        '(("s" . "src")
          ("E" . "src emacs-lisp")
          ("e" . "example")
          ("q" . "quote")
          ("v" . "verse")
          ("V" . "verbatim")
          ("c" . "center")
          ("C" . "comment")))
  (setq org-catch-invisible-edits 'show)
  (setq org-return-follows-link nil)
  (setq org-loop-over-headlines-in-active-region 'start-level)
  (setq org-modules '(ol-info ol-eww))
  (setq org-use-sub-superscripts '{})
  (setq org-insert-heading-respect-content t)

;;;; refile, todo
  (setq org-refile-targets
        '((org-agenda-files . (:maxlevel . 2))
          (nil . (:maxlevel . 2))))
  (setq org-refile-use-outline-path t)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache t)
  (setq org-reverse-note-order nil)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "MAYBE(m)" "WAIT(w@/!)" "|" "CANCEL(c@)" "DONE(d!)")))
  (setq org-todo-keyword-faces
        '(("WAIT" . '(bold org-todo))
          ("MAYBE" . '(bold shadow))
          ("CANCEL" . '(bold org-done))))
  (setq org-use-fast-todo-selection 'expert)
  (setq org-priority-faces
        '((?A . '(bold org-priority))
          (?B . org-priority)
          (?C . '(shadow org-priority))))
  (setq org-fontify-done-headline nil)
  (setq org-fontify-todo-headline nil)
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-fontify-whole-heading-line nil)
  (setq org-fontify-whole-block-delimiter-line nil)
  (setq org-highlight-latex-and-related nil) ; other options affect elisp regexp in src blocks
  (setq org-enforce-todo-dependencies t)
  (setq org-enforce-todo-checkbox-dependencies t)
  (setq org-track-ordered-property-with-tag t)
  (setq org-highest-priority ?A)
  (setq org-lowest-priority ?C)
  (setq org-default-priority ?A)

;;;; tags
  (setq org-tag-alist ; I don't really use those, but whatever
        '(("meeting")
          ("admin")
          ("emacs")
          ("modus")
          ("politics")
          ("economics")
          ("philosophy")
          ("book")
          ("essay")
          ("mail")
          ("purchase")
          ("hardware")
          ("software")
          ("website")))

  (setq org-auto-align-tags nil)
  (setq org-tags-column 0)

;;;; log
  (setq org-log-done 'time)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out nil)
  (setq org-log-redeadline 'time)
  (setq org-log-reschedule 'time)
  (setq org-read-date-prefer-future 'time)

;;;; links
  (setq org-link-keep-stored-after-insertion nil)
  ;; TODO 2021-10-15 org-link-make-description-function

;;;; capture
  (setq org-capture-templates
        `(("b" "Basic task for future review" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* %^{Title}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%l")
           :empty-lines-after 1)
          ("c" "Clock in to a task" entry
           (file+headline "tasks.org" "Clocked tasks")
           ,(concat "* TODO %^{Title}\n"
                    "SCHEDULED: %T\n"
                    ":PROPERTIES:\n"
                    ":EFFORT: %^{Effort estimate in minutes|5|10|15|30|45|60|90|120}\n"
                    ":END:\n\n"
                    "%a\n")
           :prepend t
           :clock-in t
           :clock-keep t
           :immediate-finish t
           :empty-lines-after 1)
          ("m" "Memorandum of conversation" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* Memorandum of conversation with %^{Person}\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%i%?")
           :empty-lines-after 1)
          ("t" "Task with a due date" entry
           (file+headline "tasks.org" "Tasks with a date")
           ,(concat "* TODO %^{Title} %^g\n"
                    "SCHEDULED: %^t\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)
          ("e" "Email note" entry
           (file+headline "tasks.org" "Tasks to be reviewed")
           ,(concat "* MAYBE %:subject :mail:\n"
                    ":PROPERTIES:\n"
                    ":CAPTURED: %U\n"
                    ":END:\n\n"
                    "%a\n%i%?")
           :empty-lines-after 1)))

  (setq org-capture-templates-contexts
        '(("e" ((in-mode . "notmuch-search-mode")
                (in-mode . "notmuch-show-mode")
                (in-mode . "notmuch-tree-mode")))))

;;;; agenda
;;;;; Basic agenda setup
  (setq org-default-notes-file (thread-last org-directory (expand-file-name "notes.org")))
  (setq org-agenda-files `(,org-directory "~/Documents"))
  (setq org-agenda-span 'week)
  (setq org-agenda-start-on-weekday 1)  ; Monday
  (setq org-agenda-confirm-kill t)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-show-outline-path nil)
  (setq org-agenda-window-setup 'current-window)
  (setq org-agenda-skip-comment-trees t)
  (setq org-agenda-menu-show-matcher t)
  (setq org-agenda-menu-two-columns nil)
  (setq org-agenda-sticky nil)
  (setq org-agenda-custom-commands-contexts nil)
  (setq org-agenda-max-entries nil)
  (setq org-agenda-max-todos nil)
  (setq org-agenda-max-tags nil)
  (setq org-agenda-max-effort nil)

  ;; NOTE 2021-12-07: In my `prot-org.el' (see further below), I add
  ;; `org-agenda-to-appt' to various relevant hooks.
  ;;
  ;; Create reminders for tasks with a due date when this file is read.
  (run-at-time (* 60 5) nil #'org-agenda-to-appt)

;;;;; General agenda view options
  ;; NOTE 2021-12-07: Check further below my `org-agenda-custom-commands'
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-sorting-strategy
        '(((agenda habit-down time-up priority-down category-keep)
           (todo priority-down category-keep)
           (tags priority-down category-keep)
           (search category-keep))))
  (setq org-agenda-breadcrumbs-separator "->")
  (setq org-agenda-todo-keyword-format "%-1s")
  (setq org-agenda-fontify-priorities 'cookies)
  (setq org-agenda-category-icon-alist nil)
  (setq org-agenda-remove-times-when-in-prefix nil)
  (setq org-agenda-remove-timeranges-from-blocks nil)
  (setq org-agenda-compact-blocks nil)
  (setq org-agenda-block-separator ?—)

;;;;; Agenda marks
  (setq org-agenda-bulk-mark-char "#")
  (setq org-agenda-persistent-marks nil)

;;;;; Agenda diary entries
  (setq org-agenda-insert-diary-strategy 'date-tree)
  (setq org-agenda-insert-diary-extract-time nil)
  (setq org-agenda-include-diary nil)

;;;;; Agenda follow mode
  (setq org-agenda-start-with-follow-mode nil)
  (setq org-agenda-follow-indirect t)

;;;;; Agenda multi-item tasks
  (setq org-agenda-dim-blocked-tasks t)
  (setq org-agenda-todo-list-sublevels t)

;;;;; Agenda filters and restricted views
  (setq org-agenda-persistent-filter nil)
  (setq org-agenda-restriction-lock-highlight-subtree t)

;;;;; Agenda items with deadline and scheduled timestamps
  (setq org-agenda-include-deadlines t)
  (setq org-deadline-warning-days 5)
  (setq org-agenda-skip-scheduled-if-done nil)
  (setq org-agenda-skip-scheduled-if-deadline-is-shown t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
  (setq org-agenda-skip-deadline-if-done nil)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled 1)
  (setq org-agenda-skip-scheduled-delay-if-deadline nil)
  (setq org-agenda-skip-additional-timestamps-same-entry nil)
  (setq org-agenda-skip-timestamp-if-done nil)
  (setq org-agenda-search-headline-for-time nil)
  (setq org-scheduled-past-days 365)
  (setq org-deadline-past-days 365)
  (setq org-agenda-move-date-from-past-immediately-to-today t)
  (setq org-agenda-show-future-repeats t)
  (setq org-agenda-prefer-last-repeat nil)
  (setq org-agenda-timerange-leaders
        '("" "(%d/%d): "))
  (setq org-agenda-scheduled-leaders
        '("Scheduled: " "Sched.%2dx: "))
  (setq org-agenda-inactive-leader "[")
  (setq org-agenda-deadline-leaders
        '("Deadline:  " "In %3d d.: " "%2d d. ago: "))
  ;; Time grid
  (setq org-agenda-time-leading-zero t)
  (setq org-agenda-timegrid-use-ampm nil)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-show-current-time-in-grid t)
  (setq org-agenda-current-time-string
        (concat "Now " (make-string 70 ?-)))
  (setq org-agenda-time-grid
        '((daily today require-timed)
          (0600 0700 0800 0900 1000 1100
                1200 1300 1400 1500 1600
                1700 1800 1900 2000 2100)
          " ....." "-----------------"))
  (setq org-agenda-default-appointment-duration nil)

;;;;; Agenda global to-do list
  (setq org-agenda-todo-ignore-with-date t)
  (setq org-agenda-todo-ignore-timestamp t)
  (setq org-agenda-todo-ignore-scheduled t)
  (setq org-agenda-todo-ignore-deadlines t)
  (setq org-agenda-todo-ignore-time-comparison-use-seconds t)
  (setq org-agenda-tags-todo-honor-ignore-options nil)

;;;;; Agenda tagged items
  (setq org-agenda-show-inherited-tags t)
  (setq org-agenda-use-tag-inheritance
        '(todo search agenda))
  (setq org-agenda-hide-tags-regexp nil)
  (setq org-agenda-remove-tags nil)
  (setq org-agenda-tags-column -100)

;;;;; Agenda entry
  ;; NOTE: I do not use this right now.  Leaving everything to its
  ;; default value.
  (setq org-agenda-start-with-entry-text-mode nil)
  (setq org-agenda-entry-text-maxlines 5)
  (setq org-agenda-entry-text-exclude-regexps nil)
  (setq org-agenda-entry-text-leaders "    > ")

;;;;; Agenda logging and clocking
  ;; NOTE: I do not use these yet, though I plan to.  Leaving everything
  ;; to its default value for the time being.
  (setq org-agenda-log-mode-items '(closed clock))
  (setq org-agenda-clock-consistency-checks
        '((:max-duration "10:00" :min-duration 0 :max-gap "0:05" :gap-ok-around
                         ("4:00")
                         :default-face ; This should definitely be reviewed
                         ((:background "DarkRed")
                          (:foreground "white"))
                         :overlap-face nil :gap-face nil :no-end-time-face nil
                         :long-face nil :short-face nil)))
  (setq org-agenda-log-mode-add-notes t)
  (setq org-agenda-start-with-log-mode nil)
  (setq org-agenda-start-with-clockreport-mode nil)
  (setq org-agenda-clockreport-parameter-plist '(:link t :maxlevel 2))
  (setq org-agenda-search-view-always-boolean nil)
  (setq org-agenda-search-view-force-full-words nil)
  (setq org-agenda-search-view-max-outline-level 0)
  (setq org-agenda-search-headline-for-time t)
  (setq org-agenda-use-time-grid t)
  (setq org-agenda-cmp-user-defined nil)
  (setq org-agenda-sort-notime-is-late t) ; Org 9.4
  (setq org-agenda-sort-noeffort-is-high t) ; Org 9.4

;;;;; Agenda column view
  ;; NOTE I do not use these, but may need them in the future.
  (setq org-agenda-view-columns-initially nil)
  (setq org-agenda-columns-show-summaries t)
  (setq org-agenda-columns-compute-summary-properties t)
  (setq org-agenda-columns-add-appointments-to-effort-sum nil)
  (setq org-agenda-auto-exclude-function nil)
  (setq org-agenda-bulk-custom-functions nil)

;;;;; Agenda habits
  (require 'org-habit)
  (setq org-habit-graph-column 50)
  (setq org-habit-preceding-days 9)

;;;; code blocks
  (setq org-confirm-babel-evaluate nil)
  (setq org-src-window-setup 'current-window)
  (setq org-edit-src-persistent-message nil)
  (setq org-src-fontify-natively t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-edit-src-content-indentation 0)

;;;; export
  (setq org-export-with-toc t)
  (setq org-export-headline-levels 8)
  (setq org-export-dispatch-use-expert-ui nil)
  (setq org-html-htmlize-output-type nil)
  (setq org-html-head-include-default-style nil)
  (setq org-html-head-include-scripts nil)
  (require 'ox-texinfo)
  (require 'ox-md)
  ;; FIXME: how to remove everything else?
  (setq org-export-backends '(html texinfo md))

;;;; IDs
  (setq org-id-link-to-org-use-id
        'create-if-interactive-and-no-custom-id)

  (let ((map global-map))
    (define-key map (kbd "C-c a") #'org-agenda)
    (define-key map (kbd "C-c c") #'org-capture)
    (define-key map (kbd "C-c l") #'org-store-link))
  (let ((map org-mode-map))
    (define-key map (kbd "C-'") nil)
    (define-key map (kbd "C-,") nil)
    (define-key map (kbd "<C-return>") nil)
    (define-key map (kbd "<C-S-return>") nil)
    (define-key map (kbd "C-M-S-<right>") nil)
    (define-key map (kbd "C-M-S-<left>") nil)
    (define-key map (kbd "C-c S-l") #'org-toggle-link-display)
    (define-key map (kbd "C-c C-S-l") #'org-insert-last-stored-link)))

(prot-emacs-builtin-package 'prot-org
  (setq org-agenda-format-date #'prot-org-agenda-format-date-aligned)

  ;; Check the variable `prot-org-custom-daily-agenda' in prot-org.el
  (setq org-agenda-custom-commands
        `(("A" "Daily agenda and top priority tasks"
           ,prot-org-custom-daily-agenda
           ((org-agenda-fontify-priorities nil)
            (org-agenda-dim-blocked-tasks nil)))
          ("P" "Plain text daily agenda and top priorities"
           ,prot-org-custom-daily-agenda
           ((org-agenda-with-colors nil)
            (org-agenda-prefix-format "%t %s")
            (org-agenda-current-time-string ,(car (last org-agenda-time-grid)))
            (org-agenda-fontify-priorities nil)
            (org-agenda-remove-tags t))
           ("agenda.txt"))))

  ;; I bind `org-agenda' to C-c a, so this one puts me straight into my
  ;; custom block agenda.
  (define-key global-map (kbd "C-c A") (lambda () (interactive) (org-agenda nil "A")))

  (add-to-list 'org-capture-templates
               '("j" "Music suggestion (jukebox)" entry
                 (file+headline "tasks.org" "Music suggestions")
                 #'prot-org-capture-jukebox
                 :empty-lines-after 1
                 :immediate-finish t)))
#+end_src


*** Prettier Org constructs (org-modern.el)
:PROPERTIES:
:CUSTOM_ID: h:a6b1bb67-b62b-4018-999a-90cbd0bdceb5
:END:

This is yet another high-quality package by Daniel Mendler which handles
the prettification of Org buffers in a performant way.  Rathen than
write about what the package does, it is better you check the GIF in the
project's README: https://github.com/minad/org-modern.

The package is still in its early days, so expect things to change.
Though I am already happy with the results.

Also bear in mind that I am experimenting with various tweaks to the
available faces.  Do not copy those without understanding their
implications: ~org-modern~ should work well---or even better---without
those changes, especially since it is theme-agnostic.

#+begin_src emacs-lisp :tangle no
(prot-emacs-elpa-package 'org-modern
  (setq org-modern-label-border 1)
  (setq org-modern-variable-pitch nil)
  (setq org-modern-timestamp t)
  (setq org-modern-table t)
  (setq org-modern-table-vertical 1)
  (setq org-modern-table-horizontal 0)
  (setq org-modern-list ; I swap the defaults for + and *
        '((?+ . "•")
          (?- . "–")
          (?* . "◦")))

  ;; NOTE 2022-03-05: The variables that are commented out are the
  ;; defaults.

  ;; (setq org-modern-star ["◉""○""◈""◇""⁕"])
  ;; (setq org-modern-hide-stars 'leading)
  ;; (setq org-modern-checkbox
  ;;       '((?X . #("▢✓" 0 2 (composition ((2)))))
  ;;         (?- . #("▢–" 0 2 (composition ((2)))))
  ;;         (?\s . #("▢" 0 1 (composition ((1)))))))
  ;; (setq org-modern-horizontal-rule t)
  ;; (setq org-modern-priority t)
  ;; (setq org-modern-todo t)
  ;; (setq org-modern-tag t)
  ;; (setq org-modern-block t)
  ;; (setq org-modern-keyword t)
  ;; (setq org-modern-statistics t)
  ;; (setq org-modern-progress ["○""◔""◐""◕""●"])

  (add-hook 'org-mode-hook #'org-modern-mode)
  (add-hook 'org-agenda-finalize-hook #'org-modern-agenda)

  ;; NOTE 2022-03-06: I am experimenting with various styles here.  DO NOT COPY.
  ;;
  ;; Also note that I do not wrap this in `with-eval-after-load' because
  ;; the `modus-themes' are always loaded first in my config.
  (defun prot/org-modern-face-tweaks ()
    (modus-themes-with-colors
      (custom-set-faces
       `(org-modern-label ((,class :box (:line-width (-1 . ,org-modern-label-border) :color ,bg-main))))
       `(org-modern-done ((,class :inherit org-modern-label :background ,bg-special-faint-mild :foreground ,green-alt-other)))
       `(org-modern-priority ((,class :inherit org-modern-label :background ,bg-special-faint-calm :foreground ,magenta-alt-other)))
       `(org-modern-statistics ((,class :inherit org-modern-label :background ,bg-special-faint-warm :foreground ,yellow-alt-other)))
       `(org-modern-tag ((,class :inherit org-modern-label :background ,bg-special-faint-calm :foreground ,magenta)))
       `(org-modern-todo ((,class :inherit org-modern-label :background ,bg-special-faint-warm :foreground ,red-alt-other)))
       `(org-modern-date-active ((,class :inherit org-modern-label :background ,bg-alt :foreground ,fg-main)))
       `(org-modern-date-inactive ((,class :inherit org-modern-date-active :foreground ,fg-dim)))
       `(org-modern-time-active ((,class :inherit org-modern-label :background ,bg-active :foreground ,fg-main)))
       `(org-modern-time-inactive ((,class :inherit org-modern-date-inactive))))))

  (add-hook 'modus-themes-after-load-theme-hook #'prot/org-modern-face-tweaks))
#+end_src

** Calendar and Diary (and prot-diary.el)
:PROPERTIES:
:CUSTOM_ID: h:b4040bc0-7a2a-4f17-824d-42de621bd1b9
:END:

Relevant information for what you are about to read in this section
(the list will be updated accordingly):

+ [[https://protesilaos.com/codelog/2021-04-14-emacs-diary-calendar/][Video of Emacs Diary and Calendar for tracking appointments]] (2021-04-14).
+ [[https://protesilaos.com/codelog/2021-04-15-emacs-diary-outline-minor-mode/][Make the Emacs Diary work as an Outline (outline-minor-mode)]] (2021-04-15).
+ [[https://www.youtube.com/watch?v=n8o66i08fzs][Video on using Hyperbole with the Emacs Diary]] by the Emacs Elements
  channel (Raoul Comninos) (2021-04-16).

Emacs provides a suite of tools for planning events or recording dates
of interest in your life.  These are part of the same workflow, but are
divided into several smaller libraries.  The two main ones are
=diary-lib.el= and =calendar.el=.  I extend them with =prot-diary.el=, which
is reproduced at the end of this section, after the package
configurations.

=diary-lib.el= defines everything that pertains to the =diary-file=
(defaults to =~/.emacs.d/diary=, which is what I want).  The Diary has a
two-fold purpose: (i) to store entries about calendar events, and (ii)
to display such events for the given day or range thereof.

In the first case, the Diary functions as a regular buffer that you may
edit freely.  This is where you can write one-off or recurring events
using various date and time formats expressed in natural language or as
Elisp forms (a sexp or "symbolic expression").

When it comes to single events for a given day, I prefer to input them
on a whole line using the ISO 8601 standard and a 24-hour clock, like
this: =2021-04-13 15:00 Description of event=.

For multiple events that are clustered on the same day, I write the date
on its own line and below it place a description of each event
optionally preceded by a timestamp.  Entries with no timestamp come
first, followed by those that are time sensitive.  This is just a matter
of personal style.

In this scenario of grouped events under a given date, each entry below
the date has to start with at least one empty space, otherwise the Diary
will try to interpret them as two distinct expressions (the exact number
of spaces is a matter of preference).  So the format looks like this
(use =C-x TAB= (=indent-rigidly=) to incrementally adjust the indentation of
the active region, or =C-u C-x TAB= to increase by four spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

The following is also possible, but looks too busy for no good reason:

#+begin_example
2021-04-13 This event is not time sensitive
2021-04-13 06:30-09:00 Hiking
2021-04-13 10:00 Prepare sourdough bread
2021-04-13 11:00-13:00 Write stuff
#+end_example

Though not required, you can separate events by an empty line.  Keeps
things easy to read.  Remember that lines that contain at least one
space are thought to belong to the closest date entry above them.  Which
means that for multiple events on a given day you can use something like
this, if you need to (here dots represent empty spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
....
    10:00 Prepare sourdough bread
....
    11:00-13:00 Write stuff
#+end_example

Furthermore, it is possible to use nested levels of indentation or, in
my case, call =prot-simple-cite-region= and indent it accordingly (check
the source code: [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][Common custom functions (prot-simple.el)]]).  For
example:

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
    +----[ Sample text ]
    | This is some random text
    | It relates to the above event
    +----
....
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

Remember that these are mere stylistic considerations.  I generally
prefer to keep things simple, though I appreciate the flexibility of
adapting the view of my evolving needs.

I prefer to defer all formatting related decisions until after I have
typed in all the information.  My =prot-diary-align-timestamped-entries=
lets me align the negative space between an entry's timestamp and its
description.  Consider the following block and suppose that the region
starts from the line below the date and ends at the end of the line with
the last entry (demarcated by the =|= characters).

#+begin_example
2021-04-13
|This event is not time sensitive
06:30-09:00 Hiking
10:00 Prepare sourdough bread
11:00-13:00 Write stuff|

...becomes...

2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00       Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

For anniversaries or cyclic events, I rely on Elisp.  It is better to
read the Emacs manual on the technicalities as there are lots of
examples that should help you get started.  Just bear in mind that the
exact order for the =YEAR=, =MONTH=, =DATE= arguments depends on the value
assigned to the variable =calendar-date-style=.  As I already noted, I
follow the ISO style (evaluate this: =(format-time-string "%F")=).

The second use case of the Diary, namely, of showing the events it holds
is controlled by the variable =diary-display-function=.  On my setup it
should present the information in a read-only buffer that is internally
referred to as the "fancy" style.  To bring up that interface, you can
either use the Calendar as a starting point (more on that later) or call
a command directly, such as =prot-diary-display-entries=.  The resulting
buffer is fairly straightforward: there is a date header (or many
depending on the prefix numeric argument) and below that one or more
entries related to it.  Those retain the indentation of the underlying
Diary file, as described above.  Hit =RET= over an entry to visit the
editable version of the Diary.

Apart from displaying that buffer on demand, it is possible to get its
information emailed to you.  The built-in command for that is
=diary-mail-days=, however it has the downside of sending a mail even when
there are no events for the day[s] specified.  I do not see the utility
of such behaviour: what is the purpose of drawing attention to my email
client, only to waste my time with some "nothing to see here" message?
Whereas =prot-diary-mail-entries= only sends a message when that is the
right thing to do, i.e. when there is something that requires our
attention (for N days or =diary-mail-days=).  It also has the benefit of
not popping up the Diary display in another window as a side effect of
sending the email (check =prot-diary--mail-fn= for the technicalities).  I
set it up to automatically try to send me an email briefing each morning
when I launch Emacs.

Email briefings just offer an overview of events in the immediate
future.  We still need a mechanism to alert us some minutes in advance
of a time sensitive appointment.  This is where the =appt.el= library
comes in handy.  It already knows how to scan the Diary in search for
time expressions and produce reminders for them: all it needs is to be
activated with =(appt-activate 1)=.  Unlike email, this is a more
persistent method of producing notifications inside of Emacs in the form
of a pop-up window and a complementary modeline indicator with a
countdown to the event.  The default notification time is specified in
the variable =appt-message-warning-time=, though individual Diary entries
can declare their own time (in minutes), by holding some extra text as
defined in =appt-warning-time-regexp=.  Put that in a comment
(=diary-comment-start=) to disambiguate it from the entry's description.
For example, this Diary entry will work as expected with my
configurations: =2021-04-13 18:00 Some task ;; appt 5=.  The =;; appt 5=
part will not be shown in the Diary display, but will still activate the
reminder.  Nice and simple!

To recapitulate, the Diary is flexible enough to accommodate a variety
of preferences on how to organise one's life events.  The key to get
started is to learn how to edit the actual file, which is fairly easy.
It then is trivial to either display that information on demand or be
notified about it.

Let us now cover the other major component of this suite of tools: the
Calendar.  The main point of entry is =M-x calendar=.  It displays a
horizontal three-month view centred on the current month.  Moving in the
calendar is consistent with regular Emacs motions: =C-f= and =C-b= move one
day forward/backward, =C-n= and =C-p= go down and up one week, =C-a= and =C-e=
place the point at the beginning or end of the week, respectively.  Then
we have the equivalent of paragraph and page motions: =M-{= and =M-}= which
travel forward/backward a full month, with =C-v= and =M-v= moving to the
next and previous three-month set.  To merely scroll the horizontal
calendar strip, use =<= and =>= to do so in the given direction.  As always,
do not forget to type =C-h m= (=describe-mode=) in any major-mode buffer you
are unfamiliar with to get help for it: you will learn about those
motions and some more of them (and always check the manual as well).

The Calendar offers an overview of your Diary entries, as noted above,
and, optionally, of all holidays that you have opted in to.  For the
latter, check the variable =calendar-holidays=.  I set it to only a small
set of records largely for experimental purposes, as I am not interested
in either religious or secular special days.  Consider this, if you
will, an attempt at introducing the illusion of eventfulness in my
calendar.  I really don't care about any of this.

To mark Diary entries in the Calendar, use =m= (=diary-mark-entries=).  That
accepts a prefix argument (=C-u=) in case you wish to redraw those marks.
Here we should clarify that "marks" are Emacs faces by default, unless
you explicitly override them with characters.  I prefer faces, which
leave a more pleasant, less noisy impression.  Similarly, use =x=
(=calendar-mark-holidays=) to mark holidays.  Both of those tasks can be
performed automatically upon accessing the Calendar, by setting the
variables =calendar-mark-diary-entries-flag=, =calendar-mark-holidays-flag=
to non-nil values (which is what I do).

Events that should not appear in the Calendar when Diary entries are
marked must be preceded with a special character, which is configurable
by means of =diary-nonmarking-symbol=.  I personally have no use for this,
because if something is not worth being marked, then it is not pointless
to keep track of it in my day-to-day planner.

While in the Calendar, you can move the point over a marked day and type
=d= (=diary-view-entries=) to show the read-only variant of the Diary, as
outlined above.  Or pass a number to it to encompass the Nth days
(e.g. typing =7 d= will show Diary entries for seven days starting from
the current one).  If the mark pertains to a holiday, type =h= to get a
message in the echo area about it (=calendar-cursor-holidays=).

If you opt to use my settings, the best way to learn how to disambiguate
the two marks is to access the Calendar and hit =u= (=calendar-unmark=).
Follow it up with =m= to mark Diary entries and =x= to render holiday marks.

Other than viewing what happens on a given day or date range, you can
use the Calendar to record new entries in the Diary.  I group those
under the =i= prefix key: so type, =i= and then =C-h= to get help about all
possible keys that complete that sequence and references to the commands
they call.  Note that to insert a block event you need to hit =C-SPC= on
the starting date and then move point to the ending day at which you
should do =i b= (=diary-insert-block-entry=).

It is possible to use more faces than the ones which are provided by
default.  To do so, you need to specify a face argument to the various
Elisp expressions that can be written to the Diary.  For example, my
=prot-diary.el= (reproduced further below) has a bespoke face for
"administrative tasks", which can be assigned to the given expression
like this (new line and indentation are optional, as mentioned above,
otherwise keep everything on one line):

#+begin_example
 %%(diary-date t t 13 'prot-diary-calendar-administrative-mark)
     Some administrative monthly task
 %%(diary-anniversary 1900 4 13 'prot-diary-calendar-anniversary-mark)
     Some anniversary is %d years
#+end_example

The manual covers a lot of other potentially useful tasks you may
accomplish with those tools.  For example, it is possible to import an
iCalendar, convert from one calendar to another (e.g. Gregorian to
Chinese), get the phases of the moon, sunset and sunrise times in the
given geographic coordinates...  Evaluate this expression to start
reading the relevant Info nodes: =(info "(emacs) Calendar/Diary")=.

For the integration with =outline-minor-mode= that =prot-diary.el= provides,
refer to the relevant section (in short: you get header folding like in
Org for every line that starts with =;;;=, given my =diary-comment-start= is
=;;=): [[#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1][Outline mode, outline minor mode (prot-outline.el)]].

Finally, note that I control the placement of those buffers in the
=display-buffer-alist= (read: [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).

#+begin_src emacs-lisp :tangle no
;;; Calendar and Diary (and prot-diary.el)
(prot-emacs-builtin-package 'calendar
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '(24-hours ":" minutes
                   (when time-zone
                     (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-date-display-form calendar-iso-date-display-form)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'solar)
  (setq calendar-latitude 35.17         ; Not my actual coordinates
        calendar-longitude 33.36)

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "+0200")
  (setq calendar-daylight-time-zone-name "+0300")

  (require 'diary-lib)
  (setq diary-mail-addr user-mail-address)
  (setq diary-date-forms diary-iso-date-forms)
  (setq diary-comment-start ";;")
  (setq diary-comment-end "")
  (setq diary-nonmarking-symbol "!")
  (setq diary-show-holidays-flag t)
  (setq diary-display-function #'diary-fancy-display) ; better than its alternative
  (setq diary-header-line-format nil)
  (setq diary-list-include-blanks nil)
  (setq diary-number-of-entries 2)
  (setq diary-mail-days 2)
  (setq diary-abbreviated-year-flag nil)

  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
  (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
  (add-hook 'diary-mode-hook #'goto-address-mode) ; buttonise plain text links

  ;; Those presuppose (setq diary-display-function #'diary-fancy-display)
  (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
  (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

  ;; Prevent Org from interfering with my key bindings.
  (remove-hook 'calendar-mode-hook #'org--setup-calendar-bindings)

  (let ((map calendar-mode-map))
    (define-key map (kbd "s") #'calendar-sunrise-sunset)
    (define-key map (kbd "l") #'lunar-phases)
    (define-key map (kbd "i") nil) ; Org sets this, much to my chagrin (see `remove-hook' above)
    (define-key map (kbd "i a") #'diary-insert-anniversary-entry)
    (define-key map (kbd "i b") #'diary-insert-block-entry)
    (define-key map (kbd "i c") #'diary-insert-cyclic-entry)
    (define-key map (kbd "i d") #'diary-insert-entry) ; for current "day"
    (define-key map (kbd "i i") #'diary-insert-entry) ; most common action, easier to type
    (define-key map (kbd "i m") #'diary-insert-monthly-entry)
    (define-key map (kbd "i w") #'diary-insert-weekly-entry)
    (define-key map (kbd "i y") #'diary-insert-yearly-entry)
    (define-key map (kbd "M-n") #'calendar-forward-month)
    (define-key map (kbd "M-p") #'calendar-backward-month)))

(prot-emacs-builtin-package 'appt
  (setq appt-display-diary nil)
  (setq appt-disp-window-function #'appt-disp-window)
  (setq appt-display-mode-line t)
  (setq appt-display-interval 3)
  (setq appt-audible nil)
  (setq appt-warning-time-regexp "appt \\([0-9]+\\)")
  (setq appt-message-warning-time 6)

  (run-at-time 10 nil #'appt-activate 1))

(prot-emacs-builtin-package 'prot-diary
  ;; The idea is to get a reminder via email when I launch Emacs in the
  ;; morning and this file is evaluated.  Obviously this is not a super
  ;; sophisticated approach, though I do not need one.
  (let ((time (string-to-number (format-time-string "%H"))))
    (when (and (> time 4) (< time 9))
      (run-at-time (* 60 5) nil #'prot-diary-mail-entries)))

  (require 'holidays)
  (setq calendar-holidays (append holiday-solar-holidays prot-diary-local-holidays))

  (with-eval-after-load 'prot-outline
    (add-hook 'diary-mode-hook #'prot-outline-minor-mode-safe))

  (let ((map diary-mode-map))
    (define-key map (kbd "<M-return>") #'prot-diary-newline-indent)
    (define-key map (kbd "M-n") #'prot-diary-heading-next)
    (define-key map (kbd "M-p") #'prot-diary-heading-previous)
    (define-key map (kbd "C-c C-a") #'prot-diary-align-timestamped-entries))
  (let ((map global-map))
    (define-key map (kbd "C-c d c") #'calendar)
    (define-key map (kbd "C-c d d") #'prot-diary-display-entries)
    (define-key map (kbd "C-c d e") #'prot-diary-edit-diary)
    (define-key map (kbd "C-c d i") #'prot-diary-insert-entry)
    (define-key map (kbd "C-c d m") #'prot-diary-mail-entries)))
#+end_src

These are the contents of the =prot-diary.el= library (find the source
code in [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]] (as with all my Elisp code)):

#+include: prot-lisp/prot-diary.el src emacs-lisp :tangle no

** Email settings
:PROPERTIES:
:CUSTOM_ID: h:5ad80664-3163-4d9d-be65-462637d77903
:END:

Once you delve into the technical details, email is hard as it consists
of arcane specs and protocols.  Combined with Emacs' open-endedness as
well as the wealth of free software command-line programs on offer,
there are seemingly infinite ways to set things up.  The toolset for my
current setup consists of the following:

+ The external =mbsync= program to periodically synchronise my remote
  email server and my local mail directories.  This allows me to keep a
  copy of my correspondence, while it removes the burden of updating
  mail sources from the client.  The latter benefit is particularly
  important to avoid slowing down Emacs.

+ The Notmuch package which includes the CLI program and the Emacs
  library that implements a Mail User Agent.  Notmuch is a mail indexer
  that can search through the database using a strictly tags-only
  workflow.  I was using Gnus in the past (between early 2020 and May
  2021), but ultimately decided to upgrade my workflow by going with the
  more flexible approach of Notmuch (I had also used Mu4e before, which
  is closer in spirit to Notmuch and is a good choice overall---in the
  source code of my dotfiles, from where you can find this document,
  there is the =prot-mu4e-deprecated-conf.el= file in case you need it;
  same for =prot-gnus-deprecated-conf.org=).

+ The built-in capabilities to compose and send email.

+ Other extensions to integrate email composition with encryption tools,
  Dired, Org, contact-completion (EBDB)...

*This is a mega section that encompasses all of the aforementioned.*
Please study it carefully.

*** Client-agnostic email settings (and prot-mail.el)
:PROPERTIES:
:CUSTOM_ID: h:a82766be-daab-4925-b23a-1c5ffd47e599
:END:

Before configuring any mail user agent, we need to establish the
absolute essentials: who we are, where our authentication credentials
are stored, and whether encryption is to be supported.  We must also
define how message composition should work.  This is what the following
configurations are about.

+ The =mail-user-agent= and =message-mail-user-agent= concern the default
  email composition buffer, called with =C-x m= or any other facility that
  falls back to the =compose-mail= function.  The default is =message-mode=.

  - When notmuch is in use, it will insert a special "Fcc" header whose
    task is to copy the outgoing message to the appropriate maildir path
    (this part is done in [[#h:a196812e-1644-4536-84ba-687366867def][the Notmuch section]]).

+ The value of =message-citation-line-format= is expanded into something
  like /"On 2020-02-19, 13:54 +0200, NAME <EMAIL> wrote:"/.  To learn
  about all the date-related specifiers, it is better to read the
  documentation with =M-x describe-variable RET format-time-string RET=.

+ The =mm-encode= and =mml-sec= are meant to come into effect when
  encrypting and signing an outgoing message, such as with =C-c C-m C-e=
  (=mml-secure-message-sign-encrypt=).  The optional guided key selection
  will ask for confirmation on who to encrypt to.  It presents a list
  with the available keys.  Items are marked with =m= and then the mail
  can be sent with the standard commands (e.g. =C-c C-c=).  I used that
  setup for a while, but ultimately decided that the extra steps did not
  make any difference to my workflow, as I always double-check before
  sending out an email.

+ The =gnus-dired= library can be used independently of Gnus (and should
  thus be refactored as "message-dired.el" or something).  It provides
  glue code that integrates Dired buffers with message composition, so
  that one can attach either the file at point or the marked ones with
  =C-c C-m C-a= (=gnus-dired-attach=).

#+begin_src emacs-lisp :tangle no
;;; Client-agnostic email settings (and prot-mail.el)
(prot-emacs-builtin-package 'auth-source
  (setq auth-sources '("~/.authinfo.gpg"))
  (setq user-full-name "Protesilaos Stavrou")
  (setq user-mail-address "public@protesilaos.com"))

(prot-emacs-builtin-package 'mm-encode
  (setq mm-encrypt-option nil) ; use 'guided if you need more control
  (setq mm-sign-option nil))   ; same

(prot-emacs-builtin-package 'mml-sec
  (setq mml-secure-openpgp-encrypt-to-self t)
  (setq mml-secure-openpgp-sign-with-sender t)
  (setq mml-secure-smime-encrypt-to-self t)
  (setq mml-secure-smime-sign-with-sender t))

(prot-emacs-builtin-package 'message
  (setq mail-user-agent 'message-user-agent)
  (setq mail-header-separator (purecopy "*****"))
  (setq message-elide-ellipsis ">\n> [... %l lines elided]\n>\n>") ; NOTE 2021-07-13: experimental
  (setq compose-mail-user-agent-warnings nil)
  (setq message-mail-user-agent t)      ; use `mail-user-agent'
  (setq mail-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-citation-line-format "On %Y-%m-%d, %R %z, %f wrote:\n")
  (setq message-citation-line-function
        'message-insert-formatted-citation-line)
  (setq message-confirm-send nil)
  (setq message-kill-buffer-on-exit t)
  (setq message-wide-reply-confirm-recipients t)
  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

  (add-hook 'message-setup-hook #'message-sort-headers))

(prot-emacs-builtin-package 'gnus-dired ; does not require `gnus'
  (add-hook 'dired-mode-hook #'gnus-dired-mode))

(prot-emacs-builtin-package 'prot-mail
  ;; NOTE 2021-05-14: This is a generic indicator for new mail in the
  ;; maildir.  As I now use notmuch (see relevant section in this
  ;; document) I have an alternative approach in prot-notmuch.el.
  (setq prot-mail-maildir-path-regexp "~/.mail/*/Inbox/new/") ; shell regexp
  (setq prot-mail-mode-line-indicator-commands
        '(notmuch-refresh-this-buffer))
  ;; mode line indicator with the number of new mails
  (prot-mail-mail-indicator -1))
#+end_src

And here is =prot-mail.el= (part of [[https://gitlab.com/protesilaos/dotfiles][my dotfiles' repo]]):

#+include: prot-lisp/prot-mail.el src emacs-lisp :tangle no

**** Sample of authinfo.gpg
:PROPERTIES:
:CUSTOM_ID: h:8d0bd754-8a31-431b-b112-f541cc0144ac
:END:

Below is a sample with the contents of my =authinfo.gpg=.  This is read,
inter alia, by =notmuch= and =smtpmail= to be able to both fetch and send
messages from the given account.  By default, one can use a generic
=authinfo= file though I consider that reckless: I strongly encourage you
to *encrypt this file* if you add your login credentials there.  Do it
from inside =dired= with =: e= while the point is over the file.  Emacs can
decrypt all encrypted files automatically.

#+begin_example
machine prv port 993 login MAIL password SECRET
machine inf port 993 login MAIL password SECRET
machine pub port 993 login MAIL password SECRET

machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
#+end_example

Refer to your email provider's documentation in order to determine the
port number and server address you need to use for sending and receiving
messages.  The =MAIL= is either your email address or some username for
logging into the account.

Note that the terms I use above for =prv=, =inf=, and =pub= are just arbitrary
names for the given =MAIL= and =SECRET= combination.  This allows me to
reference each name in the various package configurations in this
document, and share them publicly without worrying about leaking
sensitive data.

Which brings us to the point of actually retrieving those values.  The
=prot-mail-auth-get-field= is designed to return a field from the authinfo
file (this function is defined in my =prot-mail.el=, which is reproduced
at the end of [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).  You
will find this function used elsewhere in this document.  For example,
to get the username and password for host =inf= we do:

#+begin_example emacs-lisp :tangle no
(prot-mail-auth-get-field "inf" :user)   ; login name
(prot-mail-auth-get-field "inf" :secret) ; password
#+end_example

**** .mbsyncrc
:PROPERTIES:
:CUSTOM_ID: h:88a605b8-d5b5-486f-87c9-0c80b423ae36
:END:

I already noted in the introduction to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]] that my emails are
synced locally using the =mbsync= executable.  This program is part of a
package that, depending on your operating system, is called "isync".
Read the [[https://wiki.archlinux.org/index.php/Isync][Arch Wiki entry on mbsync]].

My =~/.mbsyncrc= is furnished below.  Note that the =awk= call reads from
the =~/.authinfo.gpg= (see [[#h:8d0bd754-8a31-431b-b112-f541cc0144ac][Sample of authinfo.gpg]]).

#+include: ../../mbsync/.mbsyncrc src conf :tangle no

*** Notmuch (mail indexer and mail user agent (MUA))
:PROPERTIES:
:CUSTOM_ID: h:a196812e-1644-4536-84ba-687366867def
:END:

Also watch the video of what you are about to read in the following
paragraphs: [[https://protesilaos.com/codelog/2021-05-15-emacs-notmuch/][Demo of the Emacs front-end to Notmuch]] (2021-05-15).


At its core, Notmuch is a command-line program that maintains an index
of a maildir directory structure and is capable to search through it
using a tag-based method.  Notmuch is both minimalist and powerful:

1. its clearly delimited role as a mail indexer allows it to be used in
   a variety of setups that involve different tools on how to handle
   email traffic;

2. while its tag-centric design lifts the inherent restrictions of
   complex filesystem paths on where a file must be stored, as messages
   can be grouped together dynamically depending on the search criteria.

In terms of overall setup, I use Notmuch together with =mbsync= to
synchronise my maildir with the IMAP server (consult my [[#h:88a605b8-d5b5-486f-87c9-0c80b423ae36][.mbsyncrc]]).
While I send messages with Emacs' own facility which relies on the
=sendmail= program (refer to [[#h:2d793cf8-83f5-4830-b73d-78385d9b96dd][Sending email (SMTP)]]).  The latter may change
in the future, as I weigh the pros and cons of programs like =msmtp=,
though this is low on my list of priorities.  As for the actual
composition of emails, it is done by Emacs' =message.el= library
([[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

Tagging is integral to the Notmuch experience, because it allows you to
cope with evolving circumstances.  It is best to consider this by means
of an example.  Suppose that you are working on some project: (1) there
is an email in your private account from a close friend that contains
valuable information but which is part of an otherwise long thread that
is not pertinent in its entirety to the task at hand, (2) there is
another message from a mailing list you do not actively participate in
and this message lives in your "throwaway" account that you use only for
mailing lists and the like, and (3) there is yet another mail from some
client or employer that is specific to the project and which is kept in
your designated "professional" inbox.  Lets say that those correspond to
"private@example.tld", "lists@example.tld", "work@example.tld".  In a
folder-based approach, it is hard to combine those otherwise unrelated
files.  Whereas with tags, say, =+project=, we can get everything into
focus with a simple search for =tag:project=.

While we will be using the Emacs interface to Notmuch, it is important
to spend some time reading the man pages for the CLI tools.  Some
examples for searching:

#+begin_example
$ notmuch search from:prot*
$ notmuch search from:protesilaos tag:todo
$ notmuch search from:protesilaos or from:socrates
$ notmuch search 'from:"/(info|public)@protesilaos.com/"'
$ notmuch search 'from:"/(info|public)@protesilaos.com/"' date:yesterday..today
$ notmuch search '(from:"*@protesilaos.com*" not to:"*@protesilaos.com*")' date:today
$ notmuch search from:"*@protesilaos.com*" date:today..08:00
$ notmuch search body:recrudescence
$ notmuch search path:inf/Inbox/** date:2021-05
#+end_example

There is no need to develop expertise in that syntax at the outset.
Just learn the basics and let the rest grow organically through regular
usage.  Though do read the man pages as they include important
information such as what "stemming" is and how it affects your search
results.

Now let's focus on the Emacs side of things, starting with the
"notmuch-hello" buffer (it runs =notmuch-hello-mode=).  What exactly shows
up here depends on =notmuch-hello-sections=.  I like to keep it clean.  At
any rate, from here we can switch to results from saved searches or
tags, or perform a new search:

+ Type =j= to invoke =notmuch-jump-search=: it will produce a prompt for a
  key binding that corresponds to one of your saved searches (controlled
  by the variable =notmuch-saved-searches=).

+ With =t= for =notmuch-search-by-tag= you get minibuffer completion against
  all known tags.

+ Hit =s= to call =notmuch-search= which lets you type a query such as one
  of the aforementioned examples.  In the "notmuch-hello" buffer I keep
  a list of recent searches, which can be helpful to re-use at a later
  point, though we can always benefit from minibuffer history
  navigation, such as =M-n= and =M-p= while at the =notmuch-search= prompt.

+ Same principle for =z= (=notmuch-tree=) only it differs from the above
  search in the overall presentation where it visualises each thread
  using indentation and arrows to show what belongs where.  It also
  reduces the subject line to the first entry in each thread, making it
  easier to follow the results.

All of those will put you in a buffer that runs =notmuch-search-mode=.  As
always, you should use =C-h m= (=describe-mode=) to learn about everything
related to the current major mode (as well as all active minor modes).

To further limit the results to an arbitrary list of search criteria,
use =l= (=notmuch-search-filter=) and then supply whatever terms are needed.
Or use =t=, which is here bound to =notmuch-search-filter-by-tag= to filter
directly by tag using completion.  For example, I can start from the
"notmuch-hello" buffer with =notmuch-search-by-tag=, select "todo", and
then use =l= or =t= to further narrow to, say, a "replied" tag or
=date:today=.

Filtering of search results is the best way to narrow the list to
relevant matches.  You can try supplying just a search term without any
keywords and you are likely to get what you are looking for.  For
example, I was in a search that included results from the emacs-devel
and bug-gnu-emacs mailing lists and had several unread threads, though I
only wanted to read about "group-function".  So I just hit =l=
(=notmuch-search-filter=) and then typed in that query.  Same principle if
you wish to exclude something, such as with =not tag:flag=.

The Notmuch presentation is compact when it comes to longer threads as
it reduces them to a single line.  We can still get a sense of context
by viewing the total count of messages in the thread: this is controlled
by the variable =notmuch-search-result-format=.  While I like this as a
default, there are cases where we need to visualise the email exchanges:
=notmuch-tree-from-unthreaded-current-query= can do just that and is bound
to =Z= in =notmuch-search-mode-map=.  A similar variant is =U= for
=notmuch-unthreaded-from-search-current-query=, as it expands the view
without adding the tree indicators and without de-duplicating subject
lines across the threads.  Go back to the standard search view with =S=
(=notmuch-search-from-tree-current-query=).

All those changes in presentation happen in new buffers: you do not lose
anything, unless you explicitly kill those buffers.  For the sake of
convenience, Notmuch provides the =notmuch-bury-or-kill-this-buffer=
command, bound to =q= in all those views.  Read its doc string to know
when it kills and when it buries the buffer.  Of course, you may always
use commands like =previous-buffer= as well as minibuffer completion and
=M-x ibuffer= or whatever else you normally use.  The point is that you
can easily switch views to get the job done.

Speaking of multiple buffers, Notmuch provides two commands to refresh
those: (i) =notmuch-refresh-this-buffer=, which is bound by default to the
usual =g= key as well as ===, and (ii) =notmuch-refresh-all-buffers= which is
assigned to =M-g=.  My =prot-notmuch-refresh-buffer= is a wrapper of those
two and is mapped to =g=: when called with a =C-u= prefix argument, it
refreshes all buffers, else it operates on the current one.  There is
also =G= (=notmuch-poll-and-refresh-this-buffer=) which runs =notmuch new=
externally and then refreshes the buffer---personally I don't need this
as mbsync automatically does that every few minutes.

To read a thread, hit =RET= (=notmuch-search-show-thread=) with point over
it in any those search/tree views.  That puts you in =notmuch-show-mode=
(did I tell you about =C-h m=?).  Notmuch organises all messages in the
thread as headings, where the first line with the summary of the message
uses a special face (a background colour, though that depends on the
theme).  With point over the heading's line =RET= expands or contracts the
body of the message.  The =n= and =p= keys move between expanded messages in
the thread, while =N= and =P= always go to the next and previous items,
respectively.  An Imenu index is also available, so you can jump to any
heading using minibuffer completion (with =M-x imenu= or some third-party
extension like the =consult-imenu= that I use).

When you compose an email, such as by replying with =r= or =R=, you are
taken to a buffer that leverages functionality provided by the built-in
=message.el=.  As always, run =C-h m= to get a sense of how things work and
what commands you may call: =C-c C-c= dispatches the email, =C-c C-a=
prompts for an attachment, =C-c C-m C-e= encrypts and signs, =C-c C-m C-a=
from a Dired buffer attaches the file at point or any marked ones (refer
to [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

For searching to be productive, we must apply tags in accordance with a
defined method of organising our workflow (more about my approach
further below).  Too many over-specialised or poorly considered tags
will likely make things more difficult, while too few will probably
prevent you from finding what you need.  How you go about it is up to
you.  Notmuch is just a tool: don't believe in the hype of magical
exominds or second brains that do the work on your behalf---maximise the
potential of the one mind you have and the rest will follow from there.

Tag addition or removal is denoted by a plus or minus prefix to the name
of the tag.  The =k= binding exists in all relevant mode maps: it offers a
shortcut to the "keys" (tags) that can be used to mark a give entry.
That command will prompt for a choice among =notmuch-tagging-keys=.  For
example =k d= will do =+del -inbox=, based on what I currently have.  Invert
the meaning of those terms by prefixing the command with a =C-u= argument.

To freely tag all items in the current view (search, tree, show) use =*=.
That gives you a completion prompt where multiple terms can be supplied,
each delimited by a space (internally this is =completing-read-multiple=
and the space is governed by a let-bound =crm-separator=).  Combine that
with the aforementioned methods for limiting the view to a given subset
for maximum effect.

Other ways to perform tagging operations involve the =+= and =-= keys.  They
also use =completing-read-multiple=.  What those commands offer, beside
the minibuffer interface, is the ability to operate on the entries
encompassed by the active region, where point and mark delimit the lines
to be affected.  There are cases where marking a region is faster than
narrowing the view with new search criteria, so use whatever makes sense
at the moment.

Remember the governing principle of Notmuch: it does not touch your
mail.  All those tags are specific to the Notmuch database (with the
exception of some basic tags that are understood by the IMAP server and
can be optionally affected by Notmuch ([[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] has the
=synchronize_flags=true= directive).

As Notmuch is not a traditional mail client, it has neither opinions nor
capabilities on how one handles their maildir.  It does not move files
around nor does it have its own deletion and anti-spam mechanisms.  It
is up to the user to provide those.  While this may seem needlessly
limited at first, it is consistent with the precise function that
Notmuch performs in the broader email toolkit.  To actually delete mail,
we can tag it accordingly (e.g. "del") and then run this command either
manually or from a script with some cron job or systemd timer:

#+begin_example
notmuch search --output=files --format=text0 tag:del | xargs -r0 rm
#+end_example

I actually prefer the manual method: mark items with =+del= and perform
their removal from the disk whenever it is expedient.  This has the
upside of offering me the chance to review the messages, in case I have
mislabelled some item: I have deleted legitimate mail before, so it is
not a bad idea to be extra careful.

I have no pressing need to define commands for moving my mail files
between different directories: I did not do that even while I was using
Gnus.  Though I might eventually do it just for the sake of
completeness.  As such, consider the following package configurations a
work-in-progress, though they already offer all I need to get things
done.

With regard to the use of tags for day-to-day usage, I like to employ
the =tag:inbox and tag:unread= search as well as =tag:inbox= for practically
everything that is unsorted or of general interest.  Then I have
specialised tags like "list" for mailing lists which should not belong
in the inbox and "todo" for messages that require some further action
(those can always be complemented by other tags for greater precision
such as =+list +emacs=).  To keep things in check, a "post-new" script
outside the Emacs setup performs initial tagging on new mail.  For
example, my sent messages are marked as =-unread= while new mailing list
traffic goes to its right place with tags like =-inbox +list= (refer to
the sections on [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] and [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).  Those that
I manually mark as =+todo= can optionally be combined with =org-capture= to
record a task that may appear in the Org agenda: call the =org-capture=
command while viewing such a message and Org will create a direct link
back to it: the glue code is found in [[#h:a7580136-cf32-44e8-81f6-590dbdd7f8f9][the section on ol-notmuch.el]] while
my =org-capture-templates= and their =org-capture-templates-contexts= are
defined in [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]]).

Unlike most Emacs packages, I install =notmuch= from my distro's repos.
This is because (i) the CLI program is independent of Emacs, and (ii)
=notmuch.el= is bundled up together with the command-line tool because the
two are developed by the same group of people.  All good!  There is also
this note in =M-x find-library RET notmuch RET=:

#+begin_quote
Note for MELPA users (and others tracking the development version
of notmuch-emacs):

This emacs package needs a fairly closely matched version of the
notmuch program. If you use the MELPA version of notmuch.el (as
opposed to MELPA stable), you should be prepared to track the
master development branch (i.e. build from git) for the notmuch
program as well. Upgrading notmuch-emacs too far beyond the notmuch
program can CAUSE YOUR EMAIL TO STOP WORKING.

TL;DR: notmuch-emacs from MELPA and notmuch from distro packages is
NOT SUPPORTED.
#+end_quote

Finally, my =prot-notmuch.el= contains various commands and some minor
stylistic extras including a mode line indicator that shows a count of
all items matching the search terms =tag:unread and tag:inbox= (can be
configured by the variable =prot-notmuch-mode-line-search-args=).

#+begin_src emacs-lisp :tangle no
;;; Notmuch (mail indexer and mail user agent (MUA))
;; I install notmuch from the distro's repos because the CLI program is
;; not dependent on Emacs.  Though the package also includes notmuch.el
;; which is what we use here (they are maintained by the same people).
(add-to-list 'load-path "/usr/share/emacs/site-lisp/")
(prot-emacs-builtin-package 'notmuch

;;; Account settings
  (setq notmuch-identities
        (let ((identities))
          (dolist (m `(,(prot-mail-auth-get-field "prv" :user)
                       ,(prot-mail-auth-get-field "inf" :user)
                       ,(prot-mail-auth-get-field "pub" :user)))
            (push (format "%s <%s>" user-full-name m) identities))
          identities))
  (setq notmuch-fcc-dirs
        `((,(prot-mail-auth-get-field "prv" :user) . "prv/Sent")
          (,(prot-mail-auth-get-field "inf" :user) . "inf/Sent")
          (,(prot-mail-auth-get-field "pub" :user) . "pub/Sent")))

;;; General UI
  (setq notmuch-show-logo nil)
  (setq notmuch-column-control t)
  (setq notmuch-hello-auto-refresh t)
  (setq notmuch-hello-recent-searches-max 20)
  (setq notmuch-hello-thousands-separator "")
  ;; ;; See my variant of it in `prot-notmuch' below.
  ;; (setq notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (setq notmuch-show-all-tags-list nil)

;;; Search
  (setq notmuch-search-oldest-first nil)
  (setq notmuch-search-result-format
        '(("date" . "%12s  ")
          ("count" . "%-7s  ")
          ("authors" . "%-20s  ")
          ("subject" . "%-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-tree-result-format
        '(("date" . "%12s  ")
          ("authors" . "%-20s  ")
          ((("tree" . "%s")
            ("subject" . "%s"))
           . " %-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-search-line-faces
        '(("unread" . notmuch-search-unread-face)
          ("flag" . notmuch-search-flagged-face)))
  (setq notmuch-show-empty-saved-searches t)
  (setq notmuch-saved-searches
        `(( :name "inbox"
            :query "tag:inbox"
            :sort-order newest-first
            :key ,(kbd "i"))
          ( :name "unread (inbox)"
            :query "tag:unread and tag:inbox"
            :sort-order newest-first
            :key ,(kbd "u"))
          ( :name "unread all"
            :query "tag:unread not tag:archived"
            :sort-order newest-first
            :key ,(kbd "U"))
          ( :name "references"
            :query "tag:ref not tag:archived"
            :sort-order newest-first
            :key ,(kbd "r"))
          ( :name "todo"
            :query "tag:todo not tag:archived"
            :sort-order newest-first
            :key ,(kbd "t"))
          ( :name "mailing lists"
            :query "tag:list not tag:archived"
            :sort-order newest-first
            :key ,(kbd "m"))
          ;; Emacs
          ( :name "emacs-devel"
            :query "(from:emacs-devel@gnu.org or to:emacs-devel@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e d"))
          ( :name "emacs-orgmode"
            :query "(from:emacs-orgmode@gnu.org or to:emacs-orgmode@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e o"))
          ( :name "emacs-bugs"
            :query "'to:\"/*@debbugs.gnu.org*/\"' not tag:archived"
            :sort-order newest-first :key ,(kbd "e b"))
          ( :name "emacs-humanities"
            :query "(from:emacs-humanities@gnu.org or to:emacs-humanities@gnu.org) not tag:archived"
            :sort-order newest-first :key ,(kbd "e h"))
          ( :name "emacs-elpher"
            :query "(from:~michel-slm/elpher@lists.sr.ht or to:~michel-slm/elpher@lists.sr.ht) not tag:archived"
            :sort-order newest-first :key ,(kbd "e e"))
          ;; CLI tools
          ( :name "notmuch"
            :query "(from:notmuch@notmuchmail.org or to:notmuch@notmuchmail.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "cn"))))

;;; Tags
  (setq notmuch-archive-tags '("-inbox" "+archived"))
  (setq notmuch-message-replied-tags '("+replied"))
  (setq notmuch-message-forwarded-tags '("+forwarded"))
  (setq notmuch-show-mark-read-tags '("-unread"))
  (setq notmuch-draft-tags '("+draft"))
  (setq notmuch-draft-folder "drafts")
  (setq notmuch-draft-save-plaintext 'ask)
  ;; ;; NOTE 2021-06-18: See an updated version in the `prot-notmuch'
  ;; ;; section below.
  ;; (setq notmuch-tagging-keys
  ;;       `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
  ;;         (,(kbd "c") ("+archived" "-inbox" "-list" "-todo" "-ref" "-unread") "Complete and archive")
  ;;         (,(kbd "d") ("+del" "-inbox" "-archived" "-unread") "Mark for deletion")
  ;;         (,(kbd "f") ("+flag" "-unread") "Flag as important")
  ;;         ;; (,(kbd "r") notmuch-show-mark-read-tags "Mark as read")
  ;;         (,(kbd "r") ("+ref" "-unread") "Reference for the future")
  ;;         (,(kbd "s") ("+spam" "+del" "-inbox" "-unread") "Mark as spam")
  ;;         (,(kbd "t") ("+todo" "-unread") "To-do")
  ;;         (,(kbd "u") ("+unread") "Mark as unread")))
  (setq notmuch-tag-formats
        '(("unread" (propertize tag 'face 'notmuch-tag-unread))
          ("flag" (propertize tag 'face 'notmuch-tag-flagged))))
  (setq notmuch-tag-deleted-formats
        '(("unread" (notmuch-apply-face bare-tag `notmuch-tag-deleted))
          (".*" (notmuch-apply-face tag `notmuch-tag-deleted))))

;;; Email composition
  (setq notmuch-mua-compose-in 'current-window)
  (setq notmuch-mua-hidden-headers nil) ; TODO 2021-05-12: Review hidden headers
  (setq notmuch-address-command nil)    ; FIXME 2021-05-13: Make it work with EBDB
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-mua-cite-function 'message-cite-original-without-signature)
  (setq notmuch-mua-reply-insert-header-p-function 'notmuch-show-reply-insert-header-p-never)
  (setq notmuch-mua-user-agent-function #'notmuch-mua-user-agent-full)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-crypto-process-mime t)
  (setq notmuch-crypto-get-keys-asynchronously t)
  (setq notmuch-mua-attachment-regexp   ; see `notmuch-mua-send-hook'
        (concat "\\b\\(attache\?ment\\|attached\\|attach\\|"
                "pi[èe]ce\s+jointe?\\|"
                "συνημμ[εέ]νο\\|επισυν[αά]πτω\\)\\b"))

;;; Reading messages
  (setq notmuch-show-relative-dates t)
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-show-indent-messages-width 0)
  (setq notmuch-show-indent-multipart nil)
  (setq notmuch-show-part-button-default-action 'notmuch-show-save-part)
  (setq notmuch-show-text/html-blocked-images ".") ; block everything
  (setq notmuch-wash-citation-lines-prefix 6)
  (setq notmuch-wash-citation-lines-suffix 6)
  (setq notmuch-wash-wrap-lines-length 100)
  (setq notmuch-unthreaded-show-out nil)
  (setq notmuch-message-headers '("To" "Cc" "Subject" "Date"))
  (setq notmuch-message-headers-visible t)

;;; Hooks and key bindings
  (add-hook 'notmuch-mua-send-hook #'notmuch-mua-attachment-check)
  (remove-hook 'notmuch-show-hook #'notmuch-show-turn-on-visual-line-mode)
  (add-hook 'notmuch-show-hook (lambda () (setq-local header-line-format nil)))

  (let ((map global-map))
    (define-key map (kbd "C-c m") #'notmuch)
    (define-key map (kbd "C-x m") #'notmuch-mua-new-mail)) ; override `compose-mail'
  (define-key notmuch-search-mode-map (kbd "/") #'notmuch-search-filter) ; alias for l
  (define-key notmuch-hello-mode-map (kbd "C-<tab>") nil))

(prot-emacs-builtin-package 'prot-notmuch
  ;; Those are for the actions that are available after pressing 'k'
  ;; (`notmuch-tag-jump').  For direct actions, refer to the key
  ;; bindings below.
  (setq notmuch-tagging-keys
        `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
          (,(kbd "c") prot-notmuch-mark-complete-tags "Complete and archive")
          (,(kbd "d") prot-notmuch-mark-delete-tags "Mark for deletion")
          (,(kbd "f") prot-notmuch-mark-flag-tags "Flag as important")
          (,(kbd "s") prot-notmuch-mark-spam-tags "Mark as spam")
          (,(kbd "t") prot-notmuch-mark-todo-tags "To-do")
          (,(kbd "x") prot-notmuch-mark-reference-tags "Reference for the future")
          (,(kbd "r") ("-unread") "Mark as read")
          (,(kbd "u") ("+unread") "Mark as unread")))

  (setq prot-notmuch-search-field-width 100)
  (setq notmuch-hello-sections '(prot-notmuch-hello-insert-saved-searches
                                 ;; prot-notmuch-hello-insert-recent-searches
                                 ))

  (add-to-list 'notmuch-tag-formats
               '("encrypted" (propertize tag 'face 'prot-notmuch-encrypted-tag)))
  (add-to-list 'notmuch-tag-formats
               '("sent" (propertize tag 'face 'prot-notmuch-sent-tag)))
  (add-to-list 'notmuch-tag-formats
               '("ref" (propertize tag 'face 'prot-notmuch-ref-tag)))
  (add-to-list 'notmuch-tag-formats
               '("todo" (propertize tag 'face 'prot-notmuch-todo-tag)))
  (add-to-list 'notmuch-tag-formats
               '("spam" (propertize tag 'face 'prot-notmuch-spam-tag)))

  ;; NOTE 2021-05-14: I have an alternative method of finding new mail
  ;; in a maildir tree by using the find command.  It is somewhat
  ;; simplistic, though it worked just fine: see prot-mail.el.  I prefer
  ;; this implementation instead, as it leverages notmuch and so I can
  ;; pass arbitrary search terms to it.
  (setq prot-notmuch-mode-line-count-args "tag:unread and tag:inbox")
  (setq prot-notmuch-mode-line-indicator-commands
        '(notmuch notmuch-refresh-this-buffer))
  ;; Mode line indicator with the number of new mails.
  (prot-notmuch-mail-indicator 1)

  (add-hook 'notmuch-hello-mode-hook #'prot-notmuch-widget-field-face-remap)

  (let ((map notmuch-search-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-search-archive-thread)
    (define-key map (kbd "D") #'prot-notmuch-search-delete-thread)
    (define-key map (kbd "T") #'prot-notmuch-search-todo-thread)
    (define-key map (kbd "X") #'prot-notmuch-search-reference-thread)
    (define-key map (kbd "C") #'prot-notmuch-search-complete-thread)
    (define-key map (kbd "S") #'prot-notmuch-search-spam-thread)
    (define-key map (kbd "g") #'prot-notmuch-refresh-buffer))
  (let ((map notmuch-show-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-show-archive-message-then-next-or-next-thread)
    (define-key map (kbd "D") #'prot-notmuch-show-delete-message)
    (define-key map (kbd "T") #'prot-notmuch-show-todo-message)
    (define-key map (kbd "X") #'prot-notmuch-show-reference-message)
    (define-key map (kbd "C") #'prot-notmuch-show-complete-message)
    (define-key map (kbd "S") #'prot-notmuch-show-spam-message)))
#+end_src


**** .notmuch-config
:PROPERTIES:
:CUSTOM_ID: h:79803e19-1150-49a6-a3df-1cffe3d0cbc5
:END:

What follows is my =~/.notmuch-config=.  The =tags=new= configuration is
what enables the use of initial tagging, as explained in the upstream
documentation (basically you want to tag some mail right after a
=notmuch new= such as, for example, to remove mailist list messages from
the inbox---see [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].

#+include: ../../notmuch/.notmuch-config src conf :tangle no

**** notmuch post-new rules
:PROPERTIES:
:CUSTOM_ID: h:70d60d41-cb63-4950-bbd9-9157c4d186dc
:END:

And here are the rules that apply after running =notmuch new=.  Its file
system path is =$maildir/.notmuch/hooks/post-new= where =$maildir= is the
database path specified in =.notmuch-config= (see [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]]).
Remember that this file needs to be an executable.

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].

#+include: ../../notmuch/.mail/.notmuch/hooks/post-new src conf :tangle no

**** Org+Notmuch integration (ol-notmuch.el)
:PROPERTIES:
:CUSTOM_ID: h:a7580136-cf32-44e8-81f6-590dbdd7f8f9
:END:

The =ol-notmuch.el= is part of the =org-contrib= package which can be found
in the NonGNU ELPA (that archive is configured out-of-the-box for
Emacs28, same as with GNU ELPA).  However, that package contains
approximately one zillion things I do not need, so I prefer to copy the
file here and handle it on its own.

#+begin_src emacs-lisp :tangle no
;;; ol-notmuch.el --- Links to notmuch messages

;; Copyright (C) 2010-2014  Matthieu Lemerre

;; Author: Matthieu Lemerre <racin@free.fr>
;; Keywords: outlines, hypermedia, calendar, wp
;; Homepage: https://orgmode.org

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This file implements links to notmuch messages and "searches". A
;; search is a query to be performed by notmuch; it is the equivalent
;; to folders in other mail clients. Similarly, mails are referred to
;; by a query, so both a link can refer to several mails.

;; Links have one the following form
;; notmuch:<search terms>
;; notmuch-search:<search terms>.

;; The first form open the queries in notmuch-show mode, whereas the
;; second link open it in notmuch-search mode. Note that queries are
;; performed at the time the link is opened, and the result may be
;; different from when the link was stored.

;;; Code:

(require 'ol)

;; customisable notmuch open functions
(defcustom org-notmuch-open-function
  'org-notmuch-follow-link
  "Function used to follow notmuch links.

Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(defcustom org-notmuch-search-open-function
  'org-notmuch-search-follow-link
  "Function used to follow notmuch-search links.
Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(make-obsolete-variable 'org-notmuch-search-open-function nil "9.3")



;; Install the link type
(org-link-set-parameters "notmuch"
			 :follow #'org-notmuch-open
			 :store #'org-notmuch-store-link)

(defun org-notmuch-store-link ()
  "Store a link to a notmuch search or message."
  (when (memq major-mode '(notmuch-show-mode notmuch-tree-mode))
    (let* ((message-id (notmuch-show-get-message-id t))
	   (subject (notmuch-show-get-subject))
	   (to (notmuch-show-get-to))
	   (from (notmuch-show-get-from))
	   (date (org-trim (notmuch-show-get-date)))
	   desc link)
      (org-link-store-props :type "notmuch" :from from :to to :date date
       			    :subject subject :message-id message-id)
      (setq desc (org-link-email-description))
      (setq link (concat "notmuch:id:" message-id))
      (org-link-add-props :link link :description desc)
      link)))

(defun org-notmuch-open (path _)
  "Follow a notmuch message link specified by PATH."
  (funcall org-notmuch-open-function path))

(defun org-notmuch-follow-link (search)
  "Follow a notmuch link to SEARCH.

Can link to more than one message, if so all matching messages are shown."
  (require 'notmuch)
  (notmuch-show search))



(org-link-set-parameters "notmuch-search"
			 :follow #'org-notmuch-search-open
			 :store #'org-notmuch-search-store-link)

(defun org-notmuch-search-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-search-mode)
    (let ((link (concat "notmuch-search:" notmuch-search-query-string))
	  (desc (concat "Notmuch search: " notmuch-search-query-string)))
      (org-link-store-props :type "notmuch-search"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-search-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-search-follow-link path))

(defun org-notmuch-search-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-search mode."
  (require 'notmuch)
  (notmuch-search search))



(org-link-set-parameters "notmuch-tree"
			 :follow #'org-notmuch-tree-open
			 :store #'org-notmuch-tree-store-link)

(defun org-notmuch-tree-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-tree-mode)
    (let ((link (concat "notmuch-tree:" (notmuch-tree-get-query)))
	  (desc (concat "Notmuch tree: " (notmuch-tree-get-query))))
      (org-link-store-props :type "notmuch-tree"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-tree-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-tree-follow-link path))

(defun org-notmuch-tree-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-tree mode."
  (require 'notmuch)
  (notmuch-tree search))

(provide 'ol-notmuch)

;;; ol-notmuch.el ends here
#+end_src


#+begin_src emacs-lisp :tangle no
(require 'ol-notmuch)
#+end_src

*** Sending email (SMTP)
:PROPERTIES:
:CUSTOM_ID: h:2d793cf8-83f5-4830-b73d-78385d9b96dd
:END:

These are the base settings for the SMTP functionality.  Passwords and
other critical information are stored in =~/.authinfo.gpg=, as
demonstrated in [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][the base email settings]].  What follows is just a
mirroring of the contents of that file.

#+begin_src emacs-lisp :tangle no
;;; Sending email (SMTP)
(prot-emacs-builtin-package 'smtpmail
  (setq smtpmail-default-smtp-server "mail.gandi.net")
  (setq smtpmail-smtp-server "mail.gandi.net")
  (setq smtpmail-stream-type 'ssl)
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-queue-mail nil))

(prot-emacs-builtin-package 'sendmail
  (setq send-mail-function 'smtpmail-send-it))
#+end_src

*** EBDB (mail contacts)
:PROPERTIES:
:CUSTOM_ID: h:d386e14b-dcf7-46a2-851f-867cd84c6cae
:END:

EBDB is a contacts' manager by Eric Abrahamsen that integrates with Mail
User Agents inside of Emacs.  I used to use it as part of my Gnus setup
but as of 2021-05-13 my plan is to make it work with Notmuch as I have
switched to it ([[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]]).

What I need from it is to perform the task of storing every address that
I exchange messages with.  When I send someone a message, their email
should be saved automatically.  While if I merely read an item, say, on
the emacs-devel mailing list, I prefer to only update existing records
else do nothing.

One could set everything to automatically update in all contexts, though
I find that such an approach will either create too many false positives
that will distract you from the immediate task of handling your
correspondence, or they will simply contribute to the creation of a
database that contains a lot of largely useless information.  Save only
what matters---ignore the rest.

While "ignore the rest" can mean to simply pass it over in silence, EBBD
actually provides a mechanism to permanently exclude individual
addresses or domain names from ever being recorded.  Those are stored in
the file specified by the variable =ebdb-permanent-ignores-file=: you can
edit it manually, adding one address per line with no attached name or
angled brackets, or a domain name that starts with the =@= sign.  No
regexp notation is accepted.  For example:

#+begin_example
@debbugs.gnu.org
help-debbugs@gnu.org
@reply.github.com
#+end_example

EBDB binds some common commands to the semicolon (=;=) prefix key inside
Gnus' summary and article buffers.  For example, =; := will update all
records that are found in the message at point, while =; s= will scan
(called "snarf") the body of the message for names and email addresses
in an attempt to create records of any findings.  As always, append =C-h=
to the prefix key to get help about all key bindings that complete the
sequence and what commands they call.

The =ebdb-mua-pop-up= controls whether a window with relevant contact
information should be displayed automatically.  Perhaps it is good to
have some extra feedback on what we know or what has been collected thus
far, though I prefer not to see anything by default (it can still be
displayed with the various commands under the =;= prefix key).  Its
informative nature aside, this window can be used to further edit
entries.  With point over a field, type =e= to edit it or =C-k= to remove it
(I bind =D= to delete).  The latter command behaves differently when the
point is before the record's main field, typically the name, where it
will prompt to delete the whole entry altogether.  For more about that
specific major mode and its associated buffers, use =C-h m= (which invokes
=describe-mode=).

To view all of your contacts, or just those matching a pattern (or
string), use =M-x ebdb=, which will prompt for a search.  Input an empty
query if you prefer to view everything in the database.  While in the
=*EBDB*= buffer, you gain access to commands for operating on the records.
Same principle as with the aforementioned =ebdb-mua-pop-up=: =c= to create a
new entry, =e= to edit the field at point, =i= to insert a new datum to the
current record, =C-k= (or my preferred =D=) to delete...  Again, =C-h m= is
your friend.

Apart from gathering data and operating on it, EBDB can auto-complete
email addresses in the message composition buffer: hit TAB in a "To:",
"Cc:" or equivalent header and then use the completion framework's
interaction model to retrieve what you want.

Finally, note that this package is fairly comprehensive as it defines
lots of options and commands: make sure to read its official manual.

#+begin_src emacs-lisp :tangle no
;;; EBDB (mail contacts)
(prot-emacs-elpa-package 'ebdb
  (require 'ebdb-message)
  (require 'ebdb-notmuch) ; FIXME 2021-05-13: does not activate the corfu-mode UI
  (setq ebdb-sources (locate-user-emacs-file "ebdb"))
  (setq ebdb-permanent-ignores-file (locate-user-emacs-file "ebdb-permanent-ignores"))

  (setq ebdb-mua-pop-up nil)
  (setq ebdb-default-window-size 0.25)
  (setq ebdb-mua-default-formatter ebdb-default-multiline-formatter)

  (setq ebdb-mua-auto-update-p 'existing)
  (setq ebdb-mua-reader-update-p 'existing)
  (setq ebdb-mua-sender-update-p 'create)
  (setq ebdb-message-auto-update-p 'create)

  (setq ebdb-message-try-all-headers t)
  (setq ebdb-message-headers
        '((sender "From" "Resent-From" "Reply-To" "Sender")
          (recipients "Resent-To" "Resent-Cc" "Resent-CC" "To" "Cc" "CC" "Bcc" "BCC")))
  (setq ebdb-message-all-addresses t)

  (setq ebdb-complete-mail 'capf)
  (setq ebdb-mail-avoid-redundancy t)
  (setq ebdb-completion-display-record nil)
  (setq ebdb-complete-mail-allow-cycling nil)

  (setq ebdb-record-self "ace719a4-61f8-4bee-a1ca-2f07e2292305")
  (setq ebdb-user-name-address-re 'self) ; match the above
  (setq ebdb-save-on-exit t)

  (with-eval-after-load 'prot-mail ; check my `prot-mail.el'
    (add-hook 'message-setup-hook #'prot-mail-ebdb-message-setup))

  (let ((map ebdb-mode-map))
    (define-key map (kbd "D") #'ebdb-delete-field-or-record)
    (define-key map (kbd "M") #'ebdb-mail) ; disables `ebdb-mail-each'
    (define-key map (kbd "m") #'ebdb-toggle-record-mark)
    (define-key map (kbd "t") #'ebdb-toggle-all-record-marks)
    (define-key map (kbd "T") #'ebdb-toggle-records-format) ; disables `ebdb-toggle-all-records-format'
    (define-key map (kbd "U") #'ebdb-unmark-all-records)))
#+end_src

** Rcirc (IRC client)
:PROPERTIES:
:CUSTOM_ID: h:4d2f596a-6fc5-4179-a361-c29f77a5ba11
:END:

The first time I used IRC in earnest was at EmacsConf 2021.  The event
lasted two days (I also delivered [[https://emacsconf.org/2021/talks/freedom][a presentation]]).  For the first day I
tried the =erc= package that is built into Emacs, while for the second I
opted for =rcirc=, another built-in option.

Overall, Rcirc feels more straightforward to me as a regular user.
Whereas ERC seems to have too many options and a larger code base for
technicalities I do not need to know about for the purposes of my casual
usage of IRC.

To get started, run =M-x irc= and confirm your choice at the prompts.  The
defaults for the server and the connection port should be fine.  In my
case, those steps are skipped because of the values specified in the
=rcirc-server-alist=.  Note the presence of =prot-mail-auth-get-field=.
This is a function that queries my =~/.authinfo.gpg= file to retrieve
encrypted information stored there (see [[#h:8d0bd754-8a31-431b-b112-f541cc0144ac][Sample of authinfo.gpg]]).  I use
this method to (i) automate the process of logging in while (ii) not
divulging sensitive data (also see the mega-section on [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]]).

IRC is fairly easy to use: you just type your message at the command
prompt and everyone in the channel can see it.  Some things I learnt:

+ Join a channel like =#emacs= by typing at the prompt =/join #emacs=.
+ Leave a channel with =/leave #vim= 😉.
+ To quit IRC do =/quit=, or optionally =/quit Going for a brisk walk=.
+ You can mention another user in the channel just by including their
  nick in your message, like =Hello protesilaos=.  When replying to
  someone, do it like this =protesilaos: My reply here=.
+ Start a private channel with, say, =protesilaos= by running the command
  =/msg protesilaos My message here=.  Then use the channel like any
  other.

There probably are more commands and other tricks we can employ.  I
expect to familiarise myself with them over time.

The following configuration is straightforward and the doc string of
every variable is clear on what it is supposed to do.

#+begin_src emacs-lisp :tangle no
(prot-emacs-builtin-package 'rcirc
  (setq rcirc-server-alist
        `(("irc.libera.chat"
           :channels ("#emacs" "#org-mode" "#rcirc")
           :port 6697 :encryption tls
           :password ,(prot-mail-auth-get-field "libera" :secret))))

  (setq rcirc-prompt "%t> ") ; Read the docs or use (customize-set-variable 'rcirc-prompt "%t> ")

  (setq rcirc-default-nick "protesilaos"
        rcirc-default-user-name rcirc-default-nick
        rcirc-default-full-name "Protesilaos Stavrou")

  ;; ;; NOTE 2021-11-28: demo from the days of EmacsConf 2021.  I don't
  ;; ;; actually need this.
  ;; (setq rcirc-bright-nicks '("bandali" "sachac" "zaeph"))

  ;; NOTE 2021-11-28: Is there a canonical way to disable this?
  (setq rcirc-timeout-seconds most-positive-fixnum)

  (rcirc-track-minor-mode 1)

  (define-key global-map (kbd "C-c i") #'irc))
#+end_src

** Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el
:PROPERTIES:
:CUSTOM_ID: h:0cd8ddab-55d1-40df-b3db-1234850792ba
:END:

This is a standalone feed reader by Christopher Wellons that comes with
good defaults and is very well designed overall.  It treats the stream
of updates as a flat list that can be narrowed incrementally using an
efficient tagging system.

In terms of feed format specifications, i.e. Atom vs RSS, things should
just work without any kind of configuration from your side (a huge plus
compared to, say, Gnus' =nnrss= backend that only supports the latter).

Elfeed stores feed sources in a single list that associates a valid URL
to one or more tags.  These are then written to a database.  The Elisp
part users should care about looks like this:

#+begin_example
(setq elfeed-feeds
      '(("https://www.archlinux.org/feeds/news/" linux distro)
        ("https://planet.emacslife.com/atom.xml" emacs community)
        ("https://www.ecb.europa.eu/rss/press.html" economics eu)
        ("http://feed.pippa.io/public/shows/teamhuman" podcast culture)
        ("https://www.youtube.com/feeds/videos.xml?channel_id=UC0uTPqBCFIpZxlz_Lv1tk_g" personal video)
        ("https://protesilaos.com/codelog.xml" personal)))
#+end_example

I keep the actual list in a GPG-encrypted file (defined in the variable
=prot-elfeed-feeds-file= which is part of my =prot-elfeed.el= library that
is reproduced after the following package configurations).  Emacs can
transparently decrypt and read gpg-protected files, making it a great
way to safely store sensitive data while still keeping everything
perfectly functional.

A good tagging system for your feeds will offer a strong foundation for
catching up with the news.  I generally use 2-3 tags per feed, while I
make sure that conceptually similar items will share at least one tag.
My tags are not particularly sophisticated, though they are not random
either: for example, I have a particular "EU" entry for all
institutions, bodies, agencies, etc. of the European Union and then I
have other more general ones, such as "politics" and "economics".  So,
in this case, the European Central Bank gets tagged with =eu=, =economics=,
while the European Parliament is =eu=, =politics=.

The user interface consists of two distinct types of buffers:

1. The =*elfeed-search*= buffer that holds the list with all the news
   items.
2. The individual item entries.

By default, hitting =s= (=elfeed-search-live-filter=) in the search buffer
will place the point inside the minibuffer, where you can then edit the
applicable filters.  The [[https://github.com/skeeto/elfeed][Elfeed README]] offers a detailed explanation of
how to apply such filters.  The ones I use the most:

+ Prepend a =+= to the name of a tag to only show items that include that
  tag.  With =-= show items that do not include it.
+ Type in a regular string with the equals sign in front of it, say
  "=TITLE", to show feeds whose name contains it.

Other common cases are regular expressions and date ranges, though I
have found that I never use those.  Probably because the tagging system
is sufficiently powerful for my particular needs.

My only inconvenience with =elfeed-search-live-filter= is that it does not
support completion out-of-the-box.  Instead it expects full user input,
which ins understandable given the types of searches it can conduct.
Since I only need this facility to filter by tag, I rebind =s= to my
=prot-elfeed-search-tag-filter=.  While =S-s= (shift and s) can still be
used to access the original command, whenever we need more precise
control over the search filters.

The MPV-related functions require the external =mpv= program.  They will
play a video in a new app window at a resolution that matches the
current setup's display width or, in the case of an enclosure
(presumably a podcast), play just the audio file without popping up a
new app window.  The process runs in a dedicated buffer, so it can be
terminated by killing the buffer.  In the future I might make this
cleaner, so that it understands input from, e.g., =playerctl=, though it
is not a priority as the current simplistic design is "good enough" for
my case.

For an older, albeit still relevant, demonstration of what I have here,
watch [[https://protesilaos.com/codelog/2020-06-09-emacs-elfeed-demo/][my Elfeed video]] (2020-06-09).

As I also am a user of Bongo, and because Emacs lets one handle things
with precision, there are a few functions here that are meant to make
the Elfeed search buffer a bongo-aware media library, from where we can
enqueue online multimedia sources (video links, or podcast enclosures).
The key is to not interfere with the primary Bongo playlist and library
tandem, which is dedicated to my local music collection, but to maintain
a separate playlist which can be controlled independently.  The entirety
of my =prot-elfeed-bongo.el= is shared after =prot-elfeed.el= below the
following package configurations (for my other extensions, refer to
[[#h:758afe0d-bc7c-4afc-9c6b-b5e569901591][Bongo music or media manager (and prot-bongo.el)]]).

The placement of my custom buffers for Elfeed's multimedia output is
controlled by =display-buffer-alist= (see [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).

I benefited in this particular Elfeed+Bongo workflow from an email
exchange I had with Madhavan Krishnan: we shared code and ideas that
helped establish the modalities of interaction between Elfeed and Bongo
(this information is made public with permission).  Video demo with
older code: [[https://protesilaos.com/codelog/2020-09-11-emacs-elfeed-bongo/][Manage podcasts in Emacs with Elfeed and Bongo]] (2020-09-11).

Also see: [[#h:aa64c61e-49b5-41b0-b1fe-10bbe3be661f][Sample configuration for MPV (Elfeed+Bongo extension)]].

#+begin_src emacs-lisp :tangle no
;;; Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el
(use-package elfeed
  :config
  (setq elfeed-use-curl t)
  (setq elfeed-curl-max-connections 10)
  (setq elfeed-db-directory (concat user-emacs-directory "elfeed/"))
  (setq elfeed-enclosure-default-dir "~/Downloads/")
  (setq elfeed-search-filter "@4-months-ago +unread")
  (setq elfeed-sort-order 'descending)
  (setq elfeed-search-clipboard-type 'CLIPBOARD)
  (setq elfeed-search-title-max-width 100)
  (setq elfeed-search-title-min-width 30)
  (setq elfeed-search-trailing-width 25)
  (setq elfeed-show-truncate-long-urls t)
  (setq elfeed-show-unique-buffers t)
  (setq elfeed-search-date-format '("%F %R" 16 :left))

  ;; Make sure to also check the section on shr and eww for how I handle
  ;; `shr-width' there.
  (add-hook 'elfeed-show-mode-hook
            (lambda () (setq-local shr-width (current-fill-column))))

  (use-package prot-elfeed-bongo)

  (define-key global-map (kbd "C-c e") #'elfeed)
  (let ((map elfeed-search-mode-map))
    (define-key map (kbd "w") #'elfeed-search-yank)
    (define-key map (kbd "g") #'elfeed-update)
    (define-key map (kbd "G") #'elfeed-search-update--force)
    (define-key map (kbd "b") #'prot-elfeed-bongo-insert-item)
    (define-key map (kbd "h") #'prot-elfeed-bongo-switch-to-playlist)) ; "hop" mnemonic
  (let ((map elfeed-show-mode-map))
    (define-key map (kbd "w") #'elfeed-show-yank)
    (define-key map (kbd "b") #'prot-elfeed-bongo-insert-item)))

(with-eval-after-load 'elfeed
  (prot-emacs-builtin-package 'prot-elfeed
    (setq prot-elfeed-tag-faces t)
    (prot-elfeed-fontify-tags)
    (add-hook 'elfeed-search-mode-hook #'prot-elfeed-load-feeds)

    (let ((map elfeed-search-mode-map))
      (define-key map (kbd "s") #'prot-elfeed-search-tag-filter)
      (define-key map (kbd "o") #'prot-elfeed-search-open-other-window)
      (define-key map (kbd "q") #'prot-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "v") #'prot-elfeed-mpv-dwim)
      (define-key map (kbd "+") #'prot-elfeed-toggle-tag))
    (let ((map elfeed-show-mode-map))
      (define-key map (kbd "a") #'prot-elfeed-show-archive-entry)
      (define-key map (kbd "e") #'prot-elfeed-show-eww)
      (define-key map (kbd "q") #'prot-elfeed-kill-buffer-close-window-dwim)
      (define-key map (kbd "v") #'prot-elfeed-mpv-dwim)
      (define-key map (kbd "+") #'prot-elfeed-toggle-tag))))
#+end_src

** Proced (process monitor, similar to `top')
:PROPERTIES:
:CUSTOM_ID: h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325
:END:

This is a built-in tool that allows you to monitor running processes
and act on them accordingly.  These are the basic settings I have
right now: it works fine.

My =prot-proced.el= (reproduced after the package configurations) simply
adds some extra colours to the otherwise plain buffer.  Makes it easier
to keep track of the information on display.

#+begin_src emacs-lisp
;;; Proced (process monitor, similar to `top')
(use-package proced
  :config
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 5)
  (setq proced-descend t)
  (setq proced-filter 'user))

#+end_src

#+RESULTS:
: t

** Pass interface (password-store)
:PROPERTIES:
:CUSTOM_ID: h:1d2bf0d0-4806-4e04-a320-7d6538ef2e78
:END:

The external =pass= program, aka "password-store", is a password manager
that uses GPG and standard UNIX tools to handle passwords.  Encrypted
files are stored in a plain directory structure.  Very simple, very
nice: now all data is available with a variety of interfaces, such as
standard CLI, a =dmenu= interface, a graphical front-end like =qtpass=, etc.

The package below provides an Emacs interface to some of the most common
actions, in the form of a list of candidates that can be narrowed down
using completion methods (study [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).  I use
it to quickly store a password to the kill ring.

#+begin_src emacs-lisp :tangle no
;;; Pass interface (password-store)
(use-package password-store
  :config
  (setq password-store-time-before-clipboard-restore 30)
  ;; Mnemonic is the root of the "code" word (κώδικας).  But also to add
  ;; the password to the kill-ring.  Other options are already taken.
  (define-key global-map (kbd "C-c k") #'password-store-copy))
#+end_src

#+RESULTS:
: t

And this one adds a major mode for browsing the =pass= keychain.  Call
it with =M-x pass=.  There is a helpful section at the top with key
bindings and their functions.

#+begin_src emacs-lisp :tangle no
(use-package pass)
#+end_src

** COMMENT Extensions for PDFs (pdf-tools)
:PROPERTIES:
:CUSTOM_ID: h:02894c1d-a739-48e7-9116-3c27a6505485
:END:

The =pdf-tools= package builds on top of the external libraries, =poppler=
and =imagemagick= (if Emacs is compiled with support for it) to deliver a
series of minor modes for reading and interacting with PDF files from
inside of Emacs.  As it depends on those external files, it requires
extra steps to make it work properly.  Those are documented at length in
its README and vary depending on your operating system.

All you need to start reading PDFs is to put the =pdf-loader-install=
function in your configurations, which loads the tools once you open an
appropriate file, such as through =dired= or with =find-file=.  Once inside
the resulting buffer, do =C-h m= (=describe-mode=) to learn about the key
bindings and the commands they call.  The basics:

| Key   | Effect            |
|-------+-------------------|
| +     | Enlarge (zoom in) |
| -     | Shrink (zoom out) |
| 0     | Reset zoom        |
| C-n   | Next line         |
| C-p   | Previous line     |
| SPC   | Scroll down       |
| S-SPC | Scroll up         |

To determine which minor modes out of the entire suite are activated,
you need to configure the variable =pdf-tools-enabled-modes=.  I reduce it
only a subset of what is available by default because I do not need all
the extras.  That granted, there are at least two minor modes that users
may find helpful: =pdf-annot-minor-mode= which provides annotation
capabilities and =pdf-sync-minor-mode= which syncs the PDF with its
corresponding TeX file when you are running some setup that compiles the
latter to the former.

The value proposition of =pdf-tools= is that it works with =isearch= and
=occur= so you can easily (i) search through the file and (ii) produce a
buffer of locations with matching queries.  As is the norm with
=pdf-tools=, those facilities are implemented as minor modes:
=pdf-isearch-minor-mode=, =pdf-occur-global-minor-mode= (this also works
with =ibuffer= and =dired=).

Another helpful integration is with Emacs' =outline-mode= and =imenu= by
means of =pdf-outline-minor-mode=.  Simply hit =o= while viewing a PDF to
produce an outline of the document and then, optionally, =M-x imenu= to
navigate it using minibuffer completion (though for the latter task you
may prefer something like =consult-outline=, which is part of the Consult
package: [[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).

Finally, I have some tweaks to change the backdrop of the buffer so that
it is distinct from the page's background while using my light Modus
Operandi theme ([[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).  Plus, I
make it automatically adapt to the =modus-themes-toggle= command, so that
the PDF switches to a dark theme when it has to.  Those are documented
in the manual of the themes.  If you are using them, evaluate this form:
=(info "(modus-themes) Backdrop for pdf-tools (DIY)")=.

#+begin_src emacs-lisp
;;; Extensions for PDFs (pdf-tools)
(use-package pdf-tools
  :config
  (setq pdf-tools-enabled-modes         ; simplified from the defaults
        '(pdf-history-minor-mode
          pdf-isearch-minor-mode
          pdf-links-minor-mode
          pdf-outline-minor-mode
          pdf-misc-size-indication-minor-mode
          pdf-occur-global-minor-mode))
  (setq pdf-view-display-size 'fit-height)
  (setq pdf-view-continuous t)
  (setq pdf-view-use-dedicated-register nil)
  (setq pdf-view-max-image-width 1080)
  (setq pdf-outline-imenu-use-flat-menus t)

  (pdf-loader-install)

  ;; Those functions and hooks are adapted from the manual of my
  ;; modus-themes.  The idea is to (i) add a backdrop that is distinct
  ;; from the background of the PDF's page and (ii) make pdf-tools adapt
  ;; to theme switching via, e.g., `modus-themes-toggle'.
  (defun prot/pdf-tools-backdrop ()
    (face-remap-add-relative
     'default
     `(:background ,(modus-themes-color 'bg-alt))))

  (defun prot/pdf-tools-midnight-mode-toggle ()
    (when (derived-mode-p 'pdf-view-mode)
      (if (eq (car custom-enabled-themes) 'modus-vivendi)
          (pdf-view-midnight-minor-mode 1)
        (pdf-view-midnight-minor-mode -1))
      (prot/pdf-tools-backdrop)))

  (add-hook 'pdf-tools-enabled-hook #'prot/pdf-tools-midnight-mode-toggle)
  (add-hook 'modus-themes-after-load-theme-hook #'prot/pdf-tools-midnight-mode-toggle))
#+end_src

#+RESULTS:
: t

** OpenStreetMap viewer (osm.el)
:PROPERTIES:
:CUSTOM_ID: h:db40bd63-fe98-42b2-a10d-83966a59be4e
:END:

This is yet another brilliant package by Daniel Mendler.  It uses Emacs'
image viewing facilities in combination with asynchronous =curl= calls
to fetch and present maps from the OpenStreetMap project.

Viewing maps is just the beginning.  It is also possible to use the
standard bookmark facility to store the coordinates of a location and
visit them on demand ([[#h:79cd6177-a81b-420f-8759-e6927b974377][Built-in bookmarking framework]]).  Or invoke the
=org-store-link= command to capture the information about the current
coordinates and produce a direct link out of them with =org-insert-link=
([[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]]).

What I like the most about =osm= is that it pushes the boundaries of
what we can do with Emacs.  It does so in a way that feels natural and
actually useful.  Well done, Daniel!

#+begin_src emacs-lisp
(use-package osm
  :config

  (let ((map global-map))
    (define-key map (kbd "C-c \" h") #'osm-home)
    (define-key map (kbd "C-c \" s") #'osm-search)
    (define-key map (kbd "C-c \" t") #'osm-server)
    (define-key map (kbd "C-c \" g") #'osm-goto)
    (define-key map (kbd "C-c \" j") #'osm-bookmark-jump))

  ;; Load Org link support
  (with-eval-after-load 'org
    (require 'osm-ol)))
#+end_src

#+RESULTS:
: t

** Selectric

Every so often, you want everyone else to /know/ that you're typing, or just to
amuse oneself. Introducing: typewriter sounds!
#+begin_src emacs-lisp :tangle packages.el
(package! selectric-mode :pin "1840de71f7414b7cd6ce425747c8e26a413233aa")
#+end_src

#+begin_src emacs-lisp
(use-package! selectic-mode
  :commands selectic-mode)
#+end_src

** Spray

Why not flash words on the screen. Why not --- hey, it could be fun.
#+begin_src emacs-lisp :tangle packages.el
(package! spray :pin "74d9dcfa2e8b38f96a43de9ab0eb13364300cb46")
#+end_src

It would be nice if Spray's default speed suited me better, and the keybindings
worked in evil mode. Let's do that and make the display slightly nicer while
we're at it.

#+begin_src emacs-lisp
(use-package! spray
  :commands spray-mode
  :config
  (setq spray-wpm 600
        spray-height 800)
  (defun spray-mode-hide-cursor ()
    "Hide or unhide the cursor as is appropriate."
    (if spray-mode
        (setq-local spray--last-evil-cursor-state evil-normal-state-cursor
                    evil-normal-state-cursor '(nil))
      (setq-local evil-normal-state-cursor spray--last-evil-cursor-state)))
  (add-hook 'spray-mode-hook #'spray-mode-hide-cursor)
  (map! :map spray-mode-map
        "<return>" #'spray-start/stop
        "f" #'spray-faster
        "s" #'spray-slower
        "t" #'spray-time
        "<right>" #'spray-forward-word
        "h" #'spray-forward-word
        "<left>" #'spray-backward-word
        "l" #'spray-backward-word
        "q" #'spray-quit))
#+end_src

** Elcord

What's even the point of using Emacs unless you're constantly telling everyone
about it?
#+begin_src emacs-lisp :tangle packages.el
(package! elcord :pin "eb4ae2e7e03a5fc26b054ba2fa9a1d308e239c76")
#+end_src

#+begin_src emacs-lisp
(use-package! elcord
  :commands elcord-mode
  :config
  (setq elcord-use-major-mode-as-main-icon t))
#+end_src

** calc
#+begin_src emacs-lisp :tangle no

;; ** CALC
;;;----------------------------------------------------------------
(use-package calc
  :bind (("C-x c" . calc)
         ("H-S-c" . calc)
         ("H-*" . calc-dispatch)
         ("C-S-e" . latex-math-from-calc))
  :config
  (defun latex-math-from-calc ()
    "Evaluate `calc' on the contents of line at point."
    (interactive)
    (let ((lang (when (member major-mode '(org-mode latex-mode))
                  'latex)))
      (cond ((region-active-p)
             (let* ((beg (region-beginning))
                    (end (region-end))
                    (string (buffer-substring-no-properties beg end)))
               (kill-region beg end)
               (insert (calc-eval `(,string calc-language ,lang
                                            calc-prefer-frac t
                                            calc-angle-mode rad)))))
            (t (let ((l (thing-at-point 'line)))
                 (end-of-line 1) (kill-line 0)
                 (insert (calc-eval `(,l
                                      calc-language ,lang
                                      calc-prefer-frac t
                                      calc-angle-mode rad)))))))))
#+end_src

#+RESULTS:
: latex-math-from-calc

** Systemd daemon
For running a systemd service for a Emacs server I have the following
#+name: emacsclient service
#+begin_src systemd :tangle no
# ~/.config/systemd/user/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

which is then enabled by
#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
 # shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

For some reason if a frame isn't opened early in the initialisation process, the
daemon doesn't seem to like opening frames later --- hence the ~&& emacsclient~
part of the =ExecStart= value.

It can now be nice to use this as a 'default app' for opening files. If we add
an appropriate desktop entry, and enable it in the desktop environment.

#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

When the daemon is running, I almost always want to do a few particular things
with it, so I may as well eat the load time at startup. We also want to keep
=mu4e= running.

It would be good to start the IRC client (=circe=) too, but that seems to have
issues when started in a non-graphical session.

Lastly, while I'm not sure quite why it happens, but after a bit it seems that
new Emacsclient frames start on the =*scratch*= buffer instead of the dashboard.
I prefer the dashboard, so let's ensure that's always switched to in new frames.
 daemon initialisation

#+begin_src emacs-lisp :tangle no
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (+mu4e-lock-add-watcher)
    (when (+mu4e-lock-available t)
      (mu4e~start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft\\|\\*stdin\\|emacs-everywhere" (buffer-name))
      (switch-to-buffer +doom-dashboard-name))))
#+end_src
* Tools
** keyboard
Sets caps to control and sets a snappy key repeat / delay.
xset r rate <delay> <rate>
#+begin_src emacs-lisp
(defun kmonad-keyboard ()
  (interactive)
  ;; (shell-command "setxkbmap -option 'ctrl:nocaps'")
  (shell-command "sudo kmonad /home/shiva/test.kbd")
  (shell-command "xset r rate 160 100"))
#+end_src

#+RESULTS:
: kmonad-keyboard

** brightness
#+begin_src emacs-lisp :tangle no
(setq my/brightness-min 1)
(setq my/brightness-max 100)
(setq my/brightness-step 5)

(defun my/get-brightness ()
  (* my/brightness-step (round (string-to-number
                                (shell-command-to-string "xbacklight -get"))
                               my/brightness-step)))

(defun my/set-brightness (level)
  (interactive "nBrightness level: ")
  (let ((safe-level
         (cond ((< level my/brightness-min) my/brightness-min)
               ((> level my/brightness-max) my/brightness-max)
               (t level))))
    (save-window-excursion
      (shell-command
       (format "xbacklight -set %s &" safe-level) nil nil))))

(defun my/brightness-step-change (delta)
  (my/set-brightness (+ delta (my/get-brightness))))

(defun my/brightness-increase ()
  (interactive)
  (my/brightness-step-change my/brightness-step))

(defun my/brightness-decrease ()
  (interactive)
  (my/brightness-step-change (- my/brightness-step)))

;; (map! "<XF86MonBrightnessDown>" 'my/brightness-decrease)
;; (map! "<XF86MonBrightnessUp>" 'my/brightness-increase)


;; (defun my/set-brightness-lg-5k (level)
;;   (interactive "nBrightness level: ")
;;   (save-window-excursion
;;     (shell-command
;;      (format "echo \"0i%s\n\" | sudo /home/shiva/repos/LG-ultrafine-brightness/build/LG_ultrafine_brightness
#+end_src

#+RESULTS:
: my/brightness-decrease

** red shift
#+begin_src emacs-lisp
(setq my/redshift-min 500)
(setq my/redshift-max 6000)
(setq my/redshift-step 250)
;; Since get-redshift is slow
(setq my/redshift-val-cache nil)
(defun my/set-redshift (redness brightness-percent)
  (interactive "nRedshift level: \nnBrightess percent: ")
  (let* ((safe-redness
          (cond ((< redness my/redshift-min) my/redshift-min)
                ((> redness my/redshift-max) my/redshift-max)
                (t redness)))
         (safe-brightness-percent
          (cond ((< brightness-percent 10) 10)
                ((> brightness-percent 100) 100)
                (t brightness-percent)))
         (redshift-command (format "redshift -P -O %s -b %s" safe-redness (/ safe-brightness-percent 100.0))))
    (message redshift-command)
    (save-window-excursion
      (shell-command redshift-command nil nil))))

#+end_src

#+RESULTS:
: my/set-redshift

** volume
#+begin_src emacs-lisp
(setq my/volume-min 1)
(setq my/volume-max 100)
(setq my/volume-step 5)

(defun my/get-volume ()
  (* my/volume-step (round (string-to-number
                                (shell-command-to-string "awk -F\"[][]\" '/dB/ { print $2 }' <(amixer sget Master)"))
                               my/volume-step)))

(defun my/set-volume (level)
  (interactive "nVolume level: ")
  (let ((clipped-level
         (cond ((< level my/volume-min) my/volume-min)
               ((> level my/volume-max) my/volume-max)
               (t level))))
    (save-window-excursion
      (shell-command
       (format "amixer set Master %s%% &" clipped-level) nil nil))))

(defun my/volume-step-change (delta)
  (my/set-volume (+ delta (my/get-volume))))

(defun my/volume-increase ()
  (interactive)
  (my/volume-step-change my/volume-step))

(defun my/volume-decrease ()
  (interactive)
  (my/volume-step-change (- my/volume-step)))

;; (map! "<XF86AudioRaiseVolume>" 'my/volume-increase)
;; (map! "<XF86AudioLowerVolume>" 'my/volume-decrease)
#+end_src

#+RESULTS:

** Convenience functions when working with PDF exports

When working on markdown or org-mode files that will be converted to
PDF, I use =pdf-tools= to preview the PDF and shortcuts to
automatically save, compile and reload on demand.

[[https://www.youtube.com/watch?v=Pd0JwOqh-gI][Here]] is a screencast showing how I edit Markdown or org-mode files in
Emacs whilst having a PDF preview.

In a screenshot, it looks like this:


#+BEGIN_SRC emacs-lisp :tangle no
  (defun md-compile ()
    "Compiles the currently loaded markdown file using pandoc into a PDF"
    (interactive)
    (save-buffer)
    (shell-command (concat "pandoc " (buffer-file-name) " -o "
                           (replace-regexp-in-string "md" "pdf" (buffer-file-name)))))

  (defun update-other-buffer ()
    (interactive)
    (other-window 1)
    (revert-buffer nil t)
    (other-window -1))

  (defun md-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a markdown-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (md-compile)
    (update-other-buffer))

  (defun latex-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a latex-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (save-buffer)
    (shell-command (concat "pdflatex " (buffer-file-name)))
    (switch-to-buffer (other-buffer))
    (kill-buffer)
    (update-other-buffer))

  (defun org-compile-beamer-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-beamer-export-to-pdf)
    (update-other-buffer))

  (defun org-compile-latex-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-latex-export-to-pdf)
    (update-other-buffer))

  (eval-after-load 'latex-mode
    '(define-key latex-mode-map (kbd "C-c r") 'latex-compile-and-update-other-buffer))

  (define-key org-mode-map (kbd "C-c lr") 'org-compile-latex-and-update-other-buffer)
  (define-key org-mode-map (kbd "C-c br") 'org-compile-beamer-and-update-other-buffer)

  (eval-after-load 'markdown-mode
    '(define-key markdown-mode-map (kbd "C-c r") 'md-compile-and-update-other-buffer))
#+END_SRC

#+RESULTS:

** Generate passwords

#+BEGIN_SRC emacs-lisp :tangle no
  (defun generate-password-non-interactive ()
     (string-trim (shell-command-to-string "pwgen -A 24")))

  (defun generate-password ()
    "Generates and inserts a new password"
    (interactive)
    (insert
     (shell-command-to-string
      (concat "pwgen -A " (read-string "Length: " "24") " 1"))))
#+END_SRC

#+RESULTS:
: generate-password

** Passwords file

Open the GPG encrypted password file.

Within this file, I'll search for passwords with =counsel-imenu= which
has nice auto-completion and means that the headers will always be
folded, so that no other person can see the passwords.

When the right header is found, I'll copy the password under the
current header to the clipboard from where I can use it where I need
it (for example a browser):

*** Copy password to clipboard

 #+BEGIN_SRC emacs-lisp :tangle no
 (fset 'copy-password-to-clipboard
    [?\C-s ?P ?a ?s ?s ?w ?o ?r ?d ?: return ?w ?v ?$ ?y C-up C-up C-up tab])
 #+END_SRC

*** Open passwords file

#+BEGIN_SRC emacs-lisp :tangle no
  (defun passwords ()
    "Open main 'passwords' file."
    (interactive)
    (find-file (concat org-directory "vault/primary.org.gpg")))
#+END_SRC
** =server-shutdown=
Thi s is the converse function to the built-in =server-start=.
#+BEGIN_SRC emacs-lisp :tangle no
(defun server-shutdown ()
  "Save buffers, Quit, and Shutdown (kill) server"
  (interactive)
  (save-some-buffers)
  (kill-emacs))
#+END_SRC

** Helper function to measure the running time of a function

#+BEGIN_SRC emacs-lisp :tangle no
  (defmacro measure-time (&rest body)
    "Measure the time it takes to evaluate BODY."
    `(let ((time (current-time)))
       ,@body
       (message "%.06f" (float-time (time-since time)))))
#+END_SRC

#+RESULTS:
: measure-time

For example =(measure-time (prettier-eslint)=.
** Sudo Save

If the current buffer is not writable, ask if it should be saved with
=sudo=.

Happily taken from Pascals configuration: https://github.com/SirPscl/emacs.d#sudo-save

#+BEGIN_SRC emacs-lisp :tangle no
  (defun ph/sudo-file-name (filename)
    "Prepend '/sudo:root@`system-name`:' to FILENAME if appropriate.
  This is, when it doesn't already have a sudo-prefix."
    (if (not (or (string-prefix-p "/sudo:root@localhost:"
                                  filename)
                 (string-prefix-p (format "/sudo:root@%s:" system-name)
                                  filename)))
        (format "/sudo:root@%s:%s" system-name filename)
      filename))

  (defun ph/sudo-save-buffer ()
    "Save FILENAME with sudo if the user approves."
    (interactive)
    (when buffer-file-name
      (let ((file (ph/sudo-file-name buffer-file-name)))
        (if (yes-or-no-p (format "Save file as %s ? " file))
            (write-file file)))))

  (advice-add 'save-buffer :around
              '(lambda (fn &rest args)
                 (when (or (not (buffer-file-name))
                           (not (buffer-modified-p))
                           (file-writable-p (buffer-file-name))
                           (not (ph/sudo-save-buffer)))
                   (call-interactively fn args))))
#+END_SRC

#+RESULTS:

** Open file with emacsclient using =filename:line= path
   This configuration is originally from the great [[https://github.com/bbatsov/prelude/commit/8c55c6f4bb8fab04040e178b97a9e68006525403][bbatsov's prelude]].

```bash
emacsclient somefile:1234

This will open file 'somefile' and set cursor on line 1234.

#+BEGIN_SRC emacs-lisp :tangle no
(defadvice server-visit-files (before parse-numbers-in-lines (files proc &optional nowait) activate)
  "Open file with emacsclient with cursors positioned on requested line.
Most of console-based utilities prints filename in format
'filename:linenumber'.  So you may wish to open filename in that format.
Just call:
  emacsclient filename:linenumber
and file 'filename' will be opened and cursor set on line 'linenumber'"
  (ad-set-arg 0
              (mapcar (lambda (fn)
                        (let ((name (car fn)))
                          (if (string-match "^\\(.*?\\):\\([0-9]+\\)\\(?::\\([0-9]+\\)\\)?$" name)
                              (cons
                               (match-string 1 name)
                               (cons (string-to-number (match-string 2 name))
                                     (string-to-number (or (match-string 3 name) ""))))
                            fn))) files)))
#+END_SRC
** Emacs takes SVG screenshot of itself

   #+begin_src emacs-lisp
    ;; https://www.reddit.com/r/emacs/comments/idz35e/emacs_27_can_take_svg_screenshots_of_itself/
    (defun screenshot-svg ()
      "Save a screenshot of the current frame as an SVG image.
    Saves to a temp file and puts the filename in the kill ring."
      (interactive)
      (let* ((filename (make-temp-file "Emacs" nil ".svg"))
             (data (x-export-frames nil 'svg)))
        (with-temp-file filename
          (insert data))
        (kill-new filename)
        (message filename)))
   #+end_src
** Disable =evil-mode= for some modes
   Since Emacs is a multi-purpose LISP REPL, there are many modes that
   are not primarily (or not at all) centered about text-manipulation.
   For those, it is reasonable to disable =evil-mode=, because it will
   bring nothing to the table, but might just shadow some keyboard
   shortcuts.
#+BEGIN_SRC emacs-lisp :tangle no
  (mapc (lambda (mode)
          (evil-set-initial-state mode 'emacs)) '(elfeed-show-mode
                                                  elfeed-search-mode
                                                  forge-pullreq-list-mode
                                                  forge-topic-list-mode
                                                  dired-mode
                                                  tide-references-mode
                                                  image-dired-mode
                                                  image-dired-thumbnail-mode
                                                  eww-mode))
#+END_SRC

Turning off evil when working in =cider--debug= minor mode:

#+BEGIN_SRC emacs-lisp :tangle no
  (defadvice cider--debug-mode (after toggle-evil activate)
    "Turn off `evil-local-mode' when enabling
  `cider--debug-mode', and turn it back on when disabling
  `cider--debug-mode'."
    (evil-local-mode (if cider--debug-mode -1 1)))
#+END_SRC

** Paste in Visual Mode

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key evil-insert-state-map (kbd "C-v") 'evil-visual-paste)

#+END_SRC

** =evil-escape=
https://github.com/syl20bnr/evil-escape

Escape from insert state and everything else.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq-default evil-escape-delay 0.2)
  (setq-default evil-escape-key-sequence "jk")
  (evil-escape-mode)
#+END_SRC

** Unbind certain Emacs keybindings in =evil-mode=
=M-.= and =M-,= are popular keybindings for "jump to definition" and
"back". =evil-mode= by default binds those to rather rarely used
functions =evil-repeat-pop-next= and =xref-pop-marker-stack=, for some reason.

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key evil-normal-state-map (kbd "M-.") nil)
  (define-key evil-normal-state-map (kbd "M-,") nil)
#+END_SRC

=M-l= and =M-l M-l= is =downcase-word=. This happens a lot by accident
for me. And undoing it often undoes _a lot_ more - like deleting whole
paragraphs of text. Also, I don't need it, because I'd use evil
bindings for that.

#+begin_src emacs-lisp :tangle no
  (define-key global-map (kbd "M-l") nil)
  (define-key evil-insert-state-map (kbd "M-l M-l") nil)
#+end_src

=M-k= is =kill-sentence=. That happens by accident, as well. And
sometimes, when in insert-mode, it even erases the history. I don't
need it, I'd use evil for that.

#+begin_src emacs-lisp :tangle no
  (define-key global-map (kbd "M-k") nil)
  (define-key evil-insert-state-map (kbd "M-k M-k") nil)
#+end_src

=TAB= is =evil-jump-forward=: Go to newer position in jump list.

#+begin_src emacs-lisp :tangle no
  (define-key global-map (kbd "<tab>") nil)
  (define-key evil-insert-state-map (kbd "<tab>") nil)
  (evil-define-key 'normal org-mode-map (kbd "<tab>") #'org-cycle)
#+end_src

** Repeatable key chords (repeat-mode)

Emacs28 comes with a built-in utility for repeating selected commands in
a more convenient fashion.  Once =repeat-mode= is enabled, a key binding
or chord that invokes a command successfully can be repeated by typing
in its tail or whatever the developer specifies.  So =other-window= may be
used like this: =C-x o=, =o=, =o= to switch three windows, instead of =C-x o=,
=C-x o=, =C-x o=.

This is achieved by furnishing transient keymaps that get activated
right after the command they belong to and only once the command in
question has been added to the =repeat-map=.  Here is a sample from
=window.el=:

#+begin_example emacs-lisp :tangle no
(defvar resize-window-repeat-map
  (let ((map (make-sparse-keymap)))
    ;; Standard keys:
    (define-key map "^" 'enlarge-window)
    (define-key map "}" 'enlarge-window-horizontally)
    (define-key map "{" 'shrink-window-horizontally) ; prot note: those three are C-x KEY
    ;; Additional keys:
    (define-key map "v" 'shrink-window) ; prot note: this is not bound by default
    map)
  "Keymap to repeat window resizing commands.  Used in `repeat-mode'.")
(put 'enlarge-window 'repeat-map 'resize-window-repeat-map)
(put 'enlarge-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window 'repeat-map 'resize-window-repeat-map)
#+end_example

Once the keymap exists and its commands are in the =repeat-map=, such as
with the above example, we do not have to recreate the entire setup if
all we need is to change key bindings: we just have to rebind the
commands to where it makes sense for us.  I actually do this for
=resize-window-repeat-map= ([[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks (window.el)]]).

At any rate, all we need here is to activate =repeat-mode= and then
implement the repetition mechanism wherever we want.

The =repeat= command is bound by default to =C-x z=, with =s-z= serving as my
alias for it (read [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][What is the meaning of the `s-KEY' bindings?]]).  With
the two variables I set in the following configurations, I make it so
that subsequent repetitions require only hitting another =z=.  Depending
on what you do, a =repeat= can save you from multiple key presses.  For
more demanding tasks you are better off with keyboard macros.

*Pro tip:* to make a keyboard macro out of your most recent commands, use
=C-x C-k l= which calls =kmacro-edit-lossage=.  The list is editable, so
remove any line that is not required and then save what is left.  The
result is stored as the latest keyboard macro (and you also have the
power to cycle through kmacros, store them in specific keys, etc.).

Moving on to the mark, which is affected by =set-mark-command-repeat-pop=,
practically every Emacs motion that operates on a portion of text will
set the mark automatically.  You can also do it manually with =C-SPC= (hit
it twice if you do not wish to activate the region).  It is then
possible to cycle through the marks in reverse order by passing a prefix
argument =C-u C-SPC=.  With =set-mark-command-repeat-pop= we can continue
cycling by repeated presses of =C-SPC=.  Again though, this is not the
type of functionality I rely on: for more deliberate actions of this
sort, consider Emacs' registers or bookmarks.

#+begin_src emacs-lisp :tangle no
;;; Repeatable key chords (repeat-mode)
(prot-emacs-builtin-package 'repeat
  (setq repeat-on-final-keystroke t)
  (setq set-mark-command-repeat-pop t)

  (repeat-mode 1))
#+end_src
** File types
*** Authinfo

My patch giving my patch giving =authinfo-mode= syntax highlighting is only
available in Emacs28+. For older versions, I've got a package I can use.
#+begin_src emacs-lisp :tangle packages.el
(package! authinfo-color-mode :recipe (:host github :repo"tecosaur/authinfo-color-mode" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+RESULTS:
| authinfo-color-mode | :modules | ((:os . arch) (:private . modules) (:private . config) (:private . modules)) | :recipe | (:host github :repo tecosaur/authinfo-color-mode :files (*.el filters preprocessors)) |

Now we just need to load it appropriately.
#+begin_src emacs-lisp
(use-package! authinfo-color-mode
  :mode ("authinfo.gpg\\'" . authinfo-color-mode)
  :init (advice-add 'authinfo-mode :override #'authinfo-color-mode))
#+end_src

#+RESULTS:

*** Systemd
For editing systemd unit files
#+begin_src emacs-lisp :tangle packages.el
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src

#+begin_src emacs-lisp
(use-package! systemd
  :defer t)
#+end_src

** PASSWORD STORE
Uses the standard Unix password store "pass".

#+begin_src emacs-lisp
(use-package! password-store)
#+end_src

** WINNER MODE
Winner mode has been included with GNU Emacs since version 20.  This is a global minor mode and, when activated, it allows you to “undo” (and “redo”) changes in the window configuration with the key commands 'SCP w <left>' and 'SPC w <right>'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("w" . "window")
       :desc "Winner redo" "<right>" #'winner-redo
       :desc "Winner undo" "<left>" #'winner-undo))
#+END_SRC

** ZAP TO CHAR
Emacs provides a 'zap-to-char' command that kills from the current point to a character.  It is bound to 'M-z' in standard GNU Emacs but since Doom Emacs uses 'SPC' as its leader key and does not have 'SPC z' binded to anything, it just makes since to use it for 'zap-to-char'.  Note that 'zap-to-char' can be used with the universal argument 'SPC u' to modify its behavior.  Examples of 'zap-to-char' usage are listed in the table below:

| KEYBINDING                | WHAT IS DOES                                               |
|---------------------------+------------------------------------------------------------|
| SPC z e                   | deletes all chars to the next occurrence of 'e'            |
| SPC u 2 SPC z e           | deletes all chars to the second occurrence of 'e'          |
| SPC u - SPC z e           | deletes all chars to the previous occurrence of 'e'        |
| SPC u -2 SPC z e          | deletes all chars to the fourth previous occurrence of 'e' |
| SPC u 1 0 0 SPC u SPC z e | deletes all chars to the 100th occurrence of 'e'           |

=TIP:= The universal argument (SPC u) can only take a single integer by default.  If you need to use a multi-digit number (like 100 in the last example in the table above), then you must terminate the universal argument with another 'SPC u' after typing the number.

'zap-up-to-char' is an alternative command that does not zap the char specified.  It is binded to 'SPC Z'.  It can also be used in conjunction with the universal argument 'SPC u' in similar fashion to the the 'zap-to-char' examples above.

=NOTE:= Vim (evil mode) has similar functionality builtin.  You can delete to the next occurrence of 'e' by using 'dte' in normal.  To delete to the next occurrence of 'e' including the 'e', then you would use 'dfe'.  And you can modify 'dt' and 'df' by prefixing them with numbers, so '2dte' would delete to the second occurrence of 'e'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Zap to char" "z" #'zap-to-char
      :desc "Zap up to char" "Z" #'zap-up-to-char)
#+END_SRC

** Tools for manual pages (manpages)
:PROPERTIES:
:CUSTOM_ID: h:ce420306-c40c-4d9a-bc01-205c5e49a5d1
:END:

Emacs offers a couple of commands for reading manual pages: =man= and
=woman=.  The former relies on the standard Unix tools, while the latter
is an elisp implementation of the same idea.  As I only ever run a
GNU/Linux system, I am okay with just =man=.

Why bother?

+ All the goodies of consistency: fonts, themes, operating on text with
  your familiar Emacs functionality, handling buffers…
+ Each manpage provides direct links to other items it references.

What you can do inside such a buffer (with minor tweaks by me):

+ Hit =i= to go to the information node you want using completion (same
  principle as with the Info pages of =C-h i= and the like).
+ =g= will generate the buffer anew.  Do it to reformat the text manually,
  though this should also happen automatically when adjusting a window's
  size.
+ =n= and =p= move between section headings.
+ Hit =RET= while over a referenced manpage to produce a new buffer with
  its contents.
+ =s= takes you directly to the familiar "See Also" section.
+ Use =m= to search for another manpage using your completion framework.
  If you invoke this command while point is over a referenced manpage,
  it becomes the default choice (same concept as with common help
  commands, =C-h f=, =C-h v=, and with many others like =find-library=).

Need to filter out those =man= buffers?  Check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][my Ibuffer entry]].

While there are customisation options for this tool, I find the defaults
to work as expected.  Note that the capitalisation of those symbols is
canonical.

#+begin_src emacs-lisp
;;; Tools for manual pages (manpages)
(use-package man
   :ensure nil
  :config
  (let ((map Man-mode-map))
    (define-key map (kbd "i") #'Man-goto-section)
    (define-key map (kbd "g") #'Man-update-manpage)))
#+end_src

#+RESULTS:
: t

** History and state
:PROPERTIES:
:CUSTOM_ID: h:1d9437fe-1355-4c2f-8ea7-6668b4d0399b
:END:

This section contains configurations for packages that are dedicated to
the task of recording the state of various Emacs tools, such as the
history of the minibuffer.

*** Emacs server and desktop
:PROPERTIES:
:CUSTOM_ID: h:68d57dd2-4df1-4b7a-8766-231216e6cd9c
:END:


With some exceptions aside, I only ever use Emacs in a single frame.
What I find more useful is the ability to save what Emacs calls the
=desktop=, which is an amalgamation of data such as the buffer list,
visited files, and some important data like the content of registers
(for various histories or other data see the following sections on
[[#h:ab868c1a-7ca6-4f54-83d8-eab49447da82][recording various types of history]]).

Because I can always access files I have visited before using completion
(see [[#h:5723c4bb-ff6c-449f-bb60-be66fab3f137][Completion for recent files and directories (prot-recentf.el)]]), I
opt to discard all files and buffers from the =desktop=.  Instead, I use
it to restore everything in the variable =desktop-globals-to-save=.

#+begin_src emacs-lisp
(use-package desktop
  :ensure nil
  :config
  (setq desktop-auto-save-timeout 300)
  (setq desktop-path `(,user-emacs-directory))
  (setq desktop-base-file-name "desktop")
  (setq desktop-files-not-to-save ".*")
  (setq desktop-buffers-not-to-save ".*")
  (setq desktop-globals-to-clear nil)
  (setq desktop-load-locked-desktop t)
  (setq desktop-missing-file-warning nil)
  (setq desktop-restore-eager 0)
  (setq desktop-restore-frames nil)
  (setq desktop-save 'ask-if-new)
  (dolist (symbol '(kill-ring log-edit-comment-ring))
    (add-to-list 'desktop-globals-to-save symbol))

  (desktop-save-mode 1))
#+end_src

#+RESULTS:
: t

*** Record various types of history
:PROPERTIES:
:CUSTOM_ID: h:ab868c1a-7ca6-4f54-83d8-eab49447da82
:END:
**** Record cursor position
:PROPERTIES:
:CUSTOM_ID: h:ae1cad56-c12c-4bd5-a5cc-e85c0ad4b978
:END:

Just remember where the point is in any given file.  This can often be a
subtle reminder of what you were doing the last time you visited that
file, allowing you to pick up from there.

#+begin_src emacs-lisp
;;; Record cursor position
(use-package saveplace
  :ensure nil
  :config
  (setq save-place-file (locate-user-emacs-file "saveplace"))
  (setq save-place-forget-unreadable-files t)
  (save-place-mode 1))
#+end_src

#+RESULTS:
: t

**** Backups
:PROPERTIES:
:CUSTOM_ID: h:3d2e3e65-b860-4ad7-87d2-24e4e9d0e296
:END:

And here are some settings pertaining to backups.  I rarely need those,
but I prefer to be safe in the knowledge that if something goes awry
there is something to fall back to.

#+begin_src emacs-lisp
;;; Backups
(setq backup-directory-alist
      `(("." . ,(concat user-emacs-directory "backup/"))))
(setq backup-by-copying t)
(setq version-control t)
(setq delete-old-versions t)
(setq kept-new-versions 6)
(setq kept-old-versions 2)
(setq create-lockfiles nil)
#+end_src

#+RESULTS:

** MOUSE SUPPORT
Adding mouse support in the terminal version of Emacs.

#+begin_src emacs-lisp
(xterm-mouse-mode 1)
#+end_src

** NEOTREE
Neotree is a file tree viewer.  When you open neotree, it jumps to the current file thanks to neo-smart-open.  The neo-window-fixed-size setting makes the neotree width be adjustable.  Doom Emacs had no keybindings set for neotree.  Since Doom Emacs uses 'SPC t' for 'toggle' keybindings, I used 'SPC t n' for toggle-neotree.

| COMMAND        | DESCRIPTION               | KEYBINDING |
|----------------+---------------------------+------------|
| neotree-toggle | /Toggle neotree/            | SPC t n    |
| neotree- dir   | /Open directory in neotree/ | SPC d n    |

#+BEGIN_SRC emacs-lisp
(after! neotree
  (setq neo-smart-open t
        neo-window-fixed-size nil))
(after! doom-themes
  (setq doom-neotree-enable-variable-pitch t))
(map! :leader
      :desc "Toggle neotree file viewer" "t n" #'neotree-toggle
      :desc "Open directory in neotree" "d n" #'neotree-dir)
#+END_SRC

** SPLITS
I set splits to default to opening on the right using 'prefer-horizontal-split'.  I set a keybinding for 'clone-indirect-buffer-other-window' for when I want to have the same document in two splits.  The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other.  But in all other respects, the indirect buffer and its base buffer are completely separate.  For example, I can fold one split but other will be unfolded.

#+BEGIN_SRC emacs-lisp
(defun prefer-horizontal-split ()
  (set-variable 'split-height-threshold nil t)
  (set-variable 'split-width-threshold 40 t)) ; make this as low as needed
(add-hook 'markdown-mode-hook 'prefer-horizontal-split)
(map! :leader
      :desc "Clone indirect buffer other window" "b c" #'clone-indirect-buffer-other-window)
#+END_SRC

#+RESULTS:
: clone-indirect-buffer-other-window

** EMOJIS
Emojify is an Emacs extension to display emojis. It can display github style emojis like :smile: or plain ascii ones like :).

#+begin_src emacs-lisp
(use-package emojify
  :hook (after-init . global-emojify-mode))
#+end_src

** monkeytype
#+begin_src emacs-lisp :tangle no
(defun my/monkeytype-mode-hook ()
  "Hooks for monkeytype-mode."
  ;; (centered-cursor-mode)
  ;; (evil-escape-mode -1)
  (evil-insert -1))
(add-hook 'monkeytype-mode-hook #'my/monkeytype-mode-hook)
#+end_src
** Speed type
#+begin_src emacs-lisp
;; Speed-type: Type a text and measure your speed
(use-package speed-type
  :defer t)
#+end_src
** RAINBOW MODE
Rainbox mode displays the actual color for any hex value color.  It's such a nice feature that I wanted it turned on all the time, regardless of what mode I am in.  The following creates a global minor mode for rainbow-mode and enables it.

#+begin_src emacs-lisp
(define-globalized-minor-mode global-rainbow-mode rainbow-mode
  (lambda () (rainbow-mode 1)))
(global-rainbow-mode 1 )
#+end_src

** Games
Games
I also use Emacs to play games and do other fun things. Using swiper means I don’t need too many search functions bound, so I can bind the games prefix to C-c g without breaking too much of my workflow.
#+begin_src emacs-lisp
(global-unset-key (kbd "C-c g"))
;; Yahtzee
;; Fun dice game. Now I can get mad at Emacs instead of my sister.

(use-package yahtzee
  ;; :ensure t
  :defer t
  :bind ("C-c g y" . yahtzee))
;; Sudoku
;; I love sudoku puzzles.

(use-package sudoku
  ;; :ensure t
  :defer t
  :bind ("C-c g s" . sudoku))
;; Tetris
;; Tetris is my childhood. No way I wouldn’t set it up to be nice and comfy.

(use-package tetris
  :defer t
  :bind (("C-c g t" . 'tetris)
         :map tetris-mode-map
         ("w" . tetris-move-bottom)
         ("a" . tetris-move-left)
         ("s" . tetris-mode-down)
         ("d" . tetris-move-right)
         ([left] . tetris-rotate-next)
         ([right] . tetris-rotate-prev)
         ([?\t] . tetris-pause-game)
         ("r" . tetris-start-game)
         ("e" . tetris-end-game)))
;; Chess
;; Just for fun. I suck at chess but it’s nice to have.

(use-package chess
  ;; :ensure t
  :defer t
  :bind ("C-c g c" . chess))
;; 2048
;; A simple and fun game. Was a big deal when I was in high school. I still play it from time to time, to pass the time and remember my powers of 2.

(use-package 2048-game
  ;; :ensure t
  :defer t
  :bind ("C-c g 2" . 2048-game))
#+end_src

** Aur
#+begin_src emacs-lisp
;; Aurel: Search, vote for and download AUR packages
(use-package aurel
  :defer t
  :config
  ;; Add "machine aur.archlinux.org login <user> password <password>" line to .authinfo
  (setq aurel-aur-user-package-info-check t))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25088 10759 802159 219000) :init (25088 10759 802148 619000) :init-secs (0 0 148 255000) :use-package-secs (0 0 161 825000)))

** Cloc (count lines of code in buffer)
#+begin_src emacs-lisp

;; cloc count the lines of code in a buffer

(use-package cloc
  :ensure t
  :commands cloc)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25088 11642 749227 346000) :init (25088 11642 749191 846000) :init-secs (0 0 290 986000) :use-package-secs (0 0 1137 828000)))

** Define Word
#+begin_src emacs-lisp :tangle no

;; define-word
;; define-word is a GNU Emacs package that lets you see the definition of a word or a phrase at point, without having to switch to a browser.

(use-package define-word)
  ;; :ensure t)
#+end_src
** Impatient mode
#+begin_src emacs-lisp
;; impatient-mode
;; Thanks to impatient-mode you can see the effect of your HTML as you type it.

;; (use-package impatient-mode
;;   :ensure ht
;;   :ensure t)
#+end_src

** Fillng
This is a useful function copied from somewhere I don't remember, sorry unknown author!

It makes fill-paragraph "toggable": M-q once to fill, M-q again to un-fill!

#+begin_src emacs-lisp
(defun op/fill-or-unfill (fn &optional justify region)
  "Meant to be an adviced :around `fill-paragraph'.
FN is the original `fill-column'.  If `last-command' is
`fill-paragraph', unfill it, fill it otherwise.  Inspired from a
post on endless parentheses.  Optional argument JUSTIFY and
REGION are passed to `fill-paragraph'."
  (let ((fill-column
         (if (eq last-command 'fill-paragraph)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (funcall fn justify region)))
(advice-add 'fill-paragraph :around #'op/fill-or-unfill)
#+end_src

#+RESULTS:

** MiniBuffer
#+begin_src emacs-lisp
;; all hail the minibuffer

;; This allows to launch a command that uses the minibuffer while already inside the minibuffer.

(setq enable-recursive-minibuffers t)
;; I'm generally pretty lazy, so why pressing shift to get the case right?

(setq completion-ignore-case t
      read-file-name-completion-ignore-case t
      read-buffer-completion-ignore-case t)
;; Misc enhancement to the minibuffer behaviour.

;; add prompt inidcator to `completing-read-multiple'.
(defun op/crm-indicator (args)
  (cons (concat "[CRM] " (car args))
        (cdr args)))
(advice-add #'completing-read-multiple :filter-args #'op/crm-indicator)

(setq minibuffer-prompt-properties
      '(read-only true cursor-intangible t face minibuffer-prompt))
(add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
#+end_src

#+RESULTS:
| savehist-minibuffer-hook | vertico-repeat-save | exwm-input--on-minibuffer-setup | winner-save-unconditionally | doom-init-smartparens-in-minibuffer-maybe-h | pl/minibuffer-setup | elfeed-search--minibuffer-setup | all-the-icons-ivy-rich-minibuffer-align-icons | marginalia--minibuffer-setup | cursor-intangible-mode | embark--record-this-command | rfn-eshadow-setup-minibuffer | minibuffer-error-initialize | minibuffer-history-isearch-setup | minibuffer-history-initialize | exwm-layout--on-minibuffer-setup |
** Auto insert
#+begin_src emacs-lisp :tangle no
;; auto-insert-mode is an elisp library that automatically inserts text into new buffers based on the file extension or major mode. For instance, trying to open a .el (Emacs LISP) file will insert the entire GPL notice, and also other stuff. This automatic insert can be interactive, too.

(add-hook 'after-init-hook #'auto-insert-mode)

(with-eval-after-load 'autoinsert
  <<c-skeleton>>
  <<go-skeleton>>
  <<clojure-skeleton>>
  <<perl-skeleton>>
  <<svg-skeleton>>)
;; I prefer the ISC license, and tend to use that for almost all the C I write:

(define-auto-insert '("\\.c\\'" . "C skeleton")
  '("Description: "
    "/*" \n
    > "* Copyright (c) " (format-time-string "%Y") " " user-full-name " <" user-mail-address ">" \n
    > "*" \n
    > "* Permission to use, copy, modify, and distribute this software for any" \n
    > "* purpose with or without fee is hereby granted, provided that the above" \n
    > "* copyright notice and this permission notice appear in all copies." \n
    > "*" \n
    > "* THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES" \n
    > "* WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF" \n
    > "* MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR" \n
    > "* ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES" \n
    > "* WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN" \n
    > "* ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF" \n
    > "* OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE." \n
    > "*/" \n
    \n
    > _ \n
    \n))
;; I added a skeleton for go files:

(define-auto-insert
  '("\\.go\\'" . "Go skeleton")
  '("Short description: "
    "package "
    (completing-read "Go package: "
                     `("main" ,(file-name-nondirectory
                                (directory-file-name default-directory))))
    \n \n > _ \n))
;; The clojure  skeleton inserts the correct ns form at the top of the buffer:

(defun op/cloj-ns ()
  "Return the clojure namespace (as string) for the current file.
Stolen from the ``ns'' yasnippet from yasnippet-snippets."
  (cl-flet ((try-src-prefix
             (path src-prfx)
             (let ((parts (split-string path src-prfx)))
               (when (= (length parts) 2)
                 (cadr parts)))))
    (let* ((p (buffer-file-name))
           (p2 (cl-first
                (cl-remove-if-not #'identity
                                  (mapcar (lambda (prfx)
                                            (try-src-prefix p prfx))
                                          '("/src/cljs/" "/src/cljc/" "/src/clj/" "/src/" "/test/")))))
           (p3 (file-name-sans-extension p2))
           (p4 (mapconcat #'identity
                          (split-string p3 "/")
                          ".")))
      (replace-regexp-in-string "_" "-" p4))))

(define-auto-insert
  '("\\.\\(clj\\|cljs\\|cljc\\)\\'" . "Clojure skeleton")
  '("Short description: "
    "(ns " (op/cloj-ns) ")" \n \n
    > _ \n))
(define-auto-insert '("\\.pl\\'" . "Perl skeleton")
  '("Name: "
    "#!/usr/bin/env perl" \n
    "#" \n
    "# Copyright (c) " (format-time-string "%Y") " " user-full-name " <" user-mail-address ">" \n
    "#" \n
    "# Permission to use, copy, modify, and distribute this software for any" \n
    "# purpose with or without fee is hereby granted, provided that the above" \n
    "# copyright notice and this permission notice appear in all copies." \n
    "#" \n
    "# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES" \n
    "# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF" \n
    "# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR" \n
    "# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES" \n
    "# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN" \n
    "# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF" \n
    "# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE." \n
    \n
    "use v5.10;" \n
    "use strict;" \n
    "use warnings;" \n \n
    _ \n \n
    "__END__" "\n\n"
    "=head1 NAME" "\n\n"
    str "\n\n"
    "=head1 SYNOPSIS" "\n\n\n"
    "=head1 DESCRIPTION" "\n\n\n"
    "=cut" "\n"))
;; I'm also writing some small SVGs in Emacs, and I keep forgetting the right xmlns…

(define-auto-insert '("\\.svg\\'" . "SVG Skeleton")
  '("Name: "
    "<svg xmlns=\"http://www.w3.org/2000/svg\"" \n
    "    version=\"1.1\"" \n
    "    width=\"\"" \n
    "    height=\"\">"
    "  " _ \n
    "</svg>"))
#+end_src
** Isearch
#+begin_src emacs-lisp
(setq isearch-lazy-count t
      search-whitespace-regexp ".*?"
      isearch-allow-scroll 'unlimited)
(load "setup-isearch")
#+end_src

#+RESULTS:
: t

** easy kill
#+begin_src emacs-lisp

(use-package! easy-kill
  :bind*
  (([remap kill-ring-save] . easy-kill)))
(global-set-key [remap kill-ring-save] 'easy-kill)
#+end_src

#+RESULTS:
: easy-kill

** smartparens
#+begin_src emacs-lisp

(use-package! smartparens
  :init
  (map! :map smartparens-mode-map
        "C-M-f" #'sp-forward-sexp
        "C-M-b" #'sp-backward-sexp
        "C-M-u" #'sp-backward-up-sexp
        "C-M-d" #'sp-down-sexp
        "C-M-p" #'sp-backward-down-sexp
        "C-M-n" #'sp-up-sexp
        "C-M-s" #'sp-splice-sexp
        "C-)" #'sp-forward-slurp-sexp
        "C-}" #'sp-forward-barf-sexp
        "C-(" #'sp-backward-slurp-sexp
        "C-M-)" #'sp-backward-slurp-sexp
        "C-M-)" #'sp-backward-barf-sexp))
#+end_src
** SmartParens
#+begin_src emacs-lisp :tangle no
(sp-local-pair
 '(org-mode)
 "<<" ">>"
 :actions '(insert))
#+end_src

#+begin_src emacs-lisp

(use-package smartparens
  :bind (:map smartparens-mode-map
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)

              ("C-M-a" . sp-beginning-of-sexp)
              ("C-M-e" . sp-end-of-sexp)
              ("C-M-n" . sp-next-sexp)
              ("C-M-p" . sp-previous-sexp)

              ("C-(" . sp-forward-barf-sexp)
              ("C-)" . sp-forward-slurp-sexp)
              ("C-{" . sp-backward-barf-sexp)
              ("C-}" . sp-backward-slurp-sexp)

              ("C-k" . sp-kill-hybrid-sexp)

              ("C-," . sp-rewrap-sexp)

              :map emacs-lisp-mode-map
              (";" . sp-comment)

              :map lisp-mode-map
              (";" . sp-comment))
  :hook ((prog-mode . turn-on-smartparens-strict-mode)
         (web-mode . op/sp-web-mode)
         (LaTeX-mode . turn-on-smartparens-strict-mode))
  :custom ((sp-highlight-pair-overlay nil))
  :config
  (require 'smartparens-config)

  (with-eval-after-load 'clojure-mode
    (define-key clojure-mode-map ";" #'sp-comment))

  (with-eval-after-load 'scheme-mode
    (define-key scheme-mode-map ";" #'sp-comment))

  (sp-with-modes 'org-mode
    (sp-local-pair "=" "=" :wrap "C-="))

  (bind-key [remap c-electric-backspace] #'sp-backward-delete-char
            smartparens-strict-mode-map)

  (sp-local-pair 'log-edit-mode "`" "'")

  (defun op/sp-web-mode ()
    (setq web-mode-enable-auto-pairing nil))

  (defun op/newline-indent (&rest _ignored)
    (split-line)
    (indent-for-tab-command))

  (let ((c-like '(awk-mode c++mode cc-mode c-mode css-mode go-mode java-mode
                           js-mode json-mode python-mode web-mode es-mode
                           perl-mode lua-mode)))
    (dolist (x `(("{" . ,c-like)
                 ("[" . ,c-like)
                 ("(" . (sql-mode ,@c-like))))
      (dolist (mode (cdr x))
        (sp-local-pair mode (car x) nil :post-handlers
                       '((op/newline-indent "RET")
                         (op/newline-indent "<return>"))))))

  (defun op/inside-comment-or-string-p ()
    "T if point is inside a string or comment."
    (let ((s (syntax-ppss)))
      (or (nth 4 s)                     ;comment
          (nth 3 s))))

  (defun op/current-line-str ()
    "Return the current line as string."
    (buffer-substring-no-properties (line-beginning-position)
                                    (line-end-position)))

  (defun op/maybe-add-semicolon-paren (_id action _ctx)
    "Insert semicolon after parens when appropriat.
Mainly useful in C and derived, and only when ACTION is insert."
    (when (eq action 'insert)
      (save-excursion
        ;; caret is between parens (|)
        (forward-char)
        (let ((line (op/current-line-str)))
          (when (and (looking-at "\\s-*$")
                     (not (string-match-p
                           (regexp-opt '("if" "else" "switch" "for" "while"
                                         "do" "define")
                                       'words)
                           line))
                     (string-match-p "[\t ]" line)
                     (not (op/inside-comment-or-string-p)))
            (insert ";"))))))

  (let ((c-like-modes-list '(c-mode c++-mode java-mode perl-mode)))
    (sp-local-pair c-like-modes-list "(" nil
                   :post-handlers
                   '(:add op/maybe-add-semicolon-paren)))

  (defhydra hydra-sp (:hint nil)
    "
 Moving^^^^                       Slurp & Barf^^   Wrapping^^            Sexp juggling^^^^               Destructive
------------------------------------------------------------------------------------------------------------------------
 [_a_] beginning  [_n_] down      [_h_] bw slurp   [_R_]   rewrap        [_S_] split   [_t_] transpose   [_c_] change inner  [_w_] copy
 [_e_] end        [_N_] bw down   [_H_] bw barf    [_u_]   unwrap        [_s_] splice  [_A_] absorb      [_C_] change outer
 [_f_] forward    [_p_] up        [_l_] slurp      [_U_]   bw unwrap     [_r_] raise   [_E_] emit        [_k_] kill          [_g_] quit
 [_b_] backward   [_P_] bw up     [_L_] barf       [_(__{__[_] wrap (){}[]   [_j_] join    [_o_] convolute   [_K_] bw kill       [_q_] quit"
    ("?" (hydra-set-property 'hydra-sp :verbosity 1))

    ;; moving
    ("a" sp-beginning-of-sexp)
    ("e" sp-end-of-sexp)
    ("f" sp-forward-sexp)
    ("b" sp-backward-sexp)
    ("n" sp-down-sexp)
    ("N" sp-backward-down-sexp)
    ("p" sp-up-sexp)
    ("P" sp-backward-up-sexp)

    ;; slurping & barfing
    ("h" sp-backward-slurp-sexp)
    ("H" sp-backward-barf-sexp)
    ("l" sp-forward-slurp-sexp)
    ("L" sp-forward-barf-sexp)

    ;; wrapping
    ("R" sp-rewrap-sexp)
    ("u" sp-unwrap-sexp)
    ("U" sp-backward-unwrap-sexp)
    ("(" sp-wrap-round)
    ("[" sp-wrap-square)
    ("{" sp-wrap-curly)

    ;; sexp juggling
    ("S" sp-split-sexp)
    ("s" sp-splice-sexp)
    ("r" sp-raise-sexp)
    ("j" sp-join-sexp)
    ("t" sp-transpose-sexp)
    ("A" sp-absorb-sexp)
    ("E" sp-emit-sexp)
    ("o" sp-convolute-sexp)

    ;; destructive editing
    ("c" sp-change-inner :exit t)
    ("C" sp-change-enclosing :exit t)
    ("k" sp-kill-sexp)
    ("K" sp-backward-kill-sexp)
    ("w" sp-copy-sexp)

    ("q" nil)
    ("g" nil))

  (define-key global-map (kbd "s-g")
    (lambda ()
      (interactive)
      (hydra-set-property 'hydra-sp :verbosity 0)
      (hydra-sp/body))))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25134 3983 706869 375000) :init (25134 3983 706498 821000) :init-secs (0 0 94934 396000) :use-package-secs (0 0 95376 547000) :config (25134 3983 706480 126000) :config-secs (0 0 94860 423000)))

** Auth Sources
#+begin_src emacs-lisp :tangle no

;;; Auth Source
(use-package auth-source
  ;; :ensure nil
  :custom
  (auth-source-save-behavior nil)
  ;; Read credentials from KeepassXC too via the Secret Service API.
  ;; For this to work, KXC has to have this integration enabled and
  ;; some password groups shared via SS API. Also, those secrets must
  ;; expose attributes (advanced tab) like 'host', 'port' and/or
  ;; 'user' so they can be found by auth-source. Ex:
  ;; (auth-source-search :type 'secrets :host "irc.libera.chat")
  (auth-sources '("secrets:Passwords")))
#+end_src

#+RESULTS:
: auth-source

** undo tree
#+begin_src emacs-lisp

(use-package undo-tree
  :config
  (global-undo-tree-mode 1)
  :custom
  (undo-tree-visualizer-diff nil)
  (undo-tree-visualizer-timestamps t)
  (undo-tree-visualizer-relative-timestamps t))
#+end_src
** atomic-chrome / GhostText: Edit text area in browser
You need to install the Firefox extension [[https://github.com/GhostText/GhostText][GhostText]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package atomic-chrome
  :if (daemonp)
  :defer 10
  :config
  ;; Set port to a less common one
  ;; Must be changed in Firefox too!
  (setq atomic-chrome-server-ghost-text-port 8326)
  (setq atomic-chrome-default-major-mode 'gfm-mode)
  (setq atomic-chrome-url-major-mode-alist
        '(("reddit\\.com" . markdown-mode)
          ("github\\.com" . gfm-mode)
          ("gitlab\\.com" . gfm-mode)
          ("gitlab\\.paesslergmbh\\.de" . gfm-mode)
          ("gitlab\\.sovendus\\.com" . gfm-mode)
          ("lab\\.ebenefuenf\\.com" . gfm-mode)
          ("jira.sovendus.com" . jira-markup-mode)
          ("jira.paesslergmbh.de" . jira-markup-mode)))
  (atomic-chrome-start-server))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25098 24336 620398 905000) :use-package-secs (0 0 15 123000)))

** Nicer buffer name for buffers with same name
#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :defer 5
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t)
  (setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
  (setq uniquify-separator "/"))
#+END_SRC

#+RESULTS:
: /

** Automatically remove trailing whitespace (only if I put them there)
#+BEGIN_SRC emacs-lisp :tangle no
(use-package ws-butler
  :hook ((text-mode prog-mode) . ws-butler-mode)
  :config (setq ws-butler-keep-whitespace-before-point nil))
(use-package whitespace
  :config
  (global-whitespace-mode)
  :hook
  (prog-mode . (lambda () (setq show-trailing-whitespace t)))
  (text-mode . (lambda () (setq show-trailing-whitespace t)))
  (conf-mode . (lambda () (setq show-trailing-whitespace t)))
  :custom
  (whitespace-style '(face trailing tabs empty big-indent))
  (whitespace-global-modes '(not erc-mode magit-mode)))


#+END_SRC
** Abbrev
Thanks to [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][use a single abbrev-table for multiple modes? - Emacs Stack Exchange]] I
have the following.
#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev.el" doom-private-dir))))
#+end_src

#+RESULTS:
| +abbrev-file-name |

** Very large files

The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.
#+begin_src emacs-lisp :tangle no
(package! vlf :recipe (:host github :repo "m00natic/vlfi" :files ("*.el"))
  :pin "cc02f2533782d6b9b628cec7e2dcf25b2d05a27c")
#+end_src

#+RESULTS:
| vlf | :modules | ((:private . config) (:private . modules)) | :recipe | (:host github :repo m00natic/vlfi :files (*.el)) | :pin | cc02f2533782d6b9b628cec7e2dcf25b2d05a27c |

To make VLF available without delaying startup, we'll just load it in quiet moments.
#+begin_src emacs-lisp :tangle no
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write vlf-search vlf-occur vlf-follow vlf-ediff vlf)
#+end_src

#+RESULTS:
| t | easymenu | tree-widget | timer | recentf | custom | savehist | eldoc | easymenu | help-mode | yasnippet | dash | f | s | with-editor | git-commit | package | eieio | transient | magit | calendar | find-func | format-spec | org-macs | org-compat | org-faces | org-entities | org-list | org-pcomplete | org-src | org-footnote | org-macro | ob | org | org-agenda | org-capture | org | vlf-tune | vlf-base | vlf-write | vlf-search | vlf-occur | vlf-follow | vlf-ediff | vlf | vlf-setup |

** Eros
#+begin_quote
From the =:tools eval= module.
#+end_quote

This package enables the very nice inline evaluation with =gr= and =gR=. The prefix
could be slightly nicer though.
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ") ; default =>
#+end_src

#+RESULTS:
: ⟹

** EVIL
#+begin_quote
From the =:editor evil= module.
#+end_quote

When I want to make a substitution, I want it to be global more often than not
--- so let's make that the default.

Now, EVIL cares a fair bit about keeping compatibility with Vim's default
behaviour. I don't. There are some particular settings that I'd rather be
something else, so let's change them.

#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

#+RESULTS:

I don't use ~evil-escape-mode~, so I may as well turn it off, I've heard it
contributes a typing delay. I'm not sure it's much, but it is an extra
~pre-command-hook~ that I don't benefit from, so...
It seems that there's a dedicated package for this, so instead of just disabling
the mode on startup, let's prevent installation of the package.
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src

#+RESULTS:
| vlf | evil-escape |

** Smerg

For repeated operations, a hydra would be helpful. But I prefer transient.
#+begin_src emacs-lisp  :tangle no
(defun smerge-repeatedly ()
  "Perform smerge actions again and again"
  (interactive)
  (smerge-mode 1)
  (smerge-transient))
(after! transient
  (transient-define-prefix smerge-transient ()
    [["Move"
      ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (smerge-repeatedly)))
      ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev)) (smerge-repeatedly)))]
     ["Keep"
      ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
      ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
      ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
      ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
      ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
     ["Diff"
      ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
      ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
      (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
      ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
      ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
     ["Other"
      ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
      ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
      ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
      ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

** Company
#+begin_quote
From the =:completion company= module.
#+end_quote

It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!
#+begin_src emacs-lisp
(after! company
  (setq company-idle-delay 0.0
        company-minimum-prefix-length 2)
  (setq company-show-numbers t)
  (add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying.
#+end_src

#+RESULTS:
| company-abort | +company-abort-h |

Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

#+RESULTS:
: 1000

*** Plain Text
~Ispell~ is nice, let's have it in ~text~, ~markdown~, and ~GFM~.
#+begin_src emacs-lisp :tangle no
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src

#+RESULTS:

We then configure the dictionary we're using in [[*Ispell][Ispell]].
*** ESS
~company-dabbrev-code~ is nice. Let's have it.
#+begin_src emacs-lisp :tangle no
(set-company-backend! 'ess-r-mode '(company-R-args company-R-objects company-dabbrev-code :separate))
#+end_src

#+RESULTS:

** Projectile
#+begin_quote
From the =:core packages= module.
#+end_quote

Looking at documentation via =SPC h f= and =SPC h v= and looking at the source can
add package src directories to projectile. This isn't desirable in my opinion.
#+begin_src emacs-lisp
(setq projectile-ignored-projects '("~/" "/tmp" "~/.emacs.d/.local/straight/repos/"))
(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

#+RESULTS:
: projectile-ignored-project-function

** Ispell
**** Downloading dictionaries
Let's get a nice big dictionary from [[http://app.aspell.net/create][SCOWL Custom List/Dictionary Creator]] with
the following configuration
- size :: 80 (huge)
- spellings :: British(-ise) and Australian
- spelling variants level :: 0
- diacritics :: keep
- extra lists :: hacker, roman numerals

***** Hunspell
#+begin_src shell :tangle (if (file-exists-p "/usr/share/myspell/en-custom.dic") "no" "setup.sh")
cd /tmp
curl -o "hunspell-en-custom.zip" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=hunspell'
unzip "hunspell-en-custom.zip"

sudo chown root:root en-custom.*
sudo mv en-custom.{aff,dic} /usr/share/myspell/
#+end_src
***** Aspell
#+begin_src shell :tangle (if (file-expand-wildcards "/usr/lib64/aspell*/en-custom.multi") "no" "setup.sh")
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && sudo make install
#+end_src
**** Configuration
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")
#+end_src

#+RESULTS:
: en-custom

Oh, and by the way, if ~company-ispell-dictionary~ is ~nil~, then
~ispell-complete-word-dict~ is used instead, which once again when ~nil~ is
~ispell-alternate-dictionary~, which at the moment maps to a plaintext version of
the above.

It seems reasonable to want to keep an eye on my personal dict, let's have it
nearby (also means that if I change the 'main' dictionary I keep my addition).
#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-private-dir))
#+end_src

#+RESULTS:
: /home/shiva/.config/doom/.ispell_personal

** Screenshot

This makes it a breeze to take lovely screenshots.
#+begin_src emacs-lisp :tangle packages.el
(package! screenshot :recipe (:host github :repo"tecosaur/screenshot" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+RESULTS:
| screenshot | :modules | ((:private . config) (:private . modules)) | :recipe | (:host github :repo tecosaur/screenshot :files (*.el filters preprocessors)) |


Some light configuring is all we need, so we can make use of the [[https://github.com/Calinou/0x0][0x0]] wrapper
file uploading script (which I've renamed to ~upload~).
#+begin_src emacs-lisp
(use-package! screenshot
  :defer t
  :config (setq screenshot-upload-fn "upload %s 2>/dev/null"))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25089 44697 876006 799000) :init (25089 44697 875993 220000) :init-secs (0 0 99 672000) :use-package-secs (0 0 119 427000)))

** Auto activating snippets

Sometimes pressing =TAB= is just too much.
#+begin_src emacs-lisp :tangle packages.el
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "1699bec4d244a1f62af29fe4eb8b79b6d2fccf7d")
#+end_src

#+begin_src emacs-lisp
(use-package! aas
  :commands aas-mode)
#+end_src

** TRAMP

Another lovely Emacs feature, TRAMP stands for /Transparent Remote Access,
Multiple Protocol/. In brief, it's a lovely way to wander around outside your
local filesystem.

**** Prompt recognition

Unfortunately, when connecting to remote machines Tramp can be a wee pit picky
with the prompt format. Let's try to get Bash, and be a bit more permissive with
prompt recognition.

#+begin_src emacs-lisp :tangle no
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\\)[^]#$%>\n]*#?[]#$%>] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + 
#+end_src

**** Troubleshooting
In case the remote shell is misbehaving, here are some things to try

***** Zsh
There are some escape code you don't want, let's make it behave more considerately.
#+begin_src shell :eval no :tangle no
if [[ "$TERM" == "dumb" ]]; then
    unset zle_bracketed_paste
    unset zle
    PS1='$ '
    return
fi
#+end_src

**** Guix

[[https://guix.gnu.org/][Guix]] puts some binaries that TRAMP looks for in unexpected locations.
That's no problem though, we just need to help TRAMP find them.

#+begin_src emacs-lisp :tangle no
(after! tramp
  (appendq! tramp-remote-path
            '("~/.guix-profile/bin" "~/.guix-profile/sbin"
              "/run/current-system/profile/bin"
              "/run/current-system/profile/sbin")))
#+end_src
** Etrace

The /Emacs Lisp Profiler/ (ELP) does a nice job recording information, but it
isn't the best for looking at results. =etrace= converts ELP's results to the
"Chromium Catapult Trace Event Format". This means that the output of =etrace= can
be loaded in something like the [[https://www.speedscope.app/][speedscope]] webapp for easier profile
investigation.

#+begin_src emacs-lisp :tangle no
(package! etrace :recipe (:host github :repo "aspiers/etrace"))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! etrace
  :after elp)

#+end_src

** YASnippet
#+begin_quote
From the =:editor snippets= module.
#+end_quote

Nested snippets are good, so let's enable that.
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

#+RESULTS:
: t

** String inflection

For when you want to change the case pattern for a symbol.
#+begin_src emacs-lisp :tangle no
(package! string-inflection :pin "fd7926ac17293e9124b31f706a4e8f38f6a9b855")
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! string-inflection
  :commands (string-inflection-all-cycle
             string-inflection-toggle
             string-inflection-camelcase
             string-inflection-lower-camelcase
             string-inflection-kebab-case
             string-inflection-underscore
             string-inflection-capital-underscore
             string-inflection-upcase)
  :init
  (map! :leader :prefix ("c~" . "naming convention")
        :desc "cycle" "~" #'string-inflection-all-cycle
        :desc "toggle" "t" #'string-inflection-toggle
        :desc "CamelCase" "c" #'string-inflection-camelcase
        :desc "downCase" "d" #'string-inflection-lower-camelcase
        :desc "kebab-case" "k" #'string-inflection-kebab-case
        :desc "under_score" "_" #'string-inflection-underscore
        :desc "Upper_Score" "u" #'string-inflection-capital-underscore
        :desc "UP_CASE" "U" #'string-inflection-upcase)
  (after! evil
    (evil-define-operator evil-operator-string-inflection (beg end _type)
      "Define a new evil operator that cycles symbol casing."
      :move-point nil
      (interactive "<R>")
      (string-inflection-all-cycle)
      (setq evil-repeat-info '([?g ?~])))
    (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection)))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25089 58776 6422 553000) :init (25089 58776 6410 943000) :init-secs (0 0 1563 35000) :use-package-secs (0 0 1618 168000)))

** Which-key

#+begin_src emacs-lisp

(which-key-setup-side-window-bottom)
;; (which-key-setup-minibuffer)
;; (which-key-show-next-page-cycle)
(setq which-key-side-window-max-width 0.33)
(setq which-key-side-window-max-height 0.25)
;; (setq which-key-popup-type 'frame)
(setq which-key-side-window-location 'bottom)
(setq which-key-frame-max-width 90)
(setq which-key-frame-max-height 60)
(setq which-key-use-C-h-commands nil)
(setq which-key-paging-prefixes '("C-x"))
(setq which-key-paging-key "<f5>")
(setq which-key-idle-delay 0.3) ;; I need the help, I really do
(setq which-key-idle-secondary-delay 0.05)
;; Set the maximum length (in characters) for key descriptions (commands or
;; prefixes). Descriptions that are longer are truncated and have ".." added.
(setq which-key-max-description-length 20)

;; Use additional padding between columns of keys. This variable specifies the
;; number of spaces to add to the left of each column.
(setq which-key-add-column-padding 0)

;; The maximum number of columns to display in the which-key buffer. nil means
;; don't impose a maximum.
(setq which-key-max-display-columns nil)

;; Set the separator used between keys and descriptions. Change this setting to
;; an ASCII character if your font does not show the default arrow. The second
;; setting here allows for extra padding for Unicode characters. which-key uses
;; characters as a means of width measurement, so wide Unicode characters can
;; throw off the calculation.
;; (setq which-key-separator "→" )
(setq which-key-separator " " )
(setq which-key-unicode-correction 2)

;; Set the prefix string that will be inserted in front of prefix commands
;; (i.e., commands that represent a sub-map).
(setq which-key-prefix-prefix "+" )
;; (setq which-key-prefix-prefix "" )

;; Set the special keys. These are automatically truncated to one character and
;; have which-key-special-key-face applied. Disabled by default. An example
;; setting is
(setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL"))
(setq which-key-special-keys nil)

;; Show the key prefix on the left, top, or bottom (nil means hide the prefix).
;; The prefix consists of the keys you have typed so far. which-key also shows
;; the page information along with the prefix.
(setq which-key-show-prefix 'left)

;; Set to t to show the count of keys shown vs. total keys in the mode line.
(setq which-key-show-remaining-keys 't)
  (use-package which-key
    :after which-key
    :config
    ;; (advice-add 'repeat-post-hook :after
    ;;             (defun my/which-key-repeat ()
    ;;               (when-let ((cmd (or this-command real-this-command))
    ;;                          (keymap (repeat--command-property 'repeat-map)))
    ;;                 (run-at-time
    ;;                  which-key-idle-delay nil
    ;;                  (lambda ()
    ;;                    (which-key--create-buffer-and-show
    ;;                     nil (symbol-value keymap)))))))

    (defun my/which-key-repeat-mode-dispatch ()
      (interactive)
      (setq this-command last-command)
      (when-let (keymap (repeat--command-property 'repeat-map))
        (which-key--create-buffer-and-show
         nil (symbol-value keymap))))

    ;; (defun my/which-key-repeat-mode-binding ()
    ;;   (when repeat-mode
    ;;     (when-let* ((rep-map-sym (or repeat-map (repeat--command-property 'repeat-map)))
    ;;                 (keymap (and (symbolp rep-map-sym) (symbol-value rep-map-sym))))
    ;;       (set-transient-map
    ;;        (make-composed-keymap
    ;;         (let ((map (make-sparse-keymap)))
    ;;           (define-key map (kbd "C-h") #'my/which-key-repeat-mode-dispatch)
    ;;           map)
    ;;         keymap)))))

    (defun my/which-key-repeat-mode-binding ()
      (when repeat-mode
        (when-let* ((rep-map-sym (or repeat-map (repeat--command-property 'repeat-map)))
                    (keymap (and (symbolp rep-map-sym) (symbol-value rep-map-sym))))
          (set-transient-map
           (let ((map (make-sparse-keymap)))
             (set-keymap-parent map keymap)
             (define-key map (kbd "C-h") #'my/which-key-repeat-mode-dispatch)
             map)))))
    (advice-add 'repeat-post-hook :after #'my/which-key-repeat-mode-binding))
#+end_src

#+RESULTS:
: t

I also think that having =evil-= appear in so many popups is a bit too verbose,
let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src

** Emacs as external editor
#+begin_src emacs-lisp :tangle no

(defun dw/show-server-edit-buffer (buffer)
  ;; TODO: Set a transient keymap to close with 'C-c C-c'
  (split-window-vertically -15)
  (other-window 1)
  (set-buffer buffer))

(setq server-window #'dw/show-server-edit-buffer)
#+end_src
** expand region
#+begin_src emacs-lisp
 (use-package expand-region
  :bind (("M-[" . er/expand-region)
     ("C--" . er/contract-region)
         ("C-(" . er/mark-outside-pairs)))

#+end_src

#+RESULTS:
: er/mark-outside-pairs

* EMMS
One of the media players available for Emacs is emms, which stands for Emacs Multimedia System.  By default, Doom Emacs does not use 'SPC a',' so the format I use for these bindings is 'SPC a' plus 'key'.

| COMMAND               | DESCRIPTION                       | KEYBINDING |
|-----------------------+-----------------------------------+------------|
| emms-playlist-mode-go | /Switch to the playlist buffer/     | SPC a a    |
| emms-pause            | /Pause the track/                   | SPC a x    |
| emms-stop             | /Stop the track/                    | SPC a s    |
| emms-previous         | /Play previous track in playlist/   | SPC a p    |
| emms-next             | /Play next track in playlist/       | SPC a n    |

#+begin_src emacs-lisp
(use-package versuri
  :config
  (defun op/versuri-select ()
    (interactive)
    (when-let (match (call-interactively #'versuri-search))
      (apply #'versuri-display match))))

(use-package emms
  :commands (emms)
  :bind ("C-c e" . hydra-emms/body)
  :config
  (setq emms-source-file-default-directory "~/music/"
        emms-mode-line-format "「%s」"
        emms-browser-covers 'emms-browser-cache-thumbnail-async)

  (require 'emms-setup)
  (emms-all)
  (emms-default-players)
  (emms-playing-time-disable-display)

  (add-to-list 'emms-player-base-format-list "opus")
  ;; re-compute the regxp for mpv
  (emms-player-set emms-player-mpv 'regex
                   (apply #'emms-player-simple-regexp emms-player-base-format-list))

  ;; save on quit and recover on startup
  (require 'emms-history)
  (emms-history-load)

  ;; use libtag to extract tracks info.
  ;;
  ;; XXX: this needs to be compiled from sources
  ;; (~/.emacs.d/straight/repos/emms/) and cp emms-print-metadata
  ;; ~/bin.
  (require 'emms-info)
  (require 'emms-info-libtag)
  (setq emms-info-functions '(emms-info-libtag))
  (setq emms-info-libtag-known-extensions
        (regexp-opt '("opus" "mp3" "mp4" "m4a" "ogg" "flac" "spx" "wma")))

  (defun my/tick-symbol (x)
    "Return a tick if X is true-ish."
    (if x "x" " "))

  (defun my/emms-player-status ()
    "Return the state of the EMMS player: `not-active', `playing', `paused' or `dunno'.

Modeled after `emms-player-pause'."
    (cond ((not emms-player-playing-p)
           ;; here we should return 'not-active.  The fact is that
           ;; when i change song, there is a short amount of time
           ;; where we are ``not active'', and the hydra is rendered
           ;; always during that short amount of time.  So we cheat a
           ;; little.
           'playing)

          (emms-player-paused-p
           (let ((resume (emms-player-get emms-player-playing-p 'resume))
                 (pause (emms-player-get emms-player-playing-p 'pause)))
             (cond (resume 'paused)
                   (pause  'playing)
                   (t      'dunno))))
          (t (let ((pause (emms-player-get emms-player-playing-p 'pause)))
               (if pause 'playing 'dunno)))))

  (defun my/emms-toggle-time-display ()
    "Toggle the display of time information in the modeline"
    (interactive)
    (if emms-playing-time-display-p
        (emms-playing-time-disable-display)
      (emms-playing-time-enable-display)))

  (defun my/emms-select-song ()
    "Select and play a song from the current EMMS playlist."
    (interactive)
    (with-current-emms-playlist
      (emms-playlist-mode-center-current)
      (let* ((current-line-number (line-number-at-pos))
             (lines (cl-loop
                     with min-line-number = (line-number-at-pos (point-min))
                     with buffer-text-lines = (split-string (buffer-string) "\n")
                     with lines = nil
                     for l in buffer-text-lines
                     for n = min-line-number then (1+ n)
                     do (push (cons l n)
                              lines)
                     finally return (nreverse lines)))
             (selected-line (completing-read "Song: " lines)))
        (when selected-line
          (let ((line (cdr (assoc selected-line lines))))
            (goto-line line)
            (emms-playlist-mode-play-smart)
            (emms-playlist-mode-center-current))))))

  (defun op/emms-current-lyrics ()
    "Find the lyrics for the current song."
    (interactive)
    (let* ((track  (cdr (emms-playlist-current-selected-track)))
           (artist (cdr (assoc 'info-artist (cdr (emms-playlist-current-selected-track)))))
           (title  (cdr (assoc 'info-title (cdr (emms-playlist-current-selected-track))))))
      (versuri-display artist title)))

  (defhydra hydra-emms (:hint nil)
    "
%(my/emms-player-status) %(emms-track-description (emms-playlist-current-selected-track))

^Volume^     ^Controls^       ^Playback^              ^Misc^
^^^^^^^^----------------------------------------------------------------
_d_: inc     _n_: next        _r_: repeat one [% s(my/tick-symbol emms-repeat-track)]     _t_oggle modeline
_o_: dec     _p_: prev        _R_: repeat all [% s(my/tick-symbol emms-repeat-playlist)]     _T_oggle only time
_v_: vol     _a_: seek bw     _#_: shuffle            _s_elect
^ ^          _h_: seek fw     _%_: sort               _g_oto EMMS buffer
^ ^        _SPC_: play/pause                        _l_yrics
^ ^        _DEL_: restart                           _L_yrics select
  "
    ("d" emms-volume-raise)
    ("o" emms-volume-lower)
    ("v" sndio-win-open :exit t)
    ("n" emms-next)
    ("p" emms-previous)
    ("a" emms-seek-backward)
    ("h" emms-seek-forward)
    ("SPC" emms-pause)
    ("DEL" (emms-player-seek-to 0))
    ("<backspace>" (emms-player-seek-to 0))
    ("r" emms-toggle-repeat-track)
    ("R" emms-toggle-repeat-playlist)
    ("#" emms-shuffle)
    ("%" emms-sort)
    ("t" (progn (my/emms-toggle-time-display)
                (emms-mode-line-toggle)))
    ("T" my/emms-toggle-time-display)
    ("s" my/emms-select-song)
    ("g" (progn (emms)
                (with-current-emms-playlist
                  (emms-playlist-mode-center-current))))
    ("l" op/emms-current-lyrics :exit t)
    ("L" op/versuri-select :exit t)

    ("q" nil :exit t)))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25135 524 430308 775000) :init (25135 524 430230 345000) :init-secs (0 0 60438 559000) :use-package-secs (0 0 60525 457000) :config (25135 524 430121 18000) :config-secs (0 0 60291 670000)))

#+BEGIN_SRC emacs-lisp :tangle no
(emms-all)
(emms-default-players)
(emms-mode-line 1)
(emms-playing-time 1)
(setq emms-source-file-default-directory "~/Music/"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t
      emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
(map! :leader
      (:prefix ("y" . "EMMS audio player")
       :desc "Go to emms playlist" "a" #'emms-playlist-mode-go
       :desc "Emms pause track" "x" #'emms-pause
       :desc "Emms stop track" "s" #'emms-stop
       :desc "Emms play previous track" "p" #'emms-previous
       :desc "Emms play next track" "n" #'emms-next))
#+END_SRC

* EVALUATE ELISP EXPRESSIONS
Changing some keybindings from their defaults to better fit with Doom Emacs, and to avoid conflicts with my window managers which sometimes use the control key in their keybindings.  By default, Doom Emacs does not use 'SPC e' for anything, so I choose to use the format 'SPC e' plus 'key' for these (I also use 'SPC e' for 'eww' keybindings).

| COMMAND         | DESCRIPTION                                    | KEYBINDING |
|-----------------+------------------------------------------------+------------|
| eval-buffer     | /Evaluate elisp in buffer/                       | SPC e b    |
| eval-defun      | /Evaluate the defun containing or after point/   | SPC e d    |
| eval-expression | /Evaluate an elisp expression/                   | SPC e e    |
| eval-last-sexp  | /Evaluate elisp expression before point/         | SPC e l    |
| eval-region     | /Evaluate elisp in region/                       | SPC e r    |

#+Begin_src emacs-lisp
(map! :leader
      (:prefix ("e". "evaluate/EWW")
       :desc "Evaluate elisp in buffer" "b" #'eval-buffer
       :desc "Evaluate defun" "d" #'eval-defun
       :desc "Evaluate elisp expression" "e" #'eval-expression
       :desc "Evaluate last sexpression" "l" #'eval-last-sexp
       :desc "Evaluate elisp in region" "r" #'eval-region))
#+END_SRC

* INSERT DATE
Some custom functions to insert the date.  The function 'insert-todays-date' can be used one of three different ways: (1) just the keybinding without the universal argument prefix, (2) with one universal argument prefix, or (3) with two universal argument prefixes.  The universal argument prefix is 'SPC-u' in Doom Emacs (C-u in standard GNU Emacs).  The function 'insert-any-date' only outputs to one format, which is the same format as 'insert-todays-date' without a prefix.

| COMMAND               | EXAMPLE OUTPUT            | KEYBINDING            |
|-----------------------+---------------------------+-----------------------|
| dt/insert-todays-date | Friday, November 19, 2021 | SPC i d t             |
| dt/insert-todays-date | 11-19-2021                | SPC u SPC i d t       |
| dt/insert-todays-date | 2021-11-19                | SPC u SPC u SPC i d t |
| dt/insert-any-date    | Friday, November 19, 2021 | SPC i d a             |

#+begin_src emacs-lisp
(defun dt/insert-todays-date (prefix)
  (interactive "P")
  (let ((format (cond
                 ((not prefix) "%A, %B %d, %Y")
                 ((equal prefix '(4)) "%m-%d-%Y")
                 ((equal prefix '(16)) "%Y-%m-%d"))))
    (insert (format-time-string format))))

(require 'calendar)
(defun dt/insert-any-date (date)
  "Insert DATE using the current locale."
  (interactive (list (calendar-read-date)))
  (insert (calendar-date-string date)))

(map! :leader
      (:prefix ("i d" . "Insert date")
        :desc "Insert any date" "a" #'dt/insert-any-date
        :desc "Insert todays date" "t" #'dt/insert-todays-date))
#+end_src
* Some helper macros
There are a few handy macros added by doom, namely
- ~load!~ for loading external ~.el~ files relative to this one
- ~use-package!~ for configuring packages
- ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
  you load packages with ~require~ or ~use-package~
- ~map!~ for binding new keys

* Miscellaneous

I'd like some slightly nicer default buffer names
#+begin_src emacs-lisp
;; Misc
(defun my/delete-word (arg)
  "Delete characters forward until encountering the end of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (forward-word arg) (point))))

(defun my/backward-delete-word (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (my/delete-word (- arg)))

;; Stolen from: https://stackoverflow.com/questions/2471557/how-to-undo-fill-paragraph-in-emacs
(defun my/unfill-region ()
  (interactive)
  (let ((fill-column (point-max)))
    (fill-region (region-beginning) (region-end) nil)))

(defun my/getenv-tramp (variable &optional keyvalue)
  "Similar to `getenv' but acting on `tramp-remote-process-environment'.
If KEYVALUE is not nil then VARIABLE=VALUE is returned, otherwise
VALUE. When there's no such a VARIABLE set then nil is returned."
  (let ((current-variable-value
        (seq-find (lambda (x)
                       (s-starts-with-p (concat variable "=") x))
                  tramp-remote-process-environment)))
    (when current-variable-value
      (if keyvalue
          current-variable-value
        (car (last (split-string current-variable-value "=")))))))

(defun my/setenv-tramp (variable &optional value)
  "Like `setenv' but acting on `tramp-remote-process-environment'.
Removes the first occurrence of VARIABLE in
`tramp-remote-process-environment' and then adds VARIABLE=VALUE
if VALUE is not nil."
  (setq
   tramp-remote-process-environment
   (delete (my/getenv-tramp variable t)
           tramp-remote-process-environment))
  (when value
    (let ((key-value-pair (format "%s=%s" variable value)))
      (add-to-list 'tramp-remote-process-environment key-value-pair))))

(defun my/switch-to-buffer-if-exists-back-and-forth (to-buffer-name)
  "Switches to to-buffer-name if it exists. If the current buffer is
to-buffer-name then it switches back to the previous buffer."
  (when (get-buffer to-buffer-name)
    (if (string-equal to-buffer-name (buffer-name))
        (switch-to-prev-buffer)
      (switch-to-buffer to-buffer-name))))

(setq my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist nil)
(defun my/bookmark-buffer-or-switch-to-bookmark (arg)
  "Switches to the buffer associated to `last-command-event'.
If there's no mapping configured it sets it. With prefix argument
remaps `last-command-event' to the current buffer. The mapping is
stored in
`my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist'"
  (interactive "P")
  (when arg
    (setq my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist
          (assq-delete-all last-command-event
                           my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist)))
  (let ((buffer (cdr
                 (assq last-command-event
                       my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist))))
    (if buffer
        (if (buffer-live-p buffer)
            (my/switch-to-buffer-if-exists-back-and-forth (buffer-name buffer))
          (ding)
          (message "This buffer has been killed"))
      (add-to-list 'my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist
                   (cons last-command-event (current-buffer)))
      (with-current-buffer (current-buffer)
        (my/exwm-toggle-or-set-buffer-protection nil t))
      (message (format "Added %s as shortcut for buffer <%s>"
                       (key-description (vector last-command-event))
                       (current-buffer))))))


#+end_src

#+RESULTS:
: my/bookmark-buffer-or-switch-to-bookmark

* Workspaces Pers
#+begin_src emacs-lisp :tangle no
;; ¶Workspaces

(use-package perspective
  :demand t
  :bind (("C-M-k" . persp-switch)
         ("C-M-n" . persp-next)
         ("C-x k" . persp-kill-buffer*))
  :custom
  (persp-initial-frame-name "Main")
  :config
  ;; Running `persp-mode' multiple times resets the perspective list...
  (unless (equal persp-mode t)
    (persp-mode)))
#+end_src
* Abberviation
#+begin_src emacs-lisp
;; Where I store the abbreviation I need.

;;; my-abbrev --- Abbrev stuff  -*- lexical-binding: t; -*-
;;; Commentary:

;; This adds various abbrevs for various modes.  Abbrevs are useful to
;; avoid typos, for instance.  To prevent the expansion, type ``word
;; C-q SPC'' instead of ``word SPC''.

;;; Code:

(clear-abbrev-table global-abbrev-table)

(define-abbrev-table 'global-abbrev-table
  '(("prots@" "ports@")

    ("supprots" "supports")

    ("het" "the")
    ("teh" "the")

    ("wehn" "when")

    ("perchè" "perché")
    ("perche" "perché")
    ("nonchè" "nonché")
    ("nonche" "nonché")
    ("quetse" "queste")
    ("sovlgimento" "svolgimento")
    ("sovlgere" "svolgere")
    ("sbagilo" "sbaglio")
    ("caffe" "caffè")))

(when (boundp 'text-mode-abbrev-table)
  (clear-abbrev-table text-mode-abbrev-table))

(define-abbrev-table 'text-mode-abbrev-table
  '(("hw" "hardware")
    ("sw" "software")))

(when (boundp 'clojure-mode-abbrev-table)
  (clear-abbrev-table clojure-mode-abbrev-table))

(define-abbrev-table 'clojure-mode-abbrev-table
  '(("erq" "req")))

(when (boundp 'c-mode-abbrev-table)
  (clear-abbrev-table c-mode-abbrev-table))

(define-abbrev-table 'c-mode-abbrev-table
  '(("inculde" "include")
    ("inlcude" "include")))

;; turn on abbrev mode globally
(setq-default abbrev-mode t)

(provide 'my-abbrev)
;;; my-abbrev.el ends here
#+end_src

#+RESULTS:
: my-abbrev

* OPEN SPECIFIC FILES
Keybindings to open files that I work with all the time using the find-file command, which is the interactive file search that opens with 'C-x C-f' in GNU Emacs or 'SPC f f' in Doom Emacs.  These keybindings use find-file non-interactively since we specify exactly what file to open.  The format I use for these bindings is 'SPC =' plus 'key' since Doom Emacs does not use 'SPC ='.

| PATH TO FILE                   | DESCRIPTION           | KEYBINDING |
|--------------------------------+-----------------------+------------|
| ~/Org/agenda.org               | /Edit agenda file/      | SPC = a    |
| ~/.config/doom/config.org"     | /Edit doom config.org/  | SPC = c    |
| ~/.config/doom/init.el"        | /Edit doom init.el/     | SPC = i    |
| ~/.config/doom/packages.el"    | /Edit doom packages.el/ | SPC = p    |
| ~/.config/doom/eshell/aliases" | /Edit eshell aliases/   | SPC = e a  |
| ~/.config/doom/eshell/profile" | /Edit eshell profile/   | SPC = e p  |

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("=" . "open file")
       :desc "Edit agenda file" "a" #'(lambda () (interactive) (find-file "~/Org/agenda.org"))
       :desc "Edit doom config.org" "c" #'(lambda () (interactive) (find-file "~/.config/doom/config.org"))
       :desc "Edit doom init.el" "i" #'(lambda () (interactive) (find-file "~/.config/doom/init.el"))
       :desc "Edit doom packages.el" "p" #'(lambda () (interactive) (find-file "~/.config/doom/packages.el"))))
(map! :leader
      (:prefix ("= e" . "open eshell files")
       :desc "Edit eshell aliases" "a" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/aliases"))
       :desc "Edit eshell profile" "p" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/profile"))))
#+END_SRC

* ORG MODE
I wrapped most of this block in (after! org).  Without this, my settings might be evaluated too early, which will result in my settings being overwritten by Doom's defaults.  I have also enabled org-journal, org-superstar and org-roam by adding (+journal +pretty +roam2) to the org section of my Doom Emacs init.el.

=NOTE:= I have the location of my Org directory and Roam directory in $HOME/nc/ which is a Nextcloud folder that allows me to instantly sync all of my Org work between my home computer and my office computer.

#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Org babel tangle" "m B" #'org-babel-tangle)
(after! org
  (setq org-directory "~/nc/Org/"
        org-agenda-files '("~/nc/Org/agenda.org")
        org-default-notes-file (expand-file-name "notes.org" org-directory)
        org-ellipsis " ▼ "
        org-superstar-headline-bullets-list '("◉" "●" "○" "◆" "●" "○" "◆")
        org-superstar-item-bullet-alist '((?+ . ?➤) (?- . ?✦)) ; changes +/- symbols in item lists
        org-log-done 'time
        org-hide-emphasis-markers t
        ;; ex. of org-link-abbrev-alist in action
        ;; [[arch-wiki:Name_of_Page][Description]]
        org-link-abbrev-alist    ; This overwrites the default Doom org-link-abbrev-list
          '(("google" . "http://www.google.com/search?q=")
            ("arch-wiki" . "https://wiki.archlinux.org/index.php/")
            ("ddg" . "https://duckduckgo.com/?q=")
            ("wiki" . "https://en.wikipedia.org/wiki/"))
        org-todo-keywords        ; This overwrites the default Doom org-todo-keywords
          '((sequence
             "TODO(t)"           ; A task that is ready to be tackled
             "BLOG(b)"           ; Blog writing assignments
             "GYM(g)"            ; Things to accomplish at the gym
             "PROJ(p)"           ; A project that contains other tasks
             "VIDEO(v)"          ; Video assignments
             "WAIT(w)"           ; Something is holding up this task
             "|"                 ; The pipe necessary to separate "active" states and "inactive" states
             "DONE(d)"           ; Task has been completed
             "CANCELLED(c)" )))) ; Task has been cancelled
#+END_SRC

** Set font sizes for each header level in Org
You can set the Org heading levels to be different font sizes.  So I choose to have level 1 headings to be 140% in height, level 2 to be 130%, etc.  Other interesting things you could play with include adding :foreground color and/or :background color if you want to override the theme colors.
#+begin_src emacs-lisp
(custom-set-faces
  '(org-level-1 ((t (:inherit outline-1 :height 1.4))))
  '(org-level-2 ((t (:inherit outline-2 :height 1.3))))
  '(org-level-3 ((t (:inherit outline-3 :height 1.2))))
  '(org-level-4 ((t (:inherit outline-4 :height 1.1))))
  '(org-level-5 ((t (:inherit outline-5 :height 1.0))))
)
#+end_src

** Org-export
We need ox-man for "Org eXporting" to manpage format and ox-gemini for exporting to gemtext (for the gemini protocol).

=NOTE:= I also enable ox-publish for converting an Org site into an HTML site, but that is done in init.el (org +publish).

#+BEGIN_SRC emacs-lisp
(use-package ox-man)
(use-package ox-gemini)
#+END_SRC

** Org-journal
#+begin_src emacs-lisp
(setq org-journal-dir "~/nc/Org/journal/"
      org-journal-date-prefix "* "
      org-journal-time-prefix "** "
      org-journal-date-format "%B %d, %Y (%A) "
      org-journal-file-format "%Y-%m-%d.org")
#+end_src

** Org-publish
#+begin_src emacs-lisp
(setq org-publish-use-timestamps-flag nil)
(setq org-export-with-broken-links t)
(setq org-publish-project-alist
      '(("distro.tube"
         :base-directory "~/nc/gitlab-repos/distro.tube/"
         :base-extension "org"
         :publishing-directory "~/nc/gitlab-repos/distro.tube/html/"
         :recursive t
         :exclude "org-html-themes/.*"
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t)
         ("org-static"
         :base-directory "~/Org/website"
         :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
         :publishing-directory "~/public_html/"
         :recursive t
         :exclude ".*/org-html-themes/.*"
         :publishing-function org-publish-attachment)
      ))
#+end_src

** Org-roam
| COMMAND                         | DESCRIPTION                     | KEYBINDING  |
|---------------------------------+---------------------------------+-------------|
| org-roam-find-file              | org roam find file              | SPC n r f   |
| org-roam-insert                 | org roam insert                 | SPC n r i   |
| org-roam-dailies-find-date      | org roam dailies find date      | SPC n r d d |
| org-roam-dailies-find-today     | org roam dailies find today     | SPC n r d t |
| org-roam-dailies-find-tomorrow  | org roam dailies find tomorrow  | SPC n r d m |
| org-roam-dailies-find-yesterday | org roam dailies find yesterday | SPC n r d y |

#+begin_src emacs-lisp
(after! org-roam
  (setq org-roam-directory "~/nc/Roam"))
#+end_src

* PERSPECTIVE
Perspective provides multiple named workspaces (or "perspectives") in Emacs, similar to having multiple desktops in window managers like Awesome and XMonad.  Each perspective has its own buffer list and its own window layout, making it easy to work on many separate projects without getting lost in all the buffers.  Switching to a perspective activates its window configuration, and when in a perspective, only its buffers are available (by default).  Doom Emacs uses 'SPC some_key' for binding some of the perspective commands, so I used this binging format for the perspective bindings that I created..

| COMMAND                    | DESCRIPTION                         | KEYBINDING |
|----------------------------+-------------------------------------+------------|
| persp-switch               | Switch to perspective NAME          | SPC DEL    |
| persp-switch-to-buffer     | Switch to buffer in perspective     | SPC ,      |
| persp-next                 | Switch to next perspective          | SPC ]      |
| persp-prev                 | Switch to previous perspective      | SPC [      |
| persp-add-buffer           | Add a buffer to current perspective | SPC +      |
| persp-remove-by-name       | Remove perspective by name          | SPC -      |
| +workspace/switch-to-{0-9} | Switch to workspace /n/               | SPC 0-9    |

#+begin_src emacs-lisp
(map! :leader
      :desc "Switch to perspective NAME" "DEL" #'persp-switch
      :desc "Switch to buffer in perspective" "," #'persp-switch-to-buffer
      :desc "Switch to next perspective" "]" #'persp-next
      :desc "Switch to previous perspective" "[" #'persp-prev
      :desc "Add a buffer current perspective" "+" #'persp-add-buffer
      :desc "Remove perspective by name" "-" #'persp-remove-by-name)
#+end_src

* REGISTERS
Emacs registers are compartments where you can save text, rectangles and positions for later use. Once you save text or a rectangle in a register, you can copy it into the buffer once or many times; once you save a position in a register, you can jump back to that position once or many times.  The default GNU Emacs keybindings for these commands (with the exception of counsel-register) involves 'C-x r' followed by one or more other keys.  I wanted to make this a little more user friendly, and since I am using Doom Emacs, I choose to replace the 'C-x r' part of the key chords with 'SPC r'.

| COMMAND                          | DESCRIPTION                      | KEYBINDING |
|----------------------------------+----------------------------------+------------|
| copy-to-register                 | /Copy to register/                 | SPC r c    |
| frameset-to-register             | /Frameset to register/             | SPC r f    |
| insert-register                  | /Insert contents of register/      | SPC r i    |
| jump-to-register                 | /Jump to register/                 | SPC r j    |
| list-registers                   | /List registers/                   | SPC r l    |
| number-to-register               | /Number to register/               | SPC r n    |
| counsel-register                 | /Interactively choose a register/  | SPC r r    |
| view-register                    | /View a register/                  | SPC r v    |
| window-configuration-to-register | /Window configuration to register/ | SPC r w    |
| increment-register               | /Increment register/               | SPC r +    |
| point-to-register                | /Point to register/                | SPC r SPC  |

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("r" . "registers")
       :desc "Copy to register" "c" #'copy-to-register
       :desc "Frameset to register" "f" #'frameset-to-register
       :desc "Insert contents of register" "i" #'insert-register
       :desc "Jump to register" "j" #'jump-to-register
       :desc "List registers" "l" #'list-registers
       :desc "Number to register" "n" #'number-to-register
       ;; :desc "Interactively choose a register" "r" #'counsel-register
       :desc "Interactively choose a register" "r" #'consult-register
       :desc "View a register" "v" #'view-register
       :desc "Window configuration to register" "w" #'window-configuration-to-register
       :desc "Increment register" "+" #'increment-register
       :desc "Point to register" "SPC" #'point-to-register))
#+END_SRC

#+RESULTS:
: point-to-register

* SHELLS
** shell-pop
  #+begin_src emacs-lisp
    (use-package shell-pop
      :bind (("<f4>" . shell-pop))
      :config
      (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
      (setq shell-pop-term-shell "/bin/fish")
      (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type))
  #+end_src

  #+RESULTS:
  : shell-pop

** Eshell
#+begin_src emacs-lisp
(use-package eshell-bookmark
  :after eshell
  :config
  (add-hook 'eshell-mode-hook #'eshell-bookmark-setup))

(use-package eshell
  :ensure nil
  :hook
  (eshell-mode . (lambda ()
                   (define-key eshell-mode-map (kbd "M-<up>") 'eshell-previous-prompt)
                   (define-key eshell-mode-map (kbd "M-<down>") 'eshell-next-prompt)
                   (define-key eshell-mode-map (kbd "C-c C-o") 'my/eshell-kill-ring-save-outputs)
                   (define-key eshell-mode-map (kbd "C-c o") 'my/eshell-export-last-output)
                   (define-key eshell-mode-map (kbd "C-c r") 'counsel-esh-history)
                   (define-key eshell-mode-map (kbd "C-c d") 'counsel-esh-dir-history)
                   (define-key eshell-mode-map (kbd "C-c l") 'eshell/clear)
                   (define-key eshell-mode-map (kbd "C-<return>") 'my/eshell-send-detached-input)
                   ;; When calling dabbrev, hippie-expand uses strings
                   ;; containing words and symbols to:
                   ;;   1) determine the string to expand
                   ;;   2) determine what to expand it with
                   ;; (see hippie-expand-dabbrev-as-symbol)
                   ;; so for instance if I'm typing "curl foo/bar" on
                   ;; an eshell buffer, as "/" is a symbol in eshell
                   ;; mode, it will use "foo/bar" as string to
                   ;; expand. In some cases this is undesirable, for
                   ;; instance when completing URLs, as it's more
                   ;; likely that I'll want to expand the current
                   ;; component ("bar"), not the whole URL. Moving "/"
                   ;; to a non-symbol syntax class works around
                   ;; this. I can't just set
                   ;; hippie-expand-dabbrev-as-symbol to false because
                   ;; if I did h-e wouldn't expand FQDNs, i.e. "bar"
                   ;; would be expanded to "barhost" and not
                   ;; "barhost.example.org"
                   (modify-syntax-entry ?/ "|")))
  :config
  (defun my/eshell-kill-ring-save-outputs ()
    "Add to the kill ring CURRENT-PREFIX-ARG outputs, including prompts.
If no universal argument is passed, assume only one output"
    (interactive)
    (save-excursion
      (let (times)
        (if (or (null current-prefix-arg) (< current-prefix-arg 1))
            (setq times 1)
          (setq times current-prefix-arg))
        (eshell-previous-prompt times)
        (forward-line -1) ; Two lines prompt
        (beginning-of-line)
        (message (format "Shell output added to the kill ring (%d commands)" times))
        (kill-ring-save (point) (eshell-end-of-output)))))

  ;; Inspiration from:
  ;; https://github.com/protesilaos/dotfiles/blob/master/emacs/.emacs.d/prot-lisp/prot-eshell.el
  (defun my/eshell-export-last-output ()
    "Produce a buffer with output of the last Eshell command."
    (interactive)
    (let ((eshell-output (buffer-substring-no-properties
                          (eshell-beginning-of-output)
                          (eshell-end-of-output))))
      (with-current-buffer (get-buffer-create "*Exported Eshell output*")
        (erase-buffer)
        (insert eshell-output)
        (switch-to-buffer-other-window (current-buffer)))))
  (defun eshell/tcd (&optional directory)
    "Change the default directory to DIRECTORY but TRAMP-aware.
Like `eshell/cd' but taking into account that the current
directory might be in a remote file system. If that's the case,
the current TRAMP root is prepended to DIRECTORY."
    (let ((tramp-root (file-remote-p default-directory)))
      (if tramp-root
          (eshell/cd (concat tramp-root (or directory "")))
        (eshell/cd directory))))
  (defun my/eshell-send-detached-input (&optional arg)
    "Send the current Eshell input to a compilation buffer.
With universal prefix argument bury the compilation buffer and
send a notification when the process has exited."
    (interactive "p")
    (when-let* ((cmd (buffer-substring
                      eshell-last-output-end (point-max)))
                (cmd-present-p (not (string-empty-p cmd))))
      (let* ((hostname (or
                        (file-remote-p default-directory 'host)
                        (system-name)))
             (compile-command nil)
             (compilation-save-buffers-predicate 'ignore)
             (compilation-scroll-output nil)
             (compilation-buffer
              (compilation-start
               cmd
               nil
               (lambda (major-mode)
                 (format "D#%x %s" (random (expt 2 16)) cmd)))))
        (when (equal arg 4)
          (with-current-buffer compilation-buffer
            (switch-to-prev-buffer (get-buffer-window (current-buffer)))
            (setq-local compilation-finish-functions
                        `((lambda (buffer str)
                            (notifications-notify
                             :body (format "%s # %s" ,hostname ,cmd)
                             :timeout 8000
                             :category "detached_process"
                             :actions '("default" "Switch to buffer")
                             :on-action (lambda (id key) (switch-to-buffer-other-window ,(buffer-name compilation-buffer)))
                             :title (format "Process %s!" (string-chop-newline str))
                             :urgency (if (string-prefix-p "finished" str) 'normal 'critical)))))))
        (eshell-add-input-to-history cmd)
        (eshell-reset))))
  (setenv "EDITOR" "emacsclient")
  (add-to-list 'directory-abbrev-alist '("/home/ibarrien" . "~"))
  (add-to-list 'directory-abbrev-alist '("/afs/cern.ch/user/i/ibarrien" . "~"))
  :custom
  (eshell-banner-message "")
  (eshell-history-size 20000)
  (eshell-scroll-to-bottom-on-input 'all)
  (eshell-scroll-to-bottom-on-output 'all))
;; (use-package em-hist
;;   :ensure nil
;;   :bind (:map eshell-hist-mode-map
;;               ("<up>" . previous-line)
;;               ("<down>" . next-line)))

(use-package eshell-prompt-extras
  :after (eshell)
  :config
  (defun my/epe-theme-prompt ()
    (setq eshell-prompt-regexp "^λ ")
    (concat
     (let ((prompt-path (epe-fish-path (tramp-file-local-name (eshell/pwd)))))
       (format
        (epe-colorize-with-face "[%s]" 'epe-remote-face)
        (epe-colorize-with-face
         (if (string-empty-p prompt-path)
             "/"
           prompt-path)
         'epe-dir-face)))
     (if (epe-remote-p)
         (epe-colorize-with-face
          (concat "@" (epe-remote-host))
          'epe-remote-face)
       (epe-colorize-with-face
        (concat "@" (system-name))
        'epe-git-face))
     (if (eshell-exit-success-p)
         (epe-colorize-with-face "\nλ" 'success)
       (epe-colorize-with-face "\nλ" 'error))
     " "))
  (with-eval-after-load "esh-opt"
    (setq eshell-highlight-prompt nil
          eshell-prompt-function 'my/epe-theme-prompt)))



#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25132 63247 302725 802000) :init (25132 63247 302693 311000) :config (25132 63247 302654 910000) :config-secs (0 0 1628 494000) :init-secs (0 0 1720 773000) :use-package-secs (0 0 1850 984000)))

Settings for the various shells and terminal emulators within Emacs.
+ 'shell-file-name' -- sets the shell to be used in M-x shell, M-x term, M-x ansi-term and M-x vterm.
+ 'eshell-aliases-file' -- sets an aliases file for the eshell.

#+BEGIN_SRC emacs-lisp
(setq shell-file-name "/bin/bash"
      vterm-max-scrollback 5000)
(setq eshell-rc-script "~/.config/doom/eshell/profile"
      eshell-aliases-file "~/.config/doom/eshell/aliases"
      eshell-history-size 5000
      eshell-buffer-maximum-lines 5000
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      eshell-destroy-buffer-when-process-dies t
      eshell-visual-commands'("bash" "fish" "htop" "ssh" "top" "zsh"))
(map! :leader
      :desc "Eshell" "e s" #'eshell
      :desc "Eshell popup toggle" "e t" #'+eshell/toggle
      ;; :desc "Counsel eshell history" "e h" #'counsel-esh-history
      :desc "Counsel eshell history" "e h" #'+eshell/search-history
      :desc "Vterm popup toggle" "v t" #'+vterm/toggle)
#+END_SRC

#+RESULTS:
: +vterm/toggle

** eshell ex
#+begin_src emacs-lisp :tangle no
;; Eshell is the Emacs Shell. It's a strange combo, because it isn't a full-blown elisp REPL like ielm, but neither a UNIX shell like shell. It seems fun to use though.

(use-package eshell
  :bind (("C-c e" . op/eshell))
  :hook (eshell-mode . op/setup-eshell)
  :custom ((eshell-compl-dir-ignore
            "\\`\\(\\.\\.?\\|CVS\\|\\.svn\\|\\.git\\|\\.got\\)/\\'")
           (eshell-save-history-on-exit t)
           (eshell-prompt-regexp "[#$] ")
           (eshell-prompt-function (lambda () "$ "))
           (eshell-history-size 1024))
  :config
  ;; <<eshell/aliases>>

  ;; <<eshell/cl>>

  (defun op/eshell-bufname (dir)
    (concat "*eshell " (expand-file-name dir) "*")))

  ;; <<eshell/after-cd>>

  (defun op/eshell (arg)
    "Run or jump to eshell in the current project.
If called with a prefix argument ARG, always create a new eshell
buffer."
    (interactive "P")
    (let* ((proj (project-current))
           (dir (cond (proj (project-root proj))
                      (t default-directory)))
           (default-directory dir)
           (eshell-buffer-name (let ((name (op/eshell-bufname dir)))
                                 (if arg
                                     (generate-new-buffer name)
                                   name))))
      (eshell)))

  ;; <<op/append-to-buffer>>

  ;; <<op/eshell-narrow-to-output>>

  ;; <<op/setup-eshell>>)
;; I like to sync the $PWD with the buffer name, so an eshell in my home has as buffer name *eshell /home/op*.

;; <2021-06-16 Wed> Instead of advice-add I should use the eshell-directory-change-hook hook.

(defun op/eshell-after-cd (&rest _)
  (rename-buffer (op/eshell-bufname default-directory) t))

(advice-add #'eshell/cd :after #'op/eshell-after-cd)
;; To define custom commands in eshell (what would be functions or scripts in other shells), say whatever, one can define a eshell/whatever function. These are some aliases I find useful:

(defun eshell/emacs (&rest args)
  "Open a file in emacs (from the wiki)."
  (if (null args)
      (bury-buffer)
    (mapc #'find-file
          (mapcar #'expand-file-name
                  (eshell-flatten-list (nreverse args))))))

(defalias 'eshell/less #'find-file)

(defun eshell/dired ()
  (dired (eshell/pwd)))
;; cl is a better clear function, because the built in clear is a joke.

(defun eshell/cl ()
  "Clear the eshell buffer."
  (let ((inhibit-read-only t))
    (erase-buffer)))
;; Eshell can interact with other Emacs buffers, but the syntax is quite verbose. op/append-to-buffer (bound to C-c C-B) helps with this: it prompts for a buffer and inserts (but not execute) the redirect. This is especially useful when working with the OpenBSD ports tree: I can type cvs -q diff and then C-c C-B to redirect the diff to the mail buffer!

(defun op/append-to-buffer (buf)
  (interactive "Bbuffer: ")
  (insert ">>> " "#<" buf ">"))
;; Being able to narrow to the output of the command at point seems very useful, so here's a quick implementation:

(defun op/eshell-narrow-to-output ()
  "Narrow to the output of the command at point."
  (interactive)
  (save-excursion
    (let* ((start (progn (eshell-previous-prompt 1)
                         (forward-line +1)
                         (point)))
           (end (progn (eshell-next-prompt 1)
                       (forward-line -1)
                       (point))))
      (narrow-to-region start end))))
;; Eshell unfortunately doesn't uses from comint, so it lacks some niceties that were added to it. One of these things is the minibuffer completion for history navigation. I like to select an history item using the minibuffer:

(defun op/eshell-select-from-history ()
  (interactive)
  (let ((item (completing-read "Select from history: "
                               (seq-uniq (ring-elements eshell-history-ring)))))
    (when item
      ;; from eshell-previous-matching-input
      (delete-region eshell-last-output-end (point))
      (insert-and-inherit item))))
;; The weirdest thing about eshell is how it manages its own keys. eshell-mode-map, unlike other *-mode-map variables, is buffer-local, so a

;; just an example!
(define-key eshell-mode-map (kbd "...") #'some-function)
;; won't work. One needs to define a function and call it during the eshell-mode-hook like this:

(defun op/setup-eshell ()
  (define-key eshell-mode-map (kbd "C-c C-B") #'op/append-to-buffer)
  (define-key eshell-mode-map (kbd "C-c M-l") #'op/eshell-narrow-to-output)
  (message "before binding M-r")
  (define-key eshell-mode-map (kbd "M-r") #'op/eshell-select-from-history))
#+end_src

#+RESULTS:
: op/setup-eshell
** eshell recom
#+begin_src emacs-lisp :tangle no

;;;; The Emacs shell

;; This is like HISTCONTROL=ignorespace:ignoredups and 'shopt -s histappend'
;; in my ~/.bashrc: append most commands to the shared history file, but don't
;; load that file except when a fresh Eshell buffer is created.
(setq eshell-save-history-on-exit nil)
(defun spw/eshell-append-history ()
  (when (and eshell-history-file-name
	     (symbolp (file-locked-p eshell-history-file-name)))
    (unless (get-buffer " *eshell history*")
      (lock-file eshell-history-file-name)
      (with-current-buffer (get-buffer-create " *eshell history*" t)
	(when (file-exists-p eshell-history-file-name)
	  (insert-file-contents eshell-history-file-name))))
    (let ((latest (substring-no-properties (ring-ref eshell-history-ring 0))))
      (with-current-buffer (get-buffer " *eshell history*")
	(let* ((nlines (car (buffer-line-statistics)))
	       (excess (- nlines eshell-history-size))
	       (previous
		(and (cl-plusp nlines)
		     (save-excursion
		       (goto-char (1- (point-max)))
		       (buffer-substring
			(line-beginning-position) (line-end-position))))))
	  (unless (or (string-match "^\\s-" latest)
		      (and previous (string= previous latest)))
	    (unless (cl-minusp excess)
	      (forward-line (1+ excess))
	      (delete-region (point-min) (point)))
	    (save-excursion
	      (goto-char (point-max))
	      (let ((start (point)))
		(insert latest "\n")
		(subst-char-in-region start (1- (point)) ?\n ?\177)))
	    (write-region (point-min) (point-max) eshell-history-file-name nil
			  'silent)))))))
(with-eval-after-load 'esh-cmd
  (add-hook 'eshell-pre-command-hook #'spw/eshell-append-history))
;; also see below removal of `eshell-write-history' from `eshell-exit-hook'

(defun spw/eshell-cd (dir)
  (delete-region eshell-last-output-end (point-max))
  (when (> eshell-last-output-end (point))
    (goto-char eshell-last-output-end))
  (insert-and-inherit "cd " (eshell-quote-argument dir))
  (eshell-send-input))

;;; Ideas behind the following three functions due to Protesilaos Stavrou.

(defun spw/eshell-search-history ()
  (interactive)
  (when (> eshell-last-output-end (point))
    (error "Point not located after prompt"))
  (let* ((icomplete-prospects-height 3)
	 (input
	  (completing-read
	   "Previous input: " (ring-elements eshell-history-ring) nil t)))
    (delete-region eshell-last-output-end (point))
    (insert-and-inherit input)))
(with-eval-after-load 'em-hist
  (define-key eshell-hist-mode-map "\M-r" #'spw/eshell-search-history))
(with-eval-after-load 'em-smart
  (add-to-list 'eshell-smart-display-navigate-list 'spw/eshell-search-history))

(defun spw/eshell-cd-recent-dir (&optional arg)
  (interactive "P")
  (let ((directory (completing-read
		    (if arg
			"Dired in other window (directory): "
		      "Switch to directory: ")
		    (ring-elements eshell-last-dir-ring) nil t)))
    (if arg (dired-other-window directory) (spw/eshell-cd directory))))
(with-eval-after-load 'em-hist
  (define-key eshell-hist-mode-map "\C-z\C-d" #'spw/eshell-cd-recent-dir))
;; With this set to nil, recent dirs are not saved to disk, such that the
;; history of recent dirs is effectively bufer-local.
(setq eshell-last-dir-ring-file-name nil)

(defun spw/eshell-cd-project-root ()
  (interactive)
  (if-let ((project (project-current)))
      (spw/eshell-cd (project-root project))
    (user-error "No current project")))
(with-eval-after-load 'esh-mode
  (define-key eshell-mode-map "\C-z\C-r" #'spw/eshell-cd-project-root))

(with-eval-after-load 'eshell
  (dolist (module '(eshell-tramp))
    (add-to-list 'eshell-modules-list module)))

(defun spw/insert-last-argument ()
  (interactive)
  (insert "$_"))

;; seems `eshell-mode-map' is globally nil
(defun spw/define-eshell-keys ()
  (define-key eshell-mode-map "/" #'spw/eshell-self-insert-/)
  (define-key eshell-mode-map "\M-." #'spw/insert-last-argument)
  (remove-hook 'eshell-exit-hook #'eshell-write-history))
(add-hook 'eshell-mode-hook #'spw/define-eshell-keys)

(spw/reclaim-keys-from em-hist eshell-hist-mode-map [up] [down])

;;; prompt

;; Previously used "~/>" -- no trailing space -- where we appended the
;; additional forward slash at the end of the pwd as otherwise it is a bit too
;; short when we're directly inside HOME.  An alternative approach used before
;; that was to call `abbreviate-file-name' only when not directly inside HOME.
(setq eshell-prompt-function
      (lambda ()
	(if (zerop eshell-last-command-status)
	    (concat (abbreviate-file-name (eshell/pwd)) " % ")
	  (format "%s %s %% " eshell-last-command-status
		  (abbreviate-file-name (eshell/pwd)))))
      eshell-prompt-regexp "^[^%\n]* % ")

;;; misc. functions

(defun spw/default-directory-tramp-prefix ()
  "Return the TRAMP part of `default-directory'."
  (substring
   default-directory 0
   (string-match
    (tramp-file-name-localname (tramp-dissect-file-name default-directory))
    default-directory)))

;; Maybe this ought to be in `post-self-insert-hook'?
(defun spw/eshell-self-insert-/ ()
  "Intelligently insert TRAMP part of `default-directory' in remote Eshells."
  (interactive)
  (let ((tilde-before (eq ?~ (char-before)))
	(command
	 (save-excursion
	   (eshell-bol) (skip-syntax-forward " ") (thing-at-point 'sexp))))
    (if (and (file-remote-p default-directory)
	     (or (= (point) eshell-last-output-end)
		 (and tilde-before (= (1- (point)) eshell-last-output-end))
		 (and (or tilde-before (eq ?  (char-syntax (char-before))))
		      (or (eshell-find-alias-function command)
			  (and (fboundp (intern-soft command))
			       (or eshell-prefer-lisp-functions
				   (not (eshell-search-path command))))))))
	(let ((map (make-sparse-keymap))
	      (start (if tilde-before (1- (point)) (point))))
	  (when tilde-before (delete-char -1))
	  (insert (spw/default-directory-tramp-prefix))
	  (unless tilde-before (insert "/"))
	  ;; Typing a second slash undoes the insertion, for when you really
	  ;; do want to type a local absolute path.
	  (define-key map "/" (lambda ()
				(interactive)
				(delete-region start (point))
				(insert (if tilde-before "~/" "/"))))
	  (set-transient-map map))
      (insert "/"))))
(with-eval-after-load 'em-smart
  (add-to-list 'eshell-smart-display-navigate-list #'spw/eshell-self-insert-/))

;;; getting to Eshell buffers

(defun spw/eshell-jump (arg &optional chdir)
  "Pop to *eshell*, and offer cycling among other Eshells, unless
one of the following special circumstances applies:

- If a command is running in *eshell*, rename that buffer out of
  the way and start a new one.  Similarly if the buffer is
  narrowed; that was probably done with C-u C-c C-r, and the
  buffer is similarly in use.

- If CHDIR, and there is no Eshell in `default-directory', also
  change the directory of *eshell* to `default-directory'.

- If CHDIR and there is an Eshell in `default-directory',
  including one generated by `project-eshell', switch to that
  Eshell instead of *eshell*.

- If both ARG and CHDIR, or if CHDIR and the current buffer is an
  Eshell buffer which is not running a command, unconditionally
  start a new Eshell in `default-directory'.

- If not CHDIR and the current buffer is *eshell*, activate
  transient cycling to make it easy to get back to another
  Eshell.  (This is the only case in which we do not use
  `pop-to-buffer' or equivalent, so C-x 4 4 must be used to cycle
  in another window.)

For the purpose of cycling, Eshells generated by `project-eshell'
are sorted below Eshells generated by this function.

The ideas behind this behaviour are as follows.

- Just like Lisp REPLs, we do not normally need a lot of
  different Eshells; it is fine for shell history associated with
  different tasks to become mixed together.  But we do need to
  start a new Eshell when other Eshells are already busy running
  commands.

- Rename *eshell* to *eshell*<N>, but don't ever rename
  *eshell*<N> back to *eshell*, because that is a conventional
  workflow -- M-&, C-h i, M-x ielm, M-x compile etc. always take
  you to the unnumbered buffer, possibly renaming the numbered one
  out of the way.

  This is why we don't try to reuse Eshells especially
  aggressively; for example, we could find an *eshell*<N> not
  running a command a rename it to *eshell*, but we don't.

- Don't pay attention to the current project, as an old version
  of this code did, because if we're using C-c e e and/or C-c e h
  rather than C-x p e, we are probably working in a
  project-agnostic way.

  Thus, among the `project-eshell' Eshells available to cycle
  through, don't prioritise those of the current project (for
  example by moving them to the front) -- if we explicitly want
  those, can use C-x p e.

- Treat C-x p e as the primary way to get to Eshells in project
  roots, and avoid changing the directories of those Eshells, as
  it is surprising when C-x p e doesn't take us to an Eshell
  which is ready to run commands in the project root (another
  possibility would be to change the dir back to the project root
  in this case).

- It is assumed we'll sometimes use C-x 4 1 in front of this
  command, and if we're already in Eshell, we might use C-x 4 4
  to start the cycling in another window."
  (interactive "P")
  (require 'eshell)
  (cl-flet ((project-eshell-eshell-p ()
              (string-match "\\`\\*.+-eshell\\*[><0-9]*\\'" (buffer-name)))
	    (busy-p (buffer)
	      (or (get-buffer-process buffer)
		  (with-current-buffer buffer (buffer-narrowed-p))))
	    (fresh-eshell ()
              (when-let ((buffer (get-buffer eshell-buffer-name)))
		(with-current-buffer buffer (rename-uniquely)))
	      (let ((default-directory
		      (if chdir default-directory (expand-file-name "~"))))
		(eshell))))
    (let ((current-eshell (and (eq major-mode 'eshell-mode)
			       (not (project-eshell-eshell-p))
			       (not (busy-p (current-buffer)))
			       (current-buffer)))
	  (initial-default-directory default-directory)
	  default-directory-eshell
	  project-eshells
	  other-eshells)
      ;; Populate our two lists of all Eshells.
      (dolist (buffer (buffer-list))
	(with-current-buffer buffer
	  (when (eq major-mode 'eshell-mode)
	    (if (and chdir (not default-directory-eshell)
		     (string= default-directory initial-default-directory)
		     (not (busy-p buffer)))
		(setq default-directory-eshell buffer)
	      (push buffer
		    (if (project-eshell-eshell-p)
			project-eshells other-eshells))))))
      ;; Now `pop-to-buffer' if we're going to do that.
      (cond ((and chdir (or arg current-eshell))
	     (fresh-eshell))
	    ((and chdir default-directory-eshell)
	     (pop-to-buffer default-directory-eshell))
	    ((or chdir (not (string= (buffer-name) eshell-buffer-name)))
	     (if-let ((buffer (get-buffer eshell-buffer-name)))
		 (if (busy-p buffer)
		     (fresh-eshell)
		   (pop-to-buffer buffer)
		   (goto-char (point-max))
		   (when chdir (spw/eshell-cd initial-default-directory)))
	       (fresh-eshell)))
	    ;; If `display-buffer-overriding-action' has some entries, pop to
	    ;; ourselves, to allow subsequent cycling to a different Eshell in
	    ;; another window.  E.g. C-x e e C-x 4 4 C-x e e
	    ((cl-find-if-not #'null display-buffer-overriding-action)
	     (pop-to-buffer (current-buffer))))
      ;; Finally, generate and return a ring for cycling purposes.
      (let* ((all (delete (current-buffer)
			  (nconc project-eshells other-eshells)))
	     (ring (make-ring (1+ (length all)))))
	(dolist (buffer all)
	  (ring-insert ring buffer))
	(ring-insert ring (current-buffer))
	ring))))

(defun spw/eshell-jump-from-here (arg)
  (interactive "P")
  (spw/eshell-jump arg t))

(transient-cycles-define-commands ()
  (("\C-cee" . spw/eshell-jump)
   ;; This could be on C-z C-j, like `dired-jump', with corresponding
   ;; C-z 4 C-j and C-z 5 C-j.
   ("\C-ceh" . spw/eshell-jump-from-here))
  (transient-cycles-buffer-ring-cycler :ring ret-val))

;;; my commands -- like defining functions in .bashrc where simple aliases are
;;; not enough

(defun eshell/package-plan-unpack (package)
  (let* ((patches (progn
		    (string-match "\\(.+\\)-\\([^-]+\\)" package)
		    (expand-file-name (concat "~/src/package-plan/patches/"
					      (match-string 1 package)
					      "/"
					      (match-string 2 package))))))
    (make-directory patches t)
    (eshell/cd "/tmp")
    (eshell-command (concat "cabal unpack --pristine " package))
    (make-symbolic-link patches (concat "/tmp/" package "/patches"))
    (eshell/cd (concat "/tmp/" package))
    (eshell-command "ls ${readlink patches}")))
#+end_src

* Box Quote

boxquote.el provides a set of functions for using a text quoting style that partially boxes in the left hand side of an area of text, such a marking style might be used to show externally included text or example code.

This is how a boxquote looks:

╭────[ Lorem ipsum ]
│ Nullam eu ante vel est convallis dignissim.  Fusce suscipit, wisi nec facilisis
│ facilisis, est dui fermentum leo, quis tempor ligula erat quis odio.  Nunc porta
│ vulputate tellus.  Nunc rutrum turpis sed pede.  Sed bibendum.  Aliquam posuere.
│ Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
│ varius mi purus non odio.  Pellentesque condimentum, magna ut suscipit
│ hendrerit, ipsum augue ornare nulla, non luctus diam neque sit amet urna.
╰────

#+begin_src emacs-lisp
(use-package boxquote
;;:ensure t
  :defer t
  :config
  (setq-default  boxquote-bottom-corner "╰"      ; U+2570
                 boxquote-side          "│ "     ; U+2572 + space
                 boxquote-top-and-tail  "────"   ; U+2500 (×4)
                 boxquote-top-corner    "╭")     ; U+256F
  (when (package-installed-p 'hydra)
    (eval-and-compile
      (defhydra hydra-boxquote (:color blue :hint nil)
       "
                                                                    ╭──────────┐
  Text           External           Apropos         Do              │ Boxquote │
╭───────────────────────────────────────────────────────────────────┴──────────╯
  [_r_] region        [_f_] file      [_K_] describe-key        [_t_] title
  [_p_] paragraph     [_b_] buffer    [_F_] describe-function   [_u_] unbox
  [_a_] buffer        [_s_] shell     [_V_] describe-variable   [_w_] fill-paragraph
  [_e_] text           ^ ^            [_W_] where-is            [_n_] narrow
  [_d_] defun         [_y_] yank       ^ ^                      [_c_] narrow to content
  [_q_] boxquote      [_Y_] yanked     ^ ^                      [_x_] kill
--------------------------------------------------------------------------------
       "
      ("<esc>" nil "quit")
      ("x" boxquote-kill)
      ("Y" boxquote-yank)
      ("e" boxquote-text)
      ("u" boxquote-unbox)
      ("d" boxquote-defun)
      ("t" boxquote-title)
      ("r" boxquote-region)
      ("a" boxquote-buffer)
      ("q" boxquote-boxquote)
      ("W" boxquote-where-is)
      ("p" boxquote-paragraph)
      ("f" boxquote-insert-file)
      ("K" boxquote-describe-key)
      ("s" boxquote-shell-command)
      ("b" boxquote-insert-buffer)
      ("y" boxquote-kill-ring-save)
      ("w" boxquote-fill-paragraph)
      ("F" boxquote-describe-function)
      ("V" boxquote-describe-variable)
      ("n" boxquote-narrow-to-boxquote)
      ("c" boxquote-narrow-to-boxquote-content)))))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package (25088 11393 498837 905000) :init (25088 11393 498812 216000) :init-secs (0 0 311 648000) :use-package-secs (0 0 2107 22000)))

* Eaf
** Eaf  Core
#+begin_src emacs-lisp

(add-to-list 'load-path "~/.emacs.d/site-lisp/emacs-application-framework/")
;; (require 'eaf')
(use-package eaf
  :load-path "~/.emacs.d/site-lisp/emacs-application-framework"
  :custom
  (eaf-browser-continue-where-left-off t)
  (eaf-browser-enable-adblocker t)
  (browse-url-browser-function 'eaf-open-browser)
  :config
  (defalias 'browse-web #'eaf-open-browser))
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
 (require 'eaf-pdf-viewer)
 (require 'eaf-rss-reader)
 (require 'eaf-markdown-previewer)
 (require 'eaf-demo)
 (require 'eaf-airshare)
 ;; (require 'eaf-mermaid)
 (require 'eaf-file-sender)
 (require 'eaf-video-player)
 (require 'eaf-vue-demo)
 (require 'eaf-jupyter)
 (require 'eaf-browser)
 (require 'eaf-terminal)
 (require 'eaf-mindmap)
 (require 'eaf-music-player)
 (require 'eaf-system-monitor)
 (require 'eaf-file-browser)
 (require 'eaf-camera)
 (require 'eaf-org-previewer)
 (require 'eaf-org)
 (require 'eaf-netease-cloud-music)
 (require 'eaf-image-viewer)
 (require 'eaf-file-manager)
 (require 'eaf-evil)
(setq eaf-browser-translate-language "es")
(setq eaf-browser-continue-where-left-off t)
(setq eaf-browser-download-path "~/Downloads/")
  ;; (eaf-bind-key scroll_up "C-n" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key scroll_down "C-p" eaf-pdf-viewer-keybinding)
  ;; (eaf-bind-key take_photo "p" eaf-camera-keybinding)
  ;; (eaf-bind-key nil "M-q" eaf-browser-keybinding)) ;; unbind, see more in the Wiki
(setq eaf-mindmap-dark-mode "follow") ; default option
(setq eaf-browser-dark-mode "force")
(setq eaf-terminal-dark-mode nil)
(setq eaf-pdf-dark-mode "ignore") ; see below
;; (setq eaf-browser-aria2-proxy-host "127.0.0.1")
;; (setq eaf-browser-aria2-proxy-port "9888")
;; sudo systemctl start privoxy
;; (setq eaf-browser-remember-history nil)
(setq eaf-browser-default-search-engine "duckduckgo")
(setq eaf-browse-blank-page-url "https://duckduckgo.com")
;; (setq eaf-browser-default-zoom 1.25)
;; (setq eaf-browser-enable-plugin nil)
;; (setq eaf-browser-enable-javascript nil)
;; (setq eaf-camera-save-path "new/path/")
(setq eaf-music-play-order "random")
(defcustom eaf-music-default-file nil "~/Music/"
  :type 'file)
(defun eaf-org-open-file (file &optional link)
  "An wrapper function on `eaf-open'."
  (eaf-open file))

;; use `emacs-application-framework' to open PDF file: link
(add-to-list 'org-file-apps '("\\.pdf\\'" . eaf-org-open-file))

#+end_src

#+RESULTS:
: ((\.pdf\' . eaf-org-open-file) (remote . emacs) (auto-mode . emacs) (directory . emacs) (\.mm\' . default) (\.x?html?\' . default) (\.pdf\' . default))
#+begin_src emacs-lisp
(require 'eaf-evil)

(define-key key-translation-map (kbd "SPC")
    (lambda (prompt)
      (if (derived-mode-p 'eaf-mode)
          (pcase eaf--buffer-app-name
            ("browser" (if  (string= (eaf-call-sync "call_function" eaf--buffer-id "is_focus") "True")
                           (kbd "SPC")
                         (kbd eaf-evil-leader-key)))
            ("pdf-viewer" (kbd eaf-evil-leader-key))
            ("image-viewer" (kbd eaf-evil-leader-key))
            (_  (kbd "SPC")))
        (kbd "SPC"))))

#+end_src
** Awesome Tab eaf
AceJump
Call command awesome-tab-ace-jump, and a sequence of 1 or 2 characters will show on tabs in the current tab group. Type them to jump to that tab.

Customize awesome-tab-ace-keys to specify the used characters. The default value is j, k, l, s, d, f. Notice that this variable has the custom-set attribute, so setq won't work. Use customize-set-variable instead.

Customize awesome-tab-ace-str-style to specify the position of ace sequences on the tab. You can choose 'replace-icon, 'left or 'right.

Customize awesome-tab-ace-quit-keys to specify keys used to quit from ace jumping. The default value is '(?\C-g ?q ?\s), you can press C-g q or SPC to quit from ace jumping. Anyway, you can customize any other keys you like.


#+begin_src emacs-lisp :tangle no

(use-package awesome-tab
  :load-path "~/.emacs.d/site-lisp/awesome-tab"
  :config
  :defer t)
  ;; (awesome-tab-mode nil))
;; (setq awesome-tab-ace-quit-keys '(?\C-g))

(defhydra awesome-fast-switch (:hint nil)
  "
 ^^^^Fast Move             ^^^^Tab                    ^^Search            ^^Misc
-^^^^--------------------+-^^^^---------------------+-^^----------------+-^^---------------------------
   ^_k_^   prev group    | _C-a_^^     select first | _b_ search buffer | _C-k_   kill buffer
 _h_   _l_  switch tab   | _C-e_^^     select last  | _g_ search group  | _C-S-k_ kill others in group
   ^_j_^   next group    | _C-j_^^     ace jump     | ^^                | ^^
 ^^0 ~ 9^^ select window | _C-h_/_C-l_ move current | ^^                | ^^
-^^^^--------------------+-^^^^---------------------+-^^----------------+-^^---------------------------
"
  ("h" awesome-tab-backward-tab)
  ("j" awesome-tab-forward-group)
  ("k" awesome-tab-backward-group)
  ("l" awesome-tab-forward-tab)
  ("0" my-select-window)
  ("1" my-select-window)
  ("2" my-select-window)
  ("3" my-select-window)
  ("4" my-select-window)
  ("5" my-select-window)
  ("6" my-select-window)
  ("7" my-select-window)
  ("8" my-select-window)
  ("9" my-select-window)
  ("C-a" awesome-tab-select-beg-tab)
  ("C-e" awesome-tab-select-end-tab)
  ("C-j" awesome-tab-ace-jump)
  ("C-h" awesome-tab-move-current-tab-to-left)
  ("C-l" awesome-tab-move-current-tab-to-right)
  ("b" ivy-switch-buffer)
  ("g" awesome-tab-counsel-switch-group)
  ("C-k" kill-current-buffer)
  ("C-S-k" awesome-tab-kill-other-buffers-in-current-group)
  ("q" nil "quit"))
;; Awesome tab hide some tabs with regular expression that controller by function awesome-tab-hide-tab-function
;; Default hide function is awesome-hide-tab


(defun awesome-tab-hide-tab (x)
  (let ((name (format "%s" x)))
    (or
     (string-prefix-p "*epc" name)
     (string-prefix-p "*helm" name)
     (string-prefix-p "*Compile-Log*" name)
     (string-prefix-p "*lsp" name)
     (and (string-prefix-p "magit" name)
               (not (file-name-extension name)))
     )))

;; Icon
;; If you have install AllTheIcons successfully. AwesomeTab will render file icon in tab automatically.

;; If you dislike icon render in tab and still need use all-the-icons plugin, you can set variable awesome-tab-display-icon with nil.

;; Theme
;; Tab color will change with current theme, you don't need customize the color tab.

;; Emacs may not detect your theme style (light/dark) in the terminal correctly. You may need to set frame-background-mode manually to have correct tab (and text) colors:

(when (not (display-graphic-p))
  (setq frame-background-mode 'dark))
;; or you like light theme more:

;; (when (not (display-graphic-p))
;;   (setq frame-background-mode light))

;; You can customize terminal tab face by below options:
;; awesome-tab-terminal-dark-select-background-color
;; awesome-tab-terminal-dark-select-foreground-color
;; awesome-tab-terminal-dark-unselect-background-color
;; awesome-tab-terminal-dark-unselect-foreground-color
;; awesome-tab-terminal-light-select-background-color
;; awesome-tab-terminal-light-select-foreground-color
;; awesome-tab-terminal-light-unselect-background-color
;; awesome-tab-terminal-light-unselect-foreground-color

;; Tab will hide if awesome-tab-hide-tab-function return t, you can write your own code to customize hide rules.

;; GroupRules
;; Awesome tab use awesome-tab-buffer-groups-function to control tab group. Default group function is awesome-tab-buffer-groups

(defun awesome-tab-buffer-groups ()
  "`awesome-tab-buffer-groups' control buffers' group rules.

Group awesome-tab with mode if buffer is derived from `eshell-mode' `emacs-lisp-mode' `dired-mode' `org-mode' `magit-mode'.
All buffer name start with * will group to \"Emacs\".
Other buffer group by `awesome-tab-get-group-name' with project name."
  (list
   (cond
    ((or (string-equal "*" (substring (buffer-name) 0 1))
         (memq major-mode '(magit-process-mode
                            magit-status-mode
                            magit-diff-mode
                            magit-log-mode
                            magit-file-mode
                            magit-blob-mode
                            magit-blame-mode
                            )))
     "Emacs")
    ((derived-mode-p 'eshell-mode)
     "EShell")
    ((derived-mode-p 'emacs-lisp-mode)
     "Elisp")
    ((derived-mode-p 'dired-mode)
     "Dired")
    ((memq major-mode '(org-mode org-agenda-mode diary-mode))
     "OrgMode")
    (t
     (awesome-tab-get-group-name (current-buffer))))))


;; GroupRules
;; Awesome tab use awesome-tab-buffer-groups-function to control tab group. Default group function is awesome-tab-buffer-groups

(defun awesome-tab-buffer-groups ()
  "`awesome-tab-buffer-groups' control buffers' group rules.

Group awesome-tab with mode if buffer is derived from `eshell-mode' `emacs-lisp-mode' `dired-mode' `org-mode' `magit-mode'.
All buffer name start with * will group to \"Emacs\".
Other buffer group by `awesome-tab-get-group-name' with project name."
  (list
   (cond
    ((or (string-equal "*" (substring (buffer-name) 0 1))
         (memq major-mode '(magit-process-mode
                            magit-status-mode
                            magit-diff-mode
                            magit-log-mode
                            magit-file-mode
                            magit-blob-mode
                            magit-blame-mode
                            )))
     "Emacs")
    ((derived-mode-p 'eshell-mode)
     "EShell")
    ((derived-mode-p 'emacs-lisp-mode)
     "Elisp")
    ((derived-mode-p 'dired-mode)
     "Dired")
    ((memq major-mode '(org-mode org-agenda-mode diary-mode))
     "OrgMode")
    (t
     (awesome-tab-get-group-name (current-buffer))))))


;; FixedWidth
;; If you'd like all the tab labels using the same length, such as 14, use:

(setq awesome-tab-label-fixed-length 18)

;; DisplayFunctionName
;; If the implementation of the function where the cursor is located is longer than the screen, it is difficult to know what the current function.

;; You can set variable awesome-tab-display-sticky-function-name with t, then function name will display in current tab.

;; Default this feature is disable.

;; ShowTabIndex
;; If you want show index in tab, you can use below setting:

(setq awesome-tab-show-tab-index t)
;; You can also display a personalized index by change option awesome-tab-index-format-str
;; AdjustTabHeight
;; You can use below code adjust tab height:

(setq awesome-tab-height 90)
;; AdjustTabContrast
;; If you think the contrast between the label is too low, can lower both values, increase the contrast:

;; awesome-tab-dark-unselected-blend and awesome-tab-light-unselected-blend

;; AdjustActiveBar
;; You can customize active bar with change awesome-tab-active-bar-width and awesome-tab-active-bar-heigh
(require 'eaf-all-the-icons)
#+end_src

#+RESULTS:
: eaf-all-the-icons

#+RESULTS:
: my/embark-bookmark-jump-right

* Other people's Emacs work
:PROPERTIES:
:CUSTOM_ID: h:7b39c38c-ae23-4385-b439-afca89baca52
:END:

Emacs is both a piece of software and a diverse community of people that
are brought together by their shared interest in this unique program.
Emacs' development unfolds through a distributed network of volunteers,
coordinated by members of the GNU project.  While the community at-large
develops and ultimately internalises lots of valuable ideas to a pool of
accumulated knowledge, such as configurations with custom Elisp code,
video or written tutorials on particular workflows, and packages that
cover a broad range of needs.

Outside the narrow confines of the computer, Emacs is its people.

Here is a non-exhaustive list of users that I have found to be helpful,
each in their own unique way---the order is not significant:

+ Omar Antolín Camarena :: Omar's work is mentioned several times in
  this document (author of Orderless, Embark, and co-author of
  Marginalia).  Apart from those inherently useful packages, Omar has
  helped me several times with various programming issues by sharing
  concrete code examples.  Make sure to check Omar's packages and also
  monitor [[https://github.com/oantolin/emacs-config][the personal Emacs configuration]] which doubles as a laboratory
  of experimentation for new packages or other useful ideas.

+ Daniel Mendler :: Daniel's name is referenced in a number of this
  document's sections (author of Consult, Corfu, Vertico, Recursion
  indicator, co-author of Marginalia together with Omar---you get the
  idea).  As far as I can tell, Daniel does not share an Emacs
  configuration, though one can still learn a lot by studying the code
  of the numerous repositories on [[https://github.com/minad][@minad's Github]].

+ Manuel Uberti :: Manuel's contributions have been of paramount
  importance to the development of my Modus themes.  Manuel offers a lot
  to the Emacs milieu through code contributions but also by reporting
  issues and communicating with package maintainers.  The domain name
  [[https://www.manueluberti.eu/][www.manueluberti.eu]] hosts a blog with Manuel's musings on Emacs.  For
  example, you will find articles that I have already referenced in this
  document, such as [[https://www.manueluberti.eu/emacs/2020/11/14/extending-project/][Extending project.el]].  If you are interested in
  cinema like Manuel, do not miss the reviews on [[https://www.filmsinwords.eu/][www.filmsinwords.eu]].

+ Nicolas De Jaeghere :: Nicolas is another contributor to my Modus
  themes and has helped me understand several Elisp concepts, such as by
  helping me refine the macros that are defined in my =init.el=.  Nicolas
  maintains [[https://github.com/Koekelas/dotfiles][a personal dotfiles repo]] where you can find an =emacs.org=
  file with lots of advanced code snippets.

+ Adam Porter (aka alphapapa, github-alphapapa) :: Adam is a prolific
  contributor to the Emacs packaging milieu and a prominent member of
  the community on the =r/emacs= subreddit.  [[https://github.com/alphapapa][Adam's packages on Github]]
  cover a wide range of needs and are designed using excellent coding
  practices.  These include a client for the Matrix communication
  protocol (=ement.el=), a robust query language for Org (=org-ql=), a code
  colouriser that applies colour based on the level of depth (=prism.el=),
  a powerful buffer-management system (=bufler.el=), a sticky header that
  shows the first line of the code's definition when that is outside the
  visible window (=topsy.el=), a tool that tracks your position across
  Emacs buffers so you can return exactly to where you need to be
  (=dogears.el=)...  You get the idea.  I still plan to incorporate some
  of those into my workflow, starting with dogears, topsy, and bufler.

+ Andrew Tropin :: Andrew is a programmer and contributor to free
  software who also produces [[https://www.youtube.com/channel/UCuj_loxODrOPxSsXDfJmpng][live streams on Youtube]] about various
  Emacs-related topics, as well as the Guix System.  You will find
  valuable information there, such as a Git workflow about pull requests
  as compared to patches, an advanced email setup with Emacs+Notmuch,
  and project management.  Andrew's =rde= is [[https://sr.ht/~abcdw/rde/][a suite of tools]] that manages
  computing environments in Guix.

+ Rainer König :: Rainer has [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][a series of video tutorials]] on how to
  organise your life using various Org features, such as check-lists and
  the agenda.  Each video covers a single utility or closely related
  concepts, while the whole playlist offers a progression from basic to
  more advanced workflows.  Highly recommended!

+ Mike Zamansky :: Mike is a computer science professor who has been
  doing [[https://www.youtube.com/channel/UCxkMDXQ5qzYOgXPRnOBrp1w][videos on Emacs]] for several years.  There is a wealth of
  information to parse from those presentations as well as the
  corresponding [[https://github.com/zamansky/dot-emacs][dot-emacs code repository]].

+ Greg Yut :: Greg has [[https://www.youtube.com/channel/UCsUmtmlYNLQB2Z4GJAVjBcA][a channel on Youtube]] with informative videos
  about Emacs.  The first video in the series is about how to use the
  built-in Info reader, while the second explores the all-too-important
  topic of completion styles and completion category overrides.  Greg
  presents the information in a clear way that is easy to understand
  regardless of experience with Emacs.

+ Emacs Elements :: This is [[https://www.youtube.com/channel/UCe5excZqMeG1CIW-YhMTCEQ][a channel on Youtube]] where Raoul Comninos
  shows how to get things done using Emacs.  There are tutorials on how
  to use the =diary=, =calendar=, and =org-agenda=, while you will also find
  more advanced topics such as how to install, use, and make sense of
  the powerful Icicles completion framework, as well as other useful
  packages.

+ System Crafters :: David Wilson's work on Emacs covers a broad range
  of themes, encapsulated in the [[https://github.com/daviwil/emacs-from-scratch][Emacs from scratch]] configuration.  The
  [[https://youtube.com/c/SystemCrafters][Youtube channel]] contains lots of videos on how to set up and use all
  sorts of packages in Emacs, such as Org and the Mu4e email client.  It
  is fair to say that if something is related to Emacs, David has either
  already done a video about it or is planning to do one in the near
  future.  The [[https://systemcrafters.cc/][System Crafters]] website includes references to all such
  work, while it also covers contributions by the community that David
  has helped foster.  The material on offer is top-notch.  It serves as
  an excellent resource and point of reference for new and experienced
  users alike.

+ Alain M. Lafon :: Alain is one of my early influences in my Emacs
  journey.  As soon as I had made the switch, I watched the video
  presentation [[https://www.youtube.com/watch?v=gfZDwYeBlO4][Play Emacs like an instrument]], which shows some advanced
  workflows of using Emacs in a seemingly effortless fashion.  I knew
  Emacs was good, but did not realise it could be /that good/.  Alain is a
  programmer as well as a Zen monk, who is the founder and CEO of the
  200ok consultancy.  The [[https://200ok.ch/blog.html][consultancy's blog]] contains a lot of articles
  and guides on Emacs, while you can find video tutorials on similar
  topics over at [[https://www.youtube.com/channel/UCIFJHWyIlN0XFrW2vMKG6QA][Alain's Youtube channel]].

+ Xah Lee :: Xah is a well-known member of the community through years
  of contributions either with packages or [[http://www.xahlee.info/][informational websites]] on
  various aspects of Emacs.  On [[https://www.youtube.com/channel/UCXEJNKH9I4xsoyUNN3IL96A][Xah's Youtube channel]] you will find
  videos about Emacs on all sorts of topics.  Those are live streamed.

+ Karthik Chikmagalur :: Karthik's [[https://karthinks.com/software/batteries-included-with-emacs/][Batteries included with Emacs]]
  (2020-11-17) and [[https://karthinks.com/software/more-batteries-included-with-emacs/][More batteries included with Emacs]] (2020-12-11) are
  essential reading for anyone wanting to gain an overview of some of
  Emacs' built-in capabilities and learn about its 'hidden gems'.
  Another excellent piece is [[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen ways to use Embark]] (2021-10-06).
  Karthik's website includes philosophical insights as well, such as
  those found in [[https://karthinks.com/blog/thoughts-on-strength-training/][Thoughts on Strength Training]] (2019-03-02).  You will
  also discover packages by Karthik in this document, such as
  =consult-dir= and =project-x=.

+ James Norman Vladimir Cash :: James produces videos on Emacs, such as
  this one [[https://occasionallycogent.com/custom_emacs_modeline_video_edition/index.html][on customising the modeline]] and writes about similar topics,
  like reading email in Emacs.  Though I also appreciate commentary of a
  political sort: [[https://occasionallycogent.com/against_mindless_minimalism/index.html][Against Mindless Software Minimalism]] (2019-03-24).

+ Karl Voit :: Karl is an expert in Personal Information Management
  (PIM) covering that and relevant topics over at [[https://karl-voit.at/][karl-voit.at]].  There
  are lots of interesting articles on offer, such as how to organise
  data with [[https://karl-voit.at/2020/01/25/avoid-complex-folder-hierarchies/][Don't Do Complex Folder Hierarchies]] and to keep a web
  presence with [[https://karl-voit.at/2020/10/23/avoid-web-forums/][Don't Contribute Anything Relevant in Web Forums]].  Karl
  also participated in the 2021 edition of the /Grazer Linuxtage/
  conference with [[https://karl-voit.at/2021/04/10/GLT21-emacs-org-features/][a talk on Org features and extras]].

+ Sacha Chua :: Sacha's work is instrumental to the Emacs community's
  self awareness.  The [[https://sachachua.com/blog/category/geek/emacs/][weekly "Emacs news" blog entries]] offers an
  overview of what is happening in our space---consider it essential
  reading.  While Sacha was among the organisers of the last two yearly
  Emacsconf events and has shared a lot of valuable insights throughout
  the years, such as hand-drawn guides to using Emacs, chats with
  prominent members of the Emacs community, and more.

+ Bozhidar Batsov :: Bozhidar is the maintainer of several popular Emacs
  packages (and not only), such as the [[https://github.com/bbatsov/projectile][Projectile library]] for
  interacting with projects (like a Git repo), the [[https://github.com/bbatsov/prelude][Prelude starter kit]]
  which tries to enhance---but otherwise remain faithful to---the
  standard Emacs experience, ports of the popular Zenburn and Solarized
  themes, as well as the informative [[https://emacsredux.com/][blog Emacs redux]].

+ Timothy (aka tecosaur) :: Timothy, better known as TEC or tecosaur, is
  the designer of the current iteration of the [[https://orgmode.org/][Org-mode web page]] and
  provides, among others, the blog [[https://blog.tecosaur.com/tmio/archive.html][This Month in Org]] which, as it name
  implies, offers a monthly overview of noteworthy new snippets that
  concern the development of the deservedly beloved Org-mode.

+ Irreal :: Jon Snader's [[https://irreal.org/blog/][Irreal blog]] is one of the best places to start
  learning about the people in the wider Emacs community and to continue
  keeping track of their projects.  Irreal offers curated summaries of
  our fellow Emacsers' contributions, as well as original entries.  Jon
  takes the time to cover the main points in one's work and, where
  appropriate, to highlight relevant information or offer a valuable
  insight.

+ Álvaro Ramírez (aka xenodium) :: Álvaro maintains a blog on Emacs and
  related programming topics: https://xenodium.com.  One of my favourite
  aspects about the posts you will find there are the high quality GIFs
  that capture some precise and very powerful Emacs motion, custom
  command, or workflow.  Álvaro is, among others, the developer of a
  mobile app that helps you track your habits: [[https://flathabits.com/][Flat Habits]].  And the
  best part is that it is all powered by Org mode!

Please note that this is a non-exhaustive list.  Lots of people
contribute to the betterment of Emacs proper and to specialised
packages, such as Jonas Bernoulli (developer of Magit, among many
others), Oleh Krehel (developer of Ivy, Counsel, Swiper, and more),
Thierry Volpiatto (maintainer of Helm), Bastien Guerry (Org maintainer),
Eli Zaretskii (Emacs maintainer), Lars Ingebrigtsen (author of Gnus,
co-maintainer of Emacs), Dmitry Gutov (maintainer of several built-in
subsystems like project.el, as well as external packages like Company,
diff-hl...), Henrik Lissner (author and maintainer of Doom Emacs), the
ever-resourceful maintainers and contributors to Org-roam, and many
others.

For my part, I wish to express my gratitude to all those who have
contributed to my own projects, including the ones who have sent patches
against my Emacs setup, but also users who have reported issues, shared
insights, provided code and suggestions for my Modus themes.  The
themes' manual (which is 27k words as of this writing on 2021-07-27)
contains an "Acknowledgements" section where everyone is included.  I
think the least we can do is acknowledge how much we as individuals
benefit from the communities that organically grow around our projects.

Every bit counts: a bug report, a blog post detailing one's workflow,
participation in a mailing list thread, etc.  Do not hesitate to add
your part and become a member of this wonderful community.

A big thank you to everyone!

