#+TITLE: Akhil's Doom Emacs Config
#+AUTHOR: *Akhil Pratap Singh*
#+DESCRIPTION: Akhil's personal Doom Emacs config.
#+PROPERTY: header-args:emacs-lisp :tangle config.el
#+options: coverpage:yes
#+startup: fold
#+latex_class: book
#+date: @@html:<!--@@{{{git-rev}}}@@html:-->@@@@latex:\\\Large\bfseries@@ {{{modification-time(%Y-%m-%d, t)}}} @@latex:\\\normalsize\mdseries@@{{{modification-time(%H:%M, t)}}} @@latex:\acr{\lowercase{@@{{{timezone}}}@@latex:}}\iffalse@@, {{{git-rev}}}@@latex:\fi@@

/ABOUT THIS CONFIG →/

This is my personal Doom Emacs config.  Doom Emacs is a distribution of Emacs that uses the "evil" keybindings (Vim keybindings) and includes a number of nice extensions and a bit of configuration out of the box.  I am maintaining this config not just for myself, but also for those that want to explore some of what is possible with Emacs.  I will add a lot of examples of plugins and settings, some of them I may not even use personally.  I am doing this so that others can save their time and so that people can use ready snippets without errors.
*Note*: The sections that are tagged as DONE in this org document mean that I have
learned everything about them and are included in the workflow or may not
require further attention.

* Packages management
** DONE Info
CLOSED: [2022-11-12 Sat 10:20]
- State "DONE"       from              [2022-11-12 Sat 10:20]
This is where you install packages, by declaring them with the ~package!~ macro in
=packages.el=, then running ~doom refresh~ on the command line.
This file shouldn't be byte compiled.

#+begin_src emacs-lisp :tangle "packages.el" :comments no
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.

;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;(package! another-package
;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;(package! this-package
;  :recipe (:host github :repo "username/repo"
;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;(package! builtin-package :recipe (:nonrecursive t))
;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;(package! builtin-package :pin "1a2b3c4d5e")

;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;(unpin! pinned-package)
;; ...or multiple packages
;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;(unpin! t)

#+end_src

#+RESULTS:

You'll then need to restart Emacs for your changes to take effect! Or at least,
run =M-x doom/reload=.

*Warning*: Don't disable core packages listed in =~/.emacs.d/core/packages.el=.
Doom requires these, and disabling them may have terrible side effects.

** packages
*** Packages in MELPA/ELPA/emacsmirror
To install ~some-package~ from MELPA, ELPA or emacsmirror:
#+begin_src emacs-lisp :tangle packages.el

(package! exwm)
(when (featurep! :editor evil)
  (package! exwm-evil
    :recipe (:host github :repo "LemonBreezes/exwm-evil"))
  (package! exwm-firefox-evil))
(package! exwm-edit)
(package! language-detection)
(package! exwm-mff)
(package! app-launcher :recipe
  (:host github :repo "SebastienWae/app-launcher"))

(package! exwm-mff)
(package! elfeed)
(package! elfeed-goodies)
(package! elfeed-org)
;; (package! w3m)
(package! mpv)
(package! emms-player-simple-mpv)
(package! yaml)
(package! aio)
;;shell setup
(package! fish-completion)
(package! tab-bar-echo-area)
(package! pcomplete)
(package! pcmpl-args)
(package! 0x0)
(package! symon)
;; (package! slime)
;; (package! sly)
(package! cape)
(package! org-ref)
;; (package! org-fragtog)
(package! org-appear :recipe (:host github :repo "awth13/org-appear"))
(package! org-noter-pdftools)
(package! org-pdftools)
(package! org-roam-bibtex)
(package! org-super-agenda)
(package! org-gtd)

(package! visual-regexp)
(package! visual-regexp-steroids)

(package! org-roam-timestamps :recipe (:host github :repo "ThomasFKJorna/org-roam-timestamps"))

(package! org-wild-notifier)

(package! mpv)
;; (package! epc)
;; (package! ctable)
;; (package! deferred)
(package! s)
(package! sdcv)
(package! clippy)
(package! wordnut)
(package! telega)
(package! smart-mode-line)
(package! system-packages)
(package! kind-icon)
(package! define-word)

(package! dired-sidebar)
(package! dired-rainbow)
(package! diredfl)
(package! dired-rsync)
(package! dired-filter)
(package! peep-dired)
(package! dired-open)
(package! dired-subtree)
(package! dired-single)
(package! dired-collapse)
(package! dired-ranger)

(package! ibuffer-sidebar)
(package! easy-kill)
(package! exotica-theme)
(package! underwater-theme)
(package! key-chord)
;; (package! undo-tree)
(package! ibuffer-project)
(package! ibuffer-vc)
(package! prism)
(package! trashed)
(package! ytel)
(package! ytel-show)
(package! winum)
(package! osm)
(package! olivetti)
(package! framemove)
(package! monkeytype)
(package! hacker-typer)
(package! pinentry)
(package! openwith)
(package! expand-region)
(package! popper)
;; (package! telephone-line)
;; (package! ivy)
;; (package! ivy-prescient)
;; (package! ivy-hydra)
;; (package! ivy-rich)
;; (package! prescient)
(package! counsel)
(package! ranger)
(package! minions)
(package! diminish)
(package! corfu)
(package! flx)
(package! simpleclip)
(package! webpaste)
(package! versuri)
(package! google-translate)
(package! mw-thesaurus)
(package! elpher)
(package! all-the-icons-ivy-rich)
(package! transpose-frame)
(package! bookmark)
(package! beginend)

(package! eshell-bookmark)
(package! eshell-prompt-extras)
(package! engine-mode)
(package! all-the-icons-ivy)
(package! wolfram)
(package! calfw)
(package! calfw-org)
(package! dashboard)

(package! dmenu)
(package! emojify)
(package! evil-tutor)
(package! ivy-posframe)
(package! ox-gemini)
(package! pacmacs)

(package! rainbow-mode)
(package! resize-window)
(package! tldr)

(package! exwm)
(package! desktop-environment)
(package! browse-url)
(package! youtube-dl)
(package! speed-type)
(package! boxquote)
;; (package! impatient-mode)
(package! pdf-tools)
(package! org-pdfview)
(package! xelb)
(package! exwm-edit)
(package! nov)
(package! multi-vterm)
(package! cloc)
(package! yahtzee)
(package! sudoku)
(package! 2048-game)
(package! chess)
(package! smart-compile)
(package! pulseaudio-control)

  (package! gitconfig-mode
	    :recipe (:host github :repo "magit/git-modes"
			   :files ("gitconfig-mode.el")))
#+end_src

#+RESULTS:
| gitignore-mode | :modules | ((:user) (:user . modules)) | :recipe | (:host github :repo magit/git-modes :files (gitignore-mode.el)) |

*** Packages from git repositories
To install a package directly from a particular repo, you'll need to specify
a ~:recipe~. You'll find documentation on what ~:recipe~ accepts [[https://github.com/raxod502/straight.el#the-recipe-format][here]]:
#+begin_src emacs-lisp :tangle packages.el
;; Make Elisp files in that directory available to the user.
(add-to-list 'load-path "~/.config/doom/lisp/")


(package! ytel-show
    :recipe (:host github :repo "xFA25E/ytel-show"
       :files ("ytel-show.el")))

(package! kbd-mode
  :recipe (:host github
           :repo "kmonad/kbd-mode"))

(package! elfeed-tube
  :recipe (:host github
           :repo "karthink/elfeed-tube"))


(package! tmr
  :recipe (:host github
           :repo "protesilaos/tmr.el"))


(package! ef-themes
  :recipe (:host github
           :repo "protesilaos/ef-themes"))

(package! exwm-mff :recipe (:host github :repo "ieure/exwm-mff" :branch "main"))

(package! mathpix.el
  :recipe (:host github :repo "jethrokuan/mathpix.el"))

(package! mct
  :recipe (:host github :repo "protesilaos/mct"))

(package! gitignore-mode
    :recipe (:host github :repo "magit/git-modes"
       :files ("gitignore-mode.el")))


(package! pulsar
    :recipe (:host github :repo "protesilaos/pulsar"
       :files ("pulsar.el")))

(package! usls
    :recipe (:host github :repo "protesilaos/usls"
       :files ("usls.el")))

(package! lin
    :recipe (:host github :repo "protesilaos/lin"
       :files ("lin.el")))

(package! logos
    :recipe (:host github :repo "protesilaos/logos"
       :files ("logos.el")))

(package! bon-app-launcher
    :recipe (:host github :repo "slamko/bon-app-launcher"
       :files ("bon-app-launcher.el")))

#+end_src

If the package you are trying to install does not contain a ~PACKAGENAME.el~
file, or is located in a subdirectory of the repo, you'll need to specify
~:files~ in the ~:recipe~:

*** Disabling built-in packages
If you'd like to disable a package included with Doom, for whatever reason,
you can do so here with the ~:disable~ property:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :disable t)
#+end_src
You can override the recipe of a built in package without having to specify
all the properties for ~:recipe~. These will inherit the rest of its recipe
from Doom or MELPA/ELPA/Emacsmirror:
#+begin_src emacs-lisp :tangle no
(package! builtin-package :recipe (:nonrecursive t))
(package! builtin-package-2 :recipe (:repo "myfork/package"))
#+end_src

Specify a ~:branch~ to install a package from a particular branch or tag.
#+begin_src emacs-lisp :tangle no
(package! builtin-package :recipe (:branch "develop"))
#+end_src
* Desktop Configuration
** Personal Information
It's useful to have some basic personal information

#+begin_src emacs-lisp :tangle no

;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
;;    let's get encryption established
    (setenv "GPG_AGENT_INFO" nil)  ;; use emacs pinentry
    (setq auth-source-debug t)

    (setq epg-gpg-program "gpg2")  ;; not necessary
    (require 'epa-file)
    (epa-file-enable)
    (setq epg-pinentry-mode 'loopback)
    (pinentry-start)

    (require 'org-crypt)
    (org-crypt-use-before-save-magic)

#+end_src

#+begin_src emacs-lisp
;; (setq package-native-compile t)
(setq org-directory "~/org/")
(setq user-full-name "Akhil Pratap Singh"
      user-mail-address "akhilpratapsingh3417@gmail.com")
#+end_src

#+RESULTS:
: akhilpratapsingh3417@gmail.com

Apparently this is used by ~GPG~, and all sorts of other things.

Speaking of ~GPG~, I want to use =~/.authinfo.gpg= instead of the default in
=~/.emacs.d=. Why? Because my home directory is already cluttered, so this won't
make a difference, and I don't want to accidentally purge this file I have done
src_shell{rm -rf~/.emac.d~ before}. I also want to cache as much as possible, as
my home machine is pretty safe, and my laptop is shutdown a lot.

#+begin_src emacs-lisp :tangle yes
(setq auth-sources '("~/.authinfo.gpg")
      auth-source-cache-expiry nil)
 ; default is 7200 (2h)
(use-package! auth-source-pass
  :init (auth-source-pass-enable))
#+end_src

#+RESULTS:
: auth-source-pass
** load some configs.el
#+begin_src emacs-lisp :tangle yes
;; -*- lexical-binding: t -*-
(add-to-list 'load-path "~/.config/doom/lisp/")
(add-to-list 'load-path "~/.config/doom/lisp/elfeed-tube/")
(add-to-list 'load-path "~/.config/doom/lisp/bon-app-launcher")

(load "elfeed-tube.el")
(load "elfeed-tube-contrib.el")
(load "elfeed-tube-fill.el")
(load "elfeed-tube-mpv.el")
(load "elfeed-tube-test.el")
(load "elfeed-tube-utils.el")
(load "w3m-type-ahead.el")
(load "w3m-config.el")

(load "setup-ui.el")
(load "setup-minibuffer.el")
(load "better-buffers.el");;essential
(load "setup-orderless.el");;configured in doom already but...
(load "setup-vertico.el")
(load "setup-embark.el")
(load "utilities.el");;essential
(load "setup-isearch")

(load "~/.config/doom/lisp/elfeed-tube/elfeed-tube.el")
(load "~/.config/doom/lisp/elfeed-tube/elfeed-tube-contrib.el")
(load "~/.config/doom/lisp/elfeed-tube/elfeed-tube-fill.el")
(load "~/.config/doom/lisp/elfeed-tube/elfeed-tube-mpv.el")
(load "~/.config/doom/lisp/elfeed-tube/elfeed-tube-test.el")
(load "~/.config/doom/lisp/elfeed-tube/elfeed-tube-utils.el")
;; ytel provides an elfeed-like interface to search invidious instances for
;; youtube videos. Phew. The churn rate of Invidious urls is quite high, which
;; makes this flaky, but anything's better than the browser interface to
;; Youtube.
(load "setup-ytel.el");; youttuuube
(load "ytdl-downloader.el")
(load "setup-shell.el")
(load "exwm-paste.el")
(load "lock-screen.el")
(load "correct-previous-word-and-create-abbrev")
(load "lookup-on-github")
(load "show-diffs-before-killing-buffers")
(load "switch-window-patches")
(load "pulseaudio.el")
(load "auto-scroll.el")
(load "prot-common.el")
(load "prot-comment.el")
(load "prot-bookmark.el")
(load "org-protocol-capture-html.el")

;; (load "corfuv2.el")
;; (load "emacs-with-nyxt.el")
;; (load "prot-common.el")
;; (load "setup-corfu.el")
;; (load "setup-consult.el")
;; (load "sweet-kill.el") ;;overide doom session kill messages
;; (load "setup-dired.el")
;; (load "setup-email.el")
;; (load "setup-elfeed.el")
;; (load "setup-email.el")
;; (load "dunst.el")
;; (load "chromium")


#+end_src

#+RESULTS:
: t

** DONE Auto-customisations
CLOSED: [2022-11-12 Sat 10:20]
- State "DONE"       from              [2022-11-12 Sat 10:20]
By default changes made via a customisation interface are added to =init.el=.
I prefer the idea of using a separate file for this. We just need to change a
setting, and load it if it exists.

#+begin_src emacs-lisp
(setq-default custom-file (expand-file-name ".custom.el" doom-user-dir))
(when (file-exists-p custom-file)
  (load custom-file))
#+end_src

#+RESULTS:

** DONE Rudimentry Settings
CLOSED: [2022-11-12 Sat 10:21]
- State "DONE"       from              [2022-11-12 Sat 10:21]
#+begin_src emacs-lisp

;; Use visual line motions even outside of visual-line-mode buffers
(evil-global-set-key 'motion "j" 'evil-next-visual-line)
(evil-global-set-key 'motion "k" 'evil-previous-visual-line)

(global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
(global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)

(defhydra hydra-text-scale (:timeout 4) ; Change the size of text
  "scale text"
  ("j" text-scale-increase "inc")
  ("k" text-scale-decrease "dec")
  ("q" nil "finished" :exit t))

(defhydra hydra-cycle-buffers (:timeout 4) ; Cycle through buffers, killing uneccessary ones
  "cycle buffers"
  ("j" next-buffer "next")
  ("k" previous-buffer "prev")
  ("SPC" kill-current-buffer "kill")
  ("q" nil "quit" :exit t))

#+end_src

#+RESULTS:
: hydra-cycle-buffers/body

* Exwm Config
** Edwina configuration

The following config works cleanly with Doom
The following line
  ;;  (setq! display-buffer-base-action '(display-buffer-below-selected))
 causes an issue when opening an I buffer, so I switched it off (removed it)

 Lots of duplication in the map the below map seems to be all I need.

 The auto-stack seems to work well, but evil window movement replicated some of the window navigation
 and seems to have more or equivalent commands.
 Open season with this at the moment.

 noticing some issues that temp buffer are not appearing in doom, will continue to test.
 #+begin_src emacs-lisp :tangle no
(package! edwina)
 #+end_src
#+BEGIN_SRC elisp :tangle no
(use-package! edwina
  :config
  ;; (setq! display-buffer-base-action '(display-buffer-below-selected))

  ;; The above seems to now work preventing the mode map being called and added to
  ;; the keymap list
  (defun edwina--init ()
    "Initialize command `edwina-mode'."
    (print! "Simplified Edwina init")
    (message "Simplified Edwina init")
    (advice-add #'display-buffer :around #'edwina--display-buffer)
    (unless (assoc 'edwina-mode mode-line-misc-info)
      (push '(edwina-mode (:eval (edwina-mode-line-indicator)))
            (cdr (last mode-line-misc-info))))
    (edwina-arrange))

  ;; The filter for Doom obviously still needs some work.
  ;; +popup-buffer-p appears to return nil when I expected it to be non nil.
  ;; So a bit more digging required here to get this playing well with Doom.
  ;; trying the below for now, but pretty sure it can be improved.'
  ;; COnd at least allows another layer of filtering.
  (defun doom-popup-filter (in-buffer)
    (with-current-buffer in-buffer
      (progn
        (message "[EDWINA] checking buffer t[%s] ib[%s] pun[%s] pub[%s] pu[%s] cb[%s] pm[%s]" (type-of in-buffer) in-buffer (+popup-buffer-p (buffer-name in-buffer)) (+popup-buffer-p in-buffer) (+popup-buffer-p) (current-buffer) +popup-mode)
        (if (or (+popup-buffer-p)
                (cond
                 (( string-match-p "popup" (buffer-name in-buffer)) t)
                 (( string-match-p "Password-Store" (buffer-name in-buffer)) t)
                 (( string-match-p "*transient*" (buffer-name in-buffer)) t)
                 (( string-match-p "magit" (buffer-name in-buffer)) t)
                 (t nil)
                 )
                )
            (progn
              (message "Filter %s" (buffer-name in-buffer))
              t
              )
          (progn
            (message "No Filter %s" (buffer-name in-buffer))
            nil
            )
          )
        )
      )
    )
  (setq! edwina-buffer-filter #'doom-popup-filter)

  (map! :leader
        (:prefix ("e" . "Edwina")
         :desc "Toggle Edwina" "e" #'edwina-mode
         :desc "Arrange" "r" #'edwina-arrange
         :desc "Next Window" "h" #'edwina-select-next-window
         :desc "Prev Window" "l" #'edwina-select-previous-window
         :desc "Swap Next" "L" #'edwina-swap-next-window
         :desc "Swap Prev" "H" #'edwina-swap-previous-window
         :desc "Dec MFact" "-" #'edwina-dec-mfact
         :desc "Inc MFact" "=" #'edwina-inc-mfact
         :desc "Dec Master" "_" #'edwina-dec-nmaster
         :desc "Inc Master" "+" #'edwina-inc-nmaster
         :desc "Del Window" "d" #'edwina-delete-window
         :desc "Zoom on Window" "z" #'edwina-zoom
         ))

  (edwina-mode 1)
  )
#+END_SRC

#+RESULTS:
: t

** Defvar exwm
#+begin_src emacs-lisp :tangle no

     ;; (exwm :variables
     ;;       exwm-enable-systray t
     ;;       exwm-autostart-xdg-applications t
     ;;       exwm-locking-command "i3lock -n"
     ;;       exwm-install-logind-lock-handler t
     ;;       exwm-autostart-environment '("DESKTOP_SESSION=kde" "KDE_SESSION_VERSION=5")
     ;;       exwm-custom-init (lambda()
     ;;                          (exwm/autostart-process "Dunst OSD" "dunst")
     ;;                          (exwm/autostart-process "KWallet Daemon" "kwalletd5")))

(defvar exwm-locking-command "i3lock-fancy"
  "Command to run when locking session")

(defvar exwm-install-logind-lock-handler t
  "If this is non-nil and `exwm-locking-command' is set, register a D-BUS handler on the session lock signal.")

(defvar exwm-app-launcher--prompt "$ "
  "Prompt for the EXWM application launcher")

(defvar exwm-hide-tiling-modeline nil
  "Whether to hide modeline.")

(defvar exwm-buffer-name-prefix "X:"
  "A prefix to append to each buffer managed by exwm")

(defvar exwm-enable-systray t
  "Whether to enable EXWM's bundled system tray implementation.")

(defvar exwm-autostart-xdg-applications t
  "Whether to run $XDG_USER_HOME/autostart applications after initialization.")

;; (defvar exwm-autostart-environment '()
;;   "List of \"KEY=value\" strings which should be set when running autostart applications.

;; Example: '(\"DESKTOP_SESSION=kde\" \"KDE_SESSION_VERSION=5\") ")

(defvar exwm-autostart-environment '("DESKTOP_SESSION=kde" "KDE_SESSION_VERSION=5"))


(defvar exwm-custom-init nil
  "This can be set to a function that runs after all other EXWM initialization.")

(defvar exwm-workspace-switch-wrap t
  "Whether `exwm/workspace-next' and `exwm/workspace-prev' should wrap.")

(defvar exwm-randr-dwim t
  "Whether to try to dwim workspace/screen association in the screen change hook.")

(defvar exwm-move-frame-at-edge t
  "If enabled, use framemove to switch frames when trying to move
  outside of current frame." )
#+end_src
** misc
#+begin_src emacs-lisp :tangle no

(defun exwm/init-framemove ()
  (use-package framemove
    :after exwm
    :config
    (progn
      ;; Emacs frame parameters don't seem to be too reliable...
      (define-advice fm-frame-bbox (:around (oldfun frame) exwm-frame-bbox-from-randr)
        (if (frame-parameter frame 'exwm-geometry)
            (exwm//fm-frame-bbox-from-randr frame)
          (funcall oldfun frame)))
      (setq framemove-hook-into-windmove exwm-move-frame-at-edge))))

(defun exwm/init-exwm ()
  (use-package exwm
    :init
    ;; Disable dialog boxes since they are unusable in EXWM
    (setq use-dialog-box nil)
    ;; You may want Emacs to show you the time
    (display-time-mode t)
    (when exwm-hide-tiling-modeline
      (add-hook 'exwm-mode-hook #'hidden-mode-line-mode))
    (setq exwm-input-line-mode-passthrough t)

    ;; make winner aware of new window configuration
    (with-eval-after-load 'winner
      (add-hook 'exwm-manage-finish-hook 'winner-save-old-configurations t))
    :config

    ;; make sure that displaying transient states gets the keyboard input.
    ;; Borrowed from: https://github.com/abo-abo/hydra/issues/232
    (define-advice hydra-set-transient-map (:around (fun keymap on-exit &optional foreign-keys) exwm-passthrough)
      (setq exwm-input-line-mode-passthrough t)
      (let ((on-exit (lexical-let ((on-exit on-exit))
                       (lambda ()
                         (setq exwm-input-line-mode-passthrough nil)
                         (when on-exit (funcall on-exit))))))
        (funcall fun keymap on-exit foreign-keys)))

    ;; override persp-mode's idea of frame creation for floating frames.  These
    ;; are characterized by the 'unsplittable' frame parameter, and should not
    ;; be tried to assign an existing layout to.

    (eval-after-load 'persp-mode
      (advice-add 'persp-init-new-frame :before-until 'exwm//persp-mode-inhibit-p))

    ;; (eval-after-load 'terminal-here
    ;;   (exwm-input-set-key (kbd "<s-return>") 'terminal-here-launch))

    (add-hook 'exwm-update-class-hook 'exwm/rename-buffer)
    (add-hook 'exwm-update-title-hook 'exwm/rename-buffer)

    ;; kick all exwm buffers into insert mode per default
    (add-hook 'exwm-manage-finish-hook 'exwm/enter-insert-state)

    (evil-define-key 'normal exwm-mode-map (kbd "i") 'exwm/enter-insert-state)
    ;; Quick swtiching between workspaces
    ))
#+end_src

#+RESULTS:
: exwm/init-exwm

** funcs
#+begin_src emacs-lisp :tangle no

(defun exwm/exwm-buffers-info ()
  (interactive)
  "Helper, return information about open exwm windows"
  (cl-loop for buffer in (buffer-list)
        for name = (buffer-name buffer)
        for ecname = (buffer-local-value 'exwm-class-name buffer)
        when ecname
        do (message "Buffer name: '%s', exwm class name: '%s'" name ecname)))

;; D-Bus locking
;; We should be able to talk to loginctl to handle the current session, so we
;; can react to the lock signal.

(defun exwm//install-logind-lock-handler ()
  (let ((session (dbus-call-method :system "org.freedesktop.login1" "/org/freedesktop/login1"
                                   "org.freedesktop.login1.Manager" "GetSessionByPID" (emacs-pid))))
    (dbus-register-signal :system "org.freedesktop.login1" session
                          "org.freedesktop.login1.Session" "Lock"
                          (lambda()
                            (message "Lock signal received")
                            (start-process-shell-command "session-lock" nil exwm-locking-command)))))


#+end_src

#+RESULTS:
: exwm//install-logind-lock-handler

** final touchups

XDG compliance and WM settings
I have to set a few environment variables for the sake of compliance with various specifications, most notably the XDG Base Directory Specification. Also in this block I set an environment variable signaling to Java applications that the window manager is not a reparenting window manager.

#+begin_src emacs-lisp :tangle no

(setenv "XDG_CURRENT_DESKTOP" "emacs")
;; (setenv "GTK2_RC_FILES" (expand-file-name "~/.config/gtk-2.0/gtkrc"))
(setenv "GTK3_INI_FILES" (expand-file-name "~/.config/gtk-3.0/settings.ini"))
(setenv "QT_QPA_PLATFORMTHEME" "gtk2")

;;Make Java applications aware this is a non-reparenting window manager.
(setenv "_JAVA_AWT_WM_NONREPARENTING" "1")
#+end_src

Disable screen blanking
I don’t need my laptop’s screen shutting off just because I’m sitting and watching a video with the laptop idle too long.
#+begin_src emacs-lisp :tangle no
(start-process "Disable Blanking" nil "xset"
               "s" "off" "-dpms")
#+end_src

Disable the trackpad
This thing is disgusting, and I prefer trackpoints way more.
#+begin_src emacs-lisp :tangle no

(start-process "Trackpad Setup" nil "xinput"
               "disable" (shell-command-to-string
                          (concat "xinput | grep Synap | head -n 1 | "
                                  "sed -r 's/.*id=([0-9]+).*/\\1/' | "
                                  "tr '\n' ' ' | sed 's/ //'")))
#+end_src

#+RESULTS:
: #<process Trackpad Setup>

Set fallback cursor
Some X windows will have weird cursors if this isn’t done.
#+begin_src emacs-lisp :tangle no

(start-process "Fallback Cursor" nil "xsetroot"
               "-cursor_name" "left_ptr")
#+end_src
Banish the mouse
I’ve always been mixed on this behavior but it seems like a good idea.
#+begin_src emacs-lisp :tangle no
(start-process "Mouse banisher" nil "xbanish")
#+end_src
** Exwm
#+begin_src emacs-lisp :tangle no
  (require 'exwm)
  ;; using xim input
  (require 'exwm-xim)
  (exwm-xim-enable)
  (push ?\C-\\ exwm-input-prefix-keys)   ;; use Ctrl + \ to switch input method
#+END_SRC

#+begin_src emacs-lisp :tangle yes

(require 'bon-app-launcher)
(setq-default tab-width 2)
(setq-default evil-shift-width tab-width);; Window manager
(setq-default indent-tabs-mode nil)
(use-package! exwm
  :init
  (setq mouse-autoselect-window nil
        focus-follows-mouse t
        exwm-workspace-warp-cursor t
        exwm-workspace-number 5)
                                        ;exwm-workspace-display-echo-area-timeout 5
                                        ;exwm-workspace-minibuffer-position 'bottom ;; Annoying focus issues
  :config


  (defun exwm//persp-mode-inhibit-p (frame)
    (frame-parameter frame 'unsplittable))

    (add-hook 'exwm-update-class-hook
              (lambda ()
                (exwm-workspace-rename-buffer exwm-class-name)))
    (add-hook 'exwm-update-title-hook
              (lambda ()
                (pcase exwm-class-name
                  ("Vimb" (exwm-workspace-rename-buffer (format "vimb: %s" exwm-title)))
                  ("firefoxdeveloperedition" (exwm-workspace-rename-buffer (format "FirefoxD: %s" exwm-title)))
                  ("qutebrowser" (exwm-workspace-rename-buffer (format "F# %s" exwm-title))))))

  (defun exwm/run-in-background (command)
    (let ((command-parts (split-string command "[ ]+")))
      (apply #'call-process `(,(car command-parts) nil 0 nil ,@(cdr command-parts)))))

  (defun exwm/bind-function (key invocation &rest bindings)
    "Bind KEYs to FUNCTIONs globally"
    (while key
      (exwm-input-set-key (kbd key)
                          `(lambda ()
                             (interactive)
                             (funcall ',invocation)))
      (setq key (pop bindings)
            invocation (pop bindings))))

  (defun exwm/bind-command (key command &rest bindings)
    "Bind KEYs to COMMANDs globally"
    (while key
      (exwm-input-set-key (kbd key)
                          `(lambda ()
                             (interactive)
                             (exwm/run-in-background ,command)))
      (setq key (pop bindings)
            command (pop bindings))))

  ;; Simulate insert state by using line mode without passthrough
  (defun exwm/enter-insert-state ()
    (interactive)
    (setq exwm-input-line-mode-passthrough nil)
    (call-interactively 'exwm-input-grab-keyboard)
    (evil-insert-state))

  ;; Simulate normal state by using line mode with passthrough, i.e. forward all commands to emacs
  (defun exwm/enter-normal-state ()
    (interactive)
    (setq exwm-input-line-mode-passthrough t)
    (call-interactively 'exwm-input-grab-keyboard)
    (evil-normal-state))

  (defun exwm/escape ()
    "Switch to normal state, and cancel possible fullscreen layout.  Also close minibuffer."
    (interactive)
    (exwm/enter-normal-state)
    (exwm-layout-unset-fullscreen)
    (when (active-minibuffer-window)
      (minibuffer-keyboard-quit)))

  (defun exwm/enter-char-mode ()
    "Enter EXWM char mode."
    (interactive)
    (when exwm--id
      (exwm/enter-insert-state)
      ;; (exwm-input-toggle-keyboard)
      (call-interactively 'exwm-input-release-keyboard)))

  (defun efs/exwm-init-hook ()
    ;; Make workspace 1 be the one where we land at startup
    (exwm-workspace-switch-create 1)

    ;; (defun exwm/run-qute ()
    ;;   (exwm/run-in-background "qutebrowser")
    ;;   (exwm-workspace-switch-create 2))

    ;; (eshell)
    ;; (exwm/run-in-background "syncthing-gtk --minimized")
    ;; (exwm/run-in-background "udiskie -t")
    ;; (exwm/run-in-background "redshift -l 47.675510:-122.203362 -t 6500:3500")
    ;; Set up perspective names on initial workspaces
    (exwm-workspace-switch-create 0)
    (persp-switch "Chat")

;; (setq telega-tdlib-max-version "1.8.5")
    ;; Launch Telega in workspace 0 if we've logged in before
    (when (file-exists-p "~/.telega/db.sqlite")
      (telega nil))
(setq telega-notifications-mode t)
    (persp-kill "Main")
    (exwm-workspace-switch-create 1)
    (exwm-workspace-switch-create 2)
    (persp-switch "Browsers")
    (persp-kill "Main")
    (exwm-workspace-switch-create 3)
    (persp-switch "Comms")
    (persp-kill "Main")
    (exwm-workspace-switch-create 4)
    (persp-switch "Media")
    (persp-kill "Main")
    (efs/start-panel)
    ;; Launch apps that will run in the background
    (exwm/run-in-background "dunst")
    (exwm/run-in-background "nm-applet")
    (exwm/run-in-background "pasystray")
    ;; (exwm/run-in-background "volumeicon")
    (exwm/run-in-background "blueman-applet"))

;; When EXWM starts up, do some extra confifuration
(add-hook 'exwm-init-hook #'efs/exwm-init-hook)
  ;; (add-hook 'exwm-mode-hook
  ;;           (lambda ()
  ;;             (evil-local-set-key 'motion (kbd "C-u") nil)))

  (defun dw/setup-window-by-class ()
    (interactive)
    (pcase exwm-class-name
      ("Pidgin" (exwm-workspace-move-window 0))
      ("Pidgin<2>" (exwm-workspace-move-window 0))
      ("discord" (exwm-workspace-move-window 3))
      ("Microsoft Teams - Preview" (exwm-workspace-move-window 3))
      ("Spotify" (exwm-workspace-move-window 4))
      ("Vimb" (exwm-workspace-move-window 2))
      ;; ("qutebrowser" (exwm-workspace-move-window 2)
      ;;  (exwm-layout-toggle-mode-line)
      ;; (exwm-workspace-toggle-minibuffer))
    ("firefoxdeveloperedition" (exwm-workspace-move-window 2)
               (exwm-workspace-toggle-minibuffer)
                 (exwm-layout-toggle-mode-line))
    ("qjackctl" (exwm-floating-toggle-floating))
    ;; ("mpv" (exwm-floating-toggle-floating)
    ;; ("mpv" (exwm/position-window))
    ("mpv" (exwm-workspace-move-window 4))
    ;;  (exwm-layout-toggle-mode-line))
    ("gsi" (exwm-input-toggle-keyboard)))

  ;; position a window
  (defun exwm/position-window ()
    (let* ((pos (frame-position))
           (pos-x (car pos))
           (pos-y (cdr pos)))

      (exwm-floating-move (- pos-x) (- pos-y)))))

  ;; This function should be used only after configuring autorandr!
  (defun efs/update-displays ()
    (efs/run-in-background "autorandr --change --force")
    (efs/set-wallpaper)
    (message "Display config: %s"
             (string-trim (shell-command-to-string "autorandr --current"))))
;; Manipulate windows as they're created
(add-hook 'exwm-manage-finish-hook
          (lambda ()
            ;; Send the window where it belongs
            (dw/setup-window-by-class)))

;; Hide the modeline on all X windows
(add-hook 'exwm-floating-setup-hook
          (lambda ()
            (exwm-layout-hide-mode-line)))

    ;; Set the screen resolution (update this to be the correct resolution for your screen!)
    (require 'exwm-randr)
    (exwm-randr-enable)
    (start-process-shell-command "xrandr" nil "xrandr --output DP-1 --primary --mode 1920x1080 --pos 0x0 --rotate normal")

    ;; This will need to be updated to the name of a display!  You can find
    ;; the names of your displays by looking at arandr or the output of xrandr
    (setq exwm-randr-workspace-monitor-plist '(2 "Virtual-2" 3 "Virtual-2"))


(defun efs/set-wallpaper ()
  (interactive)
  ;; NOTE: You will need to update this to a valid background path!
  (start-process-shell-command
   ;; "feh" nil  "feh --bg-scale /usr/share/backgrounds/my-backgrounds/3JWY37f.jpg"))
   "feh" nil  "xargs xwallpaper --stretch < ~/.cache/wall"))
(efs/set-wallpaper)

(setq-default my/exwm--do-not-mass-kill nil)
(defun my/exwm-toggle-or-set-buffer-protection (&optional arg value)
  "Toggle or set EXWM mass-buffer-deletion protection.
When called interactively, toggle. Otherwise set to VALUE."
  (interactive "p")
  (when (derived-mode-p 'exwm-mode)
    (if arg
        (progn
          (if my/exwm--do-not-mass-kill
              (kill-local-variable 'my/exwm--do-not-mass-kill)
            (setq-local my/exwm--do-not-mass-kill t))
          (when arg
            (message "EXWM buffer protection set to %s" my/exwm--do-not-mass-kill)))
      (setq-local my/exwm--do-not-mass-kill value))))
(defun my/exwm-kill-unprotected-by-prefix (prefix)
  "Kill all EXWM buffers with PREFIX that have `my/exwm--do-not-mass-kill' set to nil."
  (interactive "sPrefix: ")
  (dolist (buf (buffer-list (current-buffer)))
    (with-current-buffer buf
      (when
          (and
           (eq major-mode 'exwm-mode)
           (string-prefix-p (concat prefix "#") (buffer-name))
           (not my/exwm--do-not-mass-kill))
        (kill-buffer)))))

(defun my/exwm--format-window-title-firefox (title &optional length)
  "Removes noise from and trims Firefox window titles.
Assumes the Add URL to Window Title extension is enabled and
configured to use @ (at symbol) as separator."
  (let* ((length (or length 45))
         (title (concat "F# " (replace-regexp-in-string " [-—] Firefox Developer Edition$" "" title)))
         (title-and-hostname (split-string title "@" nil " "))
         (hostname (substring (car (last title-and-hostname)) 0 -1))
         (page-title (string-join (reverse (nthcdr 1 (reverse title-and-hostname))) " "))
         (short-title (reverse (string-truncate-left (reverse page-title) length))))
    (if (length> title-and-hostname 1)
        (concat short-title " @ " hostname)
      (reverse (string-truncate-left (reverse title) length)))))
;; to disable simulation keys for whtever
;; (add-hook 'exwm-manage-finish-hook
;;           (lambda ()
;;             (when (and exwm-class-name
;;                        (string= exwm-class-name "Firefox"))
;;               (exwm-input-set-local-simulation-keys nil))))


;; position a window
(defun efs/position-window ()
  (let* ((pos (frame-position))
         (pos-x (car pos))
         (pos-y (cdr pos)))

    (exwm-floating-move (- pos-x) (- pos-y))))

(add-hook 'exwm-mode-hook
          (lambda ()
            (evil-local-set-key 'motion (kbd "C-u") nil)))


;; (use-package! exwm-mff
;;   :config
;;   (add-hook 'exwm-mode-hook 'exwm-mff-mode))


(defun my/launch (command)
  (interactive (list (read-shell-command "$ ")))
  (start-process-shell-command command nil command))

(defun my/screen-to-clipboard ()
  (interactive  )
  (shell-command
   (concat "bash -c 'FILENAME=$(date +'%Y-%m-%d-%H:%M:%S').png && maim -s $FILENAME"
           " && xclip $FILENAME -selection clipboard "
           "-t image/png &> /dev/null && rm $FILENAME'"))
  (message "Added to clipboard."))

(defun my/flameshot ()
  (interactive)
  (shell-command "flameshot gui"))

(define-ibuffer-column exwm-class (:name "Class")
  (if (bound-and-true-p exwm-class-name)
      exwm-class-name
    ""))
(define-ibuffer-column exwm-instance (:name "Instance")
  (if (bound-and-true-p exwm-instance-name)
      exwm-instance-name
    ""))
(define-ibuffer-column exwm-urgent (:name "U")
  (if (bound-and-true-p exwm--hints-urgency)
      "U"
    " "))
;; Set the default number of workspaces
(setq exwm-workspace-number 7)

;; Rebind CapsLock to Ctrl
;; (start-process-shell-command "xmodmap" nil "xmodmap ~/.config/doom/exwm/Xmodmap")

;; NOTE: Uncomment the following two options if you want window buffers
;;       to be available on all workspaces!

;; Automatically move EXWM buffer to current workspace when selected
(setq exwm-layout-show-all-buffers t)

;; Display all EXWM buffers in every workspace buffer list
(setq exwm-workspace-show-all-buffers 'nil)

(setq exwm-workspace-switch-create-limit 9)

;; Noticed some odd flickering here and there, apparently this should resolve it
(add-to-list 'default-frame-alist '(inhibit-double-buffering . t))

;; (setq exwm-debug-on t)

;; NOTE: Uncomment this option if you want to detach the minibuffer!
;; Detach the minibuffer (show it with exwm-workspace-toggle-minibuffer)
;; (setq exwm-workspace-minibuffer-position 'top)

;; NOTE: This is disabled because we now use Polybar!
;; Load the system tray before exwm-init
(require 'exwm-systemtray)
(setq exwm-systemtray-height 16)
(exwm-systemtray-enable)

;; Automatically send the mouse cursor to the selected workspace's display
(setq exwm-workspace-warp-cursor t)
;; Window focus should follow the mouse pointer
(setq mouse-autoselect-window t
      focus-follows-mouse t)
;; ;; Don't override any keybindings in line-mode
;; (setq exwm-input-prefix-keys '())
(defun my/exwm--format-window-title-urxvt (title)
  "Removes noise from URxvt window titles."
  (concat "U# " (replace-regexp-in-string ":.*$" "" title)))

(defun my/exwm--format-window-title-alacritty (title)
  "Removes noise from URxvt window titles."
  (concat "U# " (replace-regexp-in-string ":.*$" "" title)))


(defun my/exwm--format-window-title-st (title)
  "Removes noise from URxvt window titles."
  (concat "U# " (replace-regexp-in-string ":.*$" "" title)))

(defun my/exwm--format-window-title-* (title)
  "Removes annoying notifications counters."
  (string-trim (replace-regexp-in-string "([[:digit:]]+)" "" title)))

(defun my/exwm-buffer-name ()
  "Guesses (and formats) the buffer name using the class of the X client."
  (let ((title (my/exwm--format-window-title-* exwm-title))
        (formatter (intern
                    (format "my/exwm--format-window-title-%s"
                            (downcase exwm-class-name)))))
    (if (fboundp formatter)
        (funcall formatter title)
      title)))

(defun exwm--update-utf8-title-advice (oldfun id &optional force)
"Only update the exwm-title when the buffer is visible."
  (when (get-buffer-window (exwm--id->buffer id))
    (funcall oldfun id force)))
(advice-add #'exwm--update-utf8-title :around #'exwm--update-utf8-title-advice)

;; (exwm-input-set-key (kbd "<s-return>") #'eshell)
(exwm-input-set-key (kbd "<s-S-return>") #'bon-app-launcher-usr-bin)
(exwm-input-set-key (kbd "<C-escape>") #'consult-buffer)
(exwm-input-set-key (kbd "C-c o") #'consult-buffer-other-window)
;; (exwm-input-set-key (kbd "s-I") #'evil-window-delete)
(exwm-input-set-key (kbd "s-'") #'hydra-text-scale/body)
(exwm-input-set-key (kbd "s-.") #'hydra-cycle-buffers/body)

(exwm-input-set-key (kbd "C-c x") #'exwm/escape)
(exwm-input-set-key (kbd "C-c X") #'exwm/enter-insert-state)
;; (exwm-input-set-key (kbd "s-d") 'counsel-linux-app)
;; (exwm-input-set-key (kbd "s-d") 'bon-app-launcher-usr-bin)

;; Autorandr
;; ;; Ctrl+Q will enable the next key to be sent directly
(define-key exwm-mode-map [?\C-q] 'exwm-input-send-next-key)

(global-set-key (kbd "s-n") 'counsel-network-manager)
;; ;; Set up global key bindings.  These always work, no matter the input state!
;; Keep in mind that changing this list after EXWM initializes has no effect.
;; Workspace switching
(exwm-input-set-key (kbd "C-?") #'execute-extended-command)
(exwm-input-set-key (kbd "C-.") #'execute-extended-command)
(global-set-key (kbd "C-?") #'execute-extended-command)
(define-key evil-normal-state-map (kbd "C-.") nil)
;; (define-key evil-normal-state-map (kbd "C-n") nil)
(global-set-key (kbd "C-.") #'execute-extended-command)
;; (global-set-key (kbd "C-n") #'my/ivy-switch-buffer-firefox)
;; (global-set-key (kbd "C-N") #'my/ivy-switch-buffer-urxvt)

(setq exwm-input-simulation-keys


      '(([C-u] . [C-u])       ; multiplier, doesn't need to be here but reminder
        ;; movement TODO add more more text like jump para
        ([?\C-b] . [left])
        ([?\M-b] . [C-left])
        ([?\C-f] . [right])
        ([?\M-f] . [C-right])
        ([?\C-p] . [up])
        ([?\C-n] . [down])
        ([?\C-a] . [home]) ;; to change??
        ([?\C-e] . [end])
        ([?\C-v] . [next])
        ([?\M-v] . [prior])
        ([?\M-<] . [C-home])
        ([?\M->] . [C-end])
        ;; delete
        ([?\C-d] . [delete])
        ([?\M-d] . [C-delete])
        ;; kill/cut/copy/paste/selection
        ([?\C-k] . [S-end C-x])
        ([?\C-w] . [?\C-x])
        ([?\M-w] . [?\C-c])
        ([?\C-y] . [?\C-v])             ; Add C-S-V ?
        ([?\s-a] . [?\C-a])             ; should it be s-h cause C-x h
        ([?\s-h] . [?\C-a])             ; just both lmao
        ;; undo/redo
        ([?\C-/] . [?\C-z])
        ([?\C-?] . [?\C-y])             ; redo
        ;; search
        ([?\C-s] . [?\C-f])
        ;; selection-shift movements
        ([?\C-\S-b] . [S-left])
        ([?\C-\S-f] . [S-right])
        ([?\C-\S-p] . [S-up])
        ([?\C-\S-n] . [S-down])
        ([?\M-B] . [C-S-left])
        ([?\M-F] . [C-S-right])
        ;; newline/esc
        ([\\S-\\r] . [end return])
        ([?\C-g] . [escape])
        ;;Navigation C-] is going to home ? Alt-Home?
        ([?\M-\[] . [M-left])           ; back
        ([?\M-\]] . [M-right])          ; forward
        ;; Toggle Developer Tools
        ([?\M-i] . [C-S-i])
        ([?\M-k] . [C-S-k]) ;; web console - can't toggle
        ;; C-S-M Responsive Design View
        ;; C-S-S Debugger
        ;; M-s Menu

        ;; firefox stuffs? F7 Caret mode!!
        ;; Focus Tab Bar
        ([?\s-z] . [?\C-l S-tab S-tab S-tab]) ;; sometime no back history button hmmm
        ;; copy link
        ([?\C-l] . [?\C-l ?\C-c])
        ;; questionable shifting line up/down
        ([?\M-p] . [home S-end ?\C-c backspace delete up home return up ?\C-v])
        ([?\M-n] . [home S-end ?\C-c backspace delete end return ?\C-v])
        ([?\C-\"] . [\" end \" return]) ;; quoting

        ;; Ensure ways to still access old bindings
        ([?\C-\s-b] . [?\C-b]) ;; bookmark
        ([?\C-\s-s] . [?\C-s]) ;; save
        ([?\C-\s-p] . [C-p])
        ([?\C-\s-n] . [C-n])
        ([?\C-\S-w] . [?\C-w]) ;; close
        ([?\C-\s-k] . [C-k])
        ([?\C-\s-b] . [?\C-b]) ;; bookmark
        ([?\C-\s-s] . [?\C-s]) ;; save
        ;; QuickFind next
        ([?\C-\\] . [C-g])
        ([?\C-\/] . [C-S-g])
        ;;idk
        ;; ([?\C-\S-u] . [C-S-f])
        ;; Open new window?
        ;; ([?\M-P] . [C-S-p])
        ;; ([?\M-N] . [C-S-n])
        ;; ([?\C-\'] . [\" home \" return])
        ;; idk
        ))
(setq exwm-manage-force-tiling t)

;; (define-key exwm-mode-map (kbd "C-c") nil)
(setq exwm-input-prefix-keys
      '(?\C-x
        ?\C-h
        ?\M-x
        ?\M-`
        ?\M-&
        ?\s-@
        ?\C-c
        ?\M-b
        ?\s-b
        ?\C-W
        ?\M-:
        ?\C-\M-j  ;; Buffer list
        ?\C-\M-k  ;; Browser list
        ?\C-\M-n  ;; Next workspace
        ?\C-\     ;; Ctrl+Space
        ?\C-\;))
;; Buffer switching
;; (add-to-list 'exwm-input-prefix-keys ?\s-@)
;; ;; Engine mode
;; (add-to-list 'exwm-input-prefix-keys ?\s-b)
;; (exwm/bind-function
;;   "s-o" 'exwm/run-qute
;;   "s-q" 'kill-buffer)
;; Window switching
(define-key exwm-mode-map (kbd "<f8>") 'other-window)
(define-key exwm-mode-map (kbd "C-<f8>") 'window-swap-states)
(define-key exwm-mode-map (kbd "M-<f8>") 'rotate-frame-clockwise)

;; (exwm-input-set-key (kbd "M-y") #'my/exwm-counsel-yank-pop)
(exwm-input-set-key (kbd "M-y") 'consult-yank-pop)
(exwm-input-set-key (kbd "M-Y") 'my/exwm-counsel-yank-pop) ;;for pasting stuff in x windowapps
    (exwm-input-set-key (kbd "<s-pause>")
                        (lambda () (interactive) (start-process-shell-command "lock" nil exwm-locking-command)))

(use-package! desktop-environment
  :after exwm
  :config (desktop-environment-mode)
  :custom
  (desktop-environment-brightness-small-increment "2%+")
  (desktop-environment-brightness-small-decrement "2%-")
  (desktop-environment-brightness-normal-increment "5%+")
  (desktop-environment-brightness-normal-decrement "5%-")
  (desktop-environment-screenshot-command "flameshot gui"))

;; This needs a more elegant ASCII banner
(defhydra hydra-exwm-move-resize (:timeout 4)
  "Move/Resize Window (Shift is bigger steps, Ctrl moves window)"
  ("j" (lambda () (interactive) (exwm-layout-enlarge-window 10)) "V 10")
  ("J" (lambda () (interactive) (exwm-layout-enlarge-window 30)) "V 30")
  ("k" (lambda () (interactive) (exwm-layout-shrink-window 10)) "^ 10")
  ("K" (lambda () (interactive) (exwm-layout-shrink-window 30)) "^ 30")
  ("h" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 10)) "< 10")
  ("H" (lambda () (interactive) (exwm-layout-shrink-window-horizontally 30)) "< 30")
  ("l" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 10)) "> 10")
  ("L" (lambda () (interactive) (exwm-layout-enlarge-window-horizontally 30)) "> 30")
  ("C-j" (lambda () (interactive) (exwm-floating-move 0 10)) "V 10")
  ("C-S-j" (lambda () (interactive) (exwm-floating-move 0 30)) "V 30")
  ("C-k" (lambda () (interactive) (exwm-floating-move 0 -10)) "^ 10")
  ("C-S-k" (lambda () (interactive) (exwm-floating-move 0 -30)) "^ 30")
  ("C-h" (lambda () (interactive) (exwm-floating-move -10 0)) "< 10")
  ("C-S-h" (lambda () (interactive) (exwm-floating-move -30 0)) "< 30")
  ("C-l" (lambda () (interactive) (exwm-floating-move 10 0)) "> 10")
  ("C-S-l" (lambda () (interactive) (exwm-floating-move 30 0)) "> 30")
  ("f" nil "finished" :exit t))

(defun my/exwm-counsel-yank-pop ()
  "Same as `counsel-yank-pop' and paste into exwm buffer.
Stolen from https://github.com/DamienCassou/gpastel#for-exwmcounsel-users
and adapted to use simulations keys to have a common yank keystroke."
  (interactive)
  (let ((inhibit-read-only t)
        (yank-pop-change-selection t))
    (call-interactively #'counsel-yank-pop))
  (when (derived-mode-p 'exwm-mode)
    ;; https://github.com/ch11ng/exwm/issues/413#issuecomment-386858496
    (exwm-input--set-focus (exwm--buffer->id (window-buffer (selected-window))))
    (let ((keys (gethash [?\C-y]
                         exwm-input--simulation-keys)))
      (dolist (key keys)
        (exwm-input--fake-key key)))))

(add-hook 'exwm-update-title-hook
          (lambda ()
            (exwm-workspace-rename-buffer (my/exwm-buffer-name))))

(add-hook 'exwm-manage-finish-hook
          (lambda ()
            (setq-local default-directory (expand-file-name "~/"))
            (when (and exwm-class-name
                       (string= (downcase exwm-class-name) "urxvt"))
              (exwm-input-set-local-simulation-keys
               (append
                exwm-input-simulation-keys
                '(([?\C-y] . [?\C-\S-v])))))
            (when (and exwm-class-name
                       (string= (downcase exwm-class-name) "firefoxdeveloperedition"))
              (exwm-input-set-local-simulation-keys
               (append
                exwm-input-simulation-keys
                '(([?\C-s] . [?\C-f]) ; Swiper!
                  ([?\C-g] . [escape])
                  ([?\C-t] . nil))))))) ; Prevent accidental tab ; creation


(setq exwm-input-global-keys
      `(
        ([?\s-r]
         . exwm-reset)
        ([?\s-c]
         . exwm-input-toggle-keyboard)
        ([?\s-f]
         . my/toggle-single-window)
        ([?\s-I]
         . delete-window)
        ([?\s-H] . exwm-floating-hide)
        ([?\s-F] . exwm-floating-toggle-floating)
        ([?\s-m] . exwm-layout-toggle-mode-line)
        ([f11] . exwm-layout-toggle-fullscreen)
        ([?\s-e] . dired-jump)
;; Undo window configurations
        ([?\s-\C-r] . resize-window)
         ;; window managment
        ([?\s-T] . toggle-window-split)
        ([?\s-T] . toggle-window-split)
        ([?\s-T] . toggle-window-split)
 ;; Moving Windows
        ([?\s-T] . toggle-window-split)
        ([?\s-W] . swap-windows)
        ([?\s-a] . next-user-buffer)
        ([?\s-A] . previous-user-buffer)
        ([?\s-\C-L] . doom/window-maximize-horizontally)
        ([?\s-\C-U] . doom/window-maximize-vertically)
         ;; splits
        ;; ([?\s-v] . evil-window-vsplit)
        ;; ([?\s-z] . evil-window-split)
        ([?\s-z]
         . split-window-below)
        ([?\s-v]
         . split-window-right)
        ;; managing workspaces
        ([?\s-w] . exwm-workspace-switch)
        ([?\s-W] . exwm-workspace-swap)
        ([?\s-\C-w] . exwm-workspace-move)
        ([?\s-\]] . exwm/workspace-next)
        ([?\s-\[] . exwm/workspace-prev)
        ([?\s-\}] . exwm/workspace-move-buffer-next)
        ([?\s-{] . exwm/workspace-move-buffer-prev)
;;exwm
        ([?\s-c] . exwm-input-toggle-keyboard)
        ;; essential programs
        ([?\s-d] . dired)
        ([?\s-t] . +vterm/toggle)
        ([?\s-\;] . pp-eval-expression)
        ;; killing buffers and windows
        ([?\s-\C-h] . evil-window-move-far-right)
        ([?\s-\C-l] . evil-window-move-far-left)
        ([?\s-q] . kill-buffer-and-window)
        ([?\s-B] . kill-current-buffer)
        ([?\s-C] . +workspace/close-window-or-workspace)
        ([?\s-x] . doom/open-scratch-buffer)
        ;; change window focus with super+h,j,k,l
        ([?\s-h] . evil-window-left)
        ([?\s-j] . evil-window-next)
        ([?\s-k] . evil-window-prev)
        ([?\s-l] . evil-window-right)
        ;; move windows around using SUPER+SHIFT+h,j,k,l
        ([?\s-H] . +evil/window-move-left)
        ([?\s-J] . +evil/window-move-down)
        ([?\s-K] . +evil/window-move-up)
        ([?\s-L] . +evil/window-move-right)
        ([?\s-E] . (lambda () (interactive) (dired "~")))
        ([?\s-C] . (lambda () (interactive) (kill-buffer)))
        ;; move window workspace with SUPER+SHIFT+{0-9}
        ([?\s-!] . (lambda () (interactive) (exwm-workspace-move-window 0)))
        ([?\s-@] . (lambda () (interactive) (exwm-workspace-move-window 1)))
        ([?\s-#] . (lambda () (interactive) (exwm-workspace-move-window 2)))
        ([?\s-$] . (lambda () (interactive) (exwm-workspace-move-window 3)))
        ([?\s-%] . (lambda () (interactive) (exwm-workspace-move-window 4)))

        ;; Switch workspace
        ([?\s-w] . exwm-workspace-switch)
        ([?\s-`] . (lambda () (interactive) (exwm-workspace-switch-create 0)))
        ;; ([?\s-d] .
        ;;  (lambda ()
        ;;    (interactive)
        ;;    (bon-app-launcher-usr-bin)))
           ;; (counsel-linux-app)))

        ;; go to scratch
        ([s-escape] . (lambda ()
                        (interactive)
                        (switch-to-buffer "*scratch*")))
        ;; Bind "s-<f2>" to "slock", a simple X display locker.
        ([s-f2] . (lambda ()
                    (interactive)
                    (start-process "" nil "/usr/bin/slock")))
        ;; simple text to speech. Need to copy clipboard
        ([s-f7] . (lambda ()
                    (interactive)
                    (start-process-shell-command "" nil "xclip -o -sel clip | espeak-ng")))

        ;;youtube ytfzf
        ([?\s-Y] . (lambda ()
                     (interactive)
                     (start-process-shell-command "" nil "yt -D")))

        ;; youtube
        ([?\s-y] . (lambda ()
                     (interactive)
                     (ytel)));;ytel-search for buffers list though i usually export it via exbark export
        ;; Launch applications via shell command
	([?\s-&] . (lambda (command)
		     (interactive (list (read-shell-command "$ ")))
		     (start-process-shell-command command nil command)))
        ([?\s-#] .
         (lambda ()
           (interactive)
           (my/ivy-switch-buffer-firefox)))
        ,@(mapcar (lambda (i)
                    `(,(kbd (format "s-%d" (car i))) .
                      (lambda ()
                        (interactive)
                        (my/switch-to-buffer-if-exists-back-and-forth ,(cdr i)))))
                  '((2 . "Telegram") (3 . "Signal") (6 . "*eshell*")))
        ,@(mapcar (lambda (i)
                    `(,(kbd (format "s-%d" i)) .
                      (lambda (arg)
                        (interactive "P")
                        (my/bookmark-buffer-or-switch-to-bookmark arg))))
                  '(6 7))

	;; 's-N': Switch to certain workspace with Super (Win) plus a number key (0 - 9)
	,@(mapcar (lambda (i)
	            `(,(kbd (format "s-%d" i)) .
	              (lambda ()
	        	(interactive)
	        	(exwm-workspace-switch-create ,i))))
	          (number-sequence 0 5))

        ([?\s-8]
         . my/ivy-switch-buffer-detached-command)
        ;; ([?\s-8]
        ;;  . mu4e-headers-search-bookmark)
        ([?\s-9] .
         (lambda ()
           (interactive)
           (my/ivy-switch-buffer-urxvt)))
        ;; ([?\s-$] .
        ;;  (lambda ()
        ;;    (interactive)
        ;;    (start-process "" nil "/usr/bin/firefox")))
        ([?\s-p]
         . my/exwm-toggle-or-set-buffer-protection)
        ([?\s-Q] .
         (lambda ()
           (interactive)
           (start-process "" nil "/usr/bin/alacritty")))
        ([?\s-=]
         . balance-windows)
        ([?\s-L] .
         (lambda ()
           (interactive)
           (exwm-layout-enlarge-window-horizontally 100)))
        ([?\s-U] .
         (lambda ()
           (interactive)
           (exwm-layout-shrink-window-horizontally 100)))))

(exwm-enable))
#+end_src

#+RESULTS:
: t

** Desktop File

This file is used by your "login manager" (GDM, LightDM, etc) to display EXWM as a desktop environment option when you log in.
*IMPORTANT*: Make sure you create a symbolic link for this file into =/usr/share/xsessions=:

#+begin_src sh :tangle no

sudo ln -f ~/.config/doom/exwm/EXWM.desktop /usr/share/xsessions/EXWM.desktop

#+end_src

#+begin_src shell :tangle ./exwm/EXWM.desktop :mkdirp yes

  [Desktop Entry]
  Name=EXWM
  Comment=Emacs Window Manager
  Exec=sh /home/shiva/.config/doom/exwm/start-exwm.sh
  TryExec=sh
  Type=Application
  X-LightDM-DesktopName=exwm
  DesktopNames=exwm

#+end_src

#+RESULTS:

** launcher script v2
#+begin_src shell :tangle ./exwm/start-exwm.sh :shebang #!/bin/sh
#!/bin/bash
# Very important: Avoid spawning daemons here.
# They will not exit with this process, so we will no longer have a clean X11 shutdown.

# xset -dpms
# xset s off

# killall emacs
# Disable access control for the current user.
xhost +SI:localuser:$USER

## you might need to append the TTY you are working on
# xinit

# wmname LG3D

# ## Run site init scripts. Usually not necessary.
# if [ -d /etc/X11/xinit/xinitrc.d ] ; then
#     for f in /etc/X11/xinit/xinitrc.d/?*.sh ; do
#         [ -x "$f" ] && . "$f"
#     done
#     unset f
# fi

# . ~/exwm_screen_layout
# ~/exwm_xrandr.bash

# Set themes, etc.
# xrdb -override ~/exwm_x11_resources.xrdb
# Note: xsettingsd just publishes settings. You must ensure that it has settings to publish.
# /usr/bin/xsettingsd &
# Try to control screen blanking
# xset s off dpms 1200 1400 1600
# Set keyboard repeat rate. Default is 660 25 ("xset q")
xset r rate 200 30

# Set default cursor.
# xsetroot -cursor_name left_ptr

# Hide the mouse pointer if unused for a duration
/usr/bin/unclutter &

# unclutter --jitter 3 --ignore-scrolling &
# One can also start processes unrelated to X11, just ensure that they will exit when this process exits.

# Enable "Num Lock" mode, on keyboard keypad
# /usr/bin/numlockx on &

  # Run the screen compositor
picom &

  # xsettingsd_preset_file="${XDG_DATA_HOME:-$HOME/.local/share}/xsettingsd/presets/dark"
  # xsettingsd_config_file="${XDG_CONFIG_HOME:-$HOME/.config}/xsettingsd/xsettingsd"

  # ln -sf "$xsettingsd_preset_file" "$xsettingsd_config_file" \
  #     && xsettingsd -c "$xsettingsd_config_file" &

# eval $(gnome-keyring-daemon -s)
# export SSH_AUTH_SOCK
  # Enable screen locking on suspend
xss-lock -- slock &
# Uncomment the following block to use the exwm-xim module. Not something I use.
# export XMODIFIERS=@im=exwm-xim
# export GTK_IM_MODULE=xim
# export QT_IM_MODULE=xim
# export CLUTTER_IM_MODULE=xim

# If Emacs is started in server mode, `emacsclient` is a convenient way to
# edit files in place (used by e.g. `git commit`).

export VISUAL=emacsclient
export EDITOR="$VISUAL"
# Finally start Emacs
# Scrolling gtk3 apps won't work, unless GDK_CORE_DEVICE_EVENTS is defined
export GDK_CORE_DEVICE_EVENTS=1
# Make Java applications aware this is a non-reparenting window manager.
export _JAVA_AWT_WM_NONREPARENTING=1

# exec dbus-launch --exit-with-session /usr/local/bin/emacs --eval "(progn (require 'exwm) (exwm-enable))"
# "exwm-enable" has to be called before the frame is spawned.
 # exec dbus-launch --exit-with-session emacs -mm --debug-init -l ~/.emacs.d/desktop.el
exec dbus-run-session emacs --eval "(exwm-enable)"
# exec emacsclient -c
#+end_src
** DPI configuration

The =Xresources= file will be used with =xrdb= in =start-exwm.sh= to set our screen DPI:

#+begin_src conf :tangle ./exwm/Xresources

  Xft.dpi:   100   # Set this to your desired DPI!  Larger number means bigger text and UI

#+end_src
** Polybar
*** Polybar.el
Fira Code** Panel with Polybar

Polybar provides a great, minimalistic panel for your EXWM desktop configuration.  The following config integrates =emacsclient= and Polybar with =polybar-msg= to enable you to gather *any* information from Emacs and display it in the panel!

Check out the Polybar wiki for more details on how to configure it: https://github.com/polybar/polybar/wiki

#+begin_src emacs-lisp

  ;; Make sure the server is started (better to do this in your main Emacs config!)
  (server-start)

  (defvar efs/polybar-process nil
    "Holds the process of the running Polybar instance, if any")

  (defun efs/kill-panel ()
    (interactive)
    (when efs/polybar-process
      (ignore-errors
        (kill-process efs/polybar-process)))
    (setq efs/polybar-process nil))

  (defun efs/start-panel ()
    (interactive)
    (efs/kill-panel)
    (setq efs/polybar-process (start-process-shell-command "polybar" nil "polybar panel")))
    ;; (setq efs/polybar-process (start-process-shell-command "polybar" nil "bash ~/.config/polybar/launch.sh --material")))
  (defun efs/send-polybar-hook (module-name hook-index)
    (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" module-name hook-index)))

  (defun efs/send-polybar-exwm-workspace ()
    (efs/send-polybar-hook "exwm-workspace" 1))

  ;; Update panel indicator when workspace changes
  (add-hook 'exwm-workspace-switch-hook #'efs/send-polybar-exwm-workspace)

(defun dw/send-polybar-hook (name number)
  (start-process-shell-command "polybar-msg" nil (format "polybar-msg hook %s %s" name number)))

(defun dw/update-polybar-exwm (&optional path)
  (dw/send-polybar-hook "exwm" 1)
  (dw/send-polybar-hook "exwm-path" 1))

(defun dw/update-polybar-telegram ()
  (dw/send-polybar-hook "telegram" 1))

(defun dw/polybar-exwm-workspace ()
  (pcase exwm-workspace-current-index
    (0 "")
    (1 "")
    (2 "")
    (3 "")
    (4 "")))

(defun dw/polybar-exwm-workspace-path ()
  (let ((workspace-path (frame-parameter nil 'bufler-workspace-path-formatted)))
    (if workspace-path
        (substring-no-properties workspace-path)
      "")))

(defun dw/polybar-mail-count (max-count)
  (if (and dw/mail-enabled dw/mu4e-inbox-query)
    (let* ((mail-count (shell-command-to-string
                         (format "mu find --nocolor -n %s \"%s\" | wc -l" max-count dw/mu4e-inbox-query))))
      (format " %s" (string-trim mail-count)))
    ""))

(defun dw/telega-normalize-name (chat-name)
  (let* ((trimmed-name (string-trim-left (string-trim-right chat-name "}") "◀{"))
         (first-name (nth 0 (split-string trimmed-name " "))))
    first-name))

(defun dw/propertized-to-polybar (buffer-name)
  (if-let* ((text (substring-no-properties buffer-name))
            (fg-face (get-text-property 0 'face buffer-name))
            (fg-color (face-attribute fg-face :foreground)))
    (format "%%{F%s}%s%%{F-}" fg-color (dw/telega-normalize-name text))
    text))

(defun dw/polybar-telegram-chats ()
  (if (> (length tracking-buffers) 0)
    (format " %s" (string-join (mapcar 'dw/propertized-to-polybar tracking-buffers) ", "))
    ""))

(add-hook 'exwm-workspace-switch-hook #'dw/update-polybar-exwm)
(add-hook 'bufler-workspace-set-hook #'dw/update-polybar-exwm)
#+end_src

#+RESULTS:
| dw/update-polybar-exwm |

*** polybar config
The configuration for our ingeniously named panel, "panel".  Invoke it with =polybar panel= on the command line!
#+RESULTS:
#+begin_src conf :tangle ~/.config/polybar/config :mkdirp yes

; Docs: https://github.com/polybar/polybar
;==========================================================

[settings]
screenchange-reload = true
; pseudo-transparency = true

[global/wm]
margin-top = 0
margin-bottom = 0

[colors]
background = #f0232635
; background = #aa2F343F
background-alt = #576075
foreground = #A6Accd
; foreground = #f3f4f5
foreground-alt = #555
primary = #ffb52a
secondary = #e60053
alert = #bd2c40
underline-1 = #c792ea
draculamem = #ff5555
draculabat = #ff6e67
draculanet = #bd93f9
draculacpu = #f1fa8c
draculagreen = #5af78e
draculapink = #ff79c6

; for pywal

; [colors]
; background = ${xrdb:color0:#222}
; foreground = ${xrdb:color7:#222}
; foreground-alt = ${xrdb:color7:#222}
; primary = ${xrdb:color1:#222}
; secondary = ${xrdb:color2:#222}
; alert = ${xrdb:color3:#222}

; [bar/bar]
; ; ...
; background = ${colors.background}
; foreground = ${colors.foreground}


[bar/panel]
width = 100%
; height = <<get-setting(name="polybar/height")>>
height = 20
offset-x = 0
offset-y = 0
fixed-center = true
enable-ipc = true

background = ${colors.background}
foreground = ${colors.foreground}

line-size = 2
line-color = #f00

border-size = 0
border-color = #00000000

padding-top = 4
padding-left = 1
padding-right = 1

module-margin = 1

font-0 = "Cantarell:size=10:weight=bold;1"
font-1 = "Font Awesome:size=7;1"
font-2 = "Material Icons:size=10;3"
font-3 = "Fira Mono:size=6;-3"

modules-left = exwm exwm-path exwm-workspace
modules-center = spotify mpd
; modules-left = exwm-workspace
modules-right =  wireless-network networkspeedup networkspeeddown cpu memory filesystem uptime arch-aur-updates battery temperature date pulseaudio

; exwm-workspace exwm exwm-path spotify mu4e telegram xkeyboard cpu date battery1 battery temperture temperature1 xbacklight wireless-network wired-network
; weathe volume uptime filesystem pulseaudio memory wlan eth network networkspeedup networkspeeddown networkspeedup1 networkspeeddown1 arch-aur-updates aur-updates
; filesystem1 kernel load-average mpd release pub-ip pavolume  ;; was at the end volume pavolume
tray-position = right
tray-padding =2
tray-maxsize =40

cursor-click = pointer
cursor-scroll = ns-resize

[module/exwm-workspace]
type = custom/ipc
hook-0 = emacsclient -e "exwm-workspace-current-index" | sed -e 's/^"//' -e 's/"$//'
initial = 1
format-underline = ${colors.underline-1}
format-padding = 1

[module/exwm]
type = custom/ipc
hook-0 = emacsclient -e "(dw/polybar-exwm-workspace)" | sed -e 's/^"//' -e 's/"$//'
initial = 1
format-underline = ${colors.underline-1}
format-background = ${colors.background-alt}
format-padding = 1


[module/exwm-path]
type = custom/ipc
hook-0 = emacsclient -e "(dw/polybar-exwm-workspace-path)" | sed -e 's/^"//' -e 's/"$//'
format-foreground = #f78c6c
initial = 1

; [module/spotify]
; type = custom/script
; exec = ~/.config/polybar/player-status.sh
; interval = 3

; [module/mu4e]
; type = custom/ipc
; hook-0 = emacsclient -e '(dw/polybar-mail-count 500)' | sed -e 's/^"//' -e 's/"$//'
; initial = 1
; format-underline = ${colors.underline-1}
; click-left = emacsclient -e '(dw/go-to-inbox)'

; [module/telegram]
; type = custom/ipc
; hook-0 = emacsclient -e '(dw/polybar-telegram-chats)' | sed -e 's/^"//' -e 's/"$//'
; format-padding = 3
; initial = 1

[module/xkeyboard]
type = internal/xkeyboard
blacklist-0 = num lock

format-prefix-font = 1
format-prefix-foreground = ${colors.foreground-alt}
format-prefix-underline = ${colors.underline-1}

label-layout = %layout%
label-layout-underline = ${colors.underline-1}

label-indicator-padding = 2
label-indicator-margin = 1
label-indicator-underline = ${colors.underline-1}


[module/cpu]
type = internal/cpu
interval = 2
format = <label> <ramp-coreload>
format-foreground = ${colors.draculacpu}
; format-background = ${colors.background}
;   
; format-prefix = " "
; format-prefix-foreground = #cd1f3f
format-underline = ${colors.draculacpu}
click-right = exec htop
click-left = emacsclient -e "(proced)"
label = %percentage:2%%
label-foreground = ${colors.draculacpu}
ramp-coreload-spacing = 1
; ramp-coreload-0 = ▁
; ramp-coreload-0-foreground = ${colors.draculacpu}
; ramp-coreload-1 = ▂
; ramp-coreload-2 = ▃
; ramp-coreload-3 = ▄
; ramp-coreload-4 = ▅
; ramp-coreload-5 = ▆
; ramp-coreload-6 = ▇

ramp-coreload-0 = ▁
ramp-coreload-0-font = 3
ramp-coreload-0-foreground = #aaff77
ramp-coreload-1 = ▂
ramp-coreload-1-font = 3
ramp-coreload-1-foreground = #aaff77
ramp-coreload-2 = ▃
ramp-coreload-2-font = 3
ramp-coreload-2-foreground = #aaff77
ramp-coreload-3 = ▄
ramp-coreload-3-font = 3
ramp-coreload-3-foreground = #aaff77
ramp-coreload-4 = ▅
ramp-coreload-4-font = 3
ramp-coreload-4-foreground = #fba922
ramp-coreload-5 = ▆
ramp-coreload-5-font = 3
ramp-coreload-5-foreground = #fba922
ramp-coreload-6 = ▇
ramp-coreload-6-font = 3
ramp-coreload-6-foreground = #ff5555
ramp-coreload-7 = █
ramp-coreload-7-font = 3
ramp-coreload-7-foreground = #ff5555


[module/date]
type = internal/date
interval = 5

date = "%a %b %e"
date-alt = "%A %B %d %Y"

time = %l:%M %p
time-alt = %H:%M:%S

format-prefix-foreground = ${colors.draculapink}
format-underline = ${colors.draculapink}

label = %date% %time%
label-foreground = ${colors.draculapink}

[module/battery1a]
;https://github.com/jaagr/polybar/wiki/Module:-battery
type = internal/battery
battery = BAT1
adapter = AC0
full-at = 100

format-charging = <animation-charging> <label-charging>
label-charging =  %percentage%%
format-charging-foreground = ${colors.foreground}
format-charging-background = ${colors.background}
format-charging-underline = #a3c725

format-discharging = <ramp-capacity> <label-discharging>
label-discharging =  %percentage%%
format-discharging-underline = #c7ae25
format-discharging-foreground = ${colors.foreground}
format-discharging-background = ${colors.background}

format-full-prefix = " "
format-full-prefix-foreground = #a3c725
format-full-underline = #a3c725
format-full-foreground = ${colors.foreground}
format-full-background = ${colors.background}

ramp-capacity-0 = 
ramp-capacity-1 = 
ramp-capacity-2 = 
ramp-capacity-3 = 
ramp-capacity-4 = 
ramp-capacity-foreground = #c7ae25

animation-charging-0 = 
animation-charging-1 = 
animation-charging-2 = 
animation-charging-3 = 
animation-charging-4 = 
animation-charging-foreground = #a3c725
animation-charging-framerate = 750

[module/battery]
type = internal/battery
battery = BAT1
adapter = ADP1
full-at = 98
time-format = %-l:%M

label-charging = %percentage%% / %time%
format-charging = <animation-charging> <label-charging>
format-charging-underline = ${colors.draculagreen}
label-charging-foreground = ${colors.draculagreen}

label-discharging = %percentage%% / %time%
label-discharging-foreground = ${colors.draculagreen}
format-discharging = <ramp-capacity> <label-discharging>
format-discharging-underline = ${self.format-charging-underline}

format-full = <ramp-capacity> <label-full>
format-full-underline = ${self.format-charging-underline}

ramp-capacity-0 = 
ramp-capacity-1 = 
ramp-capacity-2 = 
ramp-capacity-3 = 
ramp-capacity-4 = 
ramp-capacity-foreground = ${colors.draculagreen}
animation-charging-0 = 
animation-charging-1 = 
animation-charging-2 = 
animation-charging-3 = 
animation-charging-4 = 
animation-charging-foreground = ${colors.draculagreen}
animation-charging-framerate = 750


[module/temperature]
;https://github.com/jaagr/polybar/wiki/Module:-temperature
type = internal/temperature
; Thermal zone to use
; To list all the zone types, run
; $ for i in /sys/class/thermal/thermal_zone*; do echo "$i: $(<$i/type)"; done
; Default: 0
thermal-zone = 0

; Full path of temperature sysfs path
; Use `sensors` to find preferred temperature source, then run
; $ for i in /sys/class/hwmon/hwmon*/temp*_input; do echo "$(<$(dirname $i)/name): $(cat ${i%_*}_label 2>/dev/null || echo $(basename ${i%_*})) $(readlink -f $i)"; done
; to find path to desired file
; Default reverts to thermal zone setting
hwmon-path = /sys/devices/platform/coretemp.0/hwmon/hwmon1/temp1_input

warn-temperature = 70
format = <ramp> <label>
format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-underline = #c72581
format-warn = <ramp> <label-warn>
format-warn-underline = #c7254f
label = %temperature%
label-warn =  %temperature%
label-warn-foreground = #c7254f

ramp-0 = 
ramp-1 = 
ramp-2 = 
ramp-3 = 
ramp-4 = 
ramp-foreground =${colors.foreground}

[module/xbacklight]

;https://github.com/jaagr/polybar/wiki/Module:-xbacklight
type = internal/xbacklight
format = <label> <bar>
format-prefix = "   "
format-prefix-foreground = ${colors.foreground}
format-prefix-background = ${colors.background}
format-prefix-underline = #9f78e1
format-underline = #9f78e1
label = %percentage%%
bar-width = 2
; bar-width = 10
bar-indicator = 
bar-indicator-foreground = #fff
bar-indicator-font = 2
bar-fill = 
bar-fill-font = 2
bar-fill-foreground = #9f78e1
bar-empty = 
bar-empty-font = 2
bar-empty-foreground = #fff
format-foreground = ${colors.foreground}
format-background = ${colors.background}

[module/wireless-network]
;https://github.com/jaagr/polybar/wiki/Module:-network
type = internal/network
interface = wlp0s20f0u3
interval = 3.0
label-connected = %essid%
click-right = exec nm-applet

format-connected = <label-connected>
;format-connected = <ramp-signal> <label-connected>
format-connected-foreground = ${colors.foreground}
format-connected-background = ${colors.background}
format-connected-prefix = "  "
format-connected-prefix-foreground = #7e52c6
format-connected-prefix-background = ${colors.background}
format-connected-underline = #7e52c6

label-disconnected = %ifname% disconnected
label-disconnected-foreground = ${colors.alert}
label-disconnected-background = ${colors.background}

format-disconnected = <label-disconnected>
format-disconnected-foreground = ${colors.alert}
format-disconnected-background = ${colors.background}
format-disconnected-prefix = "  "
format-disconnected-prefix-foreground = ${colors.alert}
format-disconnected-prefix-background = ${colors.background}
format-disconnected-underline =${colors.alert}

ramp-signal-0 = ▁
ramp-signal-1 = ▂
ramp-signal-2 = ▃
ramp-signal-3 = ▄
ramp-signal-4 = ▅
ramp-signal-5 = ▆
ramp-signal-6 = ▇
ramp-signal-7 = █
ramp-signal-foreground = #7e52c6

[module/wired-network]
;https://github.com/jaagr/polybar/wiki/Module:-network
type = internal/network
interface = enp2s0
;interface = enp14s0
interval = 3.0

; Available tokens:
;   %ifname%    [wireless+wired]
;   %local_ip%  [wireless+wired]
;   %essid%     [wireless]
;   %signal%    [wireless]
;   %upspeed%   [wireless+wired]
;   %downspeed% [wireless+wired]
;   %linkspeed% [wired]
; Default: %ifname% %local_ip%
label-connected =  %ifname%
label-disconnected = %ifname% disconnected

format-connected-foreground = ${colors.foreground}
format-connected-background = ${colors.background}
format-connected-underline = #55aa55
format-connected-prefix = " "
format-connected-prefix-foreground = #55aa55
format-connected-prefix-background = ${colors.background}

format-disconnected = <label-disconnected>
format-disconnected-underline = ${colors.alert}
label-disconnected-foreground = ${colors.foreground}

[module/weather]
type = custom/script
interval = 10
format = <label>
format-prefix = " "
format-prefix-foreground = #3EC13F
format-underline = #3EC13F
format-foreground = ${colors.foreground}
format-background = ${colors.background}
exec = python -u ~/.config/polybar/scripts/weather.py
tail = true

[module/volume]
;https://github.com/jaagr/polybar/wiki/Module:-volume
type = internal/volume
format-volume = "<label-volume>  <bar-volume>"
format-volume-underline = #40ad4b

label-volume = " "
label-volume-underline = #40ad4b
label-volume-foreground = #40ad4b
label-muted = muted

bar-volume-width = 5
bar-volume-foreground-0 = #40ad4b
bar-volume-foreground-1 = #40ad4b
bar-volume-foreground-2 = #40ad4b
bar-volume-foreground-3 = #40ad4b
bar-volume-foreground-4 = #40ad4b
bar-volume-foreground-5 = #40ad4b
bar-volume-foreground-6 = #40ad4b
bar-volume-gradient = false
bar-volume-indicator = 
bar-volume-indicator-font = 2
bar-volume-fill = 
bar-volume-fill-font = 2
bar-volume-empty = 
bar-volume-empty-font = 2
bar-volume-empty-foreground = ${colors.foreground}
format-volume-foreground = ${colors.foreground}
format-volume-background = ${colors.background}
format-muted-prefix = "  "
format-muted-prefix-foreground = "#ff0000"
format-muted-foreground = ${colors.foreground}
format-muted-background = ${colors.background}

[module/uptime]
;https://github.com/jaagr/polybar/wiki/User-contributed-modules#uptime
type = custom/script
exec = uptime | awk -F, '{sub(".*up ",x,$1);print $1}'
interval = 100
label = Uptime : %output%

format-foreground =#98be65
format-background = ${colors.background}
format-prefix = " "
format-prefix-foreground = #98be65
format-underline = #98be65


[module/pulseaudio]
type = internal/pulseaudio

; format-volume-prefix = "V: "
; format-volume-prefix-underline = ${colors.underline-1}
; format-volume-prefix-foreground = ${colors.foreground}
; format-volume = <label-volume>

label-volume = %percentage%%
label-volume-underline = ${colors.underline-1}

label-muted = muted
label-muted-foreground = ${colors.foreground}

[module/memory]
type = internal/memory
interval = 2
format-underline = ${colors.draculamem}
format-prefix = "RAM "
format-prefix-foreground = ${colors.draculamem}
label = %percentage_used:2%%
label-foreground = ${colors.draculamem}
[network-base]
type = internal/network
interval = 5
format-underline = ${colors.underline-1}
format-connected = <label-connected>
format-disconnected = <label-disconnected>
label-disconnected = %{F#F0C674}%ifname%%{F#707880} disconnected

[module/wlan]
inherit = network-base
interface-type = wireless
label-connected = %{F#bd93f9}%essid%%{F-} %{F#bd93f9}%local_ip%%{F-}
; label-connected = %{F#bd93f9}%ifname%%{F-} %{F#bd93f9}%essid%%{F-} %{F#bd93f9}%local_ip%%{F-}
label-connected-underline = ${colors.underline-1}
[module/eth]
inherit = network-base
format-underline = ${colors.underline-1}
interface-type = wired
label-connected = %{F#F0C674}%ifname%%{F-} %local_ip%


[module/network]
type = internal/network
interface = wlp2s0
interval = 1.0
label-connected = "  %downspeed%   %upspeed%  "
label-disconnected = disconnected
label-connected-background = #FF0000

[module/networkspeedup]
type = internal/network
interface = wlp0s20f0u3
label-connected = "%upspeed:7%"
format-connected = <label-connected>
format-connected-underline = ${colors.underline-1}
format-connected-prefix = " "
format-connected-prefix-foreground = ${colors.underline-1}
; format-connected-prefix-foreground = #fefefe
; format-connected-foreground = #fefefe
format-connected-foreground = ${colors.draculanet}
; format-connected-background = #8d62a9
; ip link show =interface

[module/networkspeeddown]
type = internal/network
interface = wlp0s20f0u3
label-connected = "%downspeed:7%"
format-connected = <label-connected>
format-connected-underline = ${colors.underline-1}
format-connected-prefix = "  "
format-connected-prefix-foreground = ${colors.underline-1}
; format-connected-prefix-foreground = #fefefe
; format-connected-foreground = #fefefe
format-connected-foreground = ${colors.draculanet}
; format-connected-background = #8d62ad

[module/arch-aur-updates]
type = custom/script
exec = ~/.config/polybar/scripts/check-arch-updates.sh
interval = 1000
label = Updates: %output%
; format-foreground = ${colors.foreground}
format-foreground = #FFBB00
format-background = ${colors.background}
format-underline = #FFBB00
format-prefix = "  "
format-prefix-foreground = #fefefe


[module/aur-updates]
type = custom/script
exec = ~/.config/polybar/scripts/check-aur-updates.sh
interval = 1000
label = Aur: %output%
; format-foreground = ${colors.foreground}
format-foreground = #FFBB00
format-background = ${colors.background}
format-prefix = "  "
; format-prefix-foreground = #FFBB00
format-prefix-foreground = #fefefe
format-underline = #FFBB00

[module/filesystem1]
type = internal/fs
interval = 25

mount-0 = /

label-mounted = %{F#F0C674}%mountpoint%%{F-} %{F#5af78e}%percentage_used%%{F-}
label-mounted-foreground = ${colors.draculagreen}
label-mounted-underline = ${colors.draculagreen}
label-unmounted = %mountpoint% not mounted
label-unmounted-foreground = ${colors.draculagreen}

[module/filesystem]
;https://github.com/jaagr/polybar/wiki/Module:-filesystem
type = internal/fs

; Mountpoints to display
mount-0 = /
; mount-1 = /home
; mount-2 = /var
; mount-3= /media/New_Volume
; mount-4= /media/hdd_home
; Seconds to sleep between updates
; Default: 30
interval = 30

; Display fixed precision values
; Default: false
fixed-values = false

; Spacing between entries
; Default: 2
spacing = 4

; Available tags:
;   <label-mounted> (default)
;   <bar-free>
;   <bar-used>
;   <ramp-capacity>
format-mounted = <label-mounted>
format-mounted-foreground = ${colors.foreground}
format-mounted-background = ${colors.background}
format-mounted-underline = #fe0000


; Available tokens:
;   %mountpoint%
;   %type%
;   %fsname%
;   %percentage_free%
;   %percentage_used%
;   %total%
;   %free%
;   %used%
; Default: %mountpoint% %percentage_free%%
; label-mounted = %mountpoint% : %used% used of %total%
label-mounted = %mountpoint% : %used%/%total%
; label-mounted = %mountpoint%: %percentage_free%% of %total%

; Available tokens:
;   %mountpoint%
; Default: %mountpoint% is not mounted
label-unmounted = %mountpoint% not mounted
;format-unmounted-foreground = ${colors.foreground}
; format-unmounted-background = ${colors.background}
;format-unmounted-underline = ${colors.alert}

;label-mounted = %{F#F0C674}%mountpoint%%{F-} %{F#5af78e}%percentage_used%%{F-}
label-mounted-foreground = ${colors.draculagreen}
label-mounted-underline = ${colors.draculagreen}
label-unmounted-foreground = ${colors.draculagreen}

[module/kernel]
type = custom/script
exec = uname -r
tail = false
interval = 1024
format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-prefix = "  "
format-prefix-foreground = #0084FF
format-underline = #4B5665

[module/load-average]
type = custom/script
exec = uptime | grep -ohe 'load average[s:][: ].*' | awk '{ print $3" "$4" "$5"," }' | sed 's/,//g'
interval = 100
;HOW TO SET IT MINIMAL 10 CHARACTERS - HIDDEN BEHIND SYSTEM ICONS
;label = %output%
label = %output:10%
format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-prefix = "  "
format-prefix-foreground = #62FF00
format-underline = #62FF00

[module/mpd]
;https://github.com/jaagr/polybar/wiki/Module:-mpd
type = internal/mpd
;format-online =  "<label-song>   <icon-prev>  <icon-stop>  <toggle>  <icon-next>"
;format-online =  "<label-song>  <bar-progress>"
;format-online = "<icon-prev> <icon-seekb> <icon-stop> <toggle> <icon-seekf> <icon-next>  <icon-repeat> <icon-random>  <bar-progress> <label-time>  <label-song>"
format-online =  "<label-song>  <bar-progress> <icon-prev>  <icon-stop>  <toggle>  <icon-next>"
icon-prev = 
icon-stop = 
icon-play = 
icon-pause = 
icon-next = 
label-song-maxlen = 40
label-song-ellipsis = true
bar-progress-width = 10
bar-progress-indicator = 
bar-progress-fill = 
bar-progress-empty = 
bar-progress-fill-foreground = #ff0
bar-progress-fill-background = ${colors.background}
bar-progress-indicator-foreground = ${colors.foreground}
format-online-foreground = ${colors.foreground}
format-online-background = ${colors.background}
; Available tokens:
;   %artist%
;   %album-artist%
;   %album%
;   %date%
;   %title%
; Default: %artist% - %title%
label-song = 𝄞 %artist% - %title%

;format-playing = ${self.format-online}
;format-paused = ${self.format-online}
;format-stopped = ${self.format-online}
; Available tokens:
;   None
label-offline = 🎜 mpd is offline


; Used to display the state of random/repeat/repeatone/single
; Only applies if <icon-[random|repeat|repeatone|single]> is used
toggle-on-foreground = #ff
toggle-off-foreground = #55

; [module/release]
; type = custom/script
; exec = (lsb_release -d | awk {'print $2'} ;echo " "; lsb_release -r | awk {'print $2'}) | tr -d '\n'
; interval = 6000

; format-foreground = ${colors.foreground}
; format-background = ${colors.background}
; format-prefix = "  "
; format-prefix-foreground = #62FF00
; format-underline = #62FF00
; interval = 6000

[module/pub-ip]
;https://linuxconfig.org/polybar-a-better-wm-panel-for-your-linux-system
type = custom/script
exec = ~/.config/polybar/scripts/pub-ip.sh
interval = 100
format-foreground = ${colors.foreground}
format-background = ${colors.background}
format-underline = #FFBB00
label = %output%
format-prefix = "  "
format-prefix-foreground = #FFBB00

[module/pavolume]
type = custom/script
tail = true
label = %output%
exec = ~/.config/polybar/scripts/pavolume.sh --listen
click-right = exec pavucontrol
click-left = ~/.config/polybar/scripts/pavolume.sh --togmute
scroll-up = ~/.config/polybar/scripts/pavolume.sh --up
scroll-down = ~/.config/polybar/scripts/pavolume.sh --down
format-foreground = #fefefe
format-background = #668bd7
#+end_src

;; I created a simple script to grab Spotify player information using playerctl:

#+begin_src shell :tangle ~/.config/polybar/player-status.sh :shebang #!/bin/sh


status="$(playerctl -p spotify status 2>&1)"
if [ "$status" != "No players found" ]
then
  artist="$(playerctl -p spotify metadata artist)"
  if [ "$artist" != "" ]
  then
    echo " $(playerctl -p spotify metadata artist) - $(playerctl -p spotify metadata title)"
  else
    # Clear any string that was previously displayed
    echo ""
  fi
else
  # Clear any string that was previously displayed
  echo ""
fi
#+end_src
** Desktop Notifications with Dunst

We use anapplication called [[https://dunst-project.org/][Dunst]] to enable the display of desktop notifications from Emacs and other applications running within EXWM.  Consult the [[https://dunst-project.org/documentation/][documentation]] for more details on how to configure this to your liking!

Here are some things you might want to consider changing:

- =format= - Customize how notification text contents are displayed
- =geometry= - Where the notification appears and how large it should be by default
- =urgency_normal=, etc - configures the background and frame color for notifications of different types
- =max_icon_size= - Constrain icon display since some icons will be larger than others
- =icon_path= - Important if your icons are not in a common location (like when using GNU Guix)
- =idle_threshold= - Wait for user to become active for this long before hiding notifications
- =mouse_left/right/middle_click= - Action to take when clicking a notification
- Any of the key bindings in the =shortcuts= section (though these are deprecated in 1.5.0, use =dunstctl=)

#+begin_src conf :tangle no
 # :tangle ~/.config/dunst/dunstrc :mkdirp yes

[global]
    ### Display ###
    monitor = 0

    # The geometry of the window:
    #   [{width}]x{height}[+/-{x}+/-{y}]
    geometry = "500x10-10+50"

    # Show how many messages are currently hidden (because of geometry).
    indicate_hidden = yes

    # Shrink window if it's smaller than the width.  Will be ignored if
    # width is 0.
    shrink = no

    # The transparency of the window.  Range: [0; 100].
    transparency = 10

    # The height of the entire notification.  If the height is smaller
    # than the font height and padding combined, it will be raised
    # to the font height and padding.
    notification_height = 0

    # Draw a line of "separator_height" pixel height between two
    # notifications.
    # Set to 0 to disable.
    separator_height = 1
    separator_color = frame

    # Padding between text and separator.
    padding = 4

    # Horizontal padding.
    horizontal_padding = 4

    # Defines width in pixels of frame around the notification window.
    # Set to 0 to disable.
    frame_width = 1

    # Defines color of the frame around the notification window.
    frame_color = "#89AAEB"

    # Sort messages by urgency.
    sort = yes

    # Don't remove messages, if the user is idle (no mouse or keyboard input)
    # for longer than idle_threshold seconds.
    idle_threshold = 120

    ### Text ###

    font = Fira Code 15

    # The spacing between lines.  If the height is smaller than the
    # font height, it will get raised to the font height.
    line_height = 0
    markup = full

    # The format of the message.  Possible variables are:
    #   %a  appname
    #   %s  summary
    #   %b  body
    #   %i  iconname (including its path)
    #   %I  iconname (without its path)
    #   %p  progress value if set ([  0%] to [100%]) or nothing
    #   %n  progress value if set without any extra characters
    #   %%  Literal %
    # Markup is allowed
    format = "<b>%s</b>\n%b"

    # Alignment of message text.
    # Possible values are "left", "center" and "right".
    alignment = left

    # Show age of message if message is older than show_age_threshold
    # seconds.
    # Set to -1 to disable.
    show_age_threshold = 60

    # Split notifications into multiple lines if they don't fit into
    # geometry.
    word_wrap = yes

    # When word_wrap is set to no, specify where to make an ellipsis in long lines.
    # Possible values are "start", "middle" and "end".
    ellipsize = middle

    # Ignore newlines '\n' in notifications.
    ignore_newline = no

    # Stack together notifications with the same content
    stack_duplicates = true

    # Hide the count of stacked notifications with the same content
    hide_duplicate_count = false

    # Display indicators for URLs (U) and actions (A).
    show_indicators = yes

    ### Icons ###

    # Align icons left/right/off
    icon_position = left

    # Scale larger icons down to this size, set to 0 to disable
    max_icon_size = 0

    # Paths to default icons.
    icon_path = /usr/share/icons/Adwaita/96x96/status:/usr/share/icons/Adwaita/96x96/emblems

    ### History ###

    # Should a notification popped up from history be sticky or timeout
    # as if it would normally do.
    sticky_history = no

    # Maximum amount of notifications kept in history
    history_length = 20

    ### Misc/Advanced ###

    # Browser for opening urls in context menu.
    browser = qutebrowser

    # Always run rule-defined scripts, even if the notification is suppressed
    always_run_script = true

    # Define the title of the windows spawned by dunst
    title = Dunst

    # Define the class of the windows spawned by dunst
    class = Dunst

    startup_notification = false
    verbosity = mesg
&
    # Define the corner radius of the notification window
    # in pixel size. If the radius is 0, you have no rounded
    # corners.
    # The radius will be automatically lowered if it exceeds half of the
    # notification height to avoid clipping text and/or icons.
    corner_radius = 2

    mouse_left_click = close_current
    mouse_middle_click = do_action
    mouse_right_click = close_all

# Experimental features that may or may not work correctly. Do not expect them
# to have a consistent behaviour across releases.
[experimental]
    # Calculate the dpi to use on a per-monitor basis.
    # If this setting is enabled the Xft.dpi value will be ignored and instead
    # dunst will attempt to calculate an appropriate dpi value for each monitor
    # using the resolution and physical size. This might be useful in setups
    # where there are multiple screens with very different dpi values.
    # per_monitor_dpi = false

[shortcuts]

    # Shortcuts are specified as [modifier+][modifier+]...key
    # Available modifiers are "ctrl", "mod1" (the alt-key), "mod2",
    # "mod3" and "mod4" (windows-key).
    # Xev might be helpful to find names for keys.

    # Close notification.
    #close = ctrl+space

    # Close all notifications.
    #close_all = ctrl+shift+space

    # Redisplay last message(s).
    # On the US keyboard layout "grave" is normally above TAB and left
    # of "1". Make sure this key actually exists on your keyboard layout,
    # e.g. check output of 'xmodmap -pke'
    history = ctrl+grave

    # Context menu.
    context = ctrl+shift+period

[urgency_low]
    # IMPORTANT: colors have to be defined in quotation marks.
    # Otherwise the "#" and following would be interpreted as a comment.
    background = "#222222"
    foreground = "#888888"
    timeout = 10
    # Icon for notifications with low urgency, uncomment to enable
    # icon = /path/to/icon

[urgency_normal]
    background = "#1c1f26"
    foreground = "#ffffff"
    timeout = 10
    # Icon for notifications with normal urgency, uncomment to enable
    #icon = /path/to/icon

[urgency_critical]
    background = "#900000"
    foreground = "#ffffff"
    frame_color = "#ff0000"
    timeout = 0
    # Icon for notifications with critical urgency, uncomment to enable
    #icon = /path/to/icon

#+end_src

We can also set up some functions for enabling and disabling notifications at any time:

#+begin_src emacs-lisp


  (defun efs/disable-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_PAUSE\""))

  (defun efs/enable-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_RESUME\""))

  (defun efs/toggle-desktop-notifications ()
    (interactive)
    (start-process-shell-command "notify-send" nil "notify-send \"DUNST_COMMAND_TOGGLE\""))

#+end_src

#+begin_src emacs-lisp

(defun efs/dunstctl (command)
  (start-process-shell-command "dunstctl" nil (concat "dunstctl " command)))

(exwm-input-set-key (kbd "s-n") (lambda () (interactive) (efs/dunstctl "history-pop")))
(exwm-input-set-key (kbd "s-N") (lambda () (interactive) (efs/dunstctl "close-all")))
#+end_src
#+RESULTS:
: efs/dunstctl
** movement and window switching
The default window movement keys are super cumbersome, here are some better defaults.
#+begin_src emacs-lisp

(use-package! window
  :ensure nil
  :bind (("<f8>" . other-window)
         ("C-<f8>" . window-swap-states)
         ("C-x 1" . my/toggle-single-window))
  :init
  (defun my/toggle-single-window ()
  "Toggles between a single window configuration and
the previously multi-windowed one"
  (interactive)
  (if (one-window-p)
    (when (boundp 'my-saved-window-configuration)
      (set-window-configuration my-saved-window-configuration))
    (progn
      (setq my-saved-window-configuration (current-window-configuration))
      (delete-other-windows)))))

(use-package! transpose-frame
  :bind (("M-<f8>" . rotate-frame-clockwise)))

(use-package! bookmark
  :ensure nil
  :custom
  (bookmark-save-flag 1))

(use-package! beginend
  :config
  (beginend-global-mode))

(map! "C-w" nil)
(global-set-key  (kbd "C-<tab>") #'evil-window-next)
 (global-set-key             (kbd "C-<iso-lefttab>") #'evil-window-prev)
     (global-set-key   (kbd "C-w") #'ace-window)

(map!
    :nvig "C-<iso-lefttab>" #'evil-window-prev
      :nvig  "C-w" #'ace-window)
(map! :nvig "C-<tab>" #'evil-window-next)

#+end_src

#+RESULTS:

** Desktop Key Bindings

We use the [[https://github.com/DamienCassou/desktop-environment][desktop-environment]] package to automatically bind to well-known programs for controlling the volume, screen brightness, media playback, and doing other things like locking the screen and taking screenshots.  Make sure that you install the necessary programs to make this functionality work!  Check the [[https://github.com/DamienCassou/desktop-environment#default-configuration][default programs]] list to know what you need to install.

#+begin_src emacs-lisp :tangle no
(use-package! desktop-environment
  :after (exwm)
  :custom
  (desktop-environment-brightness-small-increment "2%+")
  (desktop-environment-brightness-small-decrement "2%-")
  (desktop-environment-brightness-normal-increment "5%+")
  (desktop-environment-brightness-normal-decrement "5%-")
  (desktop-environment-volume-get-command "pamixer --get-volume")
   ;; (desktop-environment-volume-get-command
   ;; "LC_ALL=C pacmd list-sinks|grep -A 15 '* index'| awk '/volume: front/{ print $5 }' | sed 's/,//g'")
  (desktop-environment-volume-set-command "pamixer %s")
  (desktop-environment-volume-get-regexp "\\([0-9]+\\)")
  (desktop-environment-volume-normal-increment "-i 5 --allow-boost")
  (desktop-environment-volume-normal-decrement "-d 5")
  (desktop-environment-volume-toggle-command "pamixer -t")
  (desktop-environment-screenshot-directory "~/Screenshots/")
  (desktop-environment-screenshot-partial-command "import png:- | xclip -selection c -t image/png -verbose")
  (desktop-environment-screenlock-command "slock")

  :config
(desktop-environment-mode)
  (exwm-input-set-key (kbd "s-<up>") #'desktop-environment-volume-increment)
  (exwm-input-set-key (kbd "s-<down>") #'desktop-environment-volume-decrement)
  (exwm-input-set-key (kbd "s-m") #'desktop-environment-toggle-mute)
  ;; (exwm-input-set-key (kbd "s-l") #'desktop-environment-lock-screen)
  (exwm-input-set-key (kbd "<XF86AudioPlay>") #'desktop-environment-toggle-music)
  (exwm-input-set-key (kbd "<XF86AudioPause>") #'desktop-environment-toggle-music)
  (exwm-input-set-key (kbd "<XF86AudioNext>") #'desktop-environment-music-next))
  ;; (exwm-input-set-key (kbd "s-s") #'desktop-environment-screenshot-part)

(define-minor-mode display-volume-mode
  "Toggle display of volume in mode lines.

Depends on desktop-environment.

When Display Time mode is enabled, it queries the volume from
your system on every displaying using
desktop-environment-volume-get (which you can customize)."
  :global t :group 'desktop-environment
  (or global-mode-string (setq global-mode-string '("")))
  (setq display-volume-keymap (make-sparse-keymap))
  (define-key display-volume-keymap (kbd "<mode-line> <mouse-4>") 'desktop-environment-volume-increment-slowly)
  (define-key display-volume-keymap (kbd "<mode-line> <mouse-5>") 'desktop-environment-volume-decrement-slowly)
  (setq display-volume-modeline-entry
        '(:eval (propertize (format " V:%s%% "(desktop-environment-volume-get))
                            'keymap display-volume-keymap)))
  (if display-volume-mode
      (progn
        (or (memq display-volume-modeline-entry global-mode-string)
            (setq global-mode-string
                  (append global-mode-string (list display-volume-modeline-entry)))))))

(display-volume-mode)

#+end_src

#+RESULTS:
: t

** Window title
I'd like to have just the buffer name, then if applicable the project folder
#+begin_src emacs-lisp :tangle no
(setq frame-title-format
      '(""
        (:eval
         (if (s-contains-p org-roam-directory (or buffer-file-name ""))
             (replace-regexp-in-string
              ".*/[0-9]*-?" "☰ "
              (subst-char-in-string ?_ ?  buffer-file-name))
           "%b"))
        (:eval
         (let ((project-name (projectile-project-name)))
           (unless (string= "-" project-name)
             (format (if (buffer-modified-p)  " ◉ %s" "  ●  %s") project-name))))))
#+end_src

#+RESULTS:
|   | (:eval (if (s-contains-p org-roam-directory (or buffer-file-name )) (replace-regexp-in-string .*/[0-9]*-? ☰  (subst-char-in-string 95 32 buffer-file-name)) %b)) | (:eval (let ((project-name (projectile-project-name))) (unless (string= - project-name) (format (if (buffer-modified-p)  ◉ %s   ●  %s) project-name)))) |

For example when I open my config file it the window will be titled =config.org ●
doom= then as soon as I make a change it will become =config.org ◉ doom=.

* services
** DONE Proced (process monitor, similar to `top')
CLOSED: [2022-03-31 Thu 20:05]

This is a built-in tool that allows you to monitor running processes
and act on them accordingly.  These are the basic settings I have
right now: it works fine.

My =prot-proced.el= (reproduced after the package configurations) simply
adds some extra colours to the otherwise plain buffer.  Makes it easier
to keep track of the information on display.

#+begin_src emacs-lisp
;;; Proced (process monitor, similar to `top')
(use-package! proced
  :config
  (setq proced-auto-update-flag t)
  (setq proced-auto-update-interval 5)
  (setq proced-descend t)
  (setq proced-filter 'user))

(load "prot-proced")
(use-package! prot-proced
  :config
  (prot-proced-extra-keywords 1))
#+end_src

#+RESULTS:
: t

** DONE Systemd
CLOSED: [2022-03-31 Thu 20:05]
For editing systemd unit files
#+begin_src emacs-lisp :tangle no
(package! systemd :pin "b6ae63a236605b1c5e1069f7d3afe06ae32a7bae")
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! systemd
  :defer t)
#+end_src
*** Systemd daemon
For running a systemd service for a Emacs server I have the following
#+name: emacsclient service
#+begin_src systemd :tangle no
##+begin_src systemd :tangle ~/.config/systemd/user/default.target.wants/emacs.service :mkdirp yes
[Unit]
Description=Emacs server daemon
Documentation=info:emacs man:emacs(1) https://gnu.org/software/emacs/

[Service]
Type=forking
ExecStart=sh -c 'emacs --daemon && emacsclient -c --eval "(delete-frame)"'
ExecStop=/usr/bin/emacsclient --no-wait --eval "(progn (setq kill-emacs-hook nil) (kill emacs))"
Restart=on-failure

[Install]
WantedBy=default.target
#+end_src

which is then enabled by
#+begin_src shell :tangle (if (string= "enabled\n" (shell-command-to-string "systemctl --user is-enabled emacs.service")) "no" "setup.sh")
systemctl --user enable emacs.service
#+end_src

For some reason if a frame isn't opened early in the initialisation process, the
daemon doesn't seem to like opening frames later --- hence the ~&& emacsclient~
part of the =ExecStart= value.

It can now be nice to use this as a 'default app' for opening files. If we add
an appropriate desktop entry, and enable it in the desktop environment.

#+begin_src conf :tangle ~/.local/share/applications/emacs-client.desktop :mkdirp yes
[Desktop Entry]
Name=Emacs client
GenericName=Text Editor
Comment=A flexible platform for end-user applications
MimeType=text/english;text/plain;text/x-makefile;text/x-c++hdr;text/x-c++src;text/x-chdr;text/x-csrc;text/x-java;text/x-moc;text/x-pascal;text/x-tcl;text/x-tex;application/x-shellscript;text/x-c;text/x-c++;
Exec=emacsclient -create-frame --alternate-editor="" --no-wait %F
Icon=emacs
Type=Application
Terminal=false
Categories=TextEditor;Utility;
StartupWMClass=Emacs
Keywords=Text;Editor;
X-KDE-StartupNotify=false
#+end_src

When the daemon is running, I almost always want to do a few particular things
with it, so I may as well eat the load time at startup. We also want to keep
=mu4e= running.

It would be good to start the IRC client (=circe=) too, but that seems to have
issues when started in a non-graphical session.

Lastly, while I'm not sure quite why it happens, but after a bit it seems that
new Emacsclient frames start on the =*scratch*= buffer instead of the dashboard.
I prefer the dashboard, so let's ensure that's always switched to in new frames.

#+name: daemon initialisation
#+begin_src emacs-lisp
(defun greedily-do-daemon-setup ()
  (require 'org)
  (when (require 'mu4e nil t)
    (setq mu4e-confirm-quit t)
    (setq +mu4e-lock-greedy t)
    (setq +mu4e-lock-relaxed t)
    (+mu4e-lock-add-watcher)
    (when (+mu4e-lock-available t)
      (mu4e~start)))
  (when (require 'elfeed nil t)
    (run-at-time nil (* 8 60 60) #'elfeed-update)))

(when (daemonp)
  (add-hook 'emacs-startup-hook #'greedily-do-daemon-setup)
  (add-hook! 'server-after-make-frame-hook
    (unless (string-match-p "\\*draft\\|\\*stdin\\|emacs-everywhere" (buffer-name)))))
      ;; (switch-to-buffer +doom-dashboard-name))))
#+end_src

#+RESULTS: daemon initialisation

*** Emacs client wrapper
I frequently want to make use of Emacs while in a terminal emulator. To make
this easier, I can construct a few handy aliases.

However, a little convenience script in =~/.local/bin= can have the same effect,
be available beyond the specific shell I plop the alias in, then also allow me
to add a few bells and whistles --- namely:
+ Accepting stdin by putting it in a temporary file and immediately opening it.
+ Guessing that the =tty= is a good idea when ~$DISPLAY~ is unset (relevant with SSH
  sessions, among other things).
+ With a whiff of 24-bit color support, sets ~TERM~ variable to a =terminfo= that
  (probably) announces 24-bit color support.
+ Changes GUI =emacsclient= instances to be non-blocking by default (~--no-wait~),
  and instead take a flag to suppress this behaviour (~-w~).

I would use =sh=, but using arrays for argument manipulation is just too
convenient, so I'll raise the requirement to =bash=. Since arrays are the only
'extra' compared to =sh=, other shells like =ksh= etc. should work too.

#+name: e
#+begin_src shell :tangle ~/.local/bin/e :mkdirp yes :tangle-mode (identity #o755) :comments no
#!/usr/bin/env bash
force_tty=false
force_wait=false
stdin_mode=""

args=()

while :; do
    case "$1" in
        -t | -nw | --tty)
            force_tty=true
            shift ;;
        -w | --wait)
            force_wait=true
            shift ;;
        -m | --mode)
            stdin_mode=" ($2-mode)"
            shift 2 ;;
        -h | --help)
            echo -e "\033[1mUsage: e [-t] [-m MODE] [OPTIONS] FILE [-]\033[0m

Emacs client convenience wrapper.

\033[1mOptions:\033[0m
\033[0;34m-h, --help\033[0m            Show this message
\033[0;34m-t, -nw, --tty\033[0m        Force terminal mode
\033[0;34m-w, --wait\033[0m            Don't supply \033[0;34m--no-wait\033[0m to graphical emacsclient
\033[0;34m-\033[0m                     Take \033[0;33mstdin\033[0m (when last argument)
\033[0;34m-m MODE, --mode MODE\033[0m  Mode to open \033[0;33mstdin\033[0m with

Run \033[0;32memacsclient --help\033[0m to see help for the emacsclient."
            exit 0 ;;
        --*=*)
            set -- "$@" "${1%%=*}" "${1#*=}"
            shift ;;
        ,*)
            if [ "$#" = 0 ]; then
                break; fi
            args+=("$1")
            shift ;;
    esac
done

if [ ! "${#args[*]}" = 0 ] && [ "${args[-1]}" = "-" ]; then
    unset 'args[-1]'
    TMP="$(mktemp /tmp/emacsstdin-XXX)"
    cat > "$TMP"
    args+=(--eval "(let ((b (generate-new-buffer \"*stdin*\"))) (switch-to-buffer b) (insert-file-contents \"$TMP\") (delete-file \"$TMP\")${stdin_mode})")
fi

if [ -z "$DISPLAY" ] || $force_tty; then
    # detect terminals with sneaky 24-bit support
    if { [ "$COLORTERM" = truecolor ] || [ "$COLORTERM" = 24bit ]; } \
        && [ "$(tput colors 2>/dev/null)" -lt 257 ]; then
        if echo "$TERM" | grep -q "^\w\+-[0-9]"; then
            termstub="${TERM%%-*}"; else
            termstub="${TERM#*-}"; fi
        if infocmp "$termstub-direct" >/dev/null 2>&1; then
            TERM="$termstub-direct"; else
            TERM="xterm-direct"; fi # should be fairly safe
    fi
    emacsclient --tty -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
else
    if ! $force_wait; then
        args+=(--no-wait); fi
    emacsclient -create-frame --alternate-editor="$ALTERNATE_EDITOR" "${args[@]}"
fi
#+end_src

Now, to set an alias to use =e= with magit, and then for maximum laziness we can
set aliases for the terminal-forced variants.
#+begin_src shell :tangle no
alias m='e --eval "(progn (magit-status) (delete-other-windows))"'
alias mt="m -t"
alias et="e -t"
#+end_src
*** Prompt to run setup script

At various points in this config, content is conditionally tangled to
=./setup.sh=. It's no good just putting content there if it isn't run though.
To help remind me to run it when needed, let's add a little prompt when there's
anything to be run.

#+name: run-setup
#+begin_src emacs-lisp :tangle no
(if (file-exists-p "setup.sh")
    (if (string-empty-p (string-trim (with-temp-buffer (insert-file-contents "setup.sh") (buffer-string)) "#!/usr/bin/env bash"))
        (message ";; Setup script is empty")
      (message ";; Detected content in the setup script")
      (pp-to-string
       `(unless noninteractive
          (defun +config-run-setup ()
            (when (yes-or-no-p (format "%s The setup script has content. Check and run the script?"
                                       (propertize "Warning!" 'face '(bold warning))))
              (find-file (expand-file-name "setup.sh" doom-user-dir))
              (when (yes-or-no-p "Would you like to run this script?")
                (async-shell-command "./setup.sh"))))
          (add-hook! 'doom-init-ui-hook
            (run-at-time nil nil #'+config-run-setup)))))
  (message ";; setup.sh did not exist during tangle. Tangle again.")
  (pp-to-string
   `(unless noninteractive
      (add-hook! 'doom-init-ui-hook #'+literate-tangle-async-h))))
#+end_src

#+begin_src emacs-lisp :noweb no-export :tangle no
<<run-setup()>>
#+end_src

** DONE TRAMP
CLOSED: [2022-03-31 Thu 20:06]
Another lovely Emacs feature, TRAMP stands for /Transparent Remote Access,
Multiple Protocol/. In brief, it's a lovely way to wander around outside your
local filesystem.

**** Prompt recognition

Unfortunately, when connecting to remote machines Tramp can be a wee pit picky
with the prompt format. Let's try to get Bash, and be a bit more permissive with
prompt recognition.

#+begin_src emacs-lisp :tangle yes
(after! tramp
  (setenv "SHELL" "/bin/bash")
  (setq tramp-shell-prompt-pattern "\\(?:^\\|\\)[^]#$%>\n]*#?[]#$%>] *\\(\\[[0-9;]*[a-zA-Z] *\\)*")) ;; default + 
#+end_src

**** Troubleshooting
In case the remote shell is misbehaving, here are some things to try
***** Zsh
There are some escape code you don't want, let's make it behave more considerately.
#+begin_src shell :eval no :tangle yes
if [[ "$TERM" == "dumb" ]]; then
    unset zle_bracketed_paste
    unset zle
    PS1='$ '
    return
fi
#+end_src

**** Guix

[[https://guix.gnu.org/][Guix]] puts some binaries that TRAMP looks for in unexpected locations.
That's no problem though, we just need to help TRAMP find them.

#+begin_src emacs-lisp :tangle no
(after! tramp
  (appendq! tramp-remote-path
            '("~/.guix-profile/bin" "~/.guix-profile/sbin"
              "/run/current-system/profile/bin"
              "/run/current-system/profile/sbin")))
#+end_src
* UI
CLOSED: [2022-04-02 Sat 23:43]
** DONE brightness
CLOSED: [2022-03-30 Wed 12:23]
#+begin_src emacs-lisp :tangle no
(setq my/brightness-min 1)
(setq my/brightness-max 100)
(setq my/brightness-step 5)

(defun my/get-brightness ()
  (* my/brightness-step (round (string-to-number
                                (shell-command-to-string "xbacklight -get"))
                               my/brightness-step)))

(defun my/set-brightness (level)
  (interactive "nBrightness level: ")
  (let ((safe-level
         (cond ((< level my/brightness-min) my/brightness-min)
               ((> level my/brightness-max) my/brightness-max)
               (t level))))
    (save-window-excursion
      (shell-command
       (format "xbacklight -set %s &" safe-level) nil nil))))

(defun my/brightness-step-change (delta)
  (my/set-brightness (+ delta (my/get-brightness))))

(defun my/brightness-increase ()
  (interactive)
  (my/brightness-step-change my/brightness-step))

(defun my/brightness-decrease ()
  (interactive)
  (my/brightness-step-change (- my/brightness-step)))

;; (map! "<XF86MonBrightnessDown>" 'my/brightness-decrease)
;; (map! "<XF86MonBrightnessUp>" 'my/brightness-increase)


;; (defun my/set-brightness-lg-5k (level)
;;   (interactive "nBrightness level: ")
;;   (save-window-excursion
;;     (shell-command
;;      (format "echo \"0i%s\n\" | sudo /repos/LG-ultrafine-brightness/build/LG_ultrafine_brightness
#+end_src

#+RESULTS:
: my/brightness-decrease

** DONE Windows Split
CLOSED: [2022-03-30 Wed 00:00]

I find it rather handy to be asked which buffer I want to see after splitting
the window. Let's make that happen.

First, we'll enter the new window
#+begin_src emacs-lisp
(setq evil-vsplit-window-right t
      evil-split-window-below t)
#+end_src

#+RESULTS:

Then, we'll pull up a buffer prompt.
#+begin_src emacs-lisp
(defadvice! prompt-for-buffer (&rest _)
  :after '(evil-window-split evil-window-vsplit)
  (consult-buffer))
#+end_src

#+RESULTS:

** DONE All the icons
CLOSED: [2022-03-30 Wed 00:03]
#+begin_quote
From the =:core packages= module.
#+end_quote


=all-the-icons= does a generally great job giving file names icons. One minor
niggle I have is that when /I/ open a =.m= file, it's much more likely to be Matlab
than Objective-C. As such, it'll be switching the icon associated with =.m=.
#+begin_src emacs-lisp
(after! all-the-icons
  (setcdr (assoc "m" all-the-icons-extension-icon-alist)
          (cdr (assoc "matlab" all-the-icons-extension-icon-alist))))
#+end_src

** Emoji-fy
#+begin_quote
From the =:ui emoji= module.
#+end_quote

For starters, twitter's emojis look nicer than emoji-one.
Other than that, this is pretty great OOTB 😀.

#+begin_src emacs-lisp
(setq emojify-emoji-set "twemoji-v2")
#+end_src

One minor annoyance is the use of emojis over the default character
when the default is actually preferred. This occurs with overlay symbols I use
in Org mode, such as checkbox state, and a few other miscellaneous cases.

We can accommodate our preferences by deleting those entries from the emoji hash
table

#+begin_src emacs-lisp
(defvar emojify-disabled-emojis
  '(;; Org
    "◼" "☑" "☸" "⚙" "⏩" "⏪" "⬆" "⬇" "❓" "↔"
    ;; Terminal powerline
    "✔"
    ;; Box drawing
    "▶" "◀"
    ;; I just want to see this as text
    "©" "™")
  "Characters that should never be affected by `emojify-mode'.")

(defadvice! emojify-delete-from-data ()
  "Ensure `emojify-disabled-emojis' don't appear in `emojify-emojis'."
  :after #'emojify-set-emoji-data
  (dolist (emoji emojify-disabled-emojis)
    (remhash emoji emojify-emojis)))
#+end_src

#+RESULTS:

Now, it would be good to have a minor mode which allowed you to type ascii/gh
emojis and get them converted to unicode. Let's make one.
#+begin_src emacs-lisp
(defun emojify--replace-text-with-emoji (orig-fn emoji text buffer start end &optional target)
  "Modify `emojify--propertize-text-for-emoji' to replace ascii/github emoticons with unicode emojis, on the fly."
  (if (or (not emoticon-to-emoji) (= 1 (length text)))
      (funcall orig-fn emoji text buffer start end target)
    (delete-region start end)
    (insert (ht-get emoji "unicode"))))

(define-minor-mode emoticon-to-emoji
  "Write ascii/gh emojis, and have them converted to unicode live."
  :global nil
  :init-value nil
  (if emoticon-to-emoji
      (progn
        (setq-local emojify-emoji-styles '(ascii github unicode))
        (advice-add 'emojify--propertize-text-for-emoji :around #'emojify--replace-text-with-emoji)
        (unless emojify-mode
          (emojify-turn-on-emojify-mode)))
    (setq-local emojify-emoji-styles (default-value 'emojify-emoji-styles))
    (advice-remove 'emojify--propertize-text-for-emoji #'emojify--replace-text-with-emoji)))
#+end_src

#+RESULTS:

This new minor mode of ours will be nice for messages, so let's hook it in for
Email and IRC.
#+begin_src emacs-lisp
(add-hook! '(mu4e-compose-mode org-msg-edit-mode circe-channel-mode) (emoticon-to-emoji 1))
#+end_src

#+RESULTS:

** DONE Modus themes
CLOSED: [2022-03-30 Wed 11:00]
Proteolas did a lovely job with the Modus themes, so much so that they were
welcomed into Emacs 28. However, he is also rather attentive with updates, and
so I'd like to make sure we have a recent version.

#+begin_src emacs-lisp :tangle packages.el
(package! modus-themes :pin "57599b1d73fe33b324be9358991114222a0a63f7")
#+end_src

** DONE transparency
CLOSED: [2022-03-30 Wed 11:35]
  #+begin_src emacs-lisp
    (defun toggle-transparency ()
      (interactive)
      (let ((alpha (frame-parameter nil 'alpha)))
	(set-frame-parameter
	 nil 'alpha
	 (if (eql (cond ((numberp alpha) alpha)
			((numberp (cdr alpha)) (cdr alpha))
			;; also handle undocumented (<active> <inactive>) form.
			((numberp (cadr alpha)) (cadr alpha)))
		  100)
	     '(85 . 50) '(100 . 100)))))
    (global-set-key (kbd "C-c T") 'toggle-transparency)
  #+end_src

  #+RESULTS:
  : toggle-transparency

** DONE modus theme prot
CLOSED: [2022-10-14 Fri 16:22]
- State "DONE"       from              [2022-10-14 Fri 16:22]
#+begin_src emacs-lisp :tangle yes

;;; Modus themes (my highly accessible themes)
(use-package! modus-themes
  ;; Add all your customizations prior to loading the themes
  ;;
  ;; NOTE: these are not my preferences!  I am always testing various
  ;; configurations.  Though I still like what I have here.
  :config
  ;; NOTE: these are not my preferences!  I am always testing various
  ;; configurations.  Though I still like what I have here.
  (setq modus-themes-italic-constructs nil
        modus-themes-bold-constructs nil
        modus-themes-mixed-fonts t
        modus-themes-subtle-line-numbers t
        modus-themes-intense-mouseovers nil
        modus-themes-deuteranopia t
        modus-themes-tabs-accented nil
        modus-themes-variable-pitch-ui t
        modus-themes-inhibit-reload t ; only applies to `customize-set-variable' and related

        modus-themes-fringes nil ; {nil,'subtle,'intense}

        ;; Options for `modus-themes-lang-checkers' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `straight-underline', `text-also', `background',
        ;; `intense' OR `faint'.
        modus-themes-lang-checkers nil

        ;; Options for `modus-themes-mode-line' are either nil, or a list
        ;; that can combine any of `3d' OR `moody', `borderless',
        ;; `accented', a natural number for extra padding (or a cons cell
        ;; of padding and NATNUM), and a floating point for the height of
        ;; the text relative to the base font size (or a cons cell of
        ;; height and FLOAT)
        modus-themes-mode-line '(borderless (height 0.9) (padding 3))

        ;; Options for `modus-themes-markup' are either nil, or a list
        ;; that can combine any of `bold', `italic', `background',
        ;; `intense'.
        modus-themes-markup '(bold italic intense)

        ;; Options for `modus-themes-syntax' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `faint', `yellow-comments', `green-strings', `alt-syntax'
        modus-themes-syntax '(yellow-comments green-strings)

        ;; Options for `modus-themes-hl-line' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `accented', `underline', `intense'
        modus-themes-hl-line nil

        ;; Options for `modus-themes-paren-match' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `bold', `intense', `underline'
        modus-themes-paren-match '(bold)

        ;; Options for `modus-themes-links' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `neutral-underline' OR `no-underline', `faint' OR `no-color',
        ;; `bold', `italic', `background'
        modus-themes-links '(neutral-underline)

        ;; Options for `modus-themes-box-buttons' are either nil (the
        ;; default), or a list that can combine any of `flat',
        ;; `accented', `faint', `variable-pitch', `underline',
        ;; `all-buttons', the symbol of any font weight as listed in
        ;; `modus-themes-weights', and a floating point number
        ;; (e.g. 0.9) for the height of the button's text.
        modus-themes-box-buttons nil

        ;; Options for `modus-themes-prompts' are either nil (the
        ;; default), or a list of properties that may include any of those
        ;; symbols: `background', `bold', `gray', `intense', `italic'
        modus-themes-prompts '(background intense)

        ;; The `modus-themes-completions' is an alist that reads three
        ;; keys: `matches', `selection', `popup'.  Each accepts a nil
        ;; value (or empty list) or a list of properties that can include
        ;; any of the following (for WEIGHT read further below):
        ;;
        ;; `matches' - `background', `intense', `underline', `italic', WEIGHT
        ;; `selection' - `accented', `intense', `underline', `italic', `text-also', WEIGHT
        ;; `popup' - same as `selected'
        ;; `t' - applies to any key not explicitly referenced (check docs)
        ;;
        ;; WEIGHT is a symbol such as `semibold', `light', or anything
        ;; covered in `modus-themes-weights'.  Bold is used in the absence
        ;; of an explicit WEIGHT.
        modus-themes-completions
        '((matches . (semibold))
          (selection . (extrabold accented))
          (popup . (extrabold accented)))

        modus-themes-mail-citations nil ; {nil,'intense,'faint,'monochrome}

        ;; Options for `modus-themes-region' are either nil (the default),
        ;; or a list of properties that may include any of those symbols:
        ;; `no-extend', `bg-only', `accented'
        modus-themes-region '(no-extend)

        ;; Options for `modus-themes-diffs': nil, 'desaturated, 'bg-only
        modus-themes-diffs 'desaturated

        modus-themes-org-blocks nil ; {nil,'gray-background,'tinted-background}

        modus-themes-org-agenda ; this is an alist: read the manual or its doc string
        '((header-block . (variable-pitch light 1.6))
          (header-date . (underline-today grayscale workaholic 1.2))
          (event . (accented italic varied))
          (scheduled . rainbow)
          (habit . simplified))

        ;; The `modus-themes-headings' is an alist with lots of possible
        ;; combinations, including per-heading-level tweaks: read the
        ;; manual or its doc string.
        modus-themes-headings
        '((0 . (variable-pitch light (height 1.3)))
          (1 . (variable-pitch light (height 1.1)))
          (2 . (rainbow variable-pitch light (height 1.0)))
          (3 . (rainbow variable-pitch regular (height 0.9)))
          (4 . (rainbow regular (height 0.8)))
          (5 . (rainbow (height 0.7)))
          (t . (variable-pitch extrabold))))

  ;; Load the theme files before enabling a theme (else you get an error).
  (modus-themes-load-themes)

  ;; A simple check to load the desired theme at startup based on what
  ;; the global preference for GNOME is.  If such preference is not
  ;; registered, it just loads `modus-operandi'.  Check my dotfiles for
  ;; the shell script called "delight", which handles system-wide theme
  ;; switching (as I bind the `modus-themes-toggle' to <f5>, delight is
  ;; bound to s-<f5> in the desktop's own custom key bindings).
  (if (string-match-p
       "dark"
       (shell-command-to-string "gsettings get org.gnome.desktop.interface color-scheme"))
      (modus-themes-load-vivendi)
    (modus-themes-load-operandi))

  (define-key global-map (kbd "<f5>") #'modus-themes-toggle)

;;;; Modus themes "Summertime"

  ;; Read the relevant blog post:
  ;; <https://protesilaos.com/codelog/2022-07-26-modus-themes-color-override-demo/>

  ;; Thanks to user "Summer Emacs" for (i) suggesting the name
  ;; "summertime", (ii) testing variants of this in her setup, and (iii)
  ;; sending me feedback on possible tweaks and refinements.  All errors
  ;; are my own.  (This information is shared with permission.)
  (define-minor-mode modus-themes-summertime
    "Refashion the Modus themes by overriding their colors.

This is a complete technology demonstration to show how to
manually override the colors of the Modus themes.  I have taken
good care of those overrides to make them work as a fully fledged
color scheme that is compatible with all user options of the
Modus themes.

These overrides are usable by those who (i) like something more
fancy than the comparatively austere looks of the Modus themes,
and (ii) can cope with a lower contrast ratio.

The overrides are set up as a minor mode, so that the user can
activate the effect on demand.  Those who want to load the
overrides at all times can either add them directly to their
configuration or enable `modus-themes-summertime' BEFORE loading
either of the Modus themes (if the overrides are evaluated after
the theme, the theme must be reloaded).

Remember that all changes to theme-related variables require a
reload of the theme to take effect (the Modus themes have lots of
user options, apart from those overrides).

The `modus-themes-summertime' IS NOT an official extension to the
Modus themes and DOES NOT comply with its lofty accessibility
standards.  It is included in the official manual as guidance for
those who want to make use of the color overriding facility we
provide."
    :init-value nil
    :global t
    (if modus-themes-summertime
        (setq modus-themes-operandi-color-overrides
              '((bg-main . "#fff0f2")
                (bg-dim . "#fbe6ef")
                (bg-alt . "#f5dae6")
                (bg-hl-line . "#fad8e3")
                (bg-active . "#efcadf")
                (bg-inactive . "#f3ddef")
                (bg-active-accent . "#ffbbef")
                (bg-region . "#dfc5d1")
                (bg-region-accent . "#efbfef")
                (bg-region-accent-subtle . "#ffd6ef")
                (bg-header . "#edd3e0")
                (bg-tab-active . "#ffeff2")
                (bg-tab-inactive . "#f8d3ef")
                (bg-tab-inactive-accent . "#ffd9f5")
                (bg-tab-inactive-alt . "#e5c0d5")
                (bg-tab-inactive-alt-accent . "#f3cce0")
                (fg-main . "#543f78")
                (fg-dim . "#5f476f")
                (fg-alt . "#7f6f99")
                (fg-unfocused . "#8f6f9f")
                (fg-active . "#563068")
                (fg-inactive . "#8a5698")
                (fg-docstring . "#5f5fa7")
                (fg-comment-yellow . "#a9534f")
                (fg-escape-char-construct . "#8b207f")
                (fg-escape-char-backslash . "#a06d00")
                (bg-special-cold . "#d3e0f4")
                (bg-special-faint-cold . "#e0efff")
                (bg-special-mild . "#c4ede0")
                (bg-special-faint-mild . "#e0f0ea")
                (bg-special-warm . "#efd0c4")
                (bg-special-faint-warm . "#ffe4da")
                (bg-special-calm . "#f0d3ea")
                (bg-special-faint-calm . "#fadff9")
                (fg-special-cold . "#405fb8")
                (fg-special-mild . "#407f74")
                (fg-special-warm . "#9d6f4f")
                (fg-special-calm . "#af509f")
                (bg-completion . "#ffc5e5")
                (bg-completion-subtle . "#f7cfef")
                (red . "#ed2f44")
                (red-alt . "#e0403d")
                (red-alt-other . "#e04059")
                (red-faint . "#ed4f44")
                (red-alt-faint . "#e0603d")
                (red-alt-other-faint . "#e06059")
                (green . "#217a3c")
                (green-alt . "#417a1c")
                (green-alt-other . "#006f3c")
                (green-faint . "#318a4c")
                (green-alt-faint . "#518a2c")
                (green-alt-other-faint . "#20885c")
                (yellow . "#b06202")
                (yellow-alt . "#a95642")
                (yellow-alt-other . "#a06f42")
                (yellow-faint . "#b07232")
                (yellow-alt-faint . "#a96642")
                (yellow-alt-other-faint . "#a08042")
                (blue . "#275ccf")
                (blue-alt . "#475cc0")
                (blue-alt-other . "#3340ef")
                (blue-faint . "#476ce0")
                (blue-alt-faint . "#575ccf")
                (blue-alt-other-faint . "#3f60d7")
                (magenta . "#bf317f")
                (magenta-alt . "#d033c0")
                (magenta-alt-other . "#844fe4")
                (magenta-faint . "#bf517f")
                (magenta-alt-faint . "#d053c0")
                (magenta-alt-other-faint . "#846fe4")
                (cyan . "#007a9f")
                (cyan-alt . "#3f709f")
                (cyan-alt-other . "#107f7f")
                (cyan-faint . "#108aaf")
                (cyan-alt-faint . "#3f80af")
                (cyan-alt-other-faint . "#3088af")
                (red-active . "#cd2f44")
                (green-active . "#116a6c")
                (yellow-active . "#993602")
                (blue-active . "#475ccf")
                (magenta-active . "#7f2ccf")
                (cyan-active . "#007a8f")
                (red-nuanced-bg . "#ffdbd0")
                (red-nuanced-fg . "#ed6f74")
                (green-nuanced-bg . "#dcf0dd")
                (green-nuanced-fg . "#3f9a4c")
                (yellow-nuanced-bg . "#fff3aa")
                (yellow-nuanced-fg . "#b47232")
                (blue-nuanced-bg . "#e3e3ff")
                (blue-nuanced-fg . "#201f6f")
                (magenta-nuanced-bg . "#fdd0ff")
                (magenta-nuanced-fg . "#c0527f")
                (cyan-nuanced-bg . "#dbefff")
                (cyan-nuanced-fg . "#0f3f60")
                (bg-diff-heading . "#b7cfe0")
                (fg-diff-heading . "#041645")
                (bg-diff-added . "#d6f0d6")
                (fg-diff-added . "#004520")
                (bg-diff-changed . "#fcefcf")
                (fg-diff-changed . "#524200")
                (bg-diff-removed . "#ffe0ef")
                (fg-diff-removed . "#891626")
                (bg-diff-refine-added . "#84cfa4")
                (fg-diff-refine-added . "#002a00")
                (bg-diff-refine-changed . "#cccf8f")
                (fg-diff-refine-changed . "#302010")
                (bg-diff-refine-removed . "#da92b0")
                (fg-diff-refine-removed . "#500010")
                (bg-diff-focus-added . "#a6e5c6")
                (fg-diff-focus-added . "#002c00")
                (bg-diff-focus-changed . "#ecdfbf")
                (fg-diff-focus-changed . "#392900")
                (bg-diff-focus-removed . "#efbbcf")
                (fg-diff-focus-removed . "#5a0010"))
              modus-themes-vivendi-color-overrides
              '((bg-main . "#25152a")
                (bg-dim . "#2a1930")
                (bg-alt . "#382443")
                (bg-hl-line . "#332650")
                (bg-active . "#463358")
                (bg-inactive . "#2d1f3a")
                (bg-active-accent . "#50308f")
                (bg-region . "#5d4a67")
                (bg-region-accent . "#60509f")
                (bg-region-accent-subtle . "#3f285f")
                (bg-header . "#3a2543")
                (bg-tab-active . "#26162f")
                (bg-tab-inactive . "#362647")
                (bg-tab-inactive-accent . "#36265a")
                (bg-tab-inactive-alt . "#3e2f5a")
                (bg-tab-inactive-alt-accent . "#3e2f6f")
                (fg-main . "#debfe0")
                (fg-dim . "#d0b0da")
                (fg-alt . "#ae85af")
                (fg-unfocused . "#8e7f9f")
                (fg-active . "#cfbfef")
                (fg-inactive . "#b0a0c0")
                (fg-docstring . "#c8d9f7")
                (fg-comment-yellow . "#cf9a70")
                (fg-escape-char-construct . "#ff75aa")
                (fg-escape-char-backslash . "#dbab40")
                (bg-special-cold . "#2a3f58")
                (bg-special-faint-cold . "#1e283f")
                (bg-special-mild . "#0f3f31")
                (bg-special-faint-mild . "#0f281f")
                (bg-special-warm . "#44331f")
                (bg-special-faint-warm . "#372213")
                (bg-special-calm . "#4a314f")
                (bg-special-faint-calm . "#3a223f")
                (fg-special-cold . "#c0b0ff")
                (fg-special-mild . "#bfe0cf")
                (fg-special-warm . "#edc0a6")
                (fg-special-calm . "#ff9fdf")
                (bg-completion . "#502d70")
                (bg-completion-subtle . "#451d65")
                (red . "#ff5f6f")
                (red-alt . "#ff8f6d")
                (red-alt-other . "#ff6f9d")
                (red-faint . "#ffa0a0")
                (red-alt-faint . "#f5aa80")
                (red-alt-other-faint . "#ff9fbf")
                (green . "#51ca5c")
                (green-alt . "#71ca3c")
                (green-alt-other . "#51ca9c")
                (green-faint . "#78bf78")
                (green-alt-faint . "#99b56f")
                (green-alt-other-faint . "#88bf99")
                (yellow . "#f0b262")
                (yellow-alt . "#f0e242")
                (yellow-alt-other . "#d0a272")
                (yellow-faint . "#d2b580")
                (yellow-alt-faint . "#cabf77")
                (yellow-alt-other-faint . "#d0ba95")
                (blue . "#778cff")
                (blue-alt . "#8f90ff")
                (blue-alt-other . "#8380ff")
                (blue-faint . "#82b0ec")
                (blue-alt-faint . "#a0acef")
                (blue-alt-other-faint . "#80b2f0")
                (magenta . "#ff70cf")
                (magenta-alt . "#ff77f0")
                (magenta-alt-other . "#ca7fff")
                (magenta-faint . "#e0b2d6")
                (magenta-alt-faint . "#ef9fe4")
                (magenta-alt-other-faint . "#cfa6ff")
                (cyan . "#30cacf")
                (cyan-alt . "#60caff")
                (cyan-alt-other . "#40b79f")
                (cyan-faint . "#90c4ed")
                (cyan-alt-faint . "#a0bfdf")
                (cyan-alt-other-faint . "#a4d0bb")
                (red-active . "#ff6059")
                (green-active . "#64dc64")
                (yellow-active . "#ffac80")
                (blue-active . "#4fafff")
                (magenta-active . "#cf88ff")
                (cyan-active . "#50d3d0")
                (red-nuanced-bg . "#440a1f")
                (red-nuanced-fg . "#ffcccc")
                (green-nuanced-bg . "#002904")
                (green-nuanced-fg . "#b8e2b8")
                (yellow-nuanced-bg . "#422000")
                (yellow-nuanced-fg . "#dfdfb0")
                (blue-nuanced-bg . "#1f1f5f")
                (blue-nuanced-fg . "#bfd9ff")
                (magenta-nuanced-bg . "#431641")
                (magenta-nuanced-fg . "#e5cfef")
                (cyan-nuanced-bg . "#042f49")
                (cyan-nuanced-fg . "#a8e5e5")
                (bg-diff-heading . "#304466")
                (fg-diff-heading . "#dae7ff")
                (bg-diff-added . "#0a383a")
                (fg-diff-added . "#94ba94")
                (bg-diff-changed . "#2a2000")
                (fg-diff-changed . "#b0ba9f")
                (bg-diff-removed . "#50163f")
                (fg-diff-removed . "#c6adaa")
                (bg-diff-refine-added . "#006a46")
                (fg-diff-refine-added . "#e0f6e0")
                (bg-diff-refine-changed . "#585800")
                (fg-diff-refine-changed . "#ffffcc")
                (bg-diff-refine-removed . "#952838")
                (fg-diff-refine-removed . "#ffd9eb")
                (bg-diff-focus-added . "#1d4c3f")
                (fg-diff-focus-added . "#b4dfb4")
                (bg-diff-focus-changed . "#424200")
                (fg-diff-focus-changed . "#d0daaf")
                (bg-diff-focus-removed . "#6f0f39")
                (fg-diff-focus-removed . "#eebdba")))
      (setq modus-themes-operandi-color-overrides nil
            modus-themes-vivendi-color-overrides nil))))

(provide 'prot-emacs-modus-themes)
#+end_src

#+RESULTS:
: prot-emacs-modus-themes

** DONE Elcord
CLOSED: [2022-03-30 Wed 12:23]

What's even the point of using Emacs unless you're constantly telling everyone
about it?
#+begin_src emacs-lisp :tangle packages.el
(package! elcord :pin "a0fe08dac6417a7a0c4e48dc6f43fd65dbeb41dd")
#+end_src

#+begin_src emacs-lisp
(use-package! elcord
  :commands elcord-mode
  :config
  (setq elcord-use-major-mode-as-main-icon t))
#+end_src

** DONE Spray
CLOSED: [2022-03-30 Wed 12:23]

Why not flash words on the screen. Why not --- hey, it could be fun.
#+begin_src emacs-lisp :tangle packages.el
(package! spray :pin "74d9dcfa2e8b38f96a43de9ab0eb13364300cb46")
#+end_src

It would be nice if Spray's default speed suited me better, and the keybindings
worked in evil mode. Let's do that and make the display slightly nicer while
we're at it.

#+begin_src emacs-lisp
(use-package! spray
  :commands spray-mode
  :config
  (setq spray-wpm 600
        spray-height 800)
  (defun spray-mode-hide-cursor ()
    "Hide or unhide the cursor as is appropriate."
    (if spray-mode
        (setq-local spray--last-evil-cursor-state evil-normal-state-cursor
                    evil-normal-state-cursor '(nil))
      (setq-local evil-normal-state-cursor spray--last-evil-cursor-state)))
  (add-hook 'spray-mode-hook #'spray-mode-hide-cursor)
  (map! :map spray-mode-map
        "<return>" #'spray-start/stop
        "f" #'spray-faster
        "s" #'spray-slower
        "t" #'spray-time
        "<right>" #'spray-forward-word
        "h" #'spray-forward-word
        "<left>" #'spray-backward-word
        "l" #'spray-backward-word
        "q" #'spray-quit))
#+end_src
** DONE Keycast
CLOSED: [2022-10-14 Fri 14:53]
- State "DONE"       from              [2022-10-14 Fri 14:53]
#+begin_src emacs-lisp :tangle packages.el
(package! keycast :pin "72d9add8ba16e0cae8cfcff7fc050fa75e493b4e")
#+end_src

*** keycast misc

Once enabled, this package uses the mode line to show the keys being
pressed and the command they call.  It is quite useful for screen
casting.

The placement of the indicator is controlled by the user option
=keycast-mode-line-window-predicate= which I set to the current window.
The =moody.el= library offers that specific piece of functionality
(though [[#h:c07b9dfc-14a2-41a6-9310-53539dec8684][I also configure Moody]] for its primary purpose of styling the
mode line).

The tweaks to the =keycast-substitute-alist= prevent the display of
self-inserting characters and some other commands that are not
particularly useful while screen casting.  Now the indicator will only
show commands, which looks cleaner.  I got the idea and original piece
of Elisp from the [[https://github.com/aadcg/dotfiles][dotfiles of André Alexandre Gomes]] and then added a few
tweaks of my own.

#+begin_src emacs-lisp :tangle yes

;; ** SCREENCAST
;; Presentation-mode will embiggen everything. Keycast-mode shows the keys being
;; pressed. Gif-screencast will screenshot each user action and compile them
;; into a gif.
(use-package! keycast
  :ensure t
  :commands keycast-mode
  :config
  (setq keycast-separator-width 1)
  (dolist (input '(self-insert-command
                   org-self-insert-command))

    (add-to-list 'keycast-substitute-alist `(,input "." "Typing!")))

  (defun store-action-key+cmd (cmd)
    (setq keycast--this-command-keys (this-single-command-keys)
          keycast--this-command cmd)
    cmd)

  (defun store-action-key-no-cmd (cmd)
    (setq keycast--this-command-keys (this-single-command-keys)
          keycast--this-command cmd))

  (defun keycast-capture-avy-dispatch (char)
    (if-let ((cmd (assoc char avy-dispatch-alist)))
        (setq keycast--this-command-keys (make-vector 1 char)
              keycast--this-command (cdr cmd))))

  (advice-add 'embark-keymap-prompter :filter-return #'store-action-key+cmd)
  ;; (advice-add 'avy-goto-char-timer :filter-return #'store-action-key+cmd)
  (advice-add 'avy-handler-default :before #'keycast-capture-avy-dispatch)

  (defun force-keycast-update (&rest _)
    (force-mode-line-update t))

  (dolist (cmd '(embark-act embark-become))
    
    (advice-add cmd :before #'force-keycast-update))

  (setq keycast-mode-line-window-predicate 'moody-window-active-p) ; assumes `moody.el'
  (setq keycast-separator-width 1)
  (setq keycast-mode-line-remove-tail-elements nil)

  (dolist (input '(self-insert-command
                   org-self-insert-command))
    (add-to-list 'keycast-substitute-alist `(,input "." "Typing…")))

  (dolist (event '(mouse-event-p
                   mouse-movement-p
                   mwheel-scroll))
    (add-to-list 'keycast-substitute-alist `(,event nil)))

  ;; Those are for the `keycast-log-mode'
  (setq keycast-log-format "%-20K%C\n")
  (setq keycast-log-frame-alist
        '((minibuffer . nil)))
  (setq keycast-log-newest-first t)

  (define-minor-mode keycast-mode
    "Show current command and its key binding in the mode line."
    :global t
    (if keycast-mode
        (progn
          (add-hook 'pre-command-hook 'keycast--update t)
          (add-to-list 'global-mode-string '("" keycast-mode-line)))
          ;; (add-to-list 'global-mode-string '("" mode-line-keycast " ")))
      (remove-hook 'pre-command-hook 'keycast--update)
      (setq global-mode-string (remove '("" mode-line-keycast " ") global-mode-string)))
  ;; Specify `keycast-insert-after' buffer identification.  This make it
  ;; possible to seamlessly toggle `prot-moody-set-height' without
  ;; disrupting keycast.
  (with-eval-after-load 'prot-moody
    (add-hook 'prot-moody-set-height-hook #'prot-moody-keycast-insert-after)))
  (custom-set-faces!
    '(keycast-command :inherit doom-modeline-debug
                      :height 0.9)
    '(keycast-key :inherit custom-modified
                  :height 1.1
                  :weight bold)))
          (add-to-list 'global-mode-string '("" keycast-mode-line))

#+end_src

#+RESULTS:
| ( keycast-mode-line) |   | emms-mode-line-string | emms-playing-time-string | appt-mode-string | (pyvenv-virtual-env-name ( venv: pyvenv-virtual-env-name  )) | telega-mode-line-format |

** Frame sizing
CLOSED: [2022-03-31 Thu 20:07]
It's nice to control the size of new frames, when launching Emacs that can be
done with src_shell{emacs -geometry 160x48}. After the font size adjustment
during initialisation this works out to be ~102x31~.

Thanks to hotkeys, it's easy for me to expand a frame to half/full-screen, so it
makes sense to be conservative with the sizing of new frames.

Then, for creating new frames within the same Emacs instance, we'll just set the
default to be something roughly 80% of that size.

#+begin_src emacs-lisp :tangle no
(add-to-list 'default-frame-alist '(height . 24))
(add-to-list 'default-frame-alist '(width . 80))


#+end_src

#+RESULTS:
: ((width . 80) (height . 24) (right-divider-width . 2) (bottom-divider-width . 2) (font . -*-Hack-*-*-*-*-15-*-*-*-*-*-*-*) (tool-bar-lines . 0) (menu-bar-lines . 0) (vertical-scroll-bars) (internal-border-width . 1) (buffer-predicate . exwm-layout--other-buffer-predicate) (left-fringe . 4) (right-fringe . 4))

** DONE pulsar.el (highlight cursor position)
CLOSED: [2022-10-14 Fri 13:09]
- State "DONE"       from              [2022-10-14 Fri 13:09]
This is a small package of mine that highlights the current line after a
given command is invoked.  The affected commands are defined in the user
option =pulsar-pulse-functions=.  Then all one needs is to enable the
minor mode, either globally (=pulsar-global-mode=) or hook the local
mode (=pulsar-mode=) to the desired major-mode hooks.  I just enable the
global mode.

Pulsar builds on top of the built-in =pulse.el=.  More information in
the official manual: https://protesilaos.com/emacs/pulsar.

Also watch my [[https://protesilaos.com/codelog/2022-03-14-emacs-pulsar-demo/][demonstration of pulsar]] (2022-03-14).

#+begin_src emacs-lisp
;;; pulsar.el (highlight cursor position)
;; Read the pulsar manual: <https://protesilaos.com/emacs/pulsar>.
(use-package! pulsar
  :config
  (setq pulsar-pulse-functions
        '(recenter-top-bottom
          move-to-window-line-top-bottom
          ace-window
          reposition-window
          bookmark-jump
          other-window
          delete-window
          delete-other-windows
          forward-page
          backward-page
          evil-scroll-down
          evil-scroll-up
          scroll-up-command
          scroll-down-command
          windmove-right
          windmove-left
          windmove-up
          windmove-down
          windmove-swap-states-right
          windmove-swap-states-left
          windmove-swap-states-up
          windmove-swap-states-down
          toggle-window-split
          swap-windows
          tab-new
          tab-close
          tab-next
          logos-forward-page-dwim
          logos-backward-page-dwim
          org-next-visible-heading
          org-previous-visible-heading
          org-forward-heading-same-level
          org-backward-heading-same-level
          outline-backward-same-level
          outline-forward-same-level
          outline-next-visible-heading
          outline-previous-visible-heading
          outline-up-heading))

  (setq pulsar-pulse t)
  (setq pulsar-delay 0.055)
  (setq pulsar-iterations 10)
  (setq pulsar-face 'pulsar-magenta)
  (setq pulsar-highlight-face 'pulsar-green)

  (pulsar-global-mode 1)

  ;; pulsar does not define any key bindings.  This is just my personal
  ;; preference.  Remember to read the manual on the matter.  Evaluate:
  ;;
  ;; (info "(elisp) Key Binding Conventions")
  (let ((map global-map))
    (define-key map (kbd "C-x l") #'pulsar-pulse-line) ; override `count-lines-page'
    (define-key map (kbd "C-x L") #'pulsar-highlight-dwim))) ; or use `pulsar-highlight-line'
#+end_src

#+RESULTS:
: t

** DONE general line
CLOSED: [2022-09-22 Thu 11:28]
I set comment-line to 'SPC TAB TAB' which is a rather comfortable keybinding for me on my ZSA Moonlander keyboard.  The standard Emacs keybinding for comment-line is 'C-x C-;'.  The other keybindings are for commands that toggle on/off various line-related settings.  Doom Emacs uses 'SPC t' for "toggle" commands, so I choose 'SPC t' plus 'key' for those bindings.

| COMMAND                  | DESCRIPTION                               | KEYBINDING  |
|--------------------------+-------------------------------------------+-------------|
| comment-line             | /Comment or uncomment lines/                | SPC TAB TAB |
| hl-line-mode             | /Toggle line highlighting in current frame/ | SPC t h     |
| global-hl-line-mode      | /Toggle line highlighting globally/         | SPC t H     |
| doom/toggle-line-numbers | /Toggle line numbers/                       | SPC t l     |
| toggle-truncate-lines    | /Toggle truncate lines/                     | SPC t t     |

Relative line numbers are fantastic for knowing how far away line numbers are,
then =ESC 12 <UP>= gets you exactly where you think.
#+BEGIN_SRC emacs-lisp
;; (setq display-line-numbers-type 'relative)
(setq display-line-numbers-type nil)
(map! :leader
      :desc "Comment or uncomment lines" "TAB TAB" #'comment-line
      (:prefix ("t" . "toggle")
       :desc "Toggle line numbers" "l" #'doom/toggle-line-numbers
       :desc "Toggle line highlight in frame" "h" #'hl-line-mode
       :desc "Toggle line highlight globally" "H" #'global-hl-line-mode
       :desc "Toggle truncate lines" "t" #'toggle-truncate-lines))
#+END_SRC

#+RESULTS:
: toggle-truncate-lines

** DONE DASHBOARD
CLOSED: [2022-10-14 Fri 14:53]
- State "DONE"       from              [2022-10-14 Fri 14:53]
Emacs Dashboard is an extensible startup screen showing you recent files, bookmarks, agenda items and an Emacs banner.

*** Configuring Dashboard
#+begin_src emacs-lisp :tangle yes
(use-package! dashboard
  :init      ;; tweak dashboard config before loading it
  (setq dashboard-set-heading-icons t)
  (setq dashboard-set-file-icons t)
  (setq dashboard-banner-logo-title "\nKEYBINDINGS:\
\nFind file               (SPC .)     \
Open buffer list    (SPC b i)\
\nFind recent files       (SPC f r)   \
Open the eshell     (SPC e s)\
\nOpen dired file manager (SPC d d)   \
List of keybindings (SPC h b b)")
  ;;(setq dashboard-startup-banner 'logo) ;; use standard emacs logo as banner
  (setq dashboard-startup-banner "~/.config/doom/doom-emacs-dash.png")  ;; use custom image as banner
  (setq dashboard-center-content nil) ;; set to 't' for centered content
  (setq dashboard-items '((recents . 5)
                          (agenda . 5 )
                          (bookmarks . 5)
                          (projects . 5)
                          (registers . 5)))

  :config
  (dashboard-setup-startup-hook)
  (dashboard-modify-heading-icons '((recents . "file-text")
                                    (bookmarks . "book"))))

#+end_src

#+RESULTS:
: t

*** Dashboard in Emacsclient
This setting ensures that emacsclient always opens on *dashboard* rather than *scratch*.
#+begin_src emacs-lisp :tangle no
(setq doom-fallback-buffer "*dashboard*")
 (setq doom-fallback-buffer-name "► Doom"
     +doom-dashboard-name "► Doom")
#+end_src

#+RESULTS:
: ► Doom

** Prettier page breaks
CLOSED: [2022-03-31 Thu 20:59]

In some files, =^L= appears as a page break character. This isn't that visually
appealing, and Steve Purcell has been nice enough to make a package to display
these as horizontal rules.
#+begin_src emacs-lisp :tangle packages.el
(package! page-break-lines :recipe (:host github :repo "purcell/page-break-lines"))
#+end_src

#+begin_src emacs-lisp

(use-package! page-break-lines
  :commands page-break-lines-mode
  :init
  (autoload 'turn-on-page-break-lines-mode "page-break-lines")
  :config
  (setq page-break-lines-max-width fill-column)
  (map! :prefix "g"
        :desc "Prev page break" :nv "[" #'backward-page
        :desc "Next page break" :nv "]" #'forward-page))
#+end_src

#+RESULTS:

** FONTS
CLOSED: [2022-03-30 Wed 12:22]
*** Zoom font-size
#+BEGIN_SRC emacs-lisp
  (defun zoom-in ()
    (interactive)
    (let ((x (+ (face-attribute 'default :height)
                10)))
      (set-face-attribute 'default nil :height x)))

  (defun zoom-out ()
    (interactive)
    (let ((x (- (face-attribute 'default :height)
                10)))
      (set-face-attribute 'default nil :height x)))

  ;; (define-key global-map (kbd "C--") 'zoom-in)
  ;; (define-key global-map (kbd "C-+") 'zoom-out)
#+END_SRC

#+RESULTS:
: zoom-out

*** zoom frame
#+begin_src emacs-lisp

(defun zoom-frame (&optional amt frame)
    "Increaze FRAME font size by amount AMT. Defaults to selected
frame if FRAME is nil, and to 1 if AMT is nil."
    (interactive "p")
    (let* ((frame (or frame (selected-frame)))
           (font (face-attribute 'default :font frame))
           (size (font-get font :size))
           (amt (or amt 1))
           (new-size (+ size amt)))
      (set-frame-font (font-spec :size new-size) t (,frame))))

  (defun zoom-frame-out (&optional amt frame)
    "Call zoom-frame' with negative argument."
    (interactive "p")
    (zoom-frame (- (or amt 1)) frame))
#+end_src
*** Font Config
Settings related to fonts within Doom Emacs:
+ 'doom-font' -- standard monospace font that is used for most things in Emacs.
+ 'doom-variable-pitch-font' -- variable font which is useful in some Emacs plugins.
+ 'doom-big-font' -- used in doom-big-font-mode; useful for presentations.
+ 'font-lock-comment-face' -- for comments.
+ 'font-lock-keyword-face' -- for keywords with special significance like 'setq' in elisp.
Fira Code is amazing, and so is Roboto.

#+begin_src emacs-lisp :tangle yes
;; (setq doom-font (font-spec :family "FiraCode Nerd Font" :size 14)
;;       ;;doom-variable-pitch-font (font-spec :family "ETBembo" :size 14)
;;       doom-variable-pitch-font (font-spec :family "Alegreya" :size 14))
;; (add-hook! 'org-mode-hook #'mixed-pitch-mode)
(add-hook! 'org-mode-hook #'solaire-mode)
;; (setq mixed-pitch-variable-pitch-cursor nil)

 ;; (setq doom-font (font-spec :family "JetBrainsMono" :size 12 :weight 'light);;lissner's font a/q to his config
 ;;      doom-variable-pitch-font (font-spec :family "DejaVu Sans" :size 13))

;; (setq doom-font (font-spec :family "B612" :size 16)
(setq doom-font (font-spec :family "JetBrains Mono" :size 16)
      doom-big-font (font-spec :family "JetBrains Mono" :size 24)
      doom-variable-pitch-font (font-spec :family "Overpass" :size 18)
      doom-unicode-font (font-spec :family "JuliaMono")
      doom-serif-font (font-spec :family "IBM Plex Mono" :size 14 :weight 'light))

;; (setq doom-font (font-spec :family "Fira Mono" :size 12)
;;       doom-variable-pitch-font (font-spec :family "Fira Sans")
;;       doom-unicode-font (font-spec :family "DejaVu Sans Mono")
;;       doom-big-font (font-spec :family "Fira Mono" :size 19))

;;
;; (setq doom-font (font-spec :family "Input Mono Narrow" :size 15 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "Fira Sans") ; inherits `doom-font''s :size
;;       doom-unicode-font (font-spec :family "Input Mono Narrow" :size 15)
;;       doom-big-font (font-spec :family "Fira Mono" :size 17))


;; Thin grey line separating windows
(set-face-background 'vertical-border "red")
(set-face-foreground 'vertical-border (face-background 'vertical-border))

 ;; (setq doom-font (font-spec :family "Source Code Pro" :size 15)
 ;;       doom-variable-pitch-font (font-spec :family "Ubuntu" :size 15)
 ;;       doom-big-font (font-spec :family "Source Code Pro" :size 24))
(after! doom-themes
  (setq doom-themes-enable-bold t
        doom-themes-enable-italic t))
(custom-set-faces!
  '(font-lock-comment-face :slant italic)
  '(font-lock-keyword-face :slant italic))
#+END_SRC

#+RESULTS:
| doom--customize-themes-h-1854 | doom--customize-themes-h-1855 | doom--customize-themes-h-1875 | doom--customize-themes-h-1876 | doom--customize-themes-h-1878 | doom--customize-themes-h-1885 |

In addition to these fonts, Merriweather is used with =nov.el=, and Alegreya as a
serifed proportional font used by =mixed-pitch-mode= for =writeroom-mode= with Org
files.

*** detect fonts
#+name: detect-missing-fonts
#+begin_src emacs-lisp :tangle no
(defvar required-fonts '("JetBrainsMono.*" "Overpass" "JuliaMono" "IBM Plex Mono" "Merriweather" "Alegreya"))

(defvar available-fonts
  (delete-dups (or (font-family-list)
                   (split-string (shell-command-to-string "fc-list : family")
                                 "[,\n]"))))

(defvar missing-fonts
  (delq nil (mapcar
             (lambda (font)
               (unless (delq nil (mapcar (lambda (f)
                                           (string-match-p (format "^%s$" font) f))
                                         available-fonts))
                 font))
             required-fonts)))

(if missing-fonts
    (pp-to-string
     `(unless noninteractive
        (add-hook! 'doom-init-ui-hook
          (run-at-time nil nil
                       (lambda ()
                         (message "%s missing the following fonts: %s"
                                  (propertize "Warning!" 'face '(bold warning))
                                  (mapconcat (lambda (font)
                                               (propertize font 'face 'font-lock-variable-name-face))
                                             ',missing-fonts
                                             ", "))
                         (sleep-for 0.5))))))
  ";; No missing fonts detected")
#+end_src

#+RESULTS: detect-missing-fonts

*** Mixed pitch
#+begin_quote
From the =:ui zen= module.
#+end_quote

#+begin_src emacs-lisp :tangle no

(use-package! mixed-pitch
  :hook (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-face 'variable-pitch))
#+end_src

We'd like to use mixed pitch in certain modes. If we simply add a hook, when
directly opening a file with (a new) Emacs =mixed-pitch-mode= runs before UI
initialisation, which is problematic. To resolve this, we create a hook that
runs after UI initialisation and both
+ conditionally enables =mixed-pitch-mode=
+ sets up the mixed pitch hooks

#+begin_src emacs-lisp
(defvar mixed-pitch-modes '(org-mode LaTeX-mode markdown-mode gfm-mode Info-mode)
  "Modes that `mixed-pitch-mode' should be enabled in, but only after UI initialisation.")
(defun init-mixed-pitch-h ()
  "Hook `mixed-pitch-mode' into each mode in `mixed-pitch-modes'.
Also immediately enables `mixed-pitch-modes' if currently in one of the modes."
  (when (memq major-mode mixed-pitch-modes)
    (mixed-pitch-mode 1))
  (dolist (hook mixed-pitch-modes)
    (add-hook (intern (concat (symbol-name hook) "-hook")) #'mixed-pitch-mode)))
(add-hook 'doom-init-ui-hook #'init-mixed-pitch-h)
#+end_src

As mixed pitch uses the variable =mixed-pitch-face=, we can create a new function
to apply mixed pitch with a serif face instead of the default (see the
subsequent face definition). This was created for writeroom mode.

#+begin_src emacs-lisp
(autoload #'mixed-pitch-serif-mode "mixed-pitch"
  "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(setq! variable-pitch-serif-font (font-spec :family "Alegreya" :size 27))

(after! mixed-pitch
  (setq mixed-pitch-set-height t)
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))
#+end_src
#+RESULTS:
| init-mixed-pitch-h | persp-mode | window-divider-mode | +ligatures-init-h | +popup-mode |

As mixed pitch uses the variable =mixed-pitch-face=, we can create a new function
to apply mixed pitch with a serif face instead of the default. This was created
for writeroom mode.

#+begin_src emacs-lisp
(autoload #'mixed-pitch-serif-mode "mixed-pitch"
  "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch." t)

(setq! variable-pitch-serif-font (font-spec :family "Alegreya" :size 27))

(after! mixed-pitch
  (setq mixed-pitch-set-height t)
  (set-face-attribute 'variable-pitch-serif nil :font variable-pitch-serif-font)
  (defun mixed-pitch-serif-mode (&optional arg)
    "Change the default face of the current buffer to a serifed variable pitch, while keeping some faces fixed pitch."
    (interactive)
    (let ((mixed-pitch-face 'variable-pitch-serif))
      (mixed-pitch-mode (or arg 'toggle)))))
#+end_src
#+RESULTS:

Now, as Harfbuzz is currently used in Emacs, we'll be missing out on the
following Alegreya ligatures:
#+begin_center
ff /ff/ ffi /ffi/ ffj /ffj/ ffl /ffl/
fft /fft/ fi /fi/ fj /fj/ ft /ft/
Th /Th/
#+end_center

Thankfully, it isn't to hard to add these to the ~composition-function-table~.
#+begin_src emacs-lisp
(set-char-table-range composition-function-table ?f '(["\\(?:ff?[fijlt]\\)" 0 font-shape-gstring]))
(set-char-table-range composition-function-table ?T '(["\\(?:Th\\)" 0 font-shape-gstring]))
#+end_src

#+RESULTS:
| [\(?:Th\) 0 font-shape-gstring] |

**** Variable pitch serif font


It would be nice if we were able to make use of a serif version of the
=variable-pitch= face. Since this doesn't already exist, let's create it.

#+begin_src emacs-lisp
(defface variable-pitch-serif
    '((t (:family "serif")))
    "A variable-pitch face with serifs."
    :group 'basic-faces)
#+end_src

For ease of use, let's also set up an easy way of setting the ~:font~ attribute.

#+begin_src emacs-lisp
(defcustom variable-pitch-serif-font (font-spec :family "serif")
  "The font face used for `variable-pitch-serif'."
  :group 'basic-faces
  :set (lambda (symbol value)
         (set-face-attribute 'variable-pitch-serif nil :font value)
         (set-default-toplevel-value symbol value)))
#+end_src

** DONE MODELINE
CLOSED: [2022-03-31 Thu 19:49]
*** doom modeline
**** Theme and modeline
CLOSED: [2022-03-30 Wed 12:25]

Setting the theme to doom-vibrant.  To try out new themes, I set a keybinding for counsel-load-theme with 'SPC h t'.
#+begin_src emacs-lisp
(use-package! doom-themes
  :config
  ;; Enable flashing mode-line on errors
  (doom-themes-visual-bell-config)
  ;; Corrects (and improves) org-mode's native fontification.
  (doom-themes-org-config))
  (doom-themes-visual-bell-config)
(map! :leader
      :desc "Load new theme" "h t" #'load-theme)

(setq doom-theme 'modus-vivendi)
(remove-hook 'window-setup-hook #'doom-init-theme-h)
(add-hook 'after-init-hook #'doom-init-theme-h 'append)
(delq! t custom-theme-load-path)

(set-face-attribute 'mode-line nil :font "Ubuntu Mono-13")
;; (setq doom-modeline-height 20     ;; sets modeline height
;;       doom-modeline-bar-width 2   ;; sets right bar width
;;       doom-modeline-persp-name t  ;; adds perspective name to modeline
;;       doom-modeline-persp-icon t) ;; addsfolder icon next to persp name

(setq display-time-format "%l:%M %p %b %y"
      display-time-default-load-average nil)

;; You must run (all-the-icons-install-fonts) one time after
;; installing this package!

(use-package! minions
  :hook (doom-modeline-mode . minions-mode))

(use-package! doom-modeline
  :after eshell     ;; Make sure it gets hooked after eshell
  ;;:hook (after-init . doom-modeline-init)
  :custom-face
  (mode-line ((t (:height 1.0))))
  (mode-line-inactive ((t (:height .9))))
  :custom
  (doom-modeline-height 6)
  (doom-modeline-bar-width 5)
  (doom-modeline-lsp t)
  (doom-modeline-github t)
  (doom-modeline-mu4e nil)
  (doom-modeline-irc nil)
  (doom-modeline-minor-modes t)
  (doom-modeline-persp-name nil)
  (doom-modeline-buffer-file-name-style 'truncate-except-project)
  (doom-modeline-major-mode-icon nil))
#+end_src


However, by default ~red~ text is used in the ~modeline~, so let's make that orange
so I don't feel like something's gone /wrong/ when editing files.

#+begin_src emacs-lisp
(custom-set-faces!
  '(doom-modeline-buffer-modified :foreground "orange"))
#+end_src

#+RESULTS:
| doom--customize-themes-h-33 | doom--customize-themes-h-34 |

While we're modifying the modeline, =LF UTF-8= is the default file encoding, and
thus not worth noting in the modeline. So, let's conditionally hide it.

#+begin_src emacs-lisp :tangle yes
(defun doom-modeline-conditional-buffer-encoding ()
  "We expect the encoding to be LF UTF-8, so only show the modeline when this is not the case"
  (setq-local doom-modeline-buffer-encoding
              (unless (and (memq (plist-get (coding-system-plist buffer-file-coding-system) :category)
                                 '(coding-category-undecided coding-category-utf-8))
                           (not (memq (coding-system-eol-type buffer-file-coding-system) '(1 2))))
                t)))

(add-hook 'after-change-major-mode-hook #'doom-modeline-conditional-buffer-encoding)
#+end_src

#+RESULTS:
| doom--setq-evil-shift-width-for-after-change-major-mode-h | doom-modeline-conditional-buffer-encoding | clean-mode-line | solaire-global-mode-enable-in-buffers | ess-r-package-auto-activate | global-evil-surround-mode-enable-in-buffers | yas-global-mode-enable-in-buffers | doom-modeline-auto-set-modeline | +ligatures-init-buffer-h | persp-after-change-major-mode-h | better-jumper-mode-enable-in-buffers | global-company-mode-enable-in-buffers | evil-snipe-override-mode-enable-in-buffers | evil-snipe-mode-enable-in-buffers | git-commit-setup-font-lock-in-buffer | global-hl-line-mode-enable-in-buffers | smartparens-global-mode-enable-in-buffers | doom-disable-smartparens-navigate-skip-match-h | ws-butler-global-mode-enable-in-buffers | global-undo-fu-session-mode-enable-in-buffers | global-flycheck-mode-enable-in-buffers | global-emojify-mode-enable-in-buffers | doom-modeline-update-buffer-file-icon | pulsar-global-mode-enable-in-buffers | global-subword-mode-enable-in-buffers | evil-mode-enable-in-buffers | global-eldoc-mode-enable-in-buffers | global-font-lock-mode-enable-in-buffers | +company-init-backends-h | doom-highlight-non-default-indentation-h | which-func-ff-hook | doom-run-local-var-hooks-h |

**** DONE Doom's pdf modeline
CLOSED: [2022-03-30 Wed 19:58]
#+begin_quote
From the =:ui modeline= module.
#+end_quote

Very nice and pretty, however I think the PDF modeline could do with tweaking.
I raised [[https://github.com/seagle0128/doom-modeline/pull/425][an issue]] on this, however the response was basically "put your
preferences in your personal config, the current default is sensible" --- so
here we are.

First up I'm going to want a segment for just the buffer file name, and a PDF
icon. Then we'll redefine two functions used to generate the modeline.

#+begin_src emacs-lisp
(after! doom-modeline
  (doom-modeline-def-segment buffer-name
    "Display the current buffer's name, without any other information."
    (concat
     (doom-modeline-spc)
     (doom-modeline--buffer-name)))

  (doom-modeline-def-segment pdf-icon
    "PDF icon from all-the-icons."
    (concat
     (doom-modeline-spc)
     (doom-modeline-icon 'octicon "file-pdf" nil nil
                         :face (if (doom-modeline--active)
                                   'all-the-icons-red
                                 'mode-line-inactive)
                         :v-adjust 0.02)))

  (defun doom-modeline-update-pdf-pages ()
    "Update PDF pages."
    (setq doom-modeline--pdf-pages
          (let ((current-page-str (number-to-string (eval `(pdf-view-current-page))))
                (total-page-str (number-to-string (pdf-cache-number-of-pages))))
            (concat
             (propertize
              (concat (make-string (- (length total-page-str) (length current-page-str)) ? )
                      " P" current-page-str)
              'face 'mode-line)
             (propertize (concat "/" total-page-str) 'face 'doom-modeline-buffer-minor-mode)))))

  (doom-modeline-def-segment pdf-pages
    "Display PDF pages."
    (if (doom-modeline--active) doom-modeline--pdf-pages
      (propertize doom-modeline--pdf-pages 'face 'mode-line-inactive)))

  (doom-modeline-def-modeline 'pdf
    '(bar window-number pdf-pages pdf-icon buffer-name)
    '(misc-info matches major-mode process vcs)))
#+end_src

#+RESULTS:
: doom-modeline-format--pdf

*** kar modline
#+begin_src emacs-lisp :tangle no

;;----------------------------------------------------------------
;; ** SMART MODE LINE
;;----------------------------------------------------------------

;; Smart mode line hews close to Emacs' default modeline set up. The only change
;; we make is to disable display of the global-mode-string when on Emacs 28 or
;; higher, we show this info in the less crowded tab-bar instead.

(use-package! smart-mode-line
  :ensure t
  :commands sml/setup
  :init
  (setq sml/theme nil)
  (sml/setup)
  (unless (version< emacs-version "28.0")
    (setq mode-line-misc-info
          '((which-function-mode
            (which-func-mode
             ("" which-func-format " ")))
           ;; (global-mode-string
           ;;  ("" global-mode-string))
            ))))

;; Some advice to add support for Evil to smart-mode-line, long since
;; deprecated.

(use-package! smart-mode-line
  :defines sml/fix-mode-line-a
  :disabled
  :config
  (add-to-list 'sml/replacer-regexp-list '("^~/[dD]ocuments/[rR]oam.*/" ":ROAM:"))
  (defun sml/fix-mode-line-a (_theme &rest _args)
    "Advice to `load-theme' to fix the mode-line height after activating/deactivating theme"
    (set-face-attribute 'mode-line nil
                        :box `(:line-width 3 :color ,(plist-get
                                                      (custom-face-attributes-get 'mode-line nil)
                                                      :background))))

  (advice-add 'disable-theme :after #'sml/fix-mode-line-a)
  (advice-add 'load-theme :after #'sml/fix-mode-line-a)

  (custom-set-faces
   '(mode-line ((t (:box (:line-width 4 :color ))))))

          (lexical-let ((default-color (cons (face-background 'mode-line)
                                             (face-foreground 'mode-line))))
            (add-hook 'post-command-hook
                      (lambda ()
                        (let ((color (cond ((minibufferp) default-color)
                                           ((evil-insert-state-p) '("DarkGoldenrod2" . "black"))
                                           ((evil-emacs-state-p)  '("SkyBlue2" . "black"))
                                           ;; ((buffer-modified-p)   '("#006fa0" . "#ffffff"))
                                           (t default-color))))
                          (set-face-background 'mode-line (car color))
                          (set-face-foreground 'mode-line (cdr color)))))))

;; ** MINOR MODE HIDING

;; Disable help mouse-overs for mode-line segments (i.e. :help-echo text).
;; They're generally unhelpful and only add confusing visual clutter.
(setq mode-line-default-help-echo nil
      show-help-function nil)

(defvar mode-line-cleaner-alist
  `((company-mode . " ⇝")
    (corfu-mode . " ⇝")
    (yas-minor-mode .  " Y";; " Υ"
                    )
    (smartparens-mode . " ()";; " ﴾﴿"
                      )
    (evil-smartparens-mode . "")
    (eldoc-mode . "")
    (abbrev-mode . "")
    (evil-snipe-local-mode . "")
    (evil-owl-mode . "")
    (evil-rsi-mode . "")
    (evil-commentary-mode . "")
    (ivy-mode . "")
    (counsel-mode . "")
    (wrap-region-mode . "")
    (rainbow-mode . "")
    (which-key-mode . "")
    (undo-tree-mode . "")
    ;; (undo-tree-mode . " ⎌")
    (auto-revert-mode . "")
    ;; Major modes
    (lisp-interaction-mode . "λ")
    (hi-lock-mode . "")
    (python-mode . "Py")
    (emacs-lisp-mode . "Eλ")
    (nxhtml-mode . "nx")
    (dot-mode . "")
    (scheme-mode . " SCM")
    (matlab-mode . "M")
    (org-mode . " ORG";; "⦿"
              )
    (valign-mode . "")
    (eldoc-mode . "")
    (org-cdlatex-mode . "")
    (org-indent-mode . "")
    (org-roam-mode . "")
    (visual-line-mode . "")
    (latex-mode . "TeX")
    ;; (projectile-mode . " ϸ")
    (outline-minor-mode . " [o]";; " ֍"
                        )
    (hs-minor-mode . "")
    (matlab-functions-have-end-minor-mode . "")
    (org-roam-ui-mode . " UI")
    ;; Evil modes
    (evil-traces-mode . "")
    (latex-extra-mode . "")
    (strokes-mode . "")
    (flymake-mode . "fly")
    (god-mode . ,(propertize "God" 'face 'success))
    (gcmh-mode . ""))
  "Alist for `clean-mode-line'.

  ; ;; When you add a new element to the alist, keep in mind that you
  ; ;; must pass the correct minor/major mode symbol and a string you
  ; ;; want to use in the modeline *in lieu of* the original.")

(defun clean-mode-line ()
  (cl-loop for cleaner in mode-line-cleaner-alist
           do (let* ((mode (car cleaner))
                     (mode-str (cdr cleaner))
                     (old-mode-str (cdr (assq mode minor-mode-alist))))
                (when old-mode-str
                  (setcar old-mode-str mode-str))
                ;; major mode
                (when (eq mode major-mode)
                  (setq mode-name mode-str)))))


(add-hook 'after-change-major-mode-hook 'clean-mode-line)
#+end_src

#+RESULTS:
| doom--setq-evil-shift-width-for-after-change-major-mode-h | clean-mode-line | solaire-global-mode-enable-in-buffers | global-evil-surround-mode-enable-in-buffers | yas-global-mode-enable-in-buffers | better-jumper-mode-enable-in-buffers | global-company-mode-enable-in-buffers | evil-snipe-override-mode-enable-in-buffers | evil-snipe-mode-enable-in-buffers | +ligatures-init-buffer-h | persp-after-change-major-mode-h | doom-modeline-auto-set-modeline | global-hl-line-mode-enable-in-buffers | smartparens-global-mode-enable-in-buffers | doom-disable-smartparens-navigate-skip-match-h | ws-butler-global-mode-enable-in-buffers | global-undo-fu-session-mode-enable-in-buffers | global-flycheck-mode-enable-in-buffers | git-commit-setup-font-lock-in-buffer | global-emojify-mode-enable-in-buffers | doom-modeline-conditional-buffer-encoding | doom-modeline-update-buffer-file-icon | pulsar-global-mode-enable-in-buffers | global-subword-mode-enable-in-buffers | evil-mode-enable-in-buffers | global-eldoc-mode-enable-in-buffers | global-font-lock-mode-enable-in-buffers | doom-highlight-non-default-indentation-h | +company-init-backends-h | which-func-ff-hook | doom-run-local-var-hooks-h |

** Writeroom
#+begin_quote
From the =:ui zen= module.
#+end_quote

For starters, I think Doom is a bit over-zealous when zooming in
#+begin_src emacs-lisp :tangle no
(setq +zen-text-scale 0.8)
#+end_src

#+RESULTS:
: 0.8

Then, when using Org it would be nice to make a number of other aesthetic
tweaks. Namely:
+ Use a serifed variable-pitch font
+ Hiding headline leading stars
+ Using fleurons as headline bullets
+ Hiding line numbers
+ Removing outline indentation
+ Centring the text
+ Turning on ~org-pretty-table-mode~

#+begin_src emacs-lisp :tangle no
(defvar +zen-serif-p t
  "Whether to use a serifed font with `mixed-pitch-mode'.")
(after! writeroom-mode
  (defvar-local +zen--original-org-indent-mode-p nil)
  (defvar-local +zen--original-mixed-pitch-mode-p nil)
  (defvar-local +zen--original-org-pretty-table-mode-p nil)
  (defun +zen-enable-mixed-pitch-mode-h ()
    "Enable `mixed-pitch-mode' when in `+zen-mixed-pitch-modes'."
    (when (apply #'derived-mode-p +zen-mixed-pitch-modes)
      (if writeroom-mode
          (progn
            (setq +zen--original-mixed-pitch-mode-p mixed-pitch-mode)
            (funcall (if +zen-serif-p #'mixed-pitch-serif-mode #'mixed-pitch-mode) 1))
        (funcall #'mixed-pitch-mode (if +zen--original-mixed-pitch-mode-p 1 -1)))))
  (pushnew! writeroom--local-variables
            'display-line-numbers
            'visual-fill-column-width
            'org-adapt-indentation
            'org-superstar-headline-bullets-list
            'org-superstar-remove-leading-stars)
  (add-hook 'writeroom-mode-enable-hook
            (defun +zen-prose-org-h ()
              "Reformat the current Org buffer appearance for prose."
              (when (eq major-mode 'org-mode)
                (setq display-line-numbers nil
                      visual-fill-column-width 60
                      org-adapt-indentation nil)
                (when (featurep 'org-superstar)
                  (setq-local org-superstar-headline-bullets-list '("🙘" "🙙" "🙚" "🙛")
                              ;; org-superstar-headline-bullets-list '("🙐" "🙑" "🙒" "🙓" "🙔" "🙕" "🙖" "🙗")
                              org-superstar-remove-leading-stars t)
                  (org-superstar-restart))
                (setq
                 +zen--original-org-indent-mode-p org-indent-mode
                 +zen--original-org-pretty-table-mode-p (bound-and-true-p org-pretty-table-mode))
                (org-indent-mode -1)
                (org-pretty-table-mode 1))))
  (add-hook 'writeroom-mode-disable-hook
            (defun +zen-nonprose-org-h ()
              "Reverse the effect of `+zen-prose-org'."
              (when (eq major-mode 'org-mode)
                (when (featurep 'org-superstar)
                  (org-superstar-restart))
                (when +zen--original-org-indent-mode-p (org-indent-mode 1))
                ;; (unless +zen--original-org-pretty-table-mode-p (org-pretty-table-mode -1))
                ))))
#+end_src

#+RESULTS:
| +zen-nonprose-org-h |

** WINNER MODE
Winner mode has been included with GNU Emacs since version 20.  This is a global minor mode and, when activated, it allows you to “undo” (and “redo”) changes in the window configuration with the key commands 'SCP w <left>' and 'SPC w <right>'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("w" . "window")
       :desc "Winner redo" "<right>" #'winner-redo
       :desc "Winner undo" "<left>" #'winner-undo))

;; Winner mode is disabled in favor of =tab-bar-history-mode=, which does the
;; same but with a separate window configuration history for each tab. This is
;; usually what I want.

#+END_SRC

#+RESULTS:

** DONE Theme magic
CLOSED: [2022-09-22 Thu 11:41]

With all our fancy Emacs themes, my terminal is missing out!
#+begin_src emacs-lisp :tangle packages.el
(package! theme-magic :pin "844c4311bd26ebafd4b6a1d72ddcc65d87f074e3")
#+end_src

This operates using =pywal=, which is present in some repositories, but most
reliably installed with =pip=.
#+begin_src shell :eval no :tangle (if (executable-find "wal") "no" "setup.sh")
sudo python3 -m pip install pywal
#+end_src

Theme magic takes a look at a number of faces, the saturation levels, and colour
differences to try to cleverly pick eight colours to use. However, it uses the
same colours for the light variants, and doesn't always make the best picks.
Since we're using =doom-themes=, our life is a little easier and we can use the
colour utilities from Doom themes to easily grab sensible colours and generate
lightened versions --- let's do that.

#+begin_src emacs-lisp :tangle yes
(use-package! theme-magic
  :commands theme-magic-from-emacs
  :config
  ;; (defadvice! theme-magic--auto-extract-16-doom-colors ()
    ;; :override #'theme-magic--auto-extract-16-colors
    (list
     (face-attribute 'default :background)
     (doom-color 'error)
     (doom-color 'success)
     (doom-color 'type)
     (doom-color 'keywords)
     (doom-color 'constants)
     (doom-color 'functions)
     (face-attribute 'default :foreground)
     (face-attribute 'shadow :foreground)
     (doom-blend 'base8 'error 0.1)
     (doom-blend 'base8 'success 0.1)
     (doom-blend 'base8 'type 0.1)
     (doom-blend 'base8 'keywords 0.1)
     (doom-blend 'base8 'constants 0.1)
     (doom-blend 'base8 'functions 0.1)
     (face-attribute 'default :foreground)))
(require 'theme-magic)
;; (theme-magic-export-theme-mode)
#+end_src

#+RESULTS:
: t

** FIXME Screencast
- State "FIXME"      from "DONE"       [2022-10-14 Fri 15:10] \\
  fix colors and quality

In a similar manner to [[Keycast]], [[https://gitlab.com/ambrevar/emacs-gif-screencast][gif-screencast]] may come in handy.
#+begin_src emacs-lisp :tangle packages.el
(package! gif-screencast :pin "5517a557a17d8016c9e26b0acb74197550f829b9")
#+end_src

We can lazy load this using the start/stop commands.

I initially installed ~scrot~ for this, since it was the default capture program.
However it raised ~glib error: Saving to file ... failed~ each time it was run.
Google didn't reveal any easy fixed, so I switched to [[https://github.com/naelstrof/maim][maim]]. We now need to pass
it the window ID. This doesn't change throughout the lifetime of an emacs
instance, so as long as a single window is used ~xdotool getactivewindow~ will
give a satisfactory result.

It seems that when new colours appear, that tends to make ~gifsicle~ introduce
artefacts. To avoid this we pre-populate the colour map using the current doom
theme.
#+begin_src emacs-lisp

(use-package! gif-screencast
  :commands gif-screencast-mode
  :config
  (map! :map gif-screencast-mode-map
        :g "<f8>" #'gif-screencast-toggle-pause
        :g "<f9>" #'gif-screencast-stop)
  (setq gif-screencast-program "maim"
        gif-screencast-args `("--quality" "3" "-i" ,(string-trim-right
                                                     (shell-command-to-string
                                                      "xdotool getactivewindow")))
        gif-screencast-optimize-args '("--batch" "--optimize=3" "--usecolormap=/tmp/doom-color-theme"))
  (defun gif-screencast-write-colormap ()
    (f-write-text
     (replace-regexp-in-string
      "\n+" "\n"
      (mapconcat (lambda (c) (if (listp (cdr c))
                                 (cadr c))) doom-themes--colors "\n"))
     'utf-8
     "/tmp/doom-color-theme" ))
  (gif-screencast-write-colormap)
  (add-hook 'doom-load-theme-hook #'gif-screencast-write-colormap))
#+end_src

#+RESULTS:
** Treemacs
CLOSED: [2022-09-22 Thu 11:48]
#+begin_quote
From the =:ui treemacs= module.
#+end_quote

Quite often there are superfluous files I'm not that interested in. There's no
good reason for them to take up space. Let's add a mechanism to ignore them.
#+begin_src emacs-lisp :tangle yes
(after! treemacs
  (defvar treemacs-file-ignore-extensions '()
    "File extension which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-globs '()
    "Globs which will are transformed to `treemacs-file-ignore-regexps' which `treemacs-ignore-filter' will ensure are ignored")
  (defvar treemacs-file-ignore-regexps '()
    "RegExps to be tested to ignore files, generated from `treeemacs-file-ignore-globs'")
  (defun treemacs-file-ignore-generate-regexps ()
    "Generate `treemacs-file-ignore-regexps' from `treemacs-file-ignore-globs'"
    (setq treemacs-file-ignore-regexps (mapcar 'dired-glob-regexp treemacs-file-ignore-globs)))
  (if (equal treemacs-file-ignore-globs '()) nil (treemacs-file-ignore-generate-regexps))
  (defun treemacs-ignore-filter (file full-path)
    "Ignore files specified by `treemacs-file-ignore-extensions', and `treemacs-file-ignore-regexps'"
    (or (member (file-name-extension file) treemacs-file-ignore-extensions)
        (let ((ignore-file nil))
          (dolist (regexp treemacs-file-ignore-regexps ignore-file)
            (setq ignore-file (or ignore-file (if (string-match-p regexp full-path) t nil)))))))
  (add-to-list 'treemacs-ignored-file-predicates #'treemacs-ignore-filter))
#+end_src

#+RESULTS:
| treemacs-ignore-filter | treemacs--std-ignore-file-predicate |

Now, we just identify the files in question.
#+begin_src emacs-lisp :tangle yes
(setq treemacs-file-ignore-extensions
      '(;; LaTeX
        "aux"
        "ptc"
        "fdb_latexmk"
        "fls"
        "synctex.gz"
        "toc"
        ;; LaTeX - glossary
        "glg"
        "glo"
        "gls"
        "glsdefs"
        "ist"
        "acn"
        "acr"
        "alg"
        ;; LaTeX - pgfplots
        "mw"
        ;; LaTeX - pdfx
        "pdfa.xmpi"
        ))
(setq treemacs-file-ignore-globs
      '(;; LaTeX
        "*/_minted-*"
        ;; AucTeX
        "*/.auctex-auto"
        "*/_region_.log"
        "*/_region_.tex"))
#+end_src

#+RESULTS:
| */_minted-* | */.auctex-auto | */_region_.log | */_region_.tex |

** KILL NEOTREE
CLOSED: [2022-11-12 Sat 12:44]
- State "KILL"       from              [2022-11-12 Sat 12:44] \\
  treemacs is way better

Neotree is a file tree viewer.  When you open neotree, it jumps to the current file thanks to neo-smart-open.  The neo-window-fixed-size setting makes the neotree width be adjustable.  Doom Emacs had no keybindings set for neotree.  Since Doom Emacs uses 'SPC t' for 'toggle' keybindings, I used 'SPC t n' for toggle-neotree.

| COMMAND        | DESCRIPTION               | KEYBINDING |
|----------------+---------------------------+------------|
| neotree-toggle | /Toggle neotree/            | SPC t n    |
| neotree- dir   | /Open directory in neotree/ | SPC d n    |

#+BEGIN_SRC emacs-lisp :tangle no
(after! neotree
  (setq neo-smart-open t
        neo-window-fixed-size nil))
(after! doom-themes
  (setq doom-neotree-enable-variable-pitch t))
(map! :leader
      :desc "Toggle neotree file viewer" "t n" #'neotree-toggle
      :desc "Open directory in neotree" "d n" #'neotree-dir)
#+END_SRC
** DONE pulsing cursor
CLOSED: [2022-09-22 Thu 11:48]
#+begin_src emacs-lisp :tangle packages.el
(package! pulsing-cursor
    :recipe (:host github :repo "jasonjckn/pulsing-cursor"))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package pulsing-cursor
    :config (pulsing-cursor-mode +1))
#+end_src

#+RESULTS:
: t

* Completions framework
** Company
#+begin_quote
From the =:completion company= module.
#+end_quote
[[../../.emacs.d/modules/completion/company/README.org][Completion Module Readme.org]]
It's nice to have completions almost all the time, in my opinion. Key strokes
are just waiting to be saved!

#+begin_src emacs-lisp :tangle yes

(use-package! company
  :defer 3
  :general
  ("M-s <tab>"      'company-yasnippet)

  (:keymaps   'company-active-map
  "C-;"       'company-other-backend
  "C-]"       'company-show-location
  "M-."       'company-show-location)

  (:keymaps   'company-search-map
   [return]   'company-complete-selection
   "RET"      'company-complete-selection
   "S-SPC"    'company-search-toggle-filtering)

  (setq tab-always-indent 'complete))

(after! company
  (setq company-idle-delay 0.1
        company-selection-wrap-around t
        company-minimum-prefix-length 2)
  (setq company-show-quick-access t))
   ;;(add-hook 'evil-normal-state-entry-hook #'company-abort)) ;; make aborting less annoying. currently disable caues dabbrev closes company -yasnipper automatically-but i use SPC i s
#+end_src

#+RESULTS:
: t

Now, the improvements from ~precedent~ are mostly from remembering history, so
let's improve that memory.
#+begin_src emacs-lisp
(setq-default history-length 1000)
(setq-default prescient-history-length 1000)
#+end_src

#+RESULTS:
: 1000

*** Plain Text
~Ispell~ is nice, let's have it in ~text~, ~markdown~, and ~GFM~.
#+begin_src emacs-lisp :tangle no
(set-company-backend!
  '(text-mode
    markdown-mode
    gfm-mode)
  '(:seperate
    company-ispell
    company-files
    company-yasnippet))
#+end_src

#+RESULTS:

We then configure the dictionary we're using in [[*Ispell][Ispell]].
*** ESS
~company-dabbrev-code~ is nice. Let's have it.
#+begin_src emacs-lisp :tangle yes
(set-company-backend! 'ess-r-mode '(company-R-args company-R-objects company-dabbrev-code :separate))
#+end_src

#+RESULTS:

** Consult
*** desc
Daniel Mendler's Consult is a welcome addition to the ecosystem of
modular, extensible tools that work with the standard minibuffer
completion mechanisms and, by extension, with every user interface that
largely conforms with them (Icomplete, Selectrum) or fully respects them
(Embark and [[https://github.com/minad/vertico][Daniel's own Vertico]]).  For my case, this means that it
works with everything included in [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]].

Consult's value proposition is two-fold: (1) remain aligned with the
Emacs completion paradigm, and (2) offer minibuffer-centric commands
that either enhance aspects of interactivity and functionality found in
existing commands or outright provide them from scratch.

Some Consult commands are drop-in replacements for built-in options.
For example =consult-complex-command= offers an improved interactive
experience over the default =repeat-complex-command=.  Same principle for
=consult-goto-line= which displays the line numbers and offers a live
preview of where you are about to land.

Other commands enhance the defaults with a filtering mechanism that
targets candidates by their type.  A case in point is =consult-imenu=
which recognises syntactic constructs that are variables, functions,
macros (configurable via =consult-imenu-narrow=, =consult-imenu-toplevel=).

This "filtering" mechanism, which is internally known as "narrowing",
can be accessed via a key binding for all commands that support it.  In
my case, that key is the right angled bracket, or greater than sign (=>=)
from inside the minibuffer (configure =consult-narrow-key=).  So you type
the narrow key and follow it up with another key that matches the
relevant targets.  Hit backspace to remove the narrowing.  As for the
available keys, type =?= which calls =consult-narrow-help=.

This narrowing-by-type mechanism can also be used without inputting the
=consult-narrow-key=, just by typing in the appropriate character and
inserting a space.  For instance, to search only for functions in
=consult-imenu=, you type =f= and then a space.  Consult will add an
indicator to the minibuffer prompt describing the active filter.

In general, commands that involve multiple groups can benefit from this
type of narrowing.  The prime example is =consult-buffer= which combines
sources of recently visited files, bookmarks, and buffers (those are
configurable via the variable =consult-buffer-sources=).  Though others
follow the same principle, such as the aforementioned =consult-imenu= and
=consult-bookmark=.

Another intriguing facility of Consult is its asynchronous call to
external processes, such as =grep= and =find=.  Those calls can be
configured to return some output based on a minimum number of
characters, while they also allow for tweaks to their update delays.
Interactivity is already a given, meaning that you can continue typing
and see the results pop up.  Furthermore, they implement a two-stage
input scheme, separated by a configurable delimiter (=#= by default and
controlled with =consult-async-default-split=):

+ First you type in the pattern that should be sent to the external
  program.  This is what triggers the asynchronous call.  So your input
  looks like this: =#PATTERN=.  The pattern will typically consist of some
  text or a regular expression, but can also include command line flags
  for the underlying CLI program (check Consult's documentation for the
  technicalities).

+ Then you can add another field delimiter to instruct Consult to (i)
  keep the results that =#PATTERN= gave you and (ii) leverage Emacs' own
  mechanisms to further narrow the list.  Now your input looks like
  this: =#PATTERN#MORE-PATTERNS=.  The =#MORE-PATTERNS= will use whatever
  completion styles you have configured (check my =completion-styles=).

As already suggested, Consult provides previews for its commands.  This
feature should work without any further intervention.

Consult can shine when used in tandem with Embark to produce buffers
that hold all the candidates of any given minibuffer completion command
([[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]]).
For example, =embark-export= can be called from inside =consult-grep= (and
variants) to deliver a dedicated =grep-mode= buffer, which can then be
edited with the help of the =wgrep= package (check [[#h:42624165-f4cb-4318-abce-c11232426880][wgrep (writable grep)]]).
Use that to quickly refactor some pattern across your files.

Other nice extensions of Consult are (i) its ability to work as a
generic front-end for completion, and (ii) its preview facility for
registers.  The former is done by =consult-completion-in-region= which
provides completion for commands such as =dabbrev-completion= or the TAB
key in programming buffers (see [[#h:d51d37df-4e58-4e0b-85a1-019ceda342f6][Tabs, indentation, and the TAB key]]).
While the latter is an overall prettier presentation for the familiar
register preview window (watch: [[https://protesilaos.com/codelog/2020-03-08-emacs-registers/][Primer on Emacs “registers”]]
(2020-03-08)).

As for registers themselves, Consult furnishes three commands, one
focused on minibuffer completion and two as do-what-I-mean alternatives
to the built-in facilities of storing and inserting---or jumping
to---registered data.

+ =consult-register= is what you use for completion.  It searches through
  the contents of the registered compartments and, thus, works well when
  you have text-heavy registers that you need to filter through before
  inserting one at point.

+ =consult-register-store= will save a "thing" to the specified key.  What
  the thing is depends on the context:

  + If the region is active, it will operate on the affected text.
  + If you call it with a numeric argument, it will store that number.
  + If no region is active and no numeric prefix is supplied, it will
    let you select between the current position (point), window
    configuration (window), set of frames with their window
    configurations (frameset), or keyboard macro (kmacro).

  This do-what-I-mean facility is complemented by an actions' menu that
  offers hints on the keys you can use to specify the desired step
  forward.  For example, if you are operating on a region, =M-a= will let
  you append the text to the given register.

+ =consult-register-load= simplifies the mental workload of actually using
  a register.  Unlike the Emacs default where you need to know in
  advance what type of data does the register holds in order to use the
  right action for it, Consult's version just handles that for you.  All
  you have to do is instruct it to use the given register and it will
  know whether it should insert some text or jump to a point/frameset,
  etc.

In practice, I only ever use =consult-register= because I have already
developed muscle memory for the register-related actions.  Though using
all three of the above is easier to learn and more consistent overall.

*** code
#+begin_src emacs-lisp
;;; Enhanced minibuffer commands (consult.el)
(use-package! consult
  :config
  (setq consult-line-numbers-widen t)
  ;; (setq completion-in-region-function #'consult-completion-in-region)
  (setq consult-async-min-input 3)
  (setq consult-async-input-debounce 0.5)
  (setq consult-async-input-throttle 0.8)
  (setq consult-narrow-key ">")
  (setq consult-imenu-config
        '((emacs-lisp-mode :toplevel "Functions"
                           :types ((?f "Functions" font-lock-function-name-face)
                                   (?m "Macros"    font-lock-keyword-face)
                                   (?p "Packages"  font-lock-constant-face)
                                   (?t "Types"     font-lock-type-face)
                                   (?v "Variables" font-lock-variable-name-face)))))
  ;; Search C-h f for more "bookmark jump" handlers.
  (setq consult-bookmark-narrow
        `((?d "Docview" ,#'doc-view-bookmark-jump)
          (?e "Eshell" ,#'eshell-bookmark-jump)
          (?f "File" ,#'bookmark-default-handler)
          (?h "Help" ,#'help-bookmark-jump)
          (?i "Info" ,#'Info-bookmark-jump)
          (?m "Man" ,#'Man-bookmark-jump)
          ;; (?p "PDF" ,#'pdf-view-bookmark-jump)
          (?v "VC Dir" ,#'vc-dir-bookmark-jump)
          (?w "EWW" ,#'prot-eww-bookmark-jump)))
  (setq register-preview-delay 0.8
        register-preview-function #'consult-register-format)
  (setq consult-find-args "find . -not ( -wholename */.* -prune )")
  (setq consult-preview-key 'any)

  (add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)

  (require 'consult-imenu) ; the `imenu' extension is in its own file

  (let ((map global-map))
    ;; (define-key map (kbd "C-x M-m") #'consult-minor-mode-menu)
    (define-key map [remap goto-line] #'consult-goto-line)
    (define-key map (kbd "M-s M-s") #'consult-outline))
  (define-key consult-narrow-map (kbd "?") #'consult-narrow-help)

  ;; see my `pulsar' package, which is declared further above:
  ;; <https://protesilaos.com/emacs/pulsar>
  (setq consult-after-jump-hook nil) ; reset it to avoid conflicts with my function
  (dolist (fn '(pulsar-recenter-top pulsar-reveal-entry))
    (add-hook 'consult-after-jump-hook fn)))
#+end_src

#+RESULTS:
: t

*** consult keybinds
#+begin_src emacs-lisp

  (use-package! org
    :defer
    :bind (:map org-mode-map
                ;; ("C-c C-j" . consult-org-heading)
                ("M-s M-j" . consult-org-heading))

  :bind (("C-x b"   . consult-buffer)
         ("C-x C-r" . consult-recent-file)
         ("C-x M-k" . consult-kmacro)
         ("C-x M-r" . consult-complex-command);;M-:
         ("M-s M-o" . consult-multi-occur)
         ;; ("M-X" . consult-mode-command);;C-c m
         ("C-c m" . consult-mode-command);;C-c m
         ;; ("C-h C-m" . consult-minor-mode-menu)
         ("C-h h" . consult-minor-mode-menu)
         ("M-s M-l" . consult-line)
         ("M-s l"   . consult-line-symbol-at-point)
         ("M-s f"   . consult-fd)
         ("M-R"   . consult-keep-lines)
         ("M-F"   . consult-focus-lines)
         ("M-s M-f"   . consult-find)
         ("M-s M-l" . consult-locate)
         ("M-s g"   . consult-ripgrep)
         ("M-s M-g"   . consult-grep)
         ("M-s G"   . consult-git-grep)
         ("M-s M-h"   . consult-history)
         ("M-g i"   . consult-imenu)
         ("M-g m"   . consult-mark)
         ("M-y"   . consult-yank-pop) ;; M-s M-y
         ("M-g M"   . consult-global-mark)
         ("<help> a" . consult-apropos)
         ("M-s i" . consult-imenu-all)
         ("M-g e" . consult-compile-error)
         ("M-M" . consult-register-store)
         ;; ("C-x r r" . consult-register) ;;spc r r
         ("M-s k l" . consult-focus-lines)
         ("M-'" . consult-register-load)
         :map ctl-x-r-map
         ("b" . consult-bookmark) ; C-c b
         ("X" . consult-register);;C-M-#
         :map ctl-x-4-map
         ("b" . consult-buffer-other-window)
         :map ctl-x-5-map
         ("b" . consult-buffer-other-frame)
         :map tab-prefix-map
         ("b" . consult-buffer-other-tab)))

#+end_src

#+RESULTS:
: consult-buffer-other-tab

** DONE Marginalia
CLOSED: [2022-10-14 Fri 23:30]
- State "DONE"       from              [2022-10-14 Fri 23:30]
#+begin_quote
Part of the =:completion vertico= module.
#+end_quote

Marginalia is nice, but the file metadata annotations are a little too plain.
Specifically, I have these gripes
+ File attributes would be nicer if coloured
+ I don't care about the user/group information if the user/group is me
+ When a file time is recent, a relative age (e.g. =2h ago=) is more useful than
  the date
+ An indication of file fatness would be nice

Thanks to the ~marginalia-annotator-registry~, we don't have to advise, we can
just add a new =file= annotator.

Another small thing is the face used for docstrings. At the moment it's =(italic
shadow)=, but I don't like that.

#+begin_src emacs-lisp :tangle yes
(after! marginalia

  ;; (add-to-list 'marginalia-prompt-categories '("\\burl\\b" . url))
  ;; (setq marginalia-max-relative-age 0)  ; time is absolute here!
  ;; (setq marginalia-annotators
  ;;       '(marginalia-annotators-heavy marginalia-annotators-light))

  (setq marginalia-censor-variables nil)

  (defadvice! +marginalia--anotate-local-file-colorful (cand)
    "Just a more colourful version of `marginalia--anotate-local-file'."
    :override #'marginalia--annotate-local-file
    (when-let (attrs (file-attributes (substitute-in-file-name
                                       (marginalia--full-candidate cand))
                                      'integer))
      (marginalia--fields
       ((marginalia--file-owner attrs)
        :width 12 :face 'marginalia-file-owner)
       ((marginalia--file-modes attrs))
       ((+marginalia-file-size-colorful (file-attribute-size attrs))
        :width 7)
       ((+marginalia--time-colorful (file-attribute-modification-time attrs))
        :width 12))))

  (defun +marginalia--time-colorful (time)
    (let* ((seconds (float-time (time-subtract (current-time) time)))
           (color (doom-blend
                   (face-attribute 'marginalia-date :foreground nil t)
                   (face-attribute 'marginalia-documentation :foreground nil t)
                   (/ 1.0 (log (+ 3 (/ (+ 1 seconds) 345600.0)))))))
      ;; 1 - log(3 + 1/(days + 1)) % grey
      (propertize (marginalia--time time) 'face (list :foreground color))))

  (defun +marginalia-file-size-colorful (size)
    (let* ((size-index (/ (log10 (+ 1 size)) 7.0))
           (color (if (< size-index 10000000) ; 10m
                      (doom-blend 'orange 'green size-index)
                    (doom-blend 'red 'orange (- size-index 1)))))
      (propertize (file-size-human-readable size) 'face (list :foreground color)))))
#+end_src

#+RESULTS:
: +marginalia-file-size-colorful

** Embark
*** desc

Video introduction: [[https://protesilaos.com/codelog/2021-01-09-emacs-embark-extras/][Embark and my extras]] (2021-01-09).  Also read
[[https://karthinks.com/software/fifteen-ways-to-use-embark/][Fifteen ways to use Embark]] (2021-10-06) by Karthik Chikmagalur.

[ NOTE 2021-04-02: the part in that video that deals with cycling
  through the completion candidates has been moved to the file
  =prot-minibuffer.el=, though the effect is practically the same.  UPDATE
  2021-10-22: It now is its own standalone package, called
  =mct.el=---[[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]. ]

Embark provides a unified framework of regular Emacs keymaps which let
you carry out /contextually relevant actions/ on *targets* through a common
*point of entry*, typically a /prefix key/.

+ "Actions" are standard Emacs commands, such as =describe-symbol= or some
  interactive command you have defined that reads an argument from the
  minibuffer.

+ "Targets" are semantically sensitive constructs, such as the symbol at
  point, a URL, a file name, the active region, or the current
  completion candidate in the minibuffer (or the completions'
  buffer---more on that in the next section).  Embark has mechanisms
  which help it determine the category that the target belongs to.

+ The "contextually relevant [actions]" are defined in keymaps whose
  scope matches the category of the target.  So =embark-file-map= holds
  all key and command associations for when Embark recognises a file
  name as its target.  =embark-region-map= is for actions pertaining to
  the active region; =embark-buffer-map= for buffer names that you access
  through, say, =switch-to-buffer= (=C-x b=).  And so on.

+ As for the "point of entry" or "prefix key", it is an Embark command,
  such as =embark-act= or =embark-become=.  Those activate the appropriate
  keymap, thus granting you access to the relevant commands.

Embark can act on individual targets (e.g. the region) or sets of
targets (e.g. the list of minibuffer completion candidates).

Emacs users are already familiar with this contextuality of Embark, even
though they may not realise it.  Think, for example, that hitting the =j=
key in an =org-mode= buffer performs the action of inserting that letter
in the buffer: you type something.  While the same =j= key performs a
different action in, say, a =dired-mode= buffer.  There is no conflict
between those actions because each of them is bound to a distinct
keymap, and only one of those keymaps applies in their respective
context.

The beauty of Embark's design is that you configure its contextuality in
the exact same way you define all of your Emacs key bindings.  So you
can bind any command to whatever key you want and confine that action to
a context you specify.

On Emacs 28, learn more about the keymaps with =M-x describe-keymap= and
then search for =embark=.

Now a few things about actions that you can gain access to by invoking
either of =embark-act= (most cases), or =embark-become= (where appropriate):

+ Embark has two ways to help you learn about its actions, though you
  will probably only ever need one of them.  The first one, which is the
  default, is to display a detailed buffer when the variable
  =embark-indicators= includes the symbol =embark-mixed-indicator= or
  =embark-verbose-indicator=.  Either of those will produce a buffer that
  shows the available actions, the keys they are bound to, and a
  description of what each action does.  The other method, which is only
  really useful if =embark-indicator= is set to =embark-minimal-indicator=
  is to follow up the =embark-act= with =C-h=.  That will produce a
  minibuffer prompt showing all available key bindings.

  - Keymaps aside, you can call /any command/ after invoking =embark-act=.
    This can be either with =M-x= or via its key binding.  For example, if
    you want to grep for the symbol at point in the current project, you
    can do =embark-act= and then =C-x p g= (=project-find-regexp=) (also read
    [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  This will, of course,
    work as expected for commands that typically prompt you for
    something to operate on.

  - Using the =C-h= as a suffix is a standard procedure in Emacs to get a
    Help buffer that contains references to all commands+keys that
    extend a give key chord.  So, for example, =C-x r C-h= will show you
    all commands under the =C-x r= prefix (see [[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]]).
    While the generic =C-h= is fine in its own right, Embark offers an
    alternative that leverages minibuffer completion: the
    =embark-prefix-help-command=.  You can either select an action from
    there or type =@= and the corresponding key.

+ You will often be targeting individual items, such as the current
  completion candidate in the minibuffer, or the symbol at point.  You
  can, however, collect the entire set of targets and store it in a
  buffer, which you can then re-use at your convenience or save it on
  disk (with =write-file= bound to =C-x C-w= by default).  This is done by
  the =embark-collect-snapshot= command, which you can always access
  through =embark-act=.

  - The "Embark Collect" buffer can be presented as a grid or a list,
    with the possibility to manually switch between the two by means of
    the =embark-collect-toggle-view= command.  The list view offers more
    room to the side of each candidate.  It can be used to display
    annotations (see [[#h:09d657c7-eb4d-4fe3-987a-4a2cf419bb40][Completion annotations (marginalia)]]), such as the
    first line of a variable's doc string and current value, a command's
    key binding, the buffer's underlying file system path if it is
    visiting a file, and so on.

  - Embark's "collect" buffer also has a live-updating version, which
    can be use to filter the list of targets.  This particular feature
    can, in fact, be used as a medium for visualising the list of
    candidates in the active minibuffer session.  I used that setup for
    several months together with the default minibuffer as part my
    bespoke completion framework, though as of 2021-04-02 I handle the
    live-updating completions' buffer independently of Embark
    ([[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

  - Other than producing a snapshot, Embark can also collect the targets
    and present them in a buffer whose major-mode is specialised to work
    on the category those targets belong to.  This is done with the
    =embark-export= command.  If you are targeting files, then the export
    takes you to a =dired-mode= buffer (also refer to this document's
    section on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]); buffers go to
    =ibuffer-mode= (check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][Ibuffer and extras]]); grep results in a =grep-mode=
    buffer, and so on.

Finally, the =prot-embark.el= that is reproduced after the following block
contains a few keymaps that integrate Embark with packages like =consult=
([[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).  The =embark-consult= package
provides glue code that allows Embark to produce a correct export buffer
while using relevant Consult commands, such as =consult-grep=.

*** code
#+begin_src emacs-lisp :tangle no
;;; Extended minibuffer actions and more (embark.el and prot-embark.el)
(use-package! embark
  :config
  (setq prefix-help-command #'embark-prefix-help-command)
  ;; (setq prefix-help-command #'describe-prefix-bindings) ; the default of the above
  (setq embark-collect-initial-view-alist '((t . list)))
  (setq embark-quit-after-action t)     ; XXX: Read the doc string!
  (setq embark-cycle-key (kbd "C-."))   ; see the `embark-act' key
  (setq embark-collect-live-update-delay 0.5)
  (setq embark-collect-live-initial-delay 0.8)
  (setq embark-indicators
        '(embark-mixed-indicator
          embark-highlight-indicator))
  ;; NOTE 2021-07-31: The mixed indicator starts out with a minimal view
  ;; and then pops up the verbose buffer, so those variables matter.
  (setq embark-verbose-indicator-excluded-actions
        '("\\`embark-collect-" "\\`customize-" "\\(local\\|global\\)-set-key"
          set-variable embark-cycle embark-export
          embark-keymap-help embark-become embark-isearch))
  (setq embark-verbose-indicator-buffer-sections
        `(target "\n" shadowed-targets " " cycle "\n" bindings))
  (setq embark-mixed-indicator-both nil)
  (setq embark-mixed-indicator-delay 1.2)
  ;;  NOTE 2021-07-28: This is used when `embark-indicator' is set to
  ;;  `embark-mixed-indicator' or `embark-verbose-indicator'.  We can
  ;;  specify the window parameters here, but I prefer to do that in my
  ;;  `display-buffer-alist' (search this document) because it is easier
  ;;  to keep track of all my rules in one place.
  (setq embark-verbose-indicator-display-action nil)

  (define-key global-map (kbd "C-,") #'embark-act)
  (let ((map minibuffer-local-completion-map))
    (define-key map (kbd "C-,") #'embark-act)
    (define-key map (kbd "C->") #'embark-become)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view)) ; parallel of `fill-paragraph'
  (let ((map embark-collect-mode-map))
    (define-key map (kbd "C-,") #'embark-act)
    (define-key map (kbd "M-q") #'embark-collect-toggle-view))
  (let ((map embark-region-map))
    (define-key map (kbd "a") #'align-regexp)
    (define-key map (kbd "i") #'epa-import-keys-region)
    (define-key map (kbd "r") #'repunctuate-sentences) ; overrides `rot13-region'
    (define-key map (kbd "s") #'sort-lines)
    (define-key map (kbd "u") #'untabify))
  (let ((map embark-symbol-map))
    (define-key map (kbd ".") #'embark-find-definition)
    (define-key map (kbd "k") #'describe-keymap)))

;; Needed for correct exporting while using Embark with Consult
;; commands.
(prot-emacs-elpa-package 'embark-consult)

(prot-emacs-builtin-package 'prot-embark
  (prot-embark-keymaps 1)
  (prot-embark-setup-packages 1))
#+end_src

** Minibuffer history (savehist-mode)

The built-in =savehist-mode= keeps a record of actions involving the
minibuffer.  You can access previous inputs with =M-p= and =M-n=.  Well
designed commands that use completion will have their own history, so
those key bindings will only cycle through relevant results.  You can
also search backwardly through them with =M-r=.

This kind of functionality is of paramount importance to a fast and
efficient workflow involving any completion framework that leverages the
built-in mechanisms.

Emacs will remember your input and choices so it will prioritise the
desired results when trying to force complete a given input.  Make sure
to also read the [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]] for
the minibuffer-specific setup.

#+begin_src emacs-lisp
;;; Minibuffer history (savehist-mode)
(use-package! savehist
  :config
  (setq savehist-file (locate-user-emacs-file "savehist"))
  (setq history-length 10000)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history t)
  (add-hook 'after-init-hook #'savehist-mode))
#+end_src

#+RESULTS:
: t

** CAPE (extra completion-at-point backends)

The =cape= package, by Daniel Mendler (developer of Consult, Vertico,
Corfu, ...), adds more backends to the =completion-at-point-functions=
(CAPF) facility.  This practically means that you can use in-buffer
completion in more scenaria and with relevant candidates.

A package such as Daniel's own Corfu is used to visualise in-buffer
completion.

#+begin_src emacs-lisp :tangle no
;;; CAPE (extra completion-at-point backends)
(use-package! cape
  :config
  (setq cape-dabbrev-min-length 3)
  (dolist (backend '( cape-symbol cape-keyword cape-file cape-dabbrev))
  ;; (dolist (backend '( cape-keyword cape-file cape-dict cape-history cape-symbol cape-abbrev))
    (add-to-list 'completion-at-point-functions backend)))

#+end_src

** IVY
Ivy is a generic completion mechanism for Emacs.
*** IVY-POSFRAME
Ivy-posframe is an ivy extension, which lets ivy use posframe to show its candidate menu.  Some of the settings below involve:
+ ivy-posframe-display-functions-alist -- sets the display position for specific programs
+ ivy-posframe-height-alist -- sets the height of the list displayed for specific programs

Available functions (positions) for 'ivy-posframe-display-functions-alist'
+ ivy-posframe-display-at-frame-center
+ ivy-posframe-display-at-window-center
+ ivy-posframe-display-at-frame-bottom-left
+ ivy-posframe-display-at-window-bottom-left
+ ivy-posframe-display-at-frame-bottom-window-center
+ ivy-posframe-display-at-point
+ ivy-posframe-display-at-frame-top-center

=NOTE:= If the setting for 'ivy-posframe-display' is set to 'nil' (false), anything that is set to 'ivy-display-function-fallback' will just default to their normal position in Doom Emacs (usually a bottom split).  However, if this is set to 't' (true), then the fallback position will be centered in the window.

#+BEGIN_SRC emacs-lisp :tangle no

(ivy-posframe-mode 1) ; 1 enables posframe-mode, 0 disables it.
(setq ivy-posframe-display-functions-alist
      '((swiper                     . ivy-posframe-display-at-point)
        (complete-symbol            . ivy-posframe-display-at-point)
        (counsel-M-x                . ivy-display-function-fallback)
        (counsel-esh-history        . ivy-posframe-display-at-window-center)
        (counsel-describe-function  . ivy-display-function-fallback)
        (counsel-describe-variable  . ivy-display-function-fallback)
        (counsel-find-file          . ivy-posframe-display-at-window-center)
        (counsel-recentf            . ivy-display-function-fallback)
        (counsel-register           . ivy-posframe-display-at-frame-bottom-window-center)
        (dmenu                      . ivy-posframe-display-at-frame-top-center)
        (nil                        . ivy-posframe-display))
      ivy-posframe-height-alist
      '((swiper . 20)
        (dmenu . 20)
        (t . 10)))

(use-package! ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (ivy-mode 1))

(use-package! ivy-rich
  :after ivy
  :init
  (ivy-rich-mode 1))

(use-package! counsel
  :bind (("s-a" . 'counsel-switch-buffer)
         :map minibuffer-local-map
         :map minibuffer-local-map
         ("C-c r" . 'counsel-minibuffer-history))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (counsel-mode 1))
#+END_SRC

#+RESULTS:
: counsel-minibuffer-history

*** IVY
#+begin_src emacs-lisp :tangle no
;;; Auto completion
;;;; Ivy-Counsel-Swiper
(use-package! all-the-icons-ivy
  :init (add-hook 'after-init-hook 'all-the-icons-ivy-setup)
  :config
  (add-to-list 'all-the-icons-mode-icon-alist
               '('puppet-mode all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-extension-icon-alist
               '("pp" all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-yellow))
  (add-to-list 'all-the-icons-extension-icon-alist
               '("epp" all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-blue))
  (add-to-list 'all-the-icons-extension-icon-alist
               '("erb" all-the-icons-fileicon "api-blueprint"
                 :face all-the-icons-orange))
  ;; Pending https://github.com/domtronn/all-the-icons.el/pull/267
  (add-to-list 'all-the-icons-mode-icon-alist
               '(exwm-mode
                 all-the-icons-octicon "browser"
                 :v-adjust 0.2 :face all-the-icons-purple)))

;;               ([C-return] . ivy-restrict-to-matches))
(use-package! ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ;; ([C-return] . ivy-restrict-to-matches)
         ("C-d" . ivy-reverse-i-search-kill))
  :config
  (defun my/ivy-switch-buffer-by-prefix (prefix)
    "Use ivy to select a buffer prefixed by PREFIX#."
    (minibuffer-with-setup-hook
        (lambda ()
          (insert (concat "^" prefix "# ")))
      (ivy-switch-buffer)))
  (defun my/ivy-switch-buffer-firefox ()
    "Use ivy to select a Firefox window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "F"))
  (defun my/ivy-switch-buffer-urxvt ()
    "Use ivy to select an URXVT window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "u"))
  (defun my/ivy-switch-buffer-detached-command ()
    "Use ivy to select a compilation buffer."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "d"))
  (setcdr (assoc t ivy-format-functions-alist) #'ivy-format-function-line)
  (ivy-mode 1)
  :custom
  (ivy-use-virtual-buffers 'recentf)
  (ivy-virtual-abbreviate 'abbreviate)
  (ivy-use-selectable-prompt t)
  (ivy-re-builders-alist '((t . ivy--regex-ignore-order))))

(use-package! ivy-posframe
  :config
  (ivy-posframe-mode 1)
  (defun my/ivy-posframe-get-size ()
    (let ((height (or ivy-posframe-height ivy-height))
          (width (round (* .70 (frame-width)))))
      (list :height height :width width :min-height height :min-width width)))
  :custom
  (posframe-mouse-banish-function #'posframe-mouse-banish-simple)
  (ivy-posframe-display-functions-alist
   '((swiper . ivy-display-function-fallback)
     (t      . ivy-posframe-display)))
  (ivy-posframe-height-alist '((counsel-yank-pop . 40)
                               (t                . 20)))
  (ivy-posframe-size-function 'my/ivy-posframe-get-size))

(use-package! all-the-icons-ivy-rich
  :init (all-the-icons-ivy-rich-mode 1))

(use-package! ivy-rich
  :after (ivy counsel)
  :config
  (ivy-rich-mode 1)
  (ivy-rich-project-root-cache-mode)
  (ivy-rich-set-columns
   'counsel-find-file
   '((all-the-icons-ivy-rich-file-icon)
     (ivy-read-file-transformer)))
  (ivy-rich-set-columns
   'counsel-fzf
   '((all-the-icons-ivy-rich-file-icon)
     (all-the-icons-ivy-rich-file-name)))
  (ivy-rich-modify-columns
   'ivy-switch-buffer
   '((ivy-rich-switch-buffer-project (:width 30))
     (ivy-rich-switch-buffer-major-mode (:width 20)))))

(use-package! amx
  :after (ivy)
  :custom
  (amx-backend 'ivy)
  (amx-history-length 50))

(use-package! counsel
  ;; :after (helpful)
  :bind (("M-x" . counsel-M-x)
         ("s-a" . counsel-switch-buffer)
         ;; ("C-SPC" . counsel-M-x)
         ;; ("s-@" . consult-buffer)
         ("s-@" . ivy-switch-buffer)
         ("M-b" . ivy-switch-buffer-other-window)
         ("C-x f" . my/counsel-find-file-no-tramp)
         ("C-x F" . counsel-find-file)
         ("C-h v" . counsel-describe-variable)
         ("C-h f" . counsel-describe-function)
         ("C-h k" . helpful-key)
         ("C-x r b" . counsel-bookmark)
         ("M-y" . counsel-yank-pop))
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (defun my/counsel-find-file-no-tramp (&optional initial-input initial-directory)
    (interactive)
    (if (string-prefix-p "/ssh:" default-directory)
        (counsel-find-file "" "~/")
      (counsel-find-file initial-input initial-directory)))
  ;; Pending https://github.com/abo-abo/swiper/pull/2844/
  (defun counsel--esh-dir-history-action-cd (pair)
    "Change the current working directory to the selection.
This function is the default action for `counsel-esh-dir-history'
and changes the working directory in Eshell to the selected
candidate which must be provided as the `car' of PAIR."
    (eshell/cd (car pair)))
  (defun counsel--esh-dir-history-action-edit (pair)
    "Insert the selection to the Eshell buffer prefixed by \"cd \".
This function is an action for `counsel-esh-dir-history' to
insert the selected directory (provided as the `car' of PAIR) to
the Eshell buffer prefixed by \"cd \", allowing the caller to
modify parts of the directory before switching to it."
    (insert (format "cd %s" (car pair))))
  (defun counsel-esh-dir-history ()
    "Use Ivy to browse Eshell's directory stack."
    (interactive)
    (require 'em-dirs)
    (defvar eshell-last-dir-ring)
    (ivy-read "Directory to change to: " (ivy-history-contents eshell-last-dir-ring)
              :keymap ivy-reverse-i-search-map
              :action #'counsel--esh-dir-history-action-cd
              :caller #'counsel-esh-dir-history))
  (ivy-set-actions
   'counsel-esh-dir-history
   '(("e" counsel--esh-dir-history-action-edit "edit")))
  (defun counsel-fzf-action (x)
    (with-ivy-window
      (let ((default-directory counsel--fzf-dir))
        (find-file-other-window x)))
    (other-window -1))
  :custom
  (counsel-yank-pop-separator "\n-------------------\n")
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
(use-package! swiper
  :bind (("s-s" . swiper)
         ("s-C-s" . swiper-thing-at-point)))


#+end_src

#+RESULTS:
: swiper-thing-at-point

*** IVY push and switch view
By default, Doom Emacs does not use 'SPC v', so the format I use for these bindings is 'SPC v' plus 'key'.

#+BEGIN_SRC emacs-lisp :tangle no
(map! :leader
      (:prefix ("v" . "Ivy")
       :desc "Ivy push view" "v p" #'ivy-push-view
       :desc "Ivy switch view" "v s" #'ivy-switch-view))



#+END_SRC

#+RESULTS:
: ivy-switch-view

*** Davivil ivy mode
#+begin_src emacs-lisp :tangle yes
;; Better Completions with Ivy
;; I currently use Ivy, Counsel, and Swiper to navigate around files, buffers, and projects super quickly. Here are some workflow notes on how to best use Ivy:

;; While in an Ivy minibuffer, you can search within the current results by using S-Space.
;; To quickly jump to an item in the minibuffer, use C-' to get Avy line jump keys.
;; To see actions for the selected minibuffer item, use M-o and then press the action's key.
;; Super useful: Use C-c C-o to open ivy-occur to open the search results in a separate buffer. From there you can click any item to perform the ivy action.

(use-package! ivy
  :diminish
  :bind (("C-s" . isearch-forward)
         :map ivy-minibuffer-map
         ("TAB" . ivy-alt-done)
         ("C-f" . ivy-alt-done)
         ("C-l" . ivy-alt-done)
         ("C-j" . ivy-next-line)
         ("C-k" . ivy-previous-line)
         :map ivy-switch-buffer-map
         ("C-k" . ivy-previous-line)
         ("C-l" . ivy-done)
         ("C-d" . ivy-switch-buffer-kill)
         :map ivy-reverse-i-search-map
         ("C-k" . ivy-previous-line)
         ("C-r" . ivy-reverse-i-search-kill))
  ;; :init
  ;; (ivy-mode 1)
  :config
  (defun my/ivy-switch-buffer-by-prefix (prefix)
    "Use ivy to select a buffer prefixed by PREFIX#."
    (minibuffer-with-setup-hook
        (lambda ()
          (insert (concat "^" prefix "# ")))
      (ivy-switch-buffer)))
  (defun my/ivy-switch-buffer-firefox ()
    "Use ivy to select a Firefox window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "f")) ;; use F for case sensitive matching with buffer name
  (defun my/ivy-switch-buffer-urxvt ()
    "Use ivy to select an URXVT window (buffer)."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "u"))
  (defun my/ivy-switch-buffer-detached-command ()
    "Use ivy to select a compilation buffer."
    (interactive)
    (my/ivy-switch-buffer-by-prefix "d")))
(use-package! counsel
  :demand t
  :custom
  (counsel-linux-app-format-function #'counsel-linux-app-format-function-name-only)
  :config
  (setq ivy-initial-inputs-alist nil) ;; Don't start searches with ^

  (defun my/counsel-find-file-no-tramp (&optional initial-input initial-directory)
    (interactive)
    (if (string-prefix-p "/ssh:" default-directory)
        (counsel-find-file "" "~/")
      (counsel-find-file initial-input initial-directory)))
  ;; Pending https://github.com/abo-abo/swiper/pull/2844/
  (defun counsel--esh-dir-history-action-cd (pair)
    "Change the current working directory to the selection.
This function is the default action for `counsel-esh-dir-history'
and changes the working directory in Eshell to the selected
candidate which must be provided as the `car' of PAIR."
    (eshell/cd (car pair)))
  (defun counsel--esh-dir-history-action-edit (pair)
    "Insert the selection to the Eshell buffer prefixed by \"cd \".
This function is an action for `counsel-esh-dir-history' to
insert the selected directory (provided as the `car' of PAIR) to
the Eshell buffer prefixed by \"cd \", allowing the caller to
modify parts of the directory before switching to it."
    (insert (format "cd %s" (car pair))))
  (defun counsel-esh-dir-history ()
    "Use Ivy to browse Eshell's directory stack."
    (interactive)
    (require 'em-dirs)
    (defvar eshell-last-dir-ring)
    (ivy-read "Directory to change to: " (ivy-history-contents eshell-last-dir-ring)
              :keymap ivy-reverse-i-search-map
              :action #'counsel--esh-dir-history-action-cd
              :caller #'counsel-esh-dir-history))
  (ivy-set-actions
   'counsel-esh-dir-history
   '(("e" counsel--esh-dir-history-action-edit "edit")))
  (defun counsel-fzf-action (x)
    (with-ivy-window
      (let ((default-directory counsel--fzf-dir))
        (find-file-other-window x)))
    (other-window -1))
  :custom
  (counsel-yank-pop-separator "\n-------------------\n")
  (counsel-describe-function-function #'helpful-callable)
  (counsel-describe-variable-function #'helpful-variable))
(use-package! swiper
  :bind (("C-s" . isearch-forward)
         ("C-M-s" . swiper-thing-at-point)))
#+end_src

#+RESULTS:
: swiper-thing-at-point

* Buffers
** desc
Doom Emacs uses 'SPC b' for keybindings related to bookmarks and buffers.

=ibuffer.el= ships with Emacs and it provides a drop-in replacement for
=list-buffers=.  Compared to its counterpart, it allows for granular
control over the buffer list and is more powerful overall.  For this
reason I bind it to =C-x C-b=.

Overview of its features:

- mark and delete buffers same way you do in =dired= (see the previous
  sections on [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][dired (directory editor, file manager)]]);
- mark by a predicate, such as name, major mode, etc.;
- sort buffers by name, filesystem path, major mode, size;
- run =occur= on the marked buffers (remember: Occur produces a buffer
  that you can edit once you enable the editable state with =e=);
- run =query-replace= or =query-replace-regexp= on marked buffers.

Run the universal help command for major mode documentation (=C-h m=)
while inside =ibuffer= to get a detailed list of all available commands
and their key bindings.

With regard to the following package configurations, these are my tweaks
to the default behaviour and presentation:

+ Prompt for confirmation only when deleting a modified buffer.
+ Hide the summary.
+ Do not open on the other window; use the current one.
+ Do not show empty filter groups.
+ Do not cycle movements.  So do not go to the top when moving downward
  at the last item on the list.
Regarding /buffers/, the text you are editing in Emacs resides in an object called a /buffer/. Each time you visit a file, a buffer is used to hold the file’s text. Each time you invoke Dired, a buffer is used to hold the directory listing.  /Ibuffer/ is a program that lists all of your Emacs /buffers/, allowing you to navigate between them and filter them.

| COMMAND         | DESCRIPTION          | KEYBINDING |
|-----------------+----------------------+------------|
| ibuffer         | Launch ibuffer       | SPC b i    |
| kill-buffer     | Kill current buffer  | SPC b k    |
| next-buffer     | Goto next buffer     | SPC b n    |
| previous-buffer | Goto previous buffer | SPC b p    |
| save-buffer     | Save current buffer  | SPC b s    |

** Keybindings within ibuffer mode

| COMMAND                           | DESCRIPTION                            | KEYBINDING |
|-----------------------------------+----------------------------------------+------------|
| ibuffer-mark-forward              | Mark the buffer                        | m          |
| ibuffer-unmark-forward            | Unmark the buffer                      | u          |
| ibuffer-do-kill-on-deletion-marks | Kill the marked buffers                | x          |
| ibuffer-filter-by-content         | Ibuffer filter by content              | f c        |
| ibuffer-filter-by-directory       | Ibuffer filter by directory            | f d        |
| ibuffer-filter-by-filename        | Ibuffer filter by filename (full path) | f f        |
| ibuffer-filter-by-mode            | Ibuffer filter by mode                 | f m        |
| ibuffer-filter-by-name            | Ibuffer filter by name                 | f n        |
| ibuffer-filter-disable            | Disable ibuffer filter                 | f x        |
| ibuffer-do-kill-lines             | Hide marked buffers                    | g h        |
| ibuffer-update                    | Restore hidden buffers                 | g H        |

#+begin_src emacs-lisp

(use-package! ibuffer
  :config
  (setq ibuffer-expert t)
  (setq ibuffer-display-summary nil)
  (setq ibuffer-use-other-window nil)
  (setq ibuffer-show-empty-filter-groups nil)
  (setq ibuffer-movement-cycle nil)
  (setq ibuffer-default-sorting-mode 'filename/process)
  (setq ibuffer-use-header-line t)
  (setq ibuffer-default-shrink-to-minimum-size nil)
  (setq ibuffer-formats
        '((mark modified read-only locked " "
                (name 40 40 :left :elide)
                " "
                (size 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " " filename-and-process)
          (mark " "
                (name 16 -1)
                " " filename)))
  (setq ibuffer-saved-filter-groups nil)
  (setq ibuffer-old-time 48)
  (add-hook 'ibuffer-mode-hook #'hl-line-mode)
  (define-key global-map (kbd "C-x C-b") #'ibuffer)
(evil-define-key 'normal ibuffer-mode-map
  (kbd "f c") 'ibuffer-filter-by-content
  (kbd "f d") 'ibuffer-filter-by-directory
  (kbd "f f") 'ibuffer-filter-by-filename
  (kbd "f m") 'ibuffer-filter-by-mode
  (kbd "f n") 'ibuffer-filter-by-name
  (kbd "f x") 'ibuffer-filter-disable
  (kbd "g h") 'ibuffer-do-kill-lines
  (kbd "g H") 'ibuffer-update))
#+end_src

#+RESULTS:
: t

** DONE Helper functions to clean up the gazillion buffers
CLOSED: [2022-04-15 Fri 14:04]

When switching projects in Emacs, it can be prudent to clean up every
once in a while. Deleting all buffers except the current one is one of
the things I often do (especially in the long-running =emacsclient=).

#+BEGIN_SRC emacs-lisp
  (defun kill-other-buffers ()
    "Kill all other buffers."
    (interactive)
    (mapc 'kill-buffer (delq (current-buffer) (buffer-list))))
#+END_SRC

#+RESULTS:
: kill-other-buffers

=dired= will create buffers for every visited folder. This is a helper
to clear them out once you're done working with those folders.

#+BEGIN_SRC emacs-lisp

  (defun kill-dired-buffers ()
    "Kill all open dired buffers."
    (interactive)
    (mapc (lambda (buffer)
            (when (eq 'dired-mode (buffer-local-value 'major-mode buffer))
              (kill-buffer buffer)))
          (buffer-list)))
#+END_SRC

#+RESULTS:
: kill-dired-buffers

** PERSPECTIVE
Perspective provides multiple named workspaces (or "perspectives") in Emacs, similar to having multiple desktops in window managers like Awesome and XMonad.  Each perspective has its own buffer list and its own window layout, making it easy to work on many separate projects without getting lost in all the buffers.  Switching to a perspective activates its window configuration, and when in a perspective, only its buffers are available (by default).  Doom Emacs uses 'SPC some_key' for binding some of the perspective commands, so I used this binging format for the perspective bindings that I created..

| COMMAND                    | DESCRIPTION                         | KEYBINDING |
|----------------------------+-------------------------------------+------------|
| persp-switch               | Switch to perspective NAME          | SPC DEL    |
| persp-switch-to-buffer     | Switch to buffer in perspective     | SPC ,      |
| persp-next                 | Switch to next perspective          | SPC ]      |
| persp-prev                 | Switch to previous perspective      | SPC [      |
| persp-add-buffer           | Add a buffer to current perspective | SPC +      |
| persp-remove-by-name       | Remove perspective by name          | SPC -      |
| +workspace/switch-to-{0-9} | Switch to workspace /n/               | SPC 0-9    |

#+begin_src emacs-lisp
(map! :leader
      :desc "Switch to perspective NAME" "DEL" #'persp-switch
      :desc "Switch to buffer in perspective" "," #'persp-switch-to-buffer
      :desc "Switch to next perspective" "]" #'persp-next
      :desc "Switch to previous perspective" "[" #'persp-prev
      :desc "Add a buffer current perspective" "+" #'persp-add-buffer
      :desc "Remove perspective by name" "-" #'persp-remove-by-name)
#+end_src

** DONE doom scratch
CLOSED: [2022-04-02 Sat 23:20]
I'd much rather have my new buffers in ~org-mode~ than ~fundamental-mode~, hence
For some reason this + the mixed pitch hook causes issues with hydra and so I'll
just need to resort to =SPC b o= for now.
#+begin_src emacs-lisp
;; (setq-default major-mode 'org-mode)
(setq doom-scratch-initial-major-mode 'lisp-interaction-mode)
#+end_src
** WAIT Working with buffers
*** Keymap for buffers (Emacs28)

Starting with Emacs version 28, there is a keymap that can be accessed
with the =C-x x= sequence.  This new keymap (=ctl-x-x-map=), is meant to be
used for commands that pertain to the current buffer.  What I have here
are just some tweaks to make it work the way I prefer.

#+begin_src emacs-lisp :tangle no
;;; Keymap for buffers (Emacs28)
(let ((map ctl-x-x-map))              ; Emacs 28
  (define-key map "e" #'eval-buffer)
  (define-key map "f" #'follow-mode)  ; override `font-lock-update'
  (define-key map "r" #'rename-uniquely))

(with-eval-after-load 'org
  (define-key ctl-x-x-map "i" #'prot-org-id-headlines)
  (define-key ctl-x-x-map "h" #'prot-org-ox-html))
#+end_src

** DONE Nicer buffer name for buffers with same name uniquify
CLOSED: [2022-04-02 Sat 23:19]
#+BEGIN_SRC emacs-lisp
(use-package! uniquify
  :defer 5
  :config
  (setq uniquify-buffer-name-style 'forward)
  (setq uniquify-strip-common-suffix t)
  (setq uniquify-after-kill-buffer-p t))
  ;; (setq uniquify-ignore-buffers-re "^\\*") ; don't muck with special buffers
  ;; (setq uniquify-separator "/"))

#+END_SRC

#+RESULTS:
: t

* Window management
** DONE SPLITS
CLOSED: [2022-03-30 Wed 13:34]
I set splits to default to opening on the right using 'prefer-horizontal-split'.  I set a keybinding for 'clone-indirect-buffer-other-window' for when I want to have the same document in two splits.  The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other.  But in all other respects, the indirect buffer and its base buffer are completely separate.  For example, I can fold one split but other will be unfolded.

#+BEGIN_SRC emacs-lisp
(defun prefer-horizontal-split ()
  (set-variable 'split-height-threshold nil t)
  (set-variable 'split-width-threshold 40 t)) ; make this as low as needed
(add-hook 'markdown-mode-hook 'prefer-horizontal-split)
(map! :leader
      :desc "Clone indirect buffer other window" "b c" #'clone-indirect-buffer-other-window)
#+END_SRC

#+RESULTS:
: clone-indirect-buffer-other-window

** DONE Rotate (window management)
CLOSED: [2022-04-02 Sat 23:26]
The =rotate= package just adds the ability to rotate window layouts, but that
sounds nice to me.

#+begin_src emacs-lisp :tangle packages.el
(package! rotate :pin "4e9ac3ff800880bd9b705794ef0f7c99d72900a6")
#+end_src

** Tabs
*** CENTAUR-TABS
To use tabs in Doom Emacs, be sure to uncomment "tabs" in Doom's init.el.  Displays tabs at the top of the window similar to tabbed web browsers such as Firefox.  I don't actually use tabs in Emacs.  I placed this in my config to help others who may want tabs.  In the default configuration of Doom Emacs, 'SPC t' is used for "toggle" keybindings, so I choose 'SPC t c' to toggle centaur-tabs.  The "g" prefix for keybindings is used for a bunch of evil keybindings in Doom, but "g" plus the arrow keys were not used, so I thought I would bind those for tab navigation.  But I did leave the default "g t" and "g T" intact if you prefer to use those for centaur-tabs-forward/backward.

We want to make the tabs a nice, comfy size (~24~), with icons. The modifier
marker is nice, but the particular default Unicode one causes a lag spike, so
let's just switch to an ~o~, which still looks decent but doesn't cause any
issues.
An 'active-bar' is nice, so let's have one of those. If we have it ~under~ needs us to
turn on ~x-underline-at-decent~ though. For some reason this didn't seem to work
inside the src_elisp{(after! ... )} block ¯\_(ツ)_/¯.
Then let's change the font to a sans serif, but the default one doesn't fit too
well somehow, so let's switch to 'P22 Underground Book'; it looks much nicer.

| COMMAND                     | DESCRIPTION               | KEYBINDING       |
|-----------------------------+---------------------------+------------------|
| centaur-tabs-mode           | /Toggle tabs globally/      | SPC t c          |
| centaur-tabs-local-mode     | /Toggle tabs local display/ | SPC t C          |
| centaur-tabs-forward        | /Next tab/                  | g <right> or g t |
| centaur-tabs-backward       | /Previous tab/              | g <left> or g T  |
| centaur-tabs-forward-group  | /Next tab group/            | g <down>         |
| centaur-tabs-backward-group | /Previous tab group/        | g <up>           |

#+BEGIN_SRC emacs-lisp :tangle no
(after! centaur-tabs
  (centaur-tabs-mode -1)
(setq centaur-tabs-set-bar 'over
      centaur-tabs-set-icons t
      centaur-tabs-gray-out-icons 'buffer
      centaur-tabs-height 24
      centaur-tabs-set-modified-marker t
        ;; centaur-tabs-modified-marker "o"
        centaur-tabs-close-button "×"
      centaur-tabs-style "bar"
        centaur-tabs-set-bar 'above
      centaur-tabs-modified-marker "•")
  (centaur-tabs-change-fonts "P22 Underground Book" 160))
(map! :leader
      :desc "Toggle tabs globally" "t c" #'centaur-tabs-mode
      :desc "Toggle tabs local display" "t C" #'centaur-tabs-local-mode)
(evil-define-key 'normal centaur-tabs-mode-map (kbd "g <right>") 'centaur-tabs-forward        ; default Doom binding is 'g t'
                                               (kbd "g <left>")  'centaur-tabs-backward       ; default Doom binding is 'g T'
                                               (kbd "g <down>")  'centaur-tabs-forward-group
                                               (kbd "g <up>")    'centaur-tabs-backward-group)
(after! centaur-tabs
  (setq centaur-tabs-style "wave"))

#+END_SRC

#+RESULTS:
: wave

*** tab bar mode davi
#+begin_src emacs-lisp :tangle no
;; Inherit the face of `doom-modeline-panel` for better appearance
(set-face-attribute 'tab-bar-tab nil :inherit 'doom-modeline-panel :foreground nil :background nil)

;; Totally customize the format of the tab bar name
(defun my/tab-bar-format (tab i)
  (propertize
   (format
    (concat
      (if (eq (car tab) 'current-tab)
          "🔥 " "")
      "%s")
    (alist-get 'name tab))
   'face (list (append
                  '(:foreground "#FFFFFF")
                  (if (eq (car tab) 'current-tab)
                      '(:box t)
                      '())))))

;; Replace the default tab bar function
(setq tab-bar-tab-name-format-function #'my/tab-bar-format)

(defun my/tab-bar-tab-name-function ()
  (let ((project (project-current)))
    (if project
        (project-root project)
        (tab-bar-tab-name-current))))

(setq tab-bar-tab-name-function #'my/tab-bar-tab-name-function)

;; Only show the tab bar if there are 2 or more tabs
(setq tab-bar-show 1)

(defun my/tab-bar-string () "HELLO")

;; Customize the tab bar format to add the global mode line string
(setq tab-bar-format '(tab-bar-format-tabs tab-bar-separator tab-bar-format-align-right tab-bar-format-global))

(add-to-list 'global-mode-string "HELLO")

;; Make sure mode line text in the tab bar can be read
(set-face-attribute 'tab-bar nil :foreground "#FFFFFF")

(defun my/project-create-tab ()
  (interactive)
  (tab-bar-new-tab)
  (magit-status))

(setq project-switch-commands #'my/project-create-tab)

(defun my/switch-to-tab-buffer ()
  (interactive)
  (if (project-current)
      (call-interactively #'project-switch-to-buffer)
    (call-interactively #'switch-to-buffer)))

(global-set-key (kbd "C-x b") #'my/switch-to-tab-buffer)

;; Turn on tab bar mode after startup
;; (tab-bar-mode 1)

;; Save the desktop session
(desktop-save-mode 1)

#+end_src

#+RESULTS:
: t

*** tab bar
#+begin_src emacs-lisp :tangle no

;;;----------------------------------------------------------------
;; ** TABS!TABS!TABS!
;; *** TAB-BAR
;;;----------------------------------------------------------------
(use-package! tab-bar
  :if (not (version-list-<
            (version-to-list emacs-version)
            '(27 0 1 0)))
  :after cus-face
  :defer
  :bind-keymap ("H-t" . tab-prefix-map)
  :bind
  (("C-M-<tab>" . tab-bar-switch-to-next-tab)
   ("C-M-<iso-lefttab>" . tab-bar-switch-to-prev-tab)
   ("H-<tab>" . tab-bar-switch-to-next-tab)
   ("H-<iso-lefttab>" . tab-bar-switch-to-prev-tab)
   ("s-u" . tab-bar-history-back)
   ;; ("C-c u" . tab-bar-history-back)
   ;; ("s-S-U" . tab-bar-history-forward)
   :map tab-prefix-map
   ("h" . my/tab-bar-show-hide-tabs)
   ("H-t" . tab-bar-select-tab-by-name))

  :config
  (tab-bar-history-mode 1)
  (when (version< "28.0" emacs-version)
    (defun tab-bar-format-menu-bar ()
      "Produce the Menu button for the tab bar that shows the menu bar."
      `((menu-bar menu-item (propertize " 𝝺 " 'face 'tab-bar-tab-inactive)
                  tab-bar-menu-bar :help "Menu Bar")))
    (defun tab-bar-tab-name-format-default (tab i)
      (let ((current-p (eq (car tab) 'current-tab)))
        (propertize
         (concat " "
                 (if tab-bar-tab-hints (format "%d " i) "")
                 (alist-get 'name tab)
                 (or (and tab-bar-close-button-show
                          (not (eq tab-bar-close-button-show
                                   (if current-p 'non-selected 'selected)))
                          tab-bar-close-button)
                     "")
                 " ")
         'face (funcall tab-bar-tab-face-function tab))))
    (setq tab-bar-format '(tab-bar-format-menu-bar
                           ;; tab-bar-format-history
                           tab-bar-format-tabs
                           tab-bar-separator
                           tab-bar-format-add-tab
                           tab-bar-format-align-right
                           tab-bar-format-global)
          tab-bar-close-button-show nil))

  (setq  tab-bar-close-last-tab-choice 'tab-bar-mode-disable
         tab-bar-show                   (when (version< "28.0" emacs-version) 1)
         tab-bar-tab-name-truncated-max 14
         tab-bar-new-tab-choice        'ibuffer
         tab-bar-tab-name-function '(lambda nil
                                      "Use directory as tab name."
                                      (let ((dir (expand-file-name
                                                  (or (if (fboundp 'project-root)
                                                          (project-root (project-current)))
                                                      default-directory))))
                                        (substring dir (1+ (string-match "/[^/]+/$" dir)) -1 )))
         ;; tab-bar-select-tab-modifiers  '(meta)
         ;; tab-bar-tab-name-function 'tab-bar-tab-name-truncated
         ;; tab-bar-tab-name-function '(lambda nil (upcase (tab-bar-tab-name-truncated)))
         )

  (setq tab-bar-select-tab-modifiers '(meta hyper))

  (defun my/tab-bar-show-hide-tabs ()
    "Show or hide tabs."
    (interactive)
    (setq tab-bar-show (if tab-bar-show nil 1)))
   ;; (custom-set-faces
   ;; '(tab-bar ((t (:inherit nil :height 1.1))))
   ;; '(tab-bar-tab-inactive ((t (:inherit tab-bar :weight normal :height 0.9))))
   ;; '(tab-bar-tab ((t (:inherit tab-bar :underline t :weight bold))))
   ;; )

  (advice-add 'tab-bar-rename-tab
              :after
              (defun my/tab-bar-name-upcase (_name &optional _arg)
                "Upcase current tab name"
                (let* ((tab (assq 'current-tab (frame-parameter nil 'tabs)))
                       (tab-name (alist-get 'name tab)))
                  (setf (alist-get 'name tab) (upcase tab-name)
                        (alist-get 'explicit-name tab) t)))))

;; Show a list of the tabs in the echo area when switching tabs. Disabled since
;; I've taken to showing the tab-bar instead
(use-package! tab-bar-echo-area
  :if (version< emacs-version "28.0")
  :ensure
  :after tab-bar
  :init
  (if (version< emacs-version "28.0")
      (defvar tab-bar-format nil "Format for tab-bar-echo-area-mode"))
  :config
  (tab-bar-echo-area-mode 1))
#+end_src

#+RESULTS:

** Transpose Frame

This is an idea that I stole from prot' dotemacs. It augments the various transpose-* commands so they respect the region: if (use-region-p) then transpose the thing at the extremes of the region, otherwise operates as usual.

(the code is somewhat different from prot, but the idea is the same)

#+begin_src emacs-lisp :tangle no
(defmacro op/deftranspose (name scope key doc)
  "Macro to produce transposition functions.
NAME is the function's symbol.  SCOPE is the text object to
operate on.  Optional DOC is the function's docstring.

Transposition over an active region will swap the object at
mark (region beginning) with the one at point (region end).

It can optionally define a key for the defined function in the
`global-map' if KEY is passed.

Originally from protesilaos' dotemacs."
  (declare (indent defun))
  `(progn
     (defun ,name (arg)
       ,doc
       (interactive "p")
       (let ((x (intern (format "transpose-%s" ,scope))))
         (if (use-region-p)
             (funcall x 0)
           (funcall x arg))))
     ,(when key
        `(define-key global-map (kbd ,key) #',name))))

(op/deftranspose op/transpose-lines "lines" "C-x C-t"
  "Transpose lines or swap over active region.")

(op/deftranspose op/transpose-paragraphs "paragraphs" "C-S-t"
  "Transpose paragraph or swap over active region.")

(op/deftranspose op/transpose-sentences "sentences" "C-x M-t"
  "Transpose sentences or swap over active region.")

(op/deftranspose op/transpose-sexps "sexps" "C-M-t"
  "Transpose sexps or swap over active region.")

(op/deftranspose op/transpose-words "words" "M-t"
  "Transpose words or swap over active region.")
;; A command I have to try to use more is transpose-regions

(define-key global-map (kbd "C-x C-M-t") #'transpose-regions)

#+end_src

#+RESULTS:
: transpose-regions
** Side Window
Side windows are an interesting concept. Emacs reserve an optional space at the top, bottom, left and right of the frame for these side windows. You can think of them as a dockable space, akin to the panels in IDEs.

I'm finding useful to keep an IRC buffer at the bottom of the frame, to avoid jumping from the "code" frame to the "chat" frame or switch buffers continuously.

The following functions helps achieve this:

#+begin_src emacs-lisp
(defun op/buffer-to-side-window (place)
  "Place the current buffer in the side window at PLACE."
  (interactive (list (intern
                      (completing-read "Which side: "
                                       '(top left right bottom)))))
  (let ((buf (current-buffer)))
    (display-buffer-in-side-window
     buf `((window-height . 0.15)
           (side . ,place)
           (slot . -1)
           (window-parameters . ((no-delete-other-windows . t)
                                 (no-other-window t)))))
    (delete-window)))
#+end_src

#+RESULTS:
: op/buffer-to-side-window

** all in one setup kar
#+begin_src emacs-lisp :tangle yes


;; * WINDOW MANAGEMENT
;;;################################################################

;;;----------------------------------------------------------------
;; ** +SHACKLE+
;;;----------------------------------------------------------------

;; Wasamasa's Shackle package simplifies Emacs' rather arcane display-buffer
;; rules so you don't have to tear your hair out understanding how to configure
;; it. Unfortunately I did, see [[*SETUP-WINDOWS][setup-windows]].
(use-package! shackle
  :disabled t
  :init (shackle-mode))

;;;----------------------------------------------------------------
;; ** SETUP-WINDOWS
;;;----------------------------------------------------------------

;; Setup-windows defines window rules for displaying various kinds of buffers.
(load "setup-windows")
(use-package! setup-windows
  :demand t
  :hook ((help-mode . visual-line-mode)
         (Custom-mode . visual-line-mode)
         (helpful-mode . visual-line-mode))
  ;; :bind (;; ("C-x +" . balance-windows-area)
  ;;        ("<f8>" . +make-frame-floating-with-current-buffer)
  ;;        ("C-M-`" . window-toggle-side-windows))
  :bind
  ("<f9>" . +make-frame-floating-with-current-buffer)
  ;; "C-M-`" 'window-toggle-side-windows
  :general
  (:keymaps 'space-menu-window-map
            :wk-full-keys nil
            "w" '(window-toggle-side-windows :wk "toggle side windows")))

(use-package! window
  :bind (("H-+" . balance-windows-area)
         ("C-x +" . balance-windows-area)
         ("C-x q" . my/kill-buffer-and-window))
  :config
  (defun my/kill-buffer-and-window ()
    "Kill buffer.

Also kill this window, tab or frame if necessary."
    (interactive)
    (cl-letf ((symbol-function 'delete-window)
              (symbol-function 'my/delete-window-or-delete-frame))
      (kill-buffer-and-window))))

;; setup-windows:

;;;----------------------------------------------------------------
;; ** POPUPS
;;;----------------------------------------------------------------

;; Designate buffers to popup status and toggle or cycle through them
(use-package! popper
  :after (setup-windows setup-project)
  :commands popper-mode
  :bind (("C-`" . popper-toggle-latest)
         ("C-M-`" . popper-cycle)
         ("H-`" . popper-toggle-latest)
         ("H-M-`" . popper-cycle)
         ("H-6" . popper-toggle-type)
         ("H-M-k" . popper-kill-latest-popup))
  :init
  (setq popper-group-function
        (defun my/popper-group-by-heuristic ()
          "Group popups according to heuristic rules suitable for
          my usage."
          (let ((dd (abbreviate-file-name default-directory)))
            (cond
             ((string-match-p "\\(?:~/\\.config/\\|~/dotfiles/\\)" dd)
              'config)
             ((or (string-match-p "local/share/git" dd)
                  (string-match-p "plugins/" dd))
              'projects)
             ((string-match-p "\\(?:KarthikBa\\|research/\\)" dd)
              'research)
             ((string-match-p "karthinks" dd) 'website)
             ((locate-dominating-file dd "research") 'documents)
             ((locate-dominating-file dd "init.el") 'emacs)
             (t (popper-group-by-project))))))
  (setq ;; popper-mode-line nil
        popper-reference-buffers
        (append my/help-modes-list
                my/repl-modes-list
                my/occur-grep-modes-list
                ;; my/man-modes-list
                '(Custom-mode
                  (compilation-mode . hide)
                  messages-buffer-mode)
                '(("^\\*Warnings\\*$" . hide)
                  ("^\\*Compile-Log\\*$" . hide)
                  "^\\*Matlab Help\\*"
                  ;; "^\\*Messages\\*$"
                  "^\\*Backtrace\\*"
                  "^\\*evil-registers\\*"
                  "^\\*Apropos"
                  "^Calc:"
                  "^\\*eldoc\\*"
                  "^\\*TeX errors\\*"
                  "^\\*ielm\\*"
                  "^\\*TeX Help\\*"
                  "\\*Shell Command Output\\*"
                  ("\\*Async Shell Command\\*" . hide)
                  "\\*Completions\\*"
                  ;; "\\*scratch\\*"
                  "[Oo]utput\\*")))

  (use-package! popper-echo
    :config
    (defun popper-message-shorten (name)
      (cond
       ((string-match "^\\*[hH]elpful.*?: \\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                "(H)"))
       ((string-match "^\\*Help:?\\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                "(H)"))
       ((string-match "^\\*eshell:? ?\\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                (if (string-empty-p (match-string 1 name)) "shell(E)" "(E)")))
       ((string-match "^\\*\\(.*?\\)\\(?:Output\\|Command\\)\\*$" name)
        (concat (match-string 1 name)
                "(O)"))
       ((string-match "^\\*\\(.*?\\)[ -][Ll]og\\*$" name)
        (concat (match-string 1 name)
                "(L)"))
       ((string-match "^\\*[Cc]ompil\\(?:e\\|ation\\)\\(.*\\)\\*$" name)
        (concat (match-string 1 name)
                "(C)"))
       (t name)))
    (setq popper-echo-transform-function #'popper-message-shorten)
    (setq popper-echo-dispatch-keys '(?0 ?1 ?2 ?3 ?4 ?5 ?6 ?7 ?8 ?9)
          popper-echo-dispatch-actions t)
    (advice-add 'popper-echo :around
                (defun my/popper-echo-no-which-key (orig-fn)
                  (let ((which-key-show-transient-maps nil))
                    (funcall orig-fn))))
    (popper-echo-mode +1))

  :config
  (setq popper-display-control 'user)
  (defun my/popup-raise-popup ()
    "Choose a popup-window to raise as a regular window"
    (interactive)
    (popper-raise-popup
     (completing-read "Raise popup: "
                      (mapcar (lambda (win-and-buf) (buffer-name (cdr win-and-buf)))
                              (cl-mapcan (lambda (group) )
                                         (append popper-open-popup-alist
                                                popper-buried-popup-alist)))
                      nil t)))

  (defun my/popup-lower-to-popup ()
    "Choose a regular window to make a popup"
    (interactive)
    (let ((window-list (cl-set-difference
                        (window-list)
                        (mapcar 'car popper-open-popup-alist))))
      (if (< (length window-list) 2)
          (message "Only one main window!")
        (popper-lower-to-popup
         (get-buffer
          (completing-read "Lower to popup: "
                           (mapcar (lambda (win) (buffer-name (window-buffer win)))
                                   window-list)
                           nil t))))))
  :general
  (:states 'motion
           "C-w ^" '(popper-raise-popup :wk "raise popup")
           "C-w _" '(popper-lower-to-popup :wk "lower to popup"))
  (:keymaps 'space-menu-window-map
            "^" '(my/popup-raise-popup :wk "raise popup")
            "_" '(my/popup-lower-to-popup :wk "lower to popup")))

;;----------------------------------------------------------------
;; ** WINUM
;;----------------------------------------------------------------

;; Add window numbers and use them to switch windows
;; (use-package! winum
;;   :ensure
;;   :init
;;   (defun my/winum-select (num)
;;     (lambda (&optional arg) (interactive "P")
;;       (if arg
;;           (winum-select-window-by-number (- 0 num))
;;         (if (equal num (winum-get-number))
;;             (winum-select-window-by-number (winum-get-number (get-mru-window t)))
;;           (winum-select-window-by-number num)))))

;;   (setq winum-keymap
;;         (let ((map (make-sparse-keymap)))
;;           (define-key map (kbd "C-M-0") 'winum-select-window-0-or-10)
;;           (dolist (num '(1 2 3 4 5 6 7 8 9) nil)
;;             (define-key map (kbd (concat "C-M-" (int-to-string num)))
;;               (my/winum-select num)))
;;           map))

  ;; If evil-mode is enabled further mode-line customization is needed before
  ;; enabling winum:
  ;; (unless (bound-and-true-p evil-mode)
  ;;   (winum-mode 1)))


;;----------------------------------------------------------------
;; ** Ace-window
;;----------------------------------------------------------------

;; (use-package! ace-window
;;   :ensure t
;;   :bind
;;   (("C-x o" . ace-window)
;;    ("H-o"   . ace-window)
;;    ("M-o" . other-window)
;;    ("M-O" . my/other-window-prev))
;;   :general
;;   (:keymaps 'space-menu-map
;;             "`" 'ace-window)
;;   ;; :custom-face
;;   ;; (aw-leading-char-face ((t (:height 2.5 :weight normal))))
;;   :config
;;   (setq aw-dispatch-always t
;;         aw-scope 'global
;;         aw-background nil
;;         aw-keys '(?q ?w ?e ?r ?t ?y ?u ?i ?p))
;;   (setq aw-dispatch-alist
;;         '((?k aw-delete-window "Delete Window")
;;           (?m aw-swap-window "Swap Windows")
;;           (?M aw-move-window "Move Window")
;;           (?c aw-copy-window "Copy Window")
;;           (?j aw-switch-buffer-in-window "Select Buffer")
;;           (?\t aw-flip-window)
;;           (?b aw-switch-buffer-other-window "Switch Buffer Other Window")
;;           (?c aw-split-window-fair "Split Fair Window")
;;           (?s aw-split-window-vert "Split Vert Window")
;;           (?v aw-split-window-horz "Split Horz Window")
;;           (?o delete-other-windows "Delete Other Windows")
;;           (?? aw-show-dispatch-help)))
;;   (defun my/other-window-prev (&optional arg all-frames)
;;     (interactive "p")
;;     (other-window (if arg (- arg) -1) all-frames)))

;; (use-package! emacs
;;   :config
;;   (defun my/enlarge-window-horizontally (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame width."
;;     (interactive "p")
;;     (enlarge-window-horizontally (* (or repeat 1)
;;                                     (floor (frame-width) 20))))
;;   (defun my/shrink-window-horizontally (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame width."
;;     (interactive "p")
;;     (shrink-window-horizontally (* (or repeat 1)
;;                                    (floor (frame-width) 20))))
;;   (defun my/shrink-window (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame height."
;;     (interactive "p")
;;     (shrink-window (* (or repeat 1)
;;                       (floor (frame-height) 20))))
;;   (defun my/enlarge-window (&optional repeat)
;;     "Enlarge window horizontally by 8% of the frame height."
;;     (interactive "p")
;;     (enlarge-window (* (or repeat 1)
;;                        (floor (frame-height) 20))))
;;   :bind
;;   (("<C-S-right>" . my/enlarge-window-horizontally)
;;    ("<C-S-left>"  . my/shrink-window-horizontally)
;;    ("<C-S-up>"    . my/enlarge-window)
;;    ("<C-S-down>"  . my/shrink-window)))

;;----------------------------------------------------------------
;; ** Windmove
;;----------------------------------------------------------------

(use-package! windmove
  :bind
  (("s-S-<right>" . windmove-swap-states-right)
   ("s-S-<down>" . windmove-swap-states-down)
   ("s-S-<up>" . windmove-swap-states-up)
   ("s-S-<left>" . windmove-swap-states-left)))
  ;; :config
  ;; (use-package! emacs-i3))

;;----------------------------------------------------------------
;; ** Transpose-frame
;;----------------------------------------------------------------

(use-package! transpose-frame
  :ensure t
  :bind (("H-\\" . rotate-frame-anticlockwise)
         :map ctl-x-4-map
         ("|" . flop-frame)
         ("_" . flip-frame)
         ("\\" . rotate-frame-anticlockwise)))

;;----------------------------------------------------------------
;; ** Auto-revert
;;----------------------------------------------------------------

(use-package! autorevert
  :hook ((prog-mode
          text-mode
          tex-mode
          org-mode
          conf-mode) . auto-revert-mode))

;;----------------------------------------------------------------
;; ** Re-Builder
;;----------------------------------------------------------------
(use-package! re-builder
  :bind (("C-M-5" . re-builder)
         ("C-M-%" . re-builder)
         :map reb-mode-map
         ("C-c C-k" . reb-quit)
         ("RET" . reb-replace-regexp)
         :map reb-lisp-mode-map
         ("RET" . reb-replace-regexp))
  :config
  ;; reb-fix modifies reb-update-overlays to restrict matches to region
  (load "reb-fix")
  (use-package! reb-fix)
  (defvar my/re-builder-positions nil
    "Store point and region bounds before calling re-builder")
  (advice-add 're-builder
              :before
              (defun my/re-builder-save-state (&rest _)
                "Save into `my/re-builder-positions' the point and region
positions before calling `re-builder'."
                (setq my/re-builder-positions
                      (cons (point)
                            (when (region-active-p)
                              (list (region-beginning)
                                    (region-end)))))))
  (defun reb-replace-regexp (&optional delimited)
  "Run `query-replace-regexp' with the contents of re-builder. With
non-nil optional argument DELIMITED, only replace matches
surrounded by word boundaries."
  (interactive "P")
  (reb-update-regexp)
  (let* ((re (reb-target-binding reb-regexp))
         (replacement (query-replace-read-to
                       re
                       (concat "Query replace"
		               (if current-prefix-arg
		                   (if (eq current-prefix-arg '-) " backward" " word")
		                 "")
		               " regexp"
		               (if (with-selected-window reb-target-window
                                     (region-active-p)) " in region" ""))
                       t))
         (pnt (car my/re-builder-positions))
         (beg (cadr my/re-builder-positions))
         (end (caddr my/re-builder-positions)))
    (with-selected-window reb-target-window
      (goto-char pnt)
      (setq my/re-builder-positions nil)
      (reb-quit)
      (query-replace-regexp re replacement delimited beg end)))))

#+end_src

#+RESULTS:
: reb-replace-regexp

* General interface and interactions
This section contains configurations for all aspects of the Emacs user
interface, as well lots of small or self-contained tweaks that cover a
wide range of built-in libraries.

** Window divider mode

This is a built-in mode that can draw both vertical and horizontal
borders.  It can be particularly helpful when used with windows that do
not have a modeline, such as what happens when I enable my custom
=prot-tab-status-line= on Emacs28, which moves all the relevant
information to the tab bar (in effect, it creates a universal status
line---see [[#h:63ad472f-c9c2-40ad-9675-1dc529487788][Tabs for window layouts (tab-bar.el and prot-tab.el)]]).

#+begin_src emacs-lisp :tangle yes
 ;; (setq outline-minor-mode-highlight 'override) ; emacs28
 (setq outline-minor-mode-cycle t)             ; emacs28
;;Window divider mode
(setq window-divider-default-right-width 1)
(setq window-divider-default-bottom-width 1)
(setq window-divider-default-places 'right-only)
#+end_src

#+RESULTS:
: right-only

** Fringe mode

The fringes are areas to the right and left side of an Emacs frame.
They can be used to show status-related or contextual feedback such as
line truncation indicators, continuation lines, code linting markers,
etc.

The default fringe width (=nil=) is 8 pixels on either side, which I
approve of.  It is possible to set the value of the =fringe-mode= to
something like ='(10 . 5)= which applies the varied width to the left and
right side respectively.  Otherwise, we can use a single integer that
controls both sides.

The use of =setq-default= is necessary, otherwise these values become
buffer-local.

#+begin_src emacs-lisp :tangle no
;;; Fringe mode
(use-package! fringe
  :config
  (fringe-mode nil)
  (setq-default fringes-outside-margins nil)
  (setq-default indicate-buffer-boundaries nil)
  (setq-default indicate-empty-lines nil)
  (setq-default overflow-newline-into-fringe t))
#+end_src

#+RESULTS:
: t

** Depth-based code colourisation (prism.el)
*** desc
Adam Porter's (aka alphapapa) =prism.el= colourises programming code based
on the level of depth, rather than targeting syntactic constructs like
keywords, strings, variables.  This can be useful when working with
highly-nested and/or unfamiliar code.  It has two modes that are
intended for specific types of programming languages:

1. =prism-mode= is good for Lisp and languages that look like C (I only
   code in Elisp);
2. =prism-whitespace-mode= is for languages that are more sensitive to
   indentation.

The degree of colouration for each level of depth is configurable, as
are the colours to be used.  Consult Prism's documentation for the
technicalities.

My =prot-prism.el= (reproduced after the following configurations)
provides a few extras that help me set the desired style of colouration.
It provides an alist of palette presets.  Those can be applied through
minibuffer completion with the command =prot-prism-set-colors=.  All the
presets are designed to extract colour values from the active Modus
theme ([[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).  Those range from a
minimalist style of drawing only four colours, to a more expansive
sixteen-colour gamout.

The =prot-prism-set-colors= command also takes care to activate the
appropriate Prism mode for languages whose major mode is declared as
"indentation-sensitive".  Those are added as a list to the variable
=prot-prism-negative-space-sensitive-modes=.

To disable the effect, just do =M-x prot-prism-disable=.

*** code
#+begin_src emacs-lisp :tangle no
;;; Depth-based code colourisation (prism.el)
(use-package! prism
  :config
  (setq prism-comments 't))

(load "prot-prism.el")
(use-package! prot-prism
  :config
  (setq prot-prism-negative-space-sensitive-modes
        '(sh-mode yaml-mode))

  (setq prot-prism-presets-function #'prot-prism--colors))
#+end_src

#+RESULTS:
: t

** Cursor and mouse settings
*** Cursor appearance and tweaks (prot-cursor.el)

=prot-cursor.el= defines a set of presets that control the overall style
of the cursor.  There presuppose the =blink-cursor-mode=.  The properties
we pass to those presets mirror those we can pass for the various
built-in variables for the cursor.  Check the =prot-cursor.el= code, which
is reproduced right after the following package configurations.

#+begin_src emacs-lisp
;;; Cursor appearance and tweaks (prot-cursor.el)
(load "prot-cursor")
(use-package! prot-cursor
  :config
  (setq prot-cursor-presets
        '((bar . ( :cursor-type (bar . 2)
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (box . ( :cursor-type box
                   :cursor-no-selected hollow
                   :blinks 10
                   :blink-interval 0.5
                   :blink-delay 0.2))

          (underscore . ( :cursor-type (hbar . 3)
                          :cursor-no-selected hollow
                          :blinks 50
                          :blink-interval 0.2
                          :blink-delay 0.2))))
  (setq prot-cursor-last-state-file
        (locate-user-emacs-file "prot-cursor-last-state"))

  (prot-cursor-restore-last-preset)

  ;; Sets my style on startup.
  (if prot-cursor--recovered-preset
      (prot-cursor-set-cursor prot-cursor--recovered-preset)
    (prot-cursor-set-cursor 'underscore))

  ;; The other side of `prot-cursor-restore-last-preset'.
  (add-hook 'kill-emacs-hook #'prot-cursor-store-last-preset))

  ;; We have to use the "point" mnemonic, because C-c c is for
  ;; `org-capture'.
  ;; (define-key global-map (kbd "C-c p p") #'prot-cursor-set-cursor))
#+end_src

#+RESULTS:
: t

*** Mouse wheel behaviour

The value of =mouse-wheel-scroll-amount= means the following:

+ By default scroll by one line.
+ Hold down Shift to do so by five lines.
+ Hold down Meta to scroll half a screen.
+ Hold down Control to adjust the size of the text.  This was added in
  Emacs 27.

The other options in short:

+ Hide mouse pointer while typing.
+ Enable mouse scroll.
+ Faster wheel movement means faster scroll.
+ Scroll window under mouse pointer regardless of whether it is the
  current one or not.

Note that if we enable =mouse-drag-copy-region= we automatically place the
mouse selection to the kill ring.  This is the same behaviour as
terminal emulators that place the selection to the clipboard (or the
primary selection).  I choose not to use this here.

=tear-off-window= places the current window in a new frame.  On my generic
mouse, =<mouse-3>= is the right click.  Normally I call that command with
=M-x=, though it does not hurt to rely on the mouse from time to time.

#+begin_src emacs-lisp :tangle no
;;; Mouse wheel behaviour
(use-package! mouse
  ;; In Emacs 27+, use Control + mouse wheel to scale text.
  :config
  (setq mouse-wheel-scroll-amount
        '(1
          ((shift) . 5)
          ((meta) . 0.5)
          ((control) . text-scale)))
  (setq mouse-drag-copy-region nil)
  (setq make-pointer-invisible t)
  (setq mouse-wheel-progressive-speed t)
  (setq mouse-wheel-follow-mouse t)
  (add-hook 'after-init-hook #'mouse-wheel-mode)
  (define-key global-map (kbd "C-M-<mouse-3>") #'tear-off-window))
#+end_src

#+RESULTS:
: t

*** Scrolling behaviour

By default, page scrolling should keep the point at the same visual
position, rather than force it to the top or bottom of the viewport.
This eliminates the friction of guessing where the point has warped to.

As for per-line scrolling, I dislike the default behaviour of visually
re-centring the point: it is too aggressive as a standard mode of
interaction.  With the following, the point will stay at the top/bottom
of the screen while moving in that direction (use =C-l= to reposition
it).

The =next-screen-context-lines= ensures that when moving by screenfulls
(with either =C-v= or =M-v=) we do not get any continuation lines from the
previous screen.  I find this more intuitive.

#+begin_src emacs-lisp :tangle no
;;; Scrolling behaviour
;; These four come from the C source code.
(setq-default scroll-preserve-screen-position t)
(setq-default scroll-conservatively 1) ; affects `scroll-step'
(setq-default scroll-margin 0)
(setq-default next-screen-context-lines 0)
#+end_src

#+RESULTS:
: 0

*** Delete selection

This is a very helpful mode.  It kills the marked region when inserting
directly to it.  It also has checks to ensure that yanking over a
selected region will not insert itself when =mouse-drag-copy-region= is in
effect (see the section on the [[#h:02572210-eb26-4941-8f7c-666a0314877b][mouse wheel behaviour]]).

#+begin_src emacs-lisp :tangle no
;;; Delete selection
(use-package! delsel
  :config
  (add-hook 'after-init-hook #'delete-selection-mode))
#+end_src

#+RESULTS:
: t

*Pro tip*: On Emacs 27.1 or higher you can create a rectangular region by
holding down Ctrl and Meta while dragging the mouse with the left click
pressed.

*** Tooltips (tooltip-mode)

These settings control how tool tips are to be handled when hovering the
mouse over an actionable item:

+ I just want to make sure that the GTK theme is /not used/ for those: I
  prefer the generic display which follows my current theme's styles.
+ The delay is slightly reduced for the initial pop-up, while it has
  been increased for immediate pop-ups thereafter.

#+begin_src emacs-lisp :tangle no
;;; Tooltips (tooltip-mode)
(use-package! tooltip
  :config
  (setq tooltip-delay 0.5)
  (setq tooltip-short-delay 0.5)
  (setq x-gtk-use-system-tooltips nil)
  (setq tooltip-frame-parameters
        '((name . "tooltip")
          (internal-border-width . 6)
          (border-width . 0)
          (no-special-glyphs . t)))
  (add-hook 'after-init-hook #'tooltip-mode))
#+end_src

#+RESULTS:
: t

** Dired-like list for registers (rlist)

This package by Sévère Durand implements a Dired-like interface for the
purpose of deleting an entry from the list.  I feel this is the one
major feature that is missing from the registers' toolkit: it provides
you with the means to remain in control of the data you accumulate in
those compartments, so nothing ever gets out of hand.

Note that this is a fairly new project (as of 2021-02-05), so things are
likely to change over the near term.

#+begin_src emacs-lisp :tangle no
;;; Dired-like list for registers (rlist)
;; Project repo: <https://gitlab.com/mmemmew/rlist>.  This is one of the
;; packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(use-package! rlist
  :config
  (setq rlist-expert t)
  (setq rlist-verbose t)
  (let ((map global-map))
    (define-key map (kbd "C-x r <backspace>") #'rlist-list-registers)
    (define-key map (kbd "C-x r <delete>") #'rlist-list-registers)))
#+end_src

** Conveniences and minor extras
*** Automatic time stamps for files (time-stamp.el)

The built-in =time-stamp.el= provides the means to automatically update a
predefined header with the time its file was last edited/saved.  This
is, in my experience, particularly useful for packages that have a
stable version but also need to disambiguate their latest tagged release
from their current development state.

By default, this is done by checking the first eight lines of the file
for the =Time-stamp: <>= entry.  Though that is configurable.  To properly
utilise this library, you need to implement file-local variables.  Those
should control the exa
ct format of the time stamp.  For examples, this
is what I have in my =modus-themes.el=:

#+begin_example
;; Local Variables:
;; time-stamp-start: "Last-Modified:[ \t]+\\\\?[\"<]"
;; time-stamp-end: "\\\\?[\">]"
;; time-stamp-format: "%Y-%02m-%02d %02H:%02M:%02S %5z"
;; End:
#+end_example

Check =M-x find-library RET time-stamp RET= for all variables you may want
to control.

All we do here is enable the package and add a hook to insert a time
stamp upon save, where relevant.  It works seamlessly.

#+begin_src emacs-lisp
;;; Automatic time stamps for files (time-stamp.el)
(use-package! time-stamp
  :config
  (add-hook 'before-save-hook #'time-stamp))
#+end_src

#+RESULTS:
: t

*** Preserve contents of system clipboard

Say you copied a link from your web browser, then switched to Emacs to
paste it somewhere.  Before you do that, you notice something you want
to kill.  Doing that will place the last kill to the clipboard, thus
overriding the thing you copied earlier.  We can have a kill ring
solution to this with the following:

#+begin_src emacs-lisp
;;; Preserve contents of system clipboard
(setq save-interprogram-paste-before-kill t)
#+end_src

Now the contents of the clipboard are stored in the kill ring and can
be retrieved from there (e.g. with =M-y=).

* Code & Edit
** DONE Bookmarks
CLOSED: [2022-04-01 Fri 15:36]
Bookmarks are somewhat like registers in that they record positions you can jump to.  Unlike registers, they have long names, and they persist automatically from one Emacs session to the next. The prototypical use of bookmarks is to record where you were reading in various files.

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("b". "buffer")
       :desc "List bookmarks" "L" #'list-bookmarks
       :desc "Save current bookmarks to bookmark file" "w" #'bookmark-save))
  (setq bookmark-set-fringe-mark t) ; Emacs28
#+END_SRC

#+RESULTS:
: bookmark-save
** DONE MOUSE SUPPORT
CLOSED: [2022-04-01 Fri 15:37]
Adding mouse support in the terminal version of Emacs.

#+begin_src emacs-lisp
(xterm-mouse-mode 1)
#+end_src

** DONE EMOJIS
CLOSED: [2022-04-01 Fri 15:37]
Emojify is an Emacs extension to display emojis. It can display github style emojis like :smile: or plain ascii ones like :).

#+begin_src emacs-lisp
(use-package! emojify
  :hook (after-init . global-emojify-mode))
#+end_src

** DONE Sudo Save
CLOSED: [2022-04-01 Fri 15:37]

If the current buffer is not writable, ask if it should be saved with
=sudo=.

Happily taken from Pascals configuration: https://github.com/SirPscl/emacs.d#sudo-save

#+BEGIN_SRC emacs-lisp
  (defun ph/sudo-file-name (filename)
    "Prepend '/sudo:root@`system-name`:' to FILENAME if appropriate.
  This is, when it doesn't already have a sudo-prefix."
    (if (not (or (string-prefix-p "/sudo:root@localhost:"
                                  filename)
                 (string-prefix-p (format "/sudo:root@%s:" system-name)
                                  filename)))
        (format "/sudo:root@%s:%s" system-name filename)
      filename))

  (defun ph/sudo-save-buffer ()
    "Save FILENAME with sudo if the user approves."
    (interactive)
    (when buffer-file-name
      (let ((file (ph/sudo-file-name buffer-file-name)))
        (if (yes-or-no-p (format "Save file as %s ? " file))
            (write-file file)))))

  (advice-add 'save-buffer :around
              '(lambda (fn &rest args)
                 (when (or (not (buffer-file-name))
                           (not (buffer-modified-p))
                           (file-writable-p (buffer-file-name))
                           (not (ph/sudo-save-buffer)))
                   (call-interactively fn args))))
#+END_SRC

#+RESULTS:

** DONE Speed type
CLOSED: [2022-04-01 Fri 15:39]
#+begin_src emacs-lisp
;; Speed-type: Type a text and measure your speed
(use-package! speed-type
  :defer t)
#+end_src
** DONE Selectric
CLOSED: [2022-04-01 Fri 15:39]

Every so often, you want everyone else to /know/ that you're typing, or just to
amuse oneself. Introducing: typewriter sounds!
#+begin_src emacs-lisp :tangle packages.el
(package! selectric-mode :pin "1840de71f7414b7cd6ce425747c8e26a413233aa")
#+end_src

#+begin_src emacs-lisp
(use-package! selectic-mode
  :commands selectic-mode)
#+end_src

** DONE Auto activating snippets
CLOSED: [2022-04-01 Fri 15:43]

Sometimes pressing =TAB= is just too much.
#+begin_src emacs-lisp :tangle packages.el
(package! aas :recipe (:host github :repo "ymarco/auto-activating-snippets")
  :pin "e92b5cffa4e87c221c24f3e72ae33959e1ec2b68")
#+end_src

#+begin_src emacs-lisp
(use-package! aas
  :commands aas-mode)
#+end_src

** DONE YASnippet
CLOSED: [2022-04-01 Fri 15:43]
#+begin_quote
From the =:editor snippets= module.
#+end_quote

Nested snippets are good, so let's enable that.
#+begin_src emacs-lisp
(setq yas-triggers-in-field t)
#+end_src

#+RESULTS:
: t

** DONE RAINBOW MODE
CLOSED: [2022-04-01 Fri 15:43]
Rainbox mode displays the actual color for any hex value color.  It's such a nice feature that I wanted it turned on all the time, regardless of what mode I am in.  The following creates a global minor mode for rainbow-mode and enables it.

fuck this snippet , wanna know why? well try using this and see your org agenda

#+begin_src emacs-lisp :tangle no
(define-globalized-minor-mode global-rainbow-mode rainbow-mode
  (lambda () (rainbow-mode 1)))
(global-rainbow-mode 1 )
#+end_src

#+RESULTS:
: t

** DONE Box Quote
CLOSED: [2022-04-01 Fri 15:43]

boxquote.el provides a set of functions for using a text quoting style that partially boxes in the left hand side of an area of text, such a marking style might be used to show externally included text or example code.

This is how a boxquote looks:

╭────[ Lorem ipsum ]
│ Nullam eu ante vel est convallis dignissim.  Fusce suscipit, wisi nec facilisis
│ facilisis, est dui fermentum leo, quis tempor ligula erat quis odio.  Nunc porta
│ vulputate tellus.  Nunc rutrum turpis sed pede.  Sed bibendum.  Aliquam posuere.
│ Nunc aliquet, augue nec adipiscing interdum, lacus tellus malesuada massa, quis
│ varius mi purus non odio.  Pellentesque condimentum, magna ut suscipit
│ hendrerit, ipsum augue ornare nulla, non luctus diam neque sit amet urna.
╰────

#+begin_src emacs-lisp
(use-package! boxquote
;;:ensure t
  :defer t
  :config
  (setq-default  boxquote-bottom-corner "╰"      ; U+2570
                 boxquote-side          "│ "     ; U+2572 + space
                 boxquote-top-and-tail  "────"   ; U+2500 (×4)
                 boxquote-top-corner    "╭")     ; U+256F
  (when (package-installed-p 'hydra)
    (eval-and-compile
      (defhydra hydra-boxquote (:color blue :hint nil)
       "
                                                                    ╭──────────┐
  Text           External           Apropos         Do              │ Boxquote │
╭───────────────────────────────────────────────────────────────────┴──────────╯
  [_r_] region        [_f_] file      [_K_] describe-key        [_t_] title
  [_p_] paragraph     [_b_] buffer    [_F_] describe-function   [_u_] unbox
  [_a_] buffer        [_s_] shell     [_V_] describe-variable   [_w_] fill-paragraph
  [_e_] text           ^ ^            [_W_] where-is            [_n_] narrow
  [_d_] defun         [_y_] yank       ^ ^                      [_c_] narrow to content
  [_q_] boxquote      [_Y_] yanked     ^ ^                      [_x_] kill
--------------------------------------------------------------------------------
       "
      ("<esc>" nil "quit")
      ("x" boxquote-kill)
      ("Y" boxquote-yank)
      ("e" boxquote-text)
      ("u" boxquote-unbox)
      ("d" boxquote-defun)
      ("t" boxquote-title)
      ("r" boxquote-region)
      ("a" boxquote-buffer)
      ("q" boxquote-boxquote)
      ("W" boxquote-where-is)
      ("p" boxquote-paragraph)
      ("f" boxquote-insert-file)
      ("K" boxquote-describe-key)
      ("s" boxquote-shell-command)
      ("b" boxquote-insert-buffer)
      ("y" boxquote-kill-ring-save)
      ("w" boxquote-fill-paragraph)
      ("F" boxquote-describe-function)
      ("V" boxquote-describe-variable)
      ("n" boxquote-narrow-to-boxquote)
      ("c" boxquote-narrow-to-boxquote-content)))))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package! (25088 11393 498837 905000) :init (25088 11393 498812 216000) :init-secs (0 0 311 648000) :use-package-secs (0 0 2107 22000)))

** DONE Cloc (count lines of code in buffer)
CLOSED: [2022-04-01 Fri 15:42]
#+begin_src emacs-lisp

;; cloc count the lines of code in a buffer

(use-package! cloc
  :ensure t
  :commands cloc)
#+end_src

#+RESULTS:

** DONE Abbrev
CLOSED: [2022-04-01 Fri 15:45]
Thanks to [[https://emacs.stackexchange.com/questions/45462/use-a-single-abbrev-table-for-multiple-modes/45476#45476][use a single abbrev-table for multiple modes? - Emacs Stack Exchange]] I
have the following.
#+begin_src emacs-lisp
(add-hook 'doom-first-buffer-hook
          (defun +abbrev-file-name ()
            (setq-default abbrev-mode t)
            (setq abbrev-file-name (expand-file-name "abbrev_defs" doom-user-dir))))
#+end_src

#+RESULTS:
| +abbrev-file-name |
** DONE Save Macros
CLOSED: [2022-11-16 Wed 19:04]
- State "DONE"       from              [2022-11-16 Wed 19:04]
#+begin_src emacs-lisp
  (defun save-macro (name)
    "save a macro. Take a name as argument
     and save the last defined macro under
     this name at the end of your .emacs"
     (interactive "SName of the macro: ")  ; ask for the name of the macro
     (kmacro-name-last-macro name)         ; use this name for the macro
     (find-file custom-file)            ; open ~/.emacs or other user init file
     (goto-char (point-max))               ; go to the end of the .emacs
     (newline)                             ; insert a newline
     (insert-kbd-macro name)               ; copy the macro
     (newline)                             ; insert a newline
     (save-buffer)
     (switch-to-buffer nil))               ; return to the initial buffer
#+end_src

** Dabbrev (dynamic word completion)
***  Desc

This is Emacs' own approach to dynamic/arbitrary text completion inside
the buffer: "dynamic abbreviation" or else =dabbrev=.  This mechanism
works by reading all text before point to find a suitable match.
Different scenaria determine whether it should also look forward and in
other buffers.  In essence, Dabbrev helps you re-type what you already
have.

With =dabbrev-expand= we make an attempt to complete the text at point.
Repeated invocations will cycle through the candidates.  No feedback is
provided, much in the same way yanking from the kill-ring works (though
for Emacs28 =yank-pop= on =M-y= will use completion if the previous command
was not =yank= on =C-y=).  To complete a phrase, matching the last succesful
=dabbrev-expand=, you need to supply an empty space and call the command
again.  This will match the next word, and so on for N words.

Whereas =dabbrev-completion= benefits from minibuffer interactivity and
the pattern matching styles in effect ([[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).
With the help of Corfu, the completion candidates are displayed in a
pop-up window near point ([[#h:675ebef4-d74d-41af-808d-f9579c2a5ec4][Corfu for in-buffer completion]]).

The =dabbrev-abbrev-char-regexp= is configured to match both regular words
and symbols (e.g. words separated by hyphens).  This makes it equally
suitable for code and ordinary language.

While the =dabbrev-abbrev-skip-leading-regexp= is instructed to also
expand words and symbols that start with any of these: =$=, =*=, =/=, ===, =~=, ='=.
This regexp may be expanded in the future, but the idea is to be able to
perform completion in contexts where the known word/symbol is preceded
by a special character.  For example, in the =org-mode= version of this
document, all inline code must be placed between the equals sign.  So
now typing the ===, then a letter, will still allow me to expand text
based on that input.

To check what I have on regular expressions, see further below my
configurations and documentation for [[#h:6c6759c8-3ae3-40b0-8356-05cc0975e12a][re-builder (regexp-builder)]].

***  code
#+begin_src emacs-lisp :tangle yes
;;; Dabbrev (dynamic word completion)
(use-package! dabbrev
  :config
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "[$*/=~']")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction 'case-replace)
  (setq dabbrev-case-fold-search nil)
  (setq dabbrev-case-replace 'case-replace)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines t)
  (setq dabbrev-upcase-means-case-search t)
  (let ((map global-map))
    (define-key map (kbd "M-/") #'dabbrev-expand)
    (define-key map (kbd "C-x M-/") #'dabbrev-completion)))

#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp :tangle yes

;;;----------------------------------------------------------------
;; ** DABBREV Karthiks
;;;----------------------------------------------------------------

(use-package! dabbrev
  :commands (dabbrev-expand dabbrev-completion)
  :config
  (setq dabbrev-abbrev-char-regexp "\\sw\\|\\s_")
  (setq dabbrev-abbrev-skip-leading-regexp "\\$\\|\\*\\|/\\|=")
  (setq dabbrev-backward-only nil)
  (setq dabbrev-case-distinction nil)
  (setq dabbrev-case-fold-search t)
  (setq dabbrev-case-replace nil)
  (setq dabbrev-check-other-buffers t)
  (setq dabbrev-eliminate-newlines nil)
  (setq dabbrev-upcase-means-case-search t))
#+end_src

#+RESULTS:
: t

** Abberviation
#+begin_src emacs-lisp :tangle no
;; Where I store the abbreviation I need.

;;; my-abbrev --- Abbrev stuff  -*- lexical-binding: t; -*-
;;; Commentary:

;; This adds various abbrevs for various modes.  Abbrevs are useful to
;; avoid typos, for instance.  To prevent the expansion, type ``word
;; C-q SPC'' instead of ``word SPC''.

;;; Code:

(clear-abbrev-table global-abbrev-table)

(define-abbrev-table 'global-abbrev-table
  '(("prots@" "ports@")

    ("supprots" "supports")

    ("het" "the")
    ("teh" "the")

    ("wehn" "when")

    ("perchè" "perché")
    ("perche" "perché")
    ("nonchè" "nonché")
    ("nonche" "nonché")
    ("quetse" "queste")
    ("sovlgimento" "svolgimento")
    ("sovlgere" "svolgere")
    ("sbagilo" "sbaglio")
    ("caffe" "caffè")))

(when (boundp 'text-mode-abbrev-table)
  (clear-abbrev-table text-mode-abbrev-table))

(define-abbrev-table 'text-mode-abbrev-table
  '(("hw" "hardware")
    ("sw" "software")))

(when (boundp 'clojure-mode-abbrev-table)
  (clear-abbrev-table clojure-mode-abbrev-table))

(define-abbrev-table 'clojure-mode-abbrev-table
  '(("erq" "req")))

(when (boundp 'c-mode-abbrev-table)
  (clear-abbrev-table c-mode-abbrev-table))

(define-abbrev-table 'c-mode-abbrev-table
  '(("inculde" "include")
    ("inlcude" "include")))

;; turn on abbrev mode globally
(setq-default abbrev-mode t)

(provide 'my-abbrev)
;;; my-abbrev.el ends here
#+end_src

#+RESULTS:
: my-abbrev

** DONE Spell
CLOSED: [2022-04-01 Fri 15:55]
**** Downloading dictionaries
Let's get a nice big dictionary from [[http://app.aspell.net/create][SCOWL Custom List/Dictionary Creator]] with
the following configuration
- size :: 80 (huge)
- spellings :: British(-ise) and Australian
- spelling variants level :: 0
- diacritics :: keep
- extra lists :: hacker, roman numerals

***** Hunspell
#+begin_src shell :tangle (if (file-exists-p "/usr/share/myspell/en-custom.dic") "no" "setup.sh")
cd /tmp
curl -o "hunspell-en-custom.zip" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=hunspell'
unzip "hunspell-en-custom.zip"

sudo chown root:root en-custom.*
sudo mv en-custom.{aff,dic} /usr/share/myspell/
#+end_src
***** Aspell
#+begin_src shell :tangle (if (file-expand-wildcards "/usr/lib64/aspell*/en-custom.multi") "no" "setup.sh")
cd /tmp
curl -o "aspell6-en-custom.tar.bz2" 'http://app.aspell.net/create?max_size=80&spelling=GBs&spelling=AU&max_variant=0&diacritic=keep&special=hacker&special=roman-numerals&encoding=utf-8&format=inline&download=aspell'
tar -xjf "aspell6-en-custom.tar.bz2"

cd aspell6-en-custom
./configure && make && sudo make install
#+end_src
**** Configuration
#+begin_src emacs-lisp
(setq ispell-dictionary "en-custom")

;; (setq ispell-program-name "aspell"
;;       ispell-extra-args '("--sug-mode=ultra" "--lang=en_us")
;;       ;; ispell-dictionary "en"
;;       ispell-personal-dictionary "/usr/lib64/aspell-0.60/en-custom.multi")

;; (after! cape
;;   (setq cape-dict-file (if (file-exists-p ispell-personal-dictionary) ispell-personal-dictionary cape-dict-file)))

(add-hook 'text-mode-hook 'flyspell-mode)
(add-hook 'prog-mode-hook 'flyspell-prog-mode)
#+end_src

#+RESULTS:
: en-custom

Oh, and by the way, if ~company-ispell-dictionary~ is ~nil~, then
~ispell-complete-word-dict~ is used instead, which once again when ~nil~ is
~ispell-alternate-dictionary~, which at the moment maps to a plaintext version of
the above.

It seems reasonable to want to keep an eye on my personal dict, let's have it
nearby (also means that if I change the 'main' dictionary I keep my addition).
#+begin_src emacs-lisp
(setq ispell-personal-dictionary (expand-file-name ".ispell_personal" doom-user-dir))
#+end_src

#+RESULTS:
: /home/shiva/.config/doom/.ispell_personal

** DONE Impatient mode
CLOSED: [2022-04-01 Fri 15:50]
#+begin_src emacs-lisp :tangle packages.el

(package! impatient-mode
    :recipe (:host github :repo "skeeto/impatient-mode"))
#+end_src

And then point your browser to http://localhost:8080/imp/, select a buffer, and watch your changes appear as you type!

#+begin_src emacs-lisp
;; impatient-mode
;; Thanks to impatient-mode you can see the effect of your HTML as you type it.
;;
;; (use-package! impatient-mode
;;   :ensure t)
#+end_src

** iedit
#+begin_src emacs-lisp

(use-package! iedit
  :ensure t
  :bind ("C-M-;" . iedit-mode))
#+end_src
** evil stuff
*** Disable =evil-mode= for some modes
   Since Emacs is a multi-purpose LISP REPL, there are many modes that
   are not primarily (or not at all) centered about text-manipulation.
   For those, it is reasonable to disable =evil-mode=, because it will
   bring nothing to the table, but might just shadow some keyboard
   shortcuts.
#+BEGIN_SRC emacs-lisp :tangle no
  (mapc (lambda (mode)
          (evil-set-initial-state mode 'emacs)) '(elfeed-show-mode
                                                  elfeed-search-mode
                                                  forge-pullreq-list-mode
                                                  forge-topic-list-mode
                                                  dired-mode
                                                  tide-references-mode
                                                  image-dired-mode
                                                  image-dired-thumbnail-mode
                                                  ytel-mode
                                                  eww-mode))
#+END_SRC

#+RESULTS:
| elfeed-show-mode | elfeed-search-mode | forge-pullreq-list-mode | forge-topic-list-mode | dired-mode | tide-references-mode | image-dired-mode | image-dired-thumbnail-mode | ytel-mode | eww-mode |

#+BEGIN_SRC emacs-lisp :tangle no
  (mapc (lambda (mode)
          (evil-set-initial-state mode 'emacs)) '(osm-mode
                                                  prot-eww-history-mode))
#+END_SRC

#+RESULTS:
| osm-mode | prot-eww-history-mode |

Turning off evil when working in =cider--debug= minor mode:

#+BEGIN_SRC emacs-lisp :tangle no
  (defadvice cider--debug-mode (after toggle-evil activate)
    "Turn off `evil-local-mode' when enabling
  `cider--debug-mode', and turn it back on when disabling
  `cider--debug-mode'."
    (evil-local-mode (if cider--debug-mode -1 1)))
#+END_SRC

*** Paste in Visual Mode

#+BEGIN_SRC emacs-lisp
  (define-key evil-insert-state-map (kbd "C-v") 'evil-visual-paste)

#+END_SRC

#+RESULTS:
: evil-visual-paste

*** =evil-escape=
https://github.com/syl20bnr/evil-escape

Escape from insert state and everything else.

#+BEGIN_SRC emacs-lisp :tangle no
  (setq-default evil-escape-delay 0.2)
  (setq-default evil-escape-key-sequence "hh")
  (evil-escape-mode)
#+END_SRC

*** Unbind certain Emacs keybindings in =evil-mode=
=M-.= and =M-,= are popular keybindings for "jump to definition" and
"back". =evil-mode= by default binds those to rather rarely used
functions =evil-repeat-pop-next= and =xref-pop-marker-stack=, for some reason.

#+begin_src emacs-lisp :tangle yes
  (define-key evil-normal-state-map (kbd "C-?") #'execute-extended-command)
#+end_src

#+RESULTS:

#+BEGIN_SRC emacs-lisp :tangle no
  (define-key evil-normal-state-map (kbd "M-.") nil)
  (define-key evil-normal-state-map (kbd "M-,") nil)
#+END_SRC

=M-l= and =M-l M-l= is =downcase-word=. This happens a lot by accident
for me. And undoing it often undoes _a lot_ more - like deleting whole
paragraphs of text. Also, I don't need it, because I'd use evil
bindings for that.

#+begin_src emacs-lisp :tangle no
  (define-key global-map (kbd "M-l") nil)
  (define-key evil-insert-state-map (kbd "M-l M-l") nil)
#+end_src

=M-k= is =kill-sentence=. That happens by accident, as well. And
sometimes, when in insert-mode, it even erases the history. I don't
need it, I'd use evil for that.

#+begin_src emacs-lisp :tangle no
  (define-key global-map (kbd "M-k") nil)
  (define-key evil-insert-state-map (kbd "M-k M-k") nil)
#+end_src

=TAB= is =evil-jump-forward=: Go to newer position in jump list.

#+begin_src emacs-lisp :tangle no
  (define-key global-map (kbd "<tab>") nil)
  (define-key evil-insert-state-map (kbd "<tab>") nil)
  (evil-define-key 'normal org-mode-map (kbd "<tab>") #'org-cycle)
#+end_src

*** EVIL
#+begin_quote
From the =:editor evil= module.
#+end_quote

When I want to make a substitution, I want it to be global more often than not
--- so let's make that the default.

Now, EVIL cares a fair bit about keeping compatibility with Vim's default
behaviour. I don't. There are some particular settings that I'd rather be
something else, so let's change them.

#+begin_src emacs-lisp
(after! evil
  (setq evil-ex-substitute-global t     ; I like my s/../.. to by global by default
        evil-move-cursor-back nil       ; Don't move the block cursor when toggling insert mode
        evil-kill-on-visual-paste nil)) ; Don't put overwritten text in the kill ring
#+end_src

#+RESULTS:

I don't use ~evil-escape-mode~, so I may as well turn it off, I've heard it
contributes a typing delay. I'm not sure it's much, but it is an extra
~pre-command-hook~ that I don't benefit from, so...
It seems that there's a dedicated package for this, so instead of just disabling
the mode on startup, let's prevent installation of the package.
#+begin_src emacs-lisp :tangle packages.el
(package! evil-escape :disable t)
#+end_src

#+RESULTS:
| vlf | evil-escape |
** Open file with emacsclient using =filename:line= path
   This configuration is originally from the great [[https://github.com/bbatsov/prelude/commit/8c55c6f4bb8fab04040e178b97a9e68006525403][bbatsov's prelude]].

```bash
emacsclient somefile:1234

This will open file 'somefile' and set cursor on line 1234.

#+BEGIN_SRC emacs-lisp
(defadvice server-visit-files (before parse-numbers-in-lines (files proc &optional nowait) activate)
  "Open file with emacsclient with cursors positioned on requested line.
Most of console-based utilities prints filename in format
'filename:linenumber'.  So you may wish to open filename in that format.
Just call:
  emacsclient filename:linenumber
and file 'filename' will be opened and cursor set on line 'linenumber'"
  (ad-set-arg 0
              (mapcar (lambda (fn)
                        (let ((name (car fn)))
                          (if (string-match "^\\(.*?\\):\\([0-9]+\\)\\(?::\\([0-9]+\\)\\)?$" name)
                              (cons
                               (match-string 1 name)
                               (cons (string-to-number (match-string 2 name))
                                     (string-to-number (or (match-string 3 name) ""))))
                            fn))) files)))
#+END_SRC

#+RESULTS:
: server-visit-files

** ZAP TO CHAR
Emacs provides a 'zap-to-char' command that kills from the current point to a character.  It is bound to 'M-z' in standard GNU Emacs but since Doom Emacs uses 'SPC' as its leader key and does not have 'SPC z' binded to anything, it just makes since to use it for 'zap-to-char'.  Note that 'zap-to-char' can be used with the universal argument 'SPC u' to modify its behavior.  Examples of 'zap-to-char' usage are listed in the table below:

| KEYBINDING                | WHAT IS DOES                                               |
|---------------------------+------------------------------------------------------------|
| SPC z e                   | deletes all chars to the next occurrence of 'e'            |
| SPC u 2 SPC z e           | deletes all chars to the second occurrence of 'e'          |
| SPC u - SPC z e           | deletes all chars to the previous occurrence of 'e'        |
| SPC u -2 SPC z e          | deletes all chars to the fourth previous occurrence of 'e' |
| SPC u 1 0 0 SPC u SPC z e | deletes all chars to the 100th occurrence of 'e'           |
| M-z                       | zap to char                                                |
| M-Z                       | zap up to char                                             |

=TIP:= The universal argument (SPC u) can only take a single integer by default.  If you need to use a multi-digit number (like 100 in the last example in the table above), then you must terminate the universal argument with another 'SPC u' after typing the number.

'zap-up-to-char' is an alternative command that does not zap the char specified.  It is binded to 'SPC Z'.  It can also be used in conjunction with the universal argument 'SPC u' in similar fashion to the the 'zap-to-char' examples above.

=NOTE:= Vim (evil mode) has similar functionality builtin.  You can delete to the next occurrence of 'e' by using 'dte' in normal.  To delete to the next occurrence of 'e' including the 'e', then you would use 'dfe'.  And you can modify 'dt' and 'df' by prefixing them with numbers, so '2dte' would delete to the second occurrence of 'e'.

#+BEGIN_SRC emacs-lisp
(map! :leader
      :desc "Zap to char" "z" #'zap-to-char
      :desc "Zap up to char" "Z" #'zap-up-to-char)
#+END_SRC

There are two kinds of "zap" functionality:

+ =zap-up-to-char= will delete everything from point up to the character
  you provide it with.  Think of how you may want to remove a file name
  but keep its file type extension, so =M-x zap-up-to-char RET .= will do
  just that.

+ =zap-to-char=, which is bound to =M-z= by default, will delete the target
  character as well.

I bind the former to =M-z= as I use it more often and leave its
counterpart on =M-Z= (=M-S-z=).

#+begin_src emacs-lisp
;;; Zap characters
(let ((map global-map))
  (define-key map (kbd "M-z") #'zap-up-to-char) ;;def
  (define-key map (kbd "M-Z") #'zap-to-char)) ; M-S-z
#+end_src
** easy kill
#+begin_src emacs-lisp

(use-package! easy-kill
  :ensure t
  :bind (([remap kill-ring-save] . #'easy-kill)
         ([remap mark-sexp]      . #'easy-mark)
         :map easy-kill-base-map
         ("," . easy-kill-expand))
  :config
  (add-to-list 'easy-kill-alist '(62 page "\n"))
  (add-to-list 'easy-kill-alist '(104 paragraph "\n")))
#+end_src

#+RESULTS:
: easy-kill

** atomic-chrome / GhostText: Edit text area in browser
You need to install the Firefox extension [[https://github.com/GhostText/GhostText][GhostText]]
#+BEGIN_SRC emacs-lisp :tangle no
(use-package! atomic-chrome
  :if (daemonp)
  :defer 10
  :config
  ;; Set port to a less common one
  ;; Must be changed in Firefox too!
  (setq atomic-chrome-server-ghost-text-port 8326)
  (setq atomic-chrome-default-major-mode 'gfm-mode)
  (setq atomic-chrome-url-major-mode-alist
        '(("reddit\\.com" . markdown-mode)
          ("github\\.com" . gfm-mode)
          ("gitlab\\.com" . gfm-mode)
          ("gitlab\\.paesslergmbh\\.de" . gfm-mode)
          ("gitlab\\.sovendus\\.com" . gfm-mode)
          ("lab\\.ebenefuenf\\.com" . gfm-mode)
          ("jira.sovendus.com" . jira-markup-mode)
          ("jira.paesslergmbh.de" . jira-markup-mode)))
  (atomic-chrome-start-server))
#+END_SRC

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package! (25098 24336 620398 905000) :use-package-secs (0 0 15 123000)))

** Emacs as external editor
#+begin_src emacs-lisp :tangle no

(defun dw/show-server-edit-buffer (buffer)
  ;; TODO: Set a transient keymap to close with 'C-c C-c'
  (split-window-vertically -15)
  (other-window 1)
  (set-buffer buffer))

(setq server-window #'dw/show-server-edit-buffer)
#+end_src

** monkeytype
#+begin_src emacs-lisp :tangle no
(defun my/monkeytype-mode-hook ()
  "Hooks for monkeytype-mode."
  ;; (centered-cursor-mode)
  ;; (evil-escape-mode -1)
  (evil-insert -1))
(add-hook 'monkeytype-mode-hook #'my/monkeytype-mode-hook)
#+end_src
** INSERT DATE
Some custom functions to insert the date.  The function 'insert-todays-date' can be used one of three different ways: (1) just the keybinding without the universal argument prefix, (2) with one universal argument prefix, or (3) with two universal argument prefixes.  The universal argument prefix is 'SPC-u' in Doom Emacs (C-u in standard GNU Emacs).  The function 'insert-any-date' only outputs to one format, which is the same format as 'insert-todays-date' without a prefix.

| COMMAND               | EXAMPLE OUTPUT            | KEYBINDING            |
|-----------------------+---------------------------+-----------------------|
| dt/insert-todays-date | Friday, November 19, 2021 | SPC i d t             |
| dt/insert-todays-date | 11-19-2021                | SPC u SPC i d t       |
| dt/insert-todays-date | 2021-11-19                | SPC u SPC u SPC i d t |
| dt/insert-any-date    | Friday, November 19, 2021 | SPC i d a             |

#+begin_src emacs-lisp
(defun dt/insert-todays-date (prefix)
  (interactive "P")
  (let ((format (cond
                 ((not prefix) "%A, %B %d, %Y")
                 ((equal prefix '(4)) "%m-%d-%Y")
                 ((equal prefix '(16)) "%Y-%m-%d"))))
    (insert (format-time-string format))))

(require 'calendar)
(defun dt/insert-any-date (date)
  "Insert DATE using the current locale."
  (interactive (list (calendar-read-date)))
  (insert (calendar-date-string date)))

(map! :leader
      (:prefix ("i d" . "Insert date")
        :desc "Insert any date" "a" #'dt/insert-any-date
        :desc "Insert todays date" "t" #'dt/insert-todays-date))
#+end_src
** REGISTERS
Emacs registers are compartments where you can save text, rectangles and positions for later use. Once you save text or a rectangle in a register, you can copy it into the buffer once or many times; once you save a position in a register, you can jump back to that position once or many times.  The default GNU Emacs keybindings for these commands (with the exception of counsel-register) involves 'C-x r' followed by one or more other keys.  I wanted to make this a little more user friendly, and since I am using Doom Emacs, I choose to replace the 'C-x r' part of the key chords with 'SPC r'.

| COMMAND                          | DESCRIPTION                      | KEYBINDING |
|----------------------------------+----------------------------------+------------|
| copy-to-register                 | /Copy to register/                 | SPC r c    |
| frameset-to-register             | /Frameset to register/             | SPC r f    |
| insert-register                  | /Insert contents of register/      | SPC r i    |
| jump-to-register                 | /Jump to register/                 | SPC r j    |
| list-registers                   | /List registers/                   | SPC r l    |
| number-to-register               | /Number to register/               | SPC r n    |
| counsel-register                 | /Interactively choose a register/  | SPC r r    |
| view-register                    | /View a register/                  | SPC r v    |
| window-configuration-to-register | /Window configuration to register/ | SPC r w    |
| increment-register               | /Increment register/               | SPC r +    |
| point-to-register                | /Point to register/                | SPC r SPC  |

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("r" . "registers")
       :desc "Copy to register" "c" #'copy-to-register
       :desc "Frameset to register" "f" #'frameset-to-register
       :desc "Insert contents of register" "i" #'insert-register
       :desc "Jump to register" "j" #'jump-to-register
       :desc "List registers" "l" #'list-registers
       :desc "Number to register" "n" #'number-to-register
       ;; :desc "Interactively choose a register" "r" #'counsel-register
       :desc "Interactively choose a register" "r" #'consult-register
       :desc "View a register" "v" #'view-register
       :desc "Window configuration to register" "w" #'window-configuration-to-register
       :desc "Increment register" "+" #'increment-register
       :desc "Point to register" "SPC" #'point-to-register))
#+END_SRC

#+RESULTS:
: point-to-register

** smartparens
#+begin_src emacs-lisp :tangle no

(use-package! smartparens
  :init
  (map! :map smartparens-mode-map
        "C-M-b" #'sp-backward-sexp
        "C-M-u" #'sp-backward-up-sexp
        "C-M-d" #'sp-down-sexp
        "C-M-p" #'sp-backward-down-sexp
        "C-M-n" #'sp-up-sexp
        "C-M-s" #'sp-splice-sexp
        "C-)" #'sp-forward-slurp-sexp
        "C-}" #'sp-forward-barf-sexp
        "C-(" #'sp-backward-slurp-sexp
        "C-M-)" #'sp-backward-slurp-sexp
        "C-M-)" #'sp-backward-barf-sexp))
#+end_src
** SmartParens
#+begin_src emacs-lisp :tangle no
(sp-local-pair
 '(org-mode)
 "<<" ">>"
 :actions '(insert))
#+end_src

#+begin_src emacs-lisp :tangle no

(use-package! smartparens
  :bind (:map smartparens-mode-map
              ("C-M-f" . sp-forward-sexp)
              ("C-M-b" . sp-backward-sexp)

              ("C-M-a" . sp-beginning-of-sexp)
              ("C-M-e" . sp-end-of-sexp)
              ("C-M-n" . sp-next-sexp)
              ("C-M-p" . sp-previous-sexp)

              ("C-(" . sp-forward-barf-sexp)
              ("C-)" . sp-forward-slurp-sexp)
              ("C-{" . sp-backward-barf-sexp)
              ("C-}" . sp-backward-slurp-sexp)

              ("C-k" . sp-kill-hybrid-sexp)

              ("C-," . sp-rewrap-sexp)

              :map emacs-lisp-mode-map
              (";" . sp-comment)

              :map lisp-mode-map
              (";" . sp-comment))
  :hook ((prog-mode . turn-on-smartparens-strict-mode)
         (web-mode . op/sp-web-mode)
         (LaTeX-mode . turn-on-smartparens-strict-mode))
  :custom ((sp-highlight-pair-overlay nil))
  :config
  (require 'smartparens-config)

  (with-eval-after-load 'clojure-mode
    (define-key clojure-mode-map ";" #'sp-comment))

  (with-eval-after-load 'scheme-mode
    (define-key scheme-mode-map ";" #'sp-comment))

  (sp-with-modes 'org-mode
    (sp-local-pair "=" "=" :wrap "C-="))

  (bind-key [remap c-electric-backspace] #'sp-backward-delete-char
            smartparens-strict-mode-map)

  (sp-local-pair 'log-edit-mode "`" "'")

  (defun op/sp-web-mode ()
    (setq web-mode-enable-auto-pairing nil))

  (defun op/newline-indent (&rest _ignored)
    (split-line)
    (indent-for-tab-command))

  (let ((c-like '(awk-mode c++mode cc-mode c-mode css-mode go-mode java-mode
                           js-mode json-mode python-mode web-mode es-mode
                           perl-mode lua-mode)))
    (dolist (x `(("{" . ,c-like)
                 ("[" . ,c-like)
                 ("(" . (sql-mode ,@c-like))))
      (dolist (mode (cdr x))
        (sp-local-pair mode (car x) nil :post-handlers
                       '((op/newline-indent "RET")
                         (op/newline-indent "<return>"))))))

  (defun op/inside-comment-or-string-p ()
    "T if point is inside a string or comment."
    (let ((s (syntax-ppss)))
      (or (nth 4 s)                     ;comment
          (nth 3 s))))

  (defun op/current-line-str ()
    "Return the current line as string."
    (buffer-substring-no-properties (line-beginning-position)
                                    (line-end-position)))

  (defun op/maybe-add-semicolon-paren (_id action _ctx)
    "Insert semicolon after parens when appropriat.
Mainly useful in C and derived, and only when ACTION is insert."
    (when (eq action 'insert)
      (save-excursion
        ;; caret is between parens (|)
        (forward-char)
        (let ((line (op/current-line-str)))
          (when (and (looking-at "\\s-*$")
                     (not (string-match-p
                           (regexp-opt '("if" "else" "switch" "for" "while"
                                         "do" "define")
                                       'words)
                           line))
                     (string-match-p "[\t ]" line)
                     (not (op/inside-comment-or-string-p)))
            (insert ";"))))))

  (let ((c-like-modes-list '(c-mode c++-mode java-mode perl-mode)))
    (sp-local-pair c-like-modes-list "(" nil
                   :post-handlers
                   '(:add op/maybe-add-semicolon-paren)))

  (defhydra hydra-sp (:hint nil)
    "
 Moving^^^^                       Slurp & Barf^^   Wrapping^^            Sexp juggling^^^^               Destructive
------------------------------------------------------------------------------------------------------------------------
 [_a_] beginning  [_n_] down      [_h_] bw slurp   [_R_]   rewrap        [_S_] split   [_t_] transpose   [_c_] change inner  [_w_] copy
 [_e_] end        [_N_] bw down   [_H_] bw barf    [_u_]   unwrap        [_s_] splice  [_A_] absorb      [_C_] change outer
 [_f_] forward    [_p_] up        [_l_] slurp      [_U_]   bw unwrap     [_r_] raise   [_E_] emit        [_k_] kill          [_g_] quit
 [_b_] backward   [_P_] bw up     [_L_] barf       [_(__{__[_] wrap (){}[]   [_j_] join    [_o_] convolute   [_K_] bw kill       [_q_] quit"
    ("?" (hydra-set-property 'hydra-sp :verbosity 1))

    ;; moving
    ("a" sp-beginning-of-sexp)
    ("e" sp-end-of-sexp)
    ("f" sp-forward-sexp)
    ("b" sp-backward-sexp)
    ("n" sp-down-sexp)
    ("N" sp-backward-down-sexp)
    ("p" sp-up-sexp)
    ("P" sp-backward-up-sexp)

    ;; slurping & barfing
    ("h" sp-backward-slurp-sexp)
    ("H" sp-backward-barf-sexp)
    ("l" sp-forward-slurp-sexp)
    ("L" sp-forward-barf-sexp)

    ;; wrapping
    ("R" sp-rewrap-sexp)
    ("u" sp-unwrap-sexp)
    ("U" sp-backward-unwrap-sexp)
    ("(" sp-wrap-round)
    ("[" sp-wrap-square)
    ("{" sp-wrap-curly)

    ;; sexp juggling
    ("S" sp-split-sexp)
    ("s" sp-splice-sexp)
    ("r" sp-raise-sexp)
    ("j" sp-join-sexp)
    ("t" sp-transpose-sexp)
    ("A" sp-absorb-sexp)
    ("E" sp-emit-sexp)
    ("o" sp-convolute-sexp)

    ;; destructive editing
    ("c" sp-change-inner :exit t)
    ("C" sp-change-enclosing :exit t)
    ("k" sp-kill-sexp)
    ("K" sp-backward-kill-sexp)
    ("w" sp-copy-sexp)

    ("q" nil)
    ("g" nil))

  (define-key global-map (kbd "s-g")
    (lambda ()
      (interactive)
      (hydra-set-property 'hydra-sp :verbosity 0)
      (hydra-sp/body))))
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data (:use-package! (25134 3983 706869 375000) :init (25134 3983 706498 821000) :init-secs (0 0 94934 396000) :use-package-secs (0 0 95376 547000) :config (25134 3983 706480 126000) :config-secs (0 0 94860 423000)))

** undo tree
#+begin_src emacs-lisp :tangle no

(use-package! undo-tree
  :config
  (global-undo-tree-mode 1)
  :custom
  (undo-tree-visualizer-diff nil)
  (undo-tree-visualizer-timestamps t)
  (undo-tree-visualizer-relative-timestamps t))
#+end_src
** expand region
#+begin_src emacs-lisp :tangle no
;;;----------------------------------------------------------------
;; ** EXPAND-REGION
;;;----------------------------------------------------------------
(use-package! expand-region
  :ensure t
  :commands expand-region
  :bind ("M-[" . 'er/expand-region)
     ("C--" . 'er/contract-region)
         ("C-(" . 'er/mark-outside-pairs))

  :config
  (add-to-list 'expand-region-exclude-text-mode-expansions 'org-mode)
  (add-to-list 'expand-region-exclude-text-mode-expansions 'LaTeX-mode)
  (set-default 'er--show-expansion-message t)
  (setq expand-region-show-usage-message nil)

  (defun my/find-bounds-of-regexps (open close)
    (let ((start (point))
          (parity 0)
          (open-close (concat "\\(?:" open "\\|" close "\\)")))
      (save-excursion
        (while (and (not (= parity -1))
                    (re-search-backward open-close nil t))
          (if (looking-at open)
              (setq parity (1- parity))
            (setq parity (1+ parity))))
        (push-mark)
        (goto-char start)
        (while (and (not (= parity 0))
                    (re-search-forward open-close nil t))
          (if (looking-back close)
              (setq parity (1+ parity))
            (setq parity (1- parity))))
        (when (= parity 0) (cons (mark) (point))))))
#+end_src

#+RESULTS:
: my/find-bounds-of-regexps

** String inflection

For when you want to change the case pattern for a symbol.
#+begin_src emacs-lisp :tangle packages.el
(package! string-inflection :pin "50ad54970b3cc79b6b83979bde9889ad9a9e1a9c")
#+end_src

#+begin_src emacs-lisp
(use-package! string-inflection
  :commands (string-inflection-all-cycle
             string-inflection-toggle
             string-inflection-camelcase
             string-inflection-lower-camelcase
             string-inflection-kebab-case
             string-inflection-underscore
             string-inflection-capital-underscore
             string-inflection-upcase)
  :init
  (map! :leader :prefix ("c~" . "naming convention")
        :desc "cycle" "~" #'string-inflection-all-cycle
        :desc "toggle" "t" #'string-inflection-toggle
        :desc "CamelCase" "c" #'string-inflection-camelcase
        :desc "downCase" "d" #'string-inflection-lower-camelcase
        :desc "kebab-case" "k" #'string-inflection-kebab-case
        :desc "under_score" "_" #'string-inflection-underscore
        :desc "Upper_Score" "u" #'string-inflection-capital-underscore
        :desc "UP_CASE" "U" #'string-inflection-upcase)
  (after! evil
    (evil-define-operator evil-operator-string-inflection (beg end _type)
      "Define a new evil operator that cycles symbol casing."
      :move-point nil
      (interactive "<R>")
      (string-inflection-all-cycle)
      (setq evil-repeat-info '([?g ?~])))
    (define-key evil-normal-state-map (kbd "g~") 'evil-operator-string-inflection)))
#+end_src

** Auto insert
#+begin_src emacs-lisp :tangle no
;; auto-insert-mode is an elisp library that automatically inserts text into new buffers based on the file extension or major mode. For instance, trying to open a .el (Emacs LISP) file will insert the entire GPL notice, and also other stuff. This automatic insert can be interactive, too.

(add-hook 'after-init-hook #'auto-insert-mode)

(with-eval-after-load 'autoinsert
  <<c-skeleton>>
  <<go-skeleton>>
  <<clojure-skeleton>>
  <<perl-skeleton>>
  <<svg-skeleton>>)
;; I prefer the ISC license, and tend to use that for almost all the C I write:

(define-auto-insert '("\\.c\\'" . "C skeleton")
  '("Description: "
    "/*" \n
    > "* Copyright (c) " (format-time-string "%Y") " " user-full-name " <" user-mail-address ">" \n
    > "*" \n
    > "* Permission to use, copy, modify, and distribute this software for any" \n
    > "* purpose with or without fee is hereby granted, provided that the above" \n
    > "* copyright notice and this permission notice appear in all copies." \n
    > "*" \n
    > "* THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES" \n
    > "* WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF" \n
    > "* MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR" \n
    > "* ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES" \n
    > "* WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN" \n
    > "* ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF" \n
    > "* OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE." \n
    > "*/" \n
    \n
    > _ \n
    \n))
;; I added a skeleton for go files:

(define-auto-insert
  '("\\.go\\'" . "Go skeleton")
  '("Short description: "
    "package "
    (completing-read "Go package: "
                     `("main" ,(file-name-nondirectory
                                (directory-file-name default-directory))))
    \n \n > _ \n))
;; The clojure  skeleton inserts the correct ns form at the top of the buffer:

(defun op/cloj-ns ()
  "Return the clojure namespace (as string) for the current file.
Stolen from the ``ns'' yasnippet from yasnippet-snippets."
  (cl-flet ((try-src-prefix
             (path src-prfx)
             (let ((parts (split-string path src-prfx)))
               (when (= (length parts) 2)
                 (cadr parts)))))
    (let* ((p (buffer-file-name))
           (p2 (cl-first
                (cl-remove-if-not #'identity
                                  (mapcar (lambda (prfx)
                                            (try-src-prefix p prfx))
                                          '("/src/cljs/" "/src/cljc/" "/src/clj/" "/src/" "/test/")))))
           (p3 (file-name-sans-extension p2))
           (p4 (mapconcat #'identity
                          (split-string p3 "/")
                          ".")))
      (replace-regexp-in-string "_" "-" p4))))

(define-auto-insert
  '("\\.\\(clj\\|cljs\\|cljc\\)\\'" . "Clojure skeleton")
  '("Short description: "
    "(ns " (op/cloj-ns) ")" \n \n
    > _ \n))
(define-auto-insert '("\\.pl\\'" . "Perl skeleton")
  '("Name: "
    "#!/usr/bin/env perl" \n
    "#" \n
    "# Copyright (c) " (format-time-string "%Y") " " user-full-name " <" user-mail-address ">" \n
    "#" \n
    "# Permission to use, copy, modify, and distribute this software for any" \n
    "# purpose with or without fee is hereby granted, provided that the above" \n
    "# copyright notice and this permission notice appear in all copies." \n
    "#" \n
    "# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES" \n
    "# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF" \n
    "# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR" \n
    "# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES" \n
    "# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN" \n
    "# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF" \n
    "# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE." \n
    \n
    "use v5.10;" \n
    "use strict;" \n
    "use warnings;" \n \n
    _ \n \n
    "__END__" "\n\n"
    "=head1 NAME" "\n\n"
    str "\n\n"
    "=head1 SYNOPSIS" "\n\n\n"
    "=head1 DESCRIPTION" "\n\n\n"
    "=cut" "\n"))
;; I'm also writing some small SVGs in Emacs, and I keep forgetting the right xmlns…

(define-auto-insert '("\\.svg\\'" . "SVG Skeleton")
  '("Name: "
    "<svg xmlns=\"http://www.w3.org/2000/svg\"" \n
    "    version=\"1.1\"" \n
    "    width=\"\"" \n
    "    height=\"\">"
    "  " _ \n
    "</svg>"))

#+end_src
** Tabs, indentation, and the TAB key
:PROPERTIES:
:CUSTOM_ID: h:d51d37df-4e58-4e0b-85a1-019ceda342f6
:END:

I believe tabs, in the sense of inserting the tab character, are best
suited for indentation.  While spaces are superior at precisely aligning
text.  However, I understand that elisp uses its own approach, which I
do not want to interfere with.  Also, Emacs tends to perform alignments
by mixing tabs with spaces, which /can actually lead to misalignments/
depending on certain variables such as the size of the tab.  As such, I
am disabling tabs by default.

If there ever is a need to use different settings in other modes, we can
customise them via hooks.  This is not an issue I have encountered yet
and am therefore refraining from solving a problem that does not affect
me.

Note that =tab-always-indent= will first do indentation and then try to
complete whatever you have typed in.

#+begin_src emacs-lisp
;;; Tabs, indentation, and the TAB key
(setq-default tab-always-indent 'complete)
(setq-default tab-first-completion 'word-or-paren-or-punct) ; Emacs 27
(setq-default tab-width 4)
(setq-default indent-tabs-mode nil)
#+end_src


This section is all about configurations and/or packages that deal with
natural or programming language enhancements.

** Configure 'electric' behaviour

Emacs labels as "electric" any behaviour that involves contextual
auto-insertion of characters.  while the idea is neat, I generally
dislike it because of its false positives.  This is a summary of my
settings:

+ If =electric-pair-mode= is enabled (which I might do manually), insert
  quotes and brackets in pairs.  Only do so if there is no alphabetic
  character after the cursor.
+ The cryptic numbers in the pairs set, correspond to curly single and
  double quotes and these =«»=.  The contents of this set are always
  inserted in pairs, regardless of major mode.  To get those numbers,
  evaluate =(string-to-char CHAR)= where CHAR is the one you are
  interested in.  For example, get the literal tab's character with
  =(string-to-char "\t")=.
+ While inputting a pair, inserting the closing character will just skip
  over the existing one, rather than add a new one.  So typing =(= will
  insert =()= and then typing =)= will just be the same as moving forward
  one character =C-f=.
+ Do not skip over whitespace when operating on pairs.  Combined with
  the above point, this means that a new character will be inserted,
  rather than be skipped over.  I find this better, because it prevents
  the point from jumping forward, plus it allows for more natural
  editing.
+ The whitespace characters are space (=\s=), tab (=\t=), and newline (=\n=).
+ The rest concern the conditions for transforming quotes into their
  curly equivalents.  I keep this disabled, because curly quotes are
  distinct characters.  It is difficult to search for them.  Just note
  that on GNU/Linux you can type them directly by hitting the "compose"
  key and then an angled bracket (=<= or =>=) followed by a quote mark.

#+begin_src emacs-lisp :tangle no
;;; Configure 'electric' behaviour
(use-package! electric
  (setq electric-pair-inhibit-predicate 'electric-pair-conservative-inhibit)
  (setq electric-pair-preserve-balance t)
  (setq electric-pair-pairs
        '((8216 . 8217)
          (8220 . 8221)
          (171 . 187)))
  (setq electric-pair-skip-self 'electric-pair-default-skip-self)
  (setq electric-pair-skip-whitespace nil)
  (setq electric-pair-skip-whitespace-chars '(9 10 32))
  (setq electric-quote-context-sensitive t)
  (setq electric-quote-paragraph t)
  (setq electric-quote-string nil)
  (setq electric-quote-replace-double t)
  (electric-pair-mode -1)
  (electric-quote-mode -1)
  ;; I don't like auto indents in Org and related.  They are okay for
  ;; programming.
  (electric-indent-mode -1)
  (add-hook 'prog-mode-hook #'electric-indent-local-mode))
#+end_src

#+RESULTS:

** Parentheses (show-paren-mode)

Configure the mode that highlights matching delimiters or parentheses.
I consider this of utmost importance when working with languages such as
elisp.

Summary of what these do:

+ Activate the mode upon startup.
+ Show the matching delimiter/parenthesis if on screen, else show
  nothing.  It is possible to highlight the expression enclosed by the
  delimiters, by using either =mixed= or =expression=.  The latter always
  highlights the entire balanced expression, while the former will only
  do so if the matching delimiter is off screen.
+ =show-paren-when-point-in-periphery= lets you highlight parentheses even
  if the point is in their vicinity.  This means the beginning or end of
  the line, with space in between.  I used that for a long while and it
  server me well.  Now that I have a better understanding of Elisp, I
  disable it.
+ Do not highlight a match when the point is on the inside of the
  parenthesis.

#+begin_src emacs-lisp :tangle no
;;; Parentheses (show-paren-mode)
(use-package! paren
  :ensure nil
  :config
  (setq show-paren-style 'parenthesis)
  (setq show-paren-when-point-in-periphery nil)
  (setq show-paren-when-point-inside-paren nil)
  (setq show-paren-context-when-offscreen 'child-frame) ; Emacs 29
  (add-hook 'after-init-hook #'show-paren-mode))
#+end_src

#+RESULTS:
: t

** EVALUATE ELISP EXPRESSIONS
Changing some keybindings from their defaults to better fit with Doom Emacs, and to avoid conflicts with my window managers which sometimes use the control key in their keybindings.  By default, Doom Emacs does not use 'SPC e' for anything, so I choose to use the format 'SPC e' plus 'key' for these (I also use 'SPC e' for 'eww' keybindings).

| COMMAND         | DESCRIPTION                                  | KEYBINDING |
|-----------------+----------------------------------------------+------------|
| eval-buffer     | /Evaluate elisp in buffer/                     | SPC e b    |
| eval-defun      | /Evaluate the defun containing or after point/ | SPC e d    |
| eval-expression | /Evaluate an elisp expression/                 | SPC e e    |
| eval-last-sexp  | /Evaluate elisp expression before point/       | SPC e l    |
| eval-region     | /Evaluate elisp in region/                     | SPC e r    |

#+Begin_src emacs-lisp
(map! :leader
      (:prefix ("e". "evaluate/EWW")
       :desc "Evaluate elisp in buffer" "b" #'eval-buffer
       :desc "Evaluate defun" "d" #'eval-defun
       :desc "Evaluate elisp expression" "e" #'eval-expression
       :desc "Evaluate last sexpression" "l" #'eval-last-sexp
       :desc "Evaluate elisp in region" "r" #'eval-region))
#+END_SRC

** Fillng
This is a useful function copied from somewhere I don't remember, sorry unknown author!

It makes fill-paragraph "toggable": M-q once to fill, M-q again to un-fill!

#+begin_src emacs-lisp :tangle no
(defun op/fill-or-unfill (fn &optional justify region)
  "Meant to be an adviced :around `fill-paragraph'.
FN is the original `fill-column'.  If `last-command' is
`fill-paragraph', unfill it, fill it otherwise.  Inspired from a
post on endless parentheses.  Optional argument JUSTIFY and
REGION are passed to `fill-paragraph'."
  (let ((fill-column
         (if (eq last-command 'fill-paragraph)
             (progn (setq this-command nil)
                    (point-max))
           fill-column)))
    (funcall fn justify region)))
(advice-add 'fill-paragraph :around #'op/fill-or-unfill)
#+end_src

#+RESULTS:

** keychord
In case  I  don’t use Evil (Vim emulation), which would add an extra layer of complexity to everything. Instead, I heavily leverage key-chord.el, which enables binding simultaneous key presses (chords) to commands.
I have some custom code to bind chords to Doom’s leaders. Many commonly used commands are bound in these “key chord maps”.
Enable the key chord package
Set hardware-specific delay. Tweak this if:

there are false keychords triggered when typing fast (delay too large)
if expected keychords don’t register (delay too small)
there’s a noticable lag when typing normally (delay too large)
#+begin_src emacs-lisp :tangle no
(use-package! key-chord
  :config
  ;; (key-chord-mode 1)
  (setq key-chord-one-key-delay 0.10 ; same key (e.g. xx) 20 delay
        key-chord-two-keys-delay 0.05))
#+end_src

#+RESULTS:
: t

#+begin_src emacs-lisp :tangle no

  (key-chord-define-global ",." 'end-of-buffer)
  ;; FIXME: accidentally triggered too often
  (key-chord-define-global "zx" 'beginning-of-buffer)

  (key-chord-define-global "qw" 'delete-window)
  (key-chord-define-global "qp" 'delete-other-windows)
  (key-chord-define-global ",," 'doom/open-scratch-buffer)

  (key-chord-define-global "fk" 'other-window)
  (key-chord-define-global "jd" 'rev-other-window)
(key-chord-define-global "JJ" 'previous-buffer)
  (key-chord-define-global "KK" 'next-buffer)


  (key-chord-define-global "hh" 'helpful-at-point)
  (key-chord-define-global "hk" 'helpful-key)
  (key-chord-define-global "hv" 'helpful-variable)

  ;; no bueno: e.g. "pathfinder", "highfidelity"
  ;; (key-chord-define-global "hf" 'helpful-function)

  (key-chord-define-global "vn" 'split-window-vertically-and-switch)
  (key-chord-define-global "vm" 'split-window-vertically-and-switch) ; ergodox
  (key-chord-define-global "hj" 'split-window-horizontally-and-switch)

  (key-chord-define-global "jm" 'my/duplicate-line-or-region)
  (key-chord-define-global "fv" 'comment-line)

  (key-chord-define-global "kl" 'er/expand-region)

  (key-chord-define-global "xx" 'execute-extended-command)
  (key-chord-define-global "xf" 'find-file)

  (key-chord-define-global "jp" 'my/insert-jupyter-python-block)
#+end_src
** Regex

Better regex than emacs regex
#+begin_src emacs-lisp :tangle no
(package! visual-regexp)
(package! visual-regexp-steroids)
#+end_src
#+begin_src emacs-lisp :tangle yes
(use-package! visual-regexp
  :config
        (map! :map 'doom-leader-regular-map
              (:prefix ("v" . "visual regex")
               :desc "Replace regexp" "r"#'vr/replace)))

(use-package! visual-regexp-steroids
  :after 'visual-regexp)
#+end_src

#+RESULTS:

** Docs
#+begin_src emacs-lisp :tangle yes
(use-package! devdocs
  :after lsp
  :config
  (add-hook! 'devdocs-mode-hook
    (face-remap-add-relative 'variable-pitch '(:family "Noto Sans"))))
#+end_src
** DONE LSP
CLOSED: [2022-09-22 Thu 12:20]
LSP auto format is nice, but not as configurable as prettier, better let prettier handle it.
#+begin_src emacs-lisp :tangle yes
(add-hook! 'after-init-hook
           (progn
  (setq-hook! 'typescript-mode-hook +format-with :nil)
  (add-hook! 'typescript-mode-hook 'prettier-mode)
  (setq-hook! 'rjsx-mode-hook +format-with :nil)
  (add-hook! 'rjsx-mode-hook 'prettier-mode)
  (setq-hook! 'js2-mode-hook +format-with :nil)
  (add-hook! 'js2-mode-hook 'prettier-mode)
  (setq-hook! 'typescript-tsx-mode-hook +format-with :nil)
  (add-hook! 'typescript-tsx-mode-hook 'prettier-mode)
  ))
#+end_src

** Very large files

The /very large files/ mode loads large files in chunks, allowing one to open
ridiculously large files.

#+begin_src emacs-lisp :tangle packages.el
(package! vlf :recipe (:host github :repo "emacs-straight/vlf" :files ("*.el"))
  :pin "cacdb359f8c37c6e7e4c7937462b632d22462130")
#+end_src

To make VLF available without delaying startup, we'll just load it in quiet moments.

#+begin_src emacs-lisp :noweb no-export :noweb-prefix no
(use-package! vlf-setup
  :defer-incrementally vlf-tune vlf-base vlf-write
  vlf-search vlf-occur vlf-follow vlf-ediff vlf
  :commands vlf vlf-mode
  :init
  <<vlf-largefile-prompt>>
  :config
  (advice-remove 'abort-if-file-too-large #'ad-Advice-abort-if-file-too-large)
  <<vlf-linenum-offset>>)
#+end_src

#+RESULTS:

Now, there are one or two tweaks worth applying to VLF. For starters, it goes to
the liberty of advising ~abort-if-file-too-large~, and in doing so removes the
option of opening files literally. I think that's a bit much, so we can remove
the advice and instead override ~files--ask-user-about-large-file~ (the more
appropriate function, I think) as a simpler approach, just sacrificing the
original behaviour with src_elisp{(setq vlf-application 'always)} (which I can't
imagine using anyway).

#+name: vlf-largefile-prompt
#+begin_src emacs-lisp :tangle no
(defadvice! +files--ask-about-large-file-vlf (size op-type filename offer-raw)
  "Like `files--ask-user-about-large-file', but with support for `vlf'."
  :override #'files--ask-user-about-large-file
  (if (eq vlf-application 'dont-ask)
      (progn (vlf filename) (error ""))
    (let ((prompt (format "File %s is large (%s), really %s?"
                          (file-name-nondirectory filename)
                          (funcall byte-count-to-string-function size) op-type)))
      (if (not offer-raw)
          (if (y-or-n-p prompt) nil 'abort)
        (let ((choice
               (car
                (read-multiple-choice
                 prompt '((?y "yes")
                          (?n "no")
                          (?l "literally")
                          (?v "vlf"))
                 (files--ask-user-about-large-file-help-text
                  op-type (funcall byte-count-to-string-function size))))))
          (cond ((eq choice ?y) nil)
                ((eq choice ?l) 'raw)
                ((eq choice ?v)
                 (vlf filename)
                 (error ""))
                (t 'abort)))))))
#+end_src

#+RESULTS: vlf-largefile-prompt

As you go from one chunk fetched by VLF to the next, the displayed line number
of the first line /in each chunk/ is unchanged. I think it's reasonable to hope
for an /overall/ line number, and by tracking chunk's cumulative line numbers we
can implement this behaviour fairly easily.

#+name: vlf-linenum-offset
#+begin_src emacs-lisp :tangle no
(defvar-local +vlf-cumulative-linenum '((0 . 0))
  "An alist keeping track of the cumulative line number.")

(defun +vlf-update-linum ()
  "Update the line number offset."
  (let ((linenum-offset (alist-get vlf-start-pos +vlf-cumulative-linenum)))
    (setq display-line-numbers-offset (or linenum-offset 0))
    (when (and linenum-offset (not (assq vlf-end-pos +vlf-cumulative-linenum)))
      (push (cons vlf-end-pos (+ linenum-offset
                                 (count-lines (point-min) (point-max))))
            +vlf-cumulative-linenum))))

(add-hook 'vlf-after-chunk-update-hook #'+vlf-log-poses-a)) ;;look here if end of file

;; Since this only works with absolute line numbers, let's make sure we use them.
;; gadd-hook! 'vlf-mode-hook (setq-local display-line-numbers t)
#+end_src

#+RESULTS: vlf-linenum-offset
| +vlf-log-poses-a |

The other thing that doesn't work too well with VLF is searching with anything
other than =M-x occur=. This is because trying to go to the next match at the end
of a chunk usually wraps the point to the beginning of the chunk, instead of
moving to the next chunk.

#+begin_src emacs-lisp :tangle no
(defun +vlf-next-chunk-or-start ()
  (if (= vlf-file-size vlf-end-pos)
      (vlf-jump-to-chunk 1)
    (vlf-next-batch 1))
  (goto-char (point-min)))

(defun +vlf-last-chunk-or-end ()
  (if (= 0 vlf-start-pos)
      (vlf-end-of-file)
    (vlf-prev-batch 1))
  (goto-char (point-max)))

(defun +vlf-isearch-wrap ()
  (if isearch-forward
      (+vlf-next-chunk-or-start)
    (+vlf-last-chunk-or-end)))

(add-hook! 'vlf-mode-hook (setq-local isearch-wrap-function #'+vlf-isearch-wrap))
#+end_src

#+RESULTS:

Unfortunately, since evil-search doesn't have an analogue to
~isearch-wrap-function~, we can't easily add support to it.
** Smart Move to beginning of line
#+begin_src emacs-lisp

(defun my-smarter-move-beginning-of-line (arg)
  "Move point back to indentation of beginning of line.

      Move point to the first non-whitespace character on this line.
      If point is already there, move to the beginning of the line.
      Effectively toggle between the first non-whitespace character and
      the beginning of the line.

      If ARG is not nil or 1, move forward ARG - 1 lines first.  If
      point reaches the beginning or end of the buffer, stop there."
  (interactive "^p")
  (setq arg (or arg 1))

  ;; Move lines first
  (when (/= arg 1)
    (let ((line-move-visual nil))
      (forward-line (1- arg))))

  (let ((orig-point (point)))
    (back-to-indentation)
    (when (= orig-point (point))
      (move-beginning-of-line 1))))

;; remap C-a to `smarter-move-beginning-of-line'
(global-set-key [remap evil-beginning-of-line]
                'my-smarter-move-beginning-of-line)
#+end_src
* SHELLS
** desc
Eshell is a strictly line-oriented command prompt written in Emacs Lisp.
This comes with its pros and cons: it can understand Elisp but does not
behave exactly like Unix shells, say, Bash.  Eshell cannot display the
kind of pseudo graphics a terminal emulator can, such as those you find
in =mutt=, =htop=, =ncmpcpp=, =newsboat= and so on.  As each user's needs are
different, you will have to determine whether Eshell can fit into your
workflow.  Start by reading its fairly short, yet insightful, manual.

For me this tool is one of the most promising in the Emacs milieu
because while it is a competent shell it can seamlessly integrate with
the rest of Emacs' capabilities.  This is best exemplified by its
extensibility, such as what I am doing with =prot-eshell.el=.  More on
that below.

The fact that Eshell cannot reproduce the artefacts of the ncurses
library does not pose a hindrance to my workflow, as I have replacements
for all such "graphical" programs within Emacs.  Notmuch has an Emacs
client which handles my email (yes, the CLI works as well), =M-x proced=
lets me interact with system processes, Bongo deals with media playback,
while Elfeed fills the niche of following RSS/Atom feed.

Read relevant sections:

+ [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].
+ [[#h:6b56ce11-c84c-4b6d-98c7-bc3eefbe9325][Proced (process monitor, similar to `top')]].
+ [[#h:758afe0d-bc7c-4afc-9c6b-b5e569901591][Bongo (music or media manager)]].
+ [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed (RSS/Atom feed reader)]].

Now an overview of =prot-eshell.el=, with the full code reproduced right
after the package configurations:

+ There are several =prot-eshell-ffap-*= commands that operate on the file
  at point.  Say you have called =ls= and wish to expand the contents of a
  file at the command prompt.  With point over the file name of
  interest, use =prot-eshell-ffap-insert=.  Wish to visit the file
  instead, so that you may edit it?  Try =prot-eshell-ffap-find-file=.
  The command =prot-eshell-ffap-kill-save= copies the file's full file
  system path, while =prot-eshell-ffap-dired-jump= opens a Dired buffer in
  that file's directory (see [[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

+ =prot-eshell-export= takes the prompt and output of the last command and
  places it in a bespoke buffer.  The name of the buffer is controlled
  by the variable =prot-eshell-output-buffer=.  If that buffer does not
  exist, it is created.  Otherwise subsequent invocations of this
  "export" command will append their contents to the existing ones.
  This is good for keeping a record of something you are working on.
  And because this is a standard buffer, you can edit it at will as well
  as call =write-file= (=C-x C-w=) to save it permanently to a file.

+ =prot-eshell-redirect-to-buffer= provides a completion prompt to help
  you redirect the output of a command to a given buffer.  Simple and
  effective.

+ =prot-eshell-narrow-output-highlight-regexp= prompts for a regexp to
  highlight in the output of the last command.  It then narrows the
  Eshell buffer to the contents of that output and emphasises the
  matches of the regexp.  Very useful when you need to inspect some logs
  or other terse output.  Remember that to widen the view you use the
  standard =widen= command, bound to =C-x n w= by default.

+ =prot-eshell-complete-history= lets you pick a command from your history
  using minibuffer completion.  Forget about a non-interactive regexp
  search or, worse, consecutive calls to =M-p= and =M-n= to cycle through
  your recent inputs one at a time.

+ =prot-eshell-complete-recent-dir= provides a minibuffer prompt with
  completion that queries through all paths in your =cd= input history.
  This is much more convenient that standard actions like =cd -= or =cd -N=
  where =N= is the position of the item in the history of entries
  (retrieved with =cd ==).

+ =prot-eshell-find-subdirectory-recursive= uses completion to help you
  pick a subdirectory that extends the present working directory.  It
  does so recursively, which makes it powerful, but can cause problems
  when called from the root of some massive directory tree.  Exercise
  restraint.

+ =prot-eshell-root-dir= switches the present working directory to that of
  the current project's root directory, if one is found.

Here is a [[https://protesilaos.com/codelog/2020-05-08-emacs-eshell-demo/][video on Eshell and my extras]] (2020-05-08) which, however,
showcases older code than what I have here.

For further inspiration, check these valuable resources (in no
particular order):

+ [[https://cestlaz.github.io/post/using-emacs-66-eshell-elisp][Mike Zamansky's video demo]] that also shows how to program an Eshell
  switcher.
+ [[https://www.youtube.com/watch?v=RhYNu6i_uY4][Howard Abrahams' video]] that covers the features of Eshell.
+ [[https://ambrevar.xyz/emacs-eshell/][Pierre Neidhardt's detailed blog post]] on the pros and cons of Eshell.
+ [[https://git.spwhitton.name/dotfiles][Sean Whitton's comprehensive dotfiles repository]] which includes lots
  of useful snippets, including for Eshell.  Some commands/functions of
  mine are either copied or adapted from Sean's implementation,
  following the review that was done on 2022-01-04.

It should come to no surprise that Emacs can operate as both a /terminal
emulator for command line shells/ and /toolkit for terminal emulators/.
The present section covers only the former category as I never use the
likes of =ansi-term= or =vterm=.
** Eshell

Settings for the various shells and terminal emulators within Emacs.
+ 'shell-file-name' -- sets the shell to be used in M-x shell, M-x term, M-x ansi-term and M-x vterm.
+ 'eshell-aliases-file' -- sets an aliases file for the eshell.

#+BEGIN_SRC emacs-lisp
(setq shell-file-name "/bin/bash"
      vterm-max-scrollback 5000)
(setq eshell-rc-script "~/.config/doom/eshell/profile"
      eshell-aliases-file "~/.config/doom/eshell/aliases"
      eshell-history-size 50000
      eshell-buffer-maximum-lines 50000
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      eshell-destroy-buffer-when-process-dies t
      eshell-visual-commands'("bash" "fish" "htop" "ssh" "top" "zsh"))
(map! :leader
      :desc "Eshell" "e s" #'eshell
      :desc "Eshell popup toggle" "e t" #'+eshell/toggle
      ;; :desc "Counsel eshell history" "e h" #'counsel-esh-history
      :desc "Counsel eshell history" "e h" #'+eshell/search-history
      :desc "Vterm popup toggle" "v t" #'+vterm/toggle)
#+END_SRC

#+RESULTS:
: +vterm/toggle

* DIRED
Dired is the file manager within Emacs.  Below, I setup keybindings for image previews (peep-dired).  Doom Emacs does not use 'SPC d' for any of its keybindings, so I've chosen the format of 'SPC d' plus 'key'.
*** desc
The directory editor abbreviated as "Dired" (which I pronounce like
"tired", "mired", etc.) is a built-in tool that performs file management
operations inside of an Emacs buffer.  It is simply superb!  I use it
daily for a number of tasks.

You can interactively copy, move (rename), symlink, delete files and
directories, handle permissions, compress or extract archives, run shell
commands, combine Dired with regular editing capabilities as part of a
keyboard macro, search[+replace] across multiple files, encrypt/decrypt
files, start an email with the current or marked files attached to the
message, and more.  Combine that with the possibility of matching items
with regular expressions, such as for marking files or narrowing the
list, or creating an editable Dired buffer to bulk rename entries, and
you have everything you need to maximise your productivity.

Watch some of my older videos:

+ [[https://protesilaos.com/codelog/2019-08-12-emacs-dired-tweaks/][Dired tweaks and refinements]] (2019-08-12).
+ [[https://protesilaos.com/codelog/2019-09-03-emacs-dired-macros/][Use Dired and keyboard macros]] (2019-09-03).
+ [[https://protesilaos.com/codelog/2019-09-19-dired-narrow/][Techniques to narrow Dired]] (2019-09-19).
+ [[https://protesilaos.com/codelog/2019-11-16-emacs-dired-chmod/][Change multi-file permissions with Dired]] (2019-11-16).
+ [[https://protesilaos.com/codelog/2019-11-13-emacs-bongo-music/][Music management with Dired and Bongo]] (2019-11-13).
+ [[https://protesilaos.com/codelog/2019-11-18-emacs-dired-bongo/][Dired+Bongo and macros to handle music playlists]] (2019-11-18).
+ [[https://protesilaos.com/codelog/2019-12-08-emacs-multi-replace/][Search and replace across multiple files (not Dired-specific)]] (2019-12-08).

The following package configurations are fairly comprehensive.  First an
overview of the options I specify for Dired proper:

+ Copy and delete recursively.  No need to be prompted about each
  action.

+ While in detailed view, search only file names when point is on one of
  them, else apply the query to the rest of the data.

+ Deletion sends items to the system's Trash, making it safer than the
  standard =rm=.  The trash can be a life-saver, as it lets you restore
  deleted files (check: [[#h:954adfb4-8f2c-4665-bb5b-e098926341b0][dired-like mode for the trash (trashed.el)]]).

+ Reformat output.  Sort directories first.  Show dotfiles and place
  them before anything else.  Omit implicit directories (the single and
  double dots).  Use human-readable size units.  To learn everything
  about these switches, you need to read the manpage of =ls=.  You can do
  so with =M-x man RET ls= or =M-x woman=.

  - Note that =dired-listing-switches= and =find-ls-option= are configured
    to show hidden directories and files /before/ their non-hidden
    counterparts.  If you want to reverse this order, you must include
    the =-X= option (such as =-AFXhlv --group-directories-first=).

  -  find-name-dired

+ Hide all the details by default (permissions, size, etc.).  Those can
  easily be toggled on with the left parenthesis.  Also enable
  highlighting of the current line (=hl-line-mode=), which makes it even
  easier to spot the current item (I do not enable this globally,
  because I only want it for line-oriented interfaces, such as Dired's,
  but not for text editing).

+ While having two dired buffers open, the rename and copy operations
  will place the path of the inactive one as the target destination.
  When multiple dired buffers are present, this works between the
  current and most recently used ones, with =M-n= and =M-p= on the
  minibuffer prompt allowing you to switch between all possible targets.

+ For Emacs 27.1 or higher, Dired can automatically create destination
  directories for its copy and rename operations.  So you can, for
  example, move (copy or rename) =file= to =/non-existent-path/file= and you
  will get what you want right away.

+ For Emacs 27.1 or higher, renaming a file of a version-controlled
  repository (git) will be done using the appropriate VC mechanism.
  This is to ensure that file name changes are tracked correctly (also
  check my detailed: [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]).

And here are a few words about the more specialised parts of the Dired
ecosystem:

+ Dired subtree :: This third-party package which is part of the
  [[https://github.com/Fuco1/dired-hacks][dired-hacks project by Matus Goljer]] offers tree-style navigation,
  meaning that the subdirectories of the current Dired buffer can be
  expanded and contracted in place.  It is possible to perform the same
  kind of folding on their subdirectories, and so on.

  Tree-style navigation is useful in my workflow when all I want is a
  quick peek at a directory's contents.

+ Dired extras (dired-x) :: These are some additional features that are
  shipped with Emacs.  The one I need the most is =dired-jump= and its
  "other window" variant.  These are among my favourite commands.  They
  will always take you to the directory that contains the current
  buffer. (Note for Emacs 28 users: =dired-jump= is now part of =dired.el=).

  'Jumping' works even when you are inside buffers that do not visit
  files, such as Magit, Diff, or Eshell: it just takes you to the
  =default-directory=.  This is its most valuable quality!  Edit a file
  then proceed to do some file management, then invoke =previous-buffer=
  or =winner-undo= to go back to where you were (I have a few key bindings
  for those in the [[#h:12591f89-eeea-4b12-93e8-9293504e5a12][Window configuration section]]).  Everything happens
  naturally.  Emacs' interconnectedness at its best!

  The other neat features of =dired-x= are (1) its ability to open Info
  files in place (=dired-info= command, bound to =I=), and (2) to open all
  marked files at once (=dired-do-find-marked-files= bound to =F= by
  default).

+ Writable Dired (wdired) :: This is the standard editable state of a
  dired buffer.  You can access it with =C-x C-q=.  Write changes to files
  or directories, as if it were a regular buffer, then confirm them with
  =C-c C-c=.  This practically means that you can rename files and change
  permissions (when the detailed list is available).  Note that while
  renaming a file, any forward slash is treated like a directory and *is
  created directly* upon successful exit.  Combine this utility with
  keyboard macros, rectangle edits, or =query-replace= (and its regexp
  variant---[[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, grep, and extras (prot-search.el)]]) and you
  have one potent tool at your disposal.

+ Image dired :: This built-in library offers facilities for generating
  thumbnails out of a selection of images and displaying them in a
  separate buffer.  An external program is needed to convert the images
  into thumbnails: =imagemagick=.  Other useful external packages are
  =optipng= and =sxiv= (or equivalent).  The former is for operating on PNG
  files, while the latter is a lightweight image viewer.  I feel this
  process is a bit cumbersome and can be very slow if you try to
  generate lots of images at once.  The culprit is the image converter.
  As such, only use this for smaller collections.  Besides, Emacs can
  open an image in a buffer and that works well for viewing individual
  items (else use =!= or =&= to run an external process, with the latter
  being asynchronous).  I don't keep a lot of images around, so I am not
  the best person to comment on this feature.  Instead, I recommend you
  view the video of [[https://www.youtube.com/watch?v=NrY3t3W0_cM][image-dired by Emacs Elements (Raoul Comninos)]].

+ prot-dired.el :: This file (reproduced in its entirety below those
  configurations) contains a few custom extensions for streamlining some
  repetitive tasks.  The video on [[https://protesilaos.com/codelog/2021-07-21-emacs-dired-custom-extras/][my custom Dired extras]] (2021-07-21)
  may also be of help.

  1. It contains methods for opening media files using an external
     program.  The idea is to provide a default option when invoking
     either =!= or =&= on a given file.  So if, for example, you try to open
     an image, it will search the system for the first program matching
     the elements in the =prot-dired-image-viewers= variable.  Same
     principle for media players.

  2. The =prot-dired-limit-regexp= command is a convenience wrapper around
     built-in capabilities of narrowing the listing to the files that
     match (or don't) a given regular expression.  When called directly,
     it prompts for a regexp and removes everything that does not match
     it.  This operation does not delete files.  It just hides them
     (restore the view either with =g= or by using the =undo= command).
     When the command is invoked with a universal prefix argument (=C-u=)
     it inverts the meaning of the regular expression so that it hides
     the matching entries.

  3. The =prot-dired-insert-subdir= is a general purpose command for
     inserting the contents of a subdirectory in the current Dired
     buffer.  It basically provides a superset of features found in the
     standard =dired-maybe-insert-subdir= (bound to =i= by default).  When
     items are marked, it searches among them for the subdirectories to
     the current directory and inserts them in the buffer, while
     ignoring invalid entries.  If no marks are active and point is on a
     subdirectory line, it inserts it directly.  If no marks are active
     and point is not on a subdirectory, then it prompts for minibuffer
     completion and inserts the selected item.  When invoked with a
     single prefix argument (=C-u=) it first asks for the command-line
     flags to pass to the underlying =ls= program, which can be helpful if
     you want to get some more verbose information or pass the =-R= flag
     to directly insert a tree recursively.  And when the command is
     called with a double prefix argument (=C-u C-u=) it removes all
     inserted subdirectories in one go.  As always, the =undo= command can
     help you manage each step.

     Tip: to remove a single subdirectory, you can still use =C-u k= over
     its heading (=dired-do-kill-lines= with its ARG).

     Another tip: to update the =ls= switches for the whole buffer, type
     =C-u s= (=dired-sort-toggle-or-edit= with its ARG).

  4. An Imenu index is set up which lets you jump to the headers of all
     inserted directories using minibuffer completion (either with the
     generic =M-x imenu= or some third-party variant).  The are commands
     which provide directional motions to move between such headings:
     =prot-dired-subdirectory-next= and =prot-dired-subdirectory-previous=.

  5. The command =prot-dired-grep-marked-files= streamlines a common
     workflow I have of using =find= on the command line to grep for file
     contents.  It performs a search in the marked files.  When no items
     are marked, it goes through all files in the current directory
     (non-recursive).  Its doc string covers the technicalities.  The
     command serves as a specialised variant of =prot-search-grep=
     ([[#h:b67687ee-25a3-4bf4-a924-180ccb63c629][Isearch, occur, grep, and extras (prot-search.el)]]).

** Dired Conf
#+begin_src emacs-lisp
;; C-u s for flags
;; (use-package! all-the-icons-dired)

  ;; (dired-listing-switches "-NGalhv --group-directories-first")
(use-package! dired
  :ensure nil
  ;; :straight nil
  :defer 1
  :commands (dired dired-jump)
  :config
  (setq dired-recursive-copies 'always)
  (setq dired-recursive-deletes 'always)
  (setq delete-by-moving-to-trash t)
  (setq dired-listing-switches
        "-AGFhlv --group-directories-first --time-style=long-iso")
  (setq dired-dwim-target t)
  (setq dired-auto-revert-buffer #'dired-directory-changed-p)
                                        ; also see `dired-do-revert-buffer'
  (advice-add 'dired-view-file :around
              (defun dired-view-other-buffer-a (orig-fn &rest args)
                (cl-letf (((symbol-function 'view-file) #'view-file-other-window))
                  (funcall orig-fn))))
  ;; (setq dired-listing-switches "-agho --group-directories-first"
  ;;       ;; dired-omit-files "^\\.[^.].*"
  ;;       dired-omit-verbose nil
  ;;       dired-hide-details-hide-symlink-targets nil
  ;;       delete-by-moving-to-trash t)

  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))
  (defun dired-find-file-other-window ()
  "In Dired, visit this file or directory in another window. If `ace-window' is available, use it to select window for visiting this file.`"
  (interactive)
  (let ((file (dired-get-file-for-visit))
        (window
         (if (fboundp 'aw-select)
             (aw-select "Select Window")
           (next-window))))
    (select-window window)
    (find-file file)))

  (add-hook 'dired-mode-hook #'dired-hide-details-mode)
  (add-hook 'dired-mode-hook #'hl-line-mode)
  (add-hook 'dired-mode-hook #'toggle-truncate-lines)
  ;; (autoload 'dired-omit-mode "dired-x")

  (add-hook 'dired-load-hook
            (lambda ()
              (interactive)
              (dired-collapse)))

  (add-hook 'dired-mode-hook
            (lambda ()
              (interactive)
              ;; (dired-omit-mode 1)
              (dired-hide-details-mode 1)
              ;; (unless (or dw/is-termux
                          ;; (s-equals? "/home/shiva/" (expand-file-name default-directory)
                (all-the-icons-dired-mode 1))
              (hl-line-mode 1))

(use-package! dired-aux
  :config
  (setq dired-isearch-filenames 'dwim)
  ;; The following variables were introduced in Emacs 27.1
  (setq dired-create-destination-dirs 'ask)
  (setq dired-vc-rename-file t)
  ;; And this is for Emacs 28
  (setq dired-do-revert-buffer (lambda (dir) (not (file-remote-p dir))))

  (let ((map dired-mode-map))
    (define-key map (kbd "C-+") #'dired-create-empty-file)
    (define-key map (kbd "C-x v v") #'dired-vc-next-action))) ; Emacs 28

;; ;; NOTE 2021-05-10: I do not use `find-dired' and related commands
;; ;; because there are other tools that offer a better interface, such
;; ;; as `consult-find', `consult-grep', `project-find-file',
;; ;; `project-find-regexp', `prot-vc-git-grep'.
;; (prot-emacs-builtin-package 'find-dired
;;   (setq find-ls-option
;;         '("-ls" . "-AGFhlv --group-directories-first --time-style=long-iso"))
;;   (setq find-name-arg "-iname"))

(use-package! dired-x
  :config
  (setq dired-clean-up-buffers-too t)
  (setq dired-clean-confirm-killing-deleted-buffers t)
  (setq dired-x-hands-off-my-keys t)    ; easier to show the keys I use
  (setq dired-bind-man nil)
  (setq dired-bind-info nil)
  (define-key dired-mode-map (kbd "I") #'dired-info))

(load "prot-dired")
(use-package! prot-dired
  :config
  (setq prot-dired-image-viewers '("feh" "sxiv"))
  (setq prot-dired-media-players '("mpv" "vlc"))
  (setq prot-dired-media-extensions
        "\\.\\(mp[34]\\|ogg\\|flac\\|webm\\|mkv\\)")
  (setq prot-dired-image-extensions
        "\\.\\(png\\|jpe?g\\|tiff\\)")
  (setq dired-guess-shell-alist-user ; those are the defaults for ! and & in Dired
        `((,prot-dired-image-extensions (prot-dired-image-viewer))
          (,prot-dired-media-extensions (prot-dired-media-player))))

  (add-hook 'dired-mode-hook #'prot-dired-setup-imenu)

  (let ((map dired-mode-map))
    (define-key map (kbd "i") #'prot-dired-insert-subdir) ; override `dired-maybe-insert-subdir'
    (define-key map (kbd "/") #'prot-dired-limit-regexp)
    (define-key map (kbd "C-c C-l") #'prot-dired-limit-regexp)
    ;; (define-key map (kbd "M-n") #'prot-dired-subdirectory-next)
    ;; (define-key map (kbd "C-c C-n") #'prot-dired-subdirectory-next)
    ;; (define-key map (kbd "M-p") #'prot-dired-subdirectory-previous)
    ;; (define-key map (kbd "C-c C-p") #'prot-dired-subdirectory-previous)
    (define-key map (kbd "M-s G") #'prot-dired-grep-marked-files))) ; M-s g is `prot-search-grep'

;; (use-package! dired-subtree
;;   :config
;;   (setq dired-subtree-use-backgrounds nil)
;;   (let ((map dired-mode-map))
;;     (define-key map (kbd "<tab>") #'dired-subtree-toggle)
;;     (define-key map (kbd "<backtab>") #'dired-subtree-remove))) ; S-TAB

(use-package! dired-subtree
  :ensure t
  :after dired
  :config
  (setq dired-subtree-use-backgrounds nil)
  :bind (:map dired-mode-map
              ("<tab>" . dired-subtree-toggle)
              ("<s-tab>" . dired-subtree-cycle)
              ("<backtab>" . dired-subtree-remove)
              ))
(use-package! wdired
  :config
  (setq wdired-allow-to-change-permissions t)
  (setq wdired-create-parent-directories t))

(use-package! async
  :ensure)

(use-package! dired-async
  :after (dired async)

  :hook (dired-mode . dired-async-mode))
(use-package! image-dired
  :config
  (setq image-dired-external-viewer "xdg-open")
  (setq image-dired-thumb-size 80)
  (setq image-dired-thumb-margin 2)
  (setq image-dired-thumb-relief 0)
  (setq image-dired-thumbs-per-row 4)
  (define-key image-dired-thumbnail-mode-map
    (kbd "<return>") #'image-dired-thumbnail-display-external))
  (use-package! dired-rainbow
    :defer 2
    :config
    (dired-rainbow-define-chmod directory "#6cb2eb" "d.*")
    (dired-rainbow-define html "#eb5286" ("css" "less" "sass" "scss" "htm" "html" "jhtm" "mht" "eml" "mustache" "xhtml"))
    (dired-rainbow-define xml "#f2d024" ("xml" "xsd" "xsl" "xslt" "wsdl" "bib" "json" "msg" "pgn" "rss" "yaml" "yml" "rdata"))
    (dired-rainbow-define document "#9561e2" ("docm" "doc" "docx" "odb" "odt" "pdb" "pdf" "ps" "rtf" "djvu" "epub" "odp" "ppt" "pptx"))
    (dired-rainbow-define markdown "#ffed4a" ("org" "etx" "info" "markdown" "md" "mkd" "nfo" "pod" "rst" "tex" "textfile" "txt"))
    (dired-rainbow-define database "#6574cd" ("xlsx" "xls" "csv" "accdb" "db" "mdb" "sqlite" "nc"))
    (dired-rainbow-define media "#de751f" ("webm" "mp3" "mp4" "mkv" "MP3" "MP4" "avi" "mpeg" "mpg" "flv" "ogg" "mov" "mid" "midi" "wav" "aiff" "flac"))
    (dired-rainbow-define image "#f66d9b" ("tiff" "tif" "cdr" "gif" "ico" "jpeg" "jpg" "png" "psd" "eps" "svg"))
    (dired-rainbow-define log "#c17d11" ("log"))
    (dired-rainbow-define shell "#f6993f" ("awk" "bash" "bat" "sed" "sh" "zsh" "vim"))
    (dired-rainbow-define interpreted "#38c172" ("py" "ipynb" "rb" "pl" "t" "msql" "mysql" "pgsql" "sql" "r" "clj" "cljs" "scala" "js"))
    (dired-rainbow-define compiled "#4dc0b5" ("asm" "cl" "lisp" "el" "c" "h" "c++" "h++" "hpp" "hxx" "m" "cc" "cs" "cp" "cpp" "go" "f" "for" "ftn" "f90" "f95" "f03" "f08" "s" "rs" "hi" "hs" "pyc" ".java"))
    (dired-rainbow-define executable "#8cc4ff" ("exe" "msi"))
    (dired-rainbow-define compressed "#51d88a" ("7z" "zip" "bz2" "tgz" "txz" "gz" "xz" "z" "Z" "jar" "war" "ear" "rar" "sar" "xpi" "apk" "xz" "tar"))
    (dired-rainbow-define packaged "#faad63" ("deb" "rpm" "apk" "jad" "jar" "cab" "pak" "pk3" "vdf" "vpk" "bsp"))
    (dired-rainbow-define encrypted "#ffed4a" ("gpg" "pgp" "asc" "bfe" "enc" "signature" "sig" "p12" "pem"))
    (dired-rainbow-define fonts "#6cb2eb" ("afm" "fon" "fnt" "pfb" "pfm" "ttf" "otf"))
    (dired-rainbow-define partition "#e3342f" ("dmg" "iso" "bin" "nrg" "qcow" "toast" "vcd" "vmdk" "bak"))
    (dired-rainbow-define vc "#0074d9" ("git" "gitignore" "gitattributes" "gitmodules"))
    (dired-rainbow-define-chmod executable-unix "#38c172" "-.*x.*"))


  ;; Use parallel versions of comression programs.
  (setq dired-compress-file-alist
        '(("\\.gz\\'" . "pigz -9f %i")
          ("\\.bz2\\'" . "pbzip2 -9f %i")
          ("\\.xz\\'" . "pixz -9f %i")
          ("\\.zst\\'" . "zstd -qf -19 --rm -o %o %i"))
        dired-compress-files-alist
        '(("\\.tar\\.gz\\'" . "tar -cf - %i | pigz -c9 > %o")
          ("\\.tar\\.bz2\\'" . "tar -cf - %i | pbzip2 -c9 > %o")
          ("\\.tar\\.xz\\'" . "tar -cf - %i | pixz -c9 > %o")
          ("\\.tar\\.zst\\'" . "tar -cf - %i | zstd -19 -o %o")
          ("\\.tar\\.lz\\'" . "tar -cf - %i | plzip -c9 > %o")
          ("\\.tar\\.lzo\\'" . "tar -cf - %i | lzop -c9 > %o")
          ("\\.zip\\'" . "zip %o -r --filesync %i")
          ("\\.pax\\'" . "pax -wf %o %i"))
        dired-compress-file-suffixes
        '(("\\.tar\\.gz\\'" "" "pigz -dc %i | tar -xf -")
          ("\\.tar\\.xz\\'" "" "pixz -dc %i | tar -xf -")
          ("\\.tgz\\'" "" "pigz -dc %i | tar -xf -")
          ("\\.gz\\'" "" "pigz -d") ; For some reason using `pigz' here does not
                                        ; work properly.
          ("\\.lz\\'" "" "plzip -d")
          ("\\.Z\\'" "" "uncompress")
          ("\\.z\\'" "" "pigz -d")
          ("\\.dz\\'" "" "dictunzip")
          ("\\.tbz\\'" ".tar" "pbunzip2")
          ("\\.bz2\\'" "" "pbunzip2")
          ("\\.xz\\'" "" "pixz -d")
          ("\\.zip\\'" "" "unzip -o -d %o %i")
          ("\\.tar\\.zst\\'" "" "unzstd -c %i | tar -xf -")
          ("\\.tzst\\'" "" "unzstd -c %i | tar -xf -")
          ("\\.zst\\'" "" "unzstd --rm")
          ("\\.7z\\'" "" "7z x -aoa -o%o %i")
          ("\\.tar\\'" ".tgz" nil)))

;;; Add music file to playlist on '!', --lgfang
(add-to-list 'dired-guess-shell-alist-user
             (list "\\.\\(flac\\|mp3\\|ogg\\|wav\\)\\'"
                   '(if (y-or-n-p "Add to emms playlist?")
                        (progn (emms-add-file (dired-get-filename))
                               (keyboard-quit))
                      "mplayer")))

  (use-package! dired-single
    :defer t)

  (use-package! dired-ranger
    :defer t)

  (use-package! dired-collapse
    :defer t)

(use-package! gnus-dired
  :defer 5
  :after dired)

(evil-define-key 'normal dired-mode-map
  (kbd "M-RET") 'dired-display-file
  (kbd "h") 'dired-single-up-directory
  ;; (kbd "H") 'dired-omit-mode
  (kbd "l") 'dired-single-buffer ; use dired-find-file instead of dired-open.
  (kbd "m") 'dired-mark
  (kbd "RET") 'dired-open-file
  (kbd "t") 'dired-toggle-marks
  (kbd "u") 'dired-unmark
  (kbd "C") 'dired-do-copy
  (kbd "i") 'dired-info
  (kbd "I") 'prot-dired-insert-subdir
  (kbd "D") 'dired-do-delete
  (kbd "J") 'dired-goto-file
  (kbd "M") 'dired-do-chmod
  (kbd "O") 'dired-do-chown
  (kbd "P") 'dired-do-print
  (kbd "R") 'dired-do-rename
  (kbd "T") 'dired-do-touch
  (kbd "y") 'dired-ranger-copy
  (kbd "X") 'dired-ranger-move
  (kbd "p") 'dired-ranger-paste
  (kbd "Y") 'dired-copy-filename-as-kill ; copies filename to kill ring.
  (kbd "+") 'dired-create-directory
  (kbd "F") 'dired-do-find-marked-files ;;open all marked files at once
  (kbd "-") 'dired-up-directory
  (kbd "% l") 'dired-downcase
  (kbd "% u") 'dired-upcase
  (kbd "@") 'emms-play-dired
  (kbd "; d") 'epa-dired-do-decrypt
  (kbd "; e") 'epa-dired-do-encrypt))
  ;; (evil-collection-define-key 'normal 'dired-mode-map
  ;;   "h" 'dired-single-up-directory
  ;;   "H" 'dired-omit-mode
  ;;   "l" 'dired-single-buffer
  ;;   "y" 'dired-ranger-copy
  ;;   "X" 'dired-ranger-move
  ;;   "p" 'dired-ranger-paste))
(map! :leader
      (:prefix ("d" . "dired")
       :desc "Open dired" "d" #'dired
       :desc "Dired jump to current" "j" #'dired-jump)
      (:after dired
       (:map dired-mode-map
        :desc "Peep-dired image previews" "d p" #'peep-dired
        :desc "Dired view file" "d v" #'dired-view-file
        :desc "Find name dired " "d N" #'find-name-dired)))

(use-package! peep-dired
  :general
  (:states '(normal visual)
           :keymaps 'dired-mode-map
           "z p" 'peep-dired)
  (:keymaps 'dired-mode-map
            "P" 'peep-dired)
  :hook (peep-dired-display-file . auto-revert-mode)
  :config
  ;; (add-hook 'peep-dired-hook 'evil-normalize-keymaps)
  (ignore-errors
    (setq peep-dired-display-action-alist
          '(display-buffer-in-direction
            (direction . below)
            (window-height . (lambda (win) (fit-window-to-buffer
                                       win
                                       (floor (* 0.6 (frame-height))))))
            (window-parameters . ((dedicated . t))))))
  (general-def
    :states '(normal visual)
    :keymaps 'peep-dired-mode-map
    :prefix "SPC"
    "SPC" 'peep-dired-scroll-page-down
    "S-SPC" 'peep-dired-scroll-page-up)
  (general-def
    :states '(normal visual)
    :keymaps 'peep-dired-mode-map
    "<backspace>" 'peep-dired-scroll-page-up
    "j" 'peep-dired-next-file
    "k" 'peep-dired-prev-file)
  ;; (evil-define-key 'normal peep-dired-mode-map (kbd "<SPC>") 'peep-dired-scroll-page-down
  ;;   (kbd "C-<SPC>") 'peep-dired-scroll-page-up
  ;;   (kbd "<backspace>") 'peep-dired-scroll-page-up
  ;;   (kbd "j") 'peep-dired-next-file
  ;;   (kbd "k") 'peep-dired-prev-file)
(setq peep-dired-cleanup-on-disable t)
(setq peep-dired-cleanup-eagerly nil)
(setq peep-dired-enable-on-directories nil)
(setq peep-dired-ignored-extensions
      '("mkv" "iso" "mp4" "pdf" "djvu" "one" "mat"
        "fig" "nb" "slx" "slxc" "r2016b" "onetoc2")))
(setq dired-open-extensions '(("gif" . "sxiv")
                              ("jpg" . "sxiv")
                              ("png" . "sxiv")
                              ("mkv" . "mpv")
                              ("webm" . "mpv")
                              ("mp4" . "mpv")))
;; (defun dw/dired-link (path)
;;   (lexical-let ((target path))
;;     (lambda () (interactive) (message "Path: %s" target) (dired target))))

;; (dw/leader-key-def
;;   "d"   '(:ignore t :which-key "dired")
;;   "dd"  '(dired :which-key "Here")
;;   "dh"  `(,(dw/dired-link "~") :which-key "Home")
;;   "dn"  `(,(dw/dired-link "~/Notes") :which-key "Notes")
;;   "do"  `(,(dw/dired-link "~/Downloads") :which-key "Downloads")
;;   "dp"  `(,(dw/dired-link "~/Pictures") :which-key "Pictures")
;;   "dv"  `(,(dw/dired-link "~/Videos") :which-key "Videos")
;;   "d."  `(,(dw/dired-link "~/.dotfiles") :which-key "dotfiles")
;;   "de"  `(,(dw/dired-link "~/.emacs.d") :which-key ".emacs.d"))

(evil-define-key 'normal peep-dired-mode-map
  (kbd "j") 'peep-dired-next-file
  (kbd "k") 'peep-dired-prev-file)
(add-hook 'peep-dired-hook 'evil-normalize-keymaps)

(setq delete-by-moving-to-trash t
      trash-directory "~/.local/share/Trash/files/")

(use-package! dired-sidebar
  :after dired
  :disabled
  :commands (dired-sidebar-toggle-sidebar)
  :general
  ("C-x D"  'list-directory
   "C-x C-d" 'dired-sidebar-toggle-sidebar
   :states '(normal visual)
   "C-w C-d" 'dired-sidebar-toggle-sidebar)

  ;; (:keymaps 'space-menu-map
  ;;  :wk-full-keys nil
  ;;  :prefix "f"
  ;;   "t" '(dired-sidebar-toggle-sidebar :wk "Dired tree"))

  (:keymaps 'dired-sidebar-mode-map
   :states  '(normal)
   "gO"     'dired-sidebar-find-file-alt
   "RET"    'dired-sidebar-find-file)

  (:keymaps 'dired-sidebar-mode-map
   "-" nil)
  :init
  (add-hook 'dired-sidebar-mode-hook
            (lambda ()
              (unless (file-remote-p default-directory)
                (auto-revert-mode))))
  :config
  (push 'toggle-window-split dired-sidebar-toggle-hidden-commands)
  (push 'rotate-windows dired-sidebar-toggle-hidden-commands)

  (setq dired-sidebar-subtree-line-prefix "__")
  (setq dired-sidebar-theme 'ascii)
  (setq dired-sidebar-use-term-integration t)
  (setq dired-sidebar-use-custom-font t))

(use-package! ibuffer-sidebar
  :disabled
  :commands +ibuffer-sidebar-toggle
  :general
  ("C-x C-d" '+ibuffer-sidebar-toggle)
  (:states '(normal visual)
   "C-x C-d" '+ibuffer-sidebar-toggle)
  (:keymaps 'space-menu-buffer-map
            :wk-full-keys nil
            "t" '(ibuffer-sidebar-toggle-sidebar :wk "Buffer sidebar"))
  :config
  ;; (setq ibuffer-sidebar-use-custom-font t)
  ;; (setq ibuffer-sidebar-face `(:family "Helvetica" :height 140))
  (defun +ibuffer-sidebar-toggle ()
    "Toggle both `dired-sidebar' and `ibuffer-sidebar'."
    (interactive)
    (when (featurep 'ibuffer)
      (ibuffer-sidebar-toggle-sidebar))
    (dired-sidebar-toggle-sidebar)))

(use-package! dired-rsync
  :ensure t
  :bind (:map dired-mode-map
         ("r" . dired-rsync))
  :hook (dired-rsync-failed . dired-rsync--pop-to-rsync-failed-buf)
  :config
  (setq dired-rsync-unmark-on-completion nil))

(use-package! dired-filter
  :ensure t
  :after dired)

(use-package! diredfl
  :ensure t
  :hook (dired-mode . diredfl-mode))
#+end_src

#+RESULTS:
| denote-dired-mode | pdf-occur-dired-minor-mode | dired-async-mode | prot-dired-setup-imenu | dired-extra-startup | toggle-truncate-lines | hl-line-mode | dired-hide-details-mode | beginend-dired-mode | doom--recentf-add-dired-directory-h | +dired-disable-gnu-ls-flags-maybe-h | dired-omit-mode | all-the-icons-dired-mode | diredfl-mode | ranger-set-dired-key | (lambda nil (interactive) (dired-hide-details-mode 1) (all-the-icons-dired-mode 1)) |

** dired-like mode for the trash (trashed.el)

=trashed= applies the principles of =dired= to the management of the user's
filesystem trash.  Use =C-h m= to see the docs and keybindings for its
major mode.

Basically, its interaction model is as follows:

- =m= to mark for some deferred action, such as =D= to delete, =R= to restore.
- =t= to toggle the status of all items as marked.  Use this without marks
  to =m= (mark) all items, then call a deferred action to operate on them.
- =d= to mark for permanent deletion.
- =r= to mark for restoration.
- =x= to execute these special marks.

#+begin_src emacs-lisp :tangle no
;;; dired-like mode for the trash (trashed.el)
(use-package! trashed
  :config
  (setq trashed-action-confirmer 'y-or-n-p)
  (setq trashed-use-header-line t)
  (setq trashed-sort-key '("Date deleted" . t))
  (setq trashed-date-format "%Y-%m-%d %H:%M:%S"))
#+end_src

#+RESULTS:
: t

** OPEN SPECIFIC FILES
Keybindings to open files that I work with all the time using the find-file command, which is the interactive file search that opens with 'C-x C-f' in GNU Emacs or 'SPC f f' in Doom Emacs.  These keybindings use find-file non-interactively since we specify exactly what file to open.  The format I use for these bindings is 'SPC =' plus 'key' since Doom Emacs does not use 'SPC ='.

| PATH TO FILE                   | DESCRIPTION           | KEYBINDING |
|--------------------------------+-----------------------+------------|
| ~/Org/agenda/agenda.org        | /Edit agenda file/      | SPC = a    |
| ~/.config/doom/config.org"     | /Edit doom config.org/  | SPC = c    |
| ~/.config/doom/init.el"        | /Edit doom init.el/     | SPC = i    |
| ~/.config/doom/packages.el"    | /Edit doom packages.el/ | SPC = p    |
| ~/.config/doom/eshell/aliases" | /Edit eshell aliases/   | SPC = e a  |
| ~/.config/doom/eshell/profile" | /Edit eshell profile/   | SPC = e p  |

#+BEGIN_SRC emacs-lisp
(map! :leader
      (:prefix ("=" . "open file")
       :desc "Edit agenda file" "a" #'(lambda () (interactive) (find-file "~/org/org-agenda/agenda.org"))
       :desc "Edit doom config.org" "c" #'(lambda () (interactive) (find-file "~/.config/doom/config.org"))
       :desc "Edit doom init.el" "i" #'(lambda () (interactive) (find-file "~/.config/doom/init.el"))
       :desc "Edit doom packages.el" "p" #'(lambda () (interactive) (find-file "~/.config/doom/packages.el"))))
(map! :leader
      (:prefix ("= e" . "open eshell files")
       :desc "Edit eshell aliases" "a" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/aliases"))
       :desc "Edit eshell profile" "p" #'(lambda () (interactive) (find-file "~/.config/doom/eshell/profile"))))
#+END_SRC
** dired General commands and keybindings(read c)
 Keybindings To Open Dired
| COMMAND    | DESCRIPTION                        | KEYBINDING |
|------------+------------------------------------+------------|
| dired      | /Open dired file manager/            | SPC d d    |
| dired-jump | /Jump to current directory in dired/ | SPC d j    |
│
*│ │ Basic dired commands*
| COMMAND                | DESCRIPTION                                 | KEYBINDING |
|------------------------+---------------------------------------------+------------|
| dired-view-file        | /View file in dired/                          | SPC d v    |
| dired-up-directory     | /Go up in directory tree/                     | h          |
| dired-find-file        | /Go down in directory tree (or open if file)/ | l          |
| dired-next-line        | Move down to next line                      | j          |
| dired-previous-line    | Move up to previous line                    | k          |
| dired-mark             | Mark file at point                          | m          |
| dired-unmark           | Unmark file at point                        | u          |
| dired-do-copy          | Copy current file or marked files           | C          |
| dired-do-rename        | Rename current file or marked files         | R          |
| dired-hide-details     | Toggle detailed listings on/off             | (          |
| dired-git-info-mode    | Toggle git information on/off               | )          |
| dired-create-directory | Create new empty directory                  | +          |
| dired-diff             | Compare file at point with another          | =          |
| dired-subtree-toggle   | Toggle viewing subtree at point             | TAB        |
|                        |                                             |            |
│
│
*│ │ Keybindings Within Dired With Peep-Dired-Mode Enabled*
*│ │ If peep-dired is enabled, you will get image previews as you go up/down with 'j' and 'k'*
│
| COMMAND              | DESCRIPTION                              | KEYBINDING |
|----------------------+------------------------------------------+------------|
| peep-dired           | /Toggle previews within dired/             | SPC d p    |
| peep-dired-next-file | /Move to next file in peep-dired-mode/     | j          |
| peep-dired-prev-file | /Move to previous file in peep-dired-mode/ | k          |
│
** open with
#+begin_src emacs-lisp
(use-package! openwith
  :config
  (setq openwith-associations
        (list
          (list (openwith-make-extension-regexp
                '("webm" "mpg" "mpeg" "mp3" "mp4"
                  "avi" "wmv" "wav" "mov" "flv"
                  "ogm" "ogg" "mkv"))
                "mpv"
                '(file))
          (list (openwith-make-extension-regexp
                '("xbm" "pbm" "pgm" "ppm" "pnm"
                  "png" "gif" "bmp" "tif" "jpeg")) ;; Removed jpg because Telega was
                  ;; causing feh to be opened...
                  "feh"
                  '(file))
          (list (openwith-make-extension-regexp
                '("pdf"))
                "zathura"
                '(file)))))

#+end_src

#+RESULTS:
: t
* Hydra
** Extensions for PDFs (pdf-tools)

The =pdf-tools= package builds on top of the external libraries, =poppler=
and =imagemagick= (if Emacs is compiled with support for it) to deliver a
series of minor modes for reading and interacting with PDF files from
inside of Emacs.  As it depends on those external files, it requires
extra steps to make it work properly.  Those are documented at length in
its README and vary depending on your operating system.

All you need to start reading PDFs is to put the =pdf-loader-install=
function in your configurations, which loads the tools once you open an
appropriate file, such as through =dired= or with =find-file=.  Once inside
the resulting buffer, do =C-h m= (=describe-mode=) to learn about the key
bindings and the commands they call.  The basics:

| Key   | Effect            |
|-------+-------------------|
| +     | Enlarge (zoom in) |
| -     | Shrink (zoom out) |
| 0     | Reset zoom        |
| C-n   | Next line         |
| C-p   | Previous line     |
| SPC   | Scroll down       |
| S-SPC | Scroll up         |

To determine which minor modes out of the entire suite are activated,
you need to configure the variable =pdf-tools-enabled-modes=.  I reduce it
only a subset of what is available by default because I do not need all
the extras.  That granted, there are at least two minor modes that users
may find helpful: =pdf-annot-minor-mode= which provides annotation
capabilities and =pdf-sync-minor-mode= which syncs the PDF with its
corresponding TeX file when you are running some setup that compiles the
latter to the former.

The value proposition of =pdf-tools= is that it works with =isearch= and
=occur= so you can easily (i) search through the file and (ii) produce a
buffer of locations with matching queries.  As is the norm with
=pdf-tools=, those facilities are implemented as minor modes:
=pdf-isearch-minor-mode=, =pdf-occur-global-minor-mode= (this also works
with =ibuffer= and =dired=).

Another helpful integration is with Emacs' =outline-mode= and =imenu= by
means of =pdf-outline-minor-mode=.  Simply hit =o= while viewing a PDF to
produce an outline of the document and then, optionally, =M-x imenu= to
navigate it using minibuffer completion (though for the latter task you
may prefer something like =consult-outline=, which is part of the Consult
package: [[#h:9c9401d6-8c53-4276-be4c-3bff345d3eeb][Enhanced minibuffer commands (consult.el)]]).

Finally, I have some tweaks to change the backdrop of the buffer so that
it is distinct from the page's background while using my light Modus
Operandi theme ([[#h:b7444e76-75d4-4ae6-a9d6-96ff9408efe6][Modus themes (my highly accessible themes)]]).  Plus, I
make it automatically adapt to the =modus-themes-toggle= command, so that
the PDF switches to a dark theme when it has to.  Those are documented
in the manual of the themes.  If you are using them, evaluate this form:
=(info "(modus-themes) Backdrop for pdf-tools (DIY)")=.

#+begin_src emacs-lisp :tangle yes
;;; Extensions for PDFs (pdf-tools)
 (pdf-loader-install)

(use-package! pdf-tools
  :config
  (setq pdf-tools-enabled-modes         ; simplified from the defaults
        '(pdf-history-minor-mode
          pdf-isearch-minor-mode
          pdf-links-minor-mode
          pdf-outline-minor-mode
          pdf-misc-size-indication-minor-mode
          pdf-occur-global-minor-mode))
  (setq pdf-view-display-size 'fit-page) ;;fit-height
  (setq pdf-view-continuous t)
  (setq pdf-annot-activate-created-annotations t)
  (setq pdf-view-use-dedicated-register nil)
  (setq pdf-view-max-image-width 1080)
  (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
  (define-key pdf-view-mode-map (kbd "C-s") 'isearch-forward)
  (setq pdf-outline-imenu-use-flat-menus t)
 (setq pdf-view-resize-factor 1.1)
 (define-key pdf-view-mode-map (kbd "h") 'pdf-annot-add-highlight-markup-annotation)
 (define-key pdf-view-mode-map (kbd "t") 'pdf-annot-add-text-annotation)
 (define-key pdf-view-mode-map (kbd "D") 'pdf-annot-delete)


  ;; Those functions and hooks are adapted from the manual of my
  ;; modus-themes.  The idea is to (i) add a backdrop that is distinct
  ;; from the background of the PDF's page and (ii) make pdf-tools adapt
  ;; to theme switching via, e.g., `modus-themes-toggle'.
  (defun prot/pdf-tools-backdrop ()
    (face-remap-add-relative
     'default
     `(:background ,(modus-themes-color 'bg-alt))))

  (defun prot/pdf-tools-midnight-mode-toggle ()
    (when (derived-mode-p 'pdf-view-mode)
      (if (eq (car custom-enabled-themes) 'modus-vivendi)
          (pdf-view-midnight-minor-mode 1)
        (pdf-view-midnight-minor-mode -1))
      (prot/pdf-tools-backdrop)))

  (add-hook 'pdf-view-mode-hook (lambda () (cua-mode 0)))
  (add-hook 'pdf-tools-enabled-hook #'prot/pdf-tools-midnight-mode-toggle)
  (add-hook 'modus-themes-after-load-theme-hook #'prot/pdf-tools-midnight-mode-toggle))

#+end_src

#+RESULTS:
: t

** Taking notes on PDFs(org-noter)
:PROPERTIES:
:NOTER_DOCUMENT: ../../org/notes/notes.org
:END:
#+begin_src emacs-lisp :tangle packages.el
(package! pdf-tools-org-noter-helpers :recipe (:host github :repo "analyticd/pdf-tools-org-noter-helpers"))
#+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! org-noter-plus-djvu :recipe (:host github :repo "c1-g/org-noter-plus-djvu"))
#+end_src
#+begin_src emacs-lisp :tangle yes
   (use-package! org-noter
  :after (:any org pdf-view)
  :config
  (setq
   ;; The WM can handle splits
   org-noter-notes-window-location 'other-frame
   ;; Please stop opening frames
   org-noter-always-create-frame nil
   ;; I want to see the whole file
   org-noter-hide-other nil
   ;; org-noter-notes-search-path "~/org/notes"
   org-noter-separate-notes-from-heading t
   org-noter-default-heading-title "Page $p$"
   org-noter-auto-save-last-location t
   org-noter-separate-notes-from-heading t
   org-noter-doc-property-in-notes t
   org-noter-always-create-frame t
   )
  )

(setq org-noter-property-doc-file "INTERLEAVE_PDF"
      org-noter-property-note-location "INTERLEAVE_PAGE_NOTE")

;; (use-package! org-pdftools
;;   :hook (org-load . org-pdftools-setup-link))
;; (use-package! org-noter-pdftools
;;   :after org-noter
;;   :config
;;   (with-eval-after-load 'pdf-annot
;;     (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)))

;; (setq org-noter-notes-search-path '("~/org/notes/"))
#+end_src
#+RESULTS:
: pdf-tools-org-noter-helpers

#+begin_src emacs-lisp
(defun org-noter-create-notes-file-for-current-book ()
  "Create the org-noter file based on the PDF file name for the current buffer."
  (interactive)
  (call-interactively 'bookmark-set)
  (save-excursion
    (let* ((book-filename buffer-file-name)
           (filename-non-directory (file-name-nondirectory book-filename))
           (filename (replace-regexp-in-string
                      " " "-"
                      (first (split-string filename-non-directory "\\\."))))
           (noter-filepath (concatenate 'string org-directory "/" filename "-notes" ".org")))
      (with-temp-buffer (find-file noter-filepath)
                        (if (not (file-exists-p noter-filepath))
                            (delay-mode-hooks
                              (point-min)
                              (org-insert-heading)
                              (insert (format " %s\n" filename))
                              (org-set-property "NOTER_DOCUMENT" book-filename)
                              (save-buffer))
                          (find-file noter-filepath))
                        (org-noter))
      (call-interactively 'bookmark-jump))))
#+end_src

#+RESULTS:
: org-noter-create-notes-file-for-current-book

** Hydra
#+begin_src emacs-lisp
(use-package! hydra
  ;; :ensure t
  :defer 0.1
  :init
  (bind-key "\\" 'hydra-master/body)
  :config
  (setq lv-use-separator t)
  (set-face-attribute 'hydra-face-blue nil :foreground "deep sky blue" :weight 'bold)

  (eval-and-compile
    (defhydra hydra-common (:color blue)
      ("<ESC>" nil "quit")))

  (defhydra hydra-master (:color blue :idle 0.4)
    "
                                                                       ╭───────┐
                                                                       │ Index │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_a_] bookmarks    [^h^]               [_o_] organization  [^v^]
  [_b_] buffers      [_i_] internet      [_p_] project       [_w_] window
  [_c_] flycheck     [_j_] jump          [_q_] exit          [_x_] shell
  [_d_] development  [_k_] spell         [_r_] register      [^y^]
  [_e_] emacs        [_l_] lisp          [_s_] search        [^z^]
  [_f_] file         [_m_] media         [_t_] text
  [_g_] git          [_n_] narrow        [^u^]
--------------------------------------------------------------------------------
    "
    ("<SPC>" joe-alternate-buffers "alternate buffers")
    ("<ESC>" nil "quit")
    ("\\" (insert "\\") "\\")
    ("a"     hydra-bookmarks/body nil)
    ("b"     hydra-buffers/body nil)
    ("c"     hydra-flycheck/body nil)
    ("d"     hydra-development/body nil)
    ("e"     hydra-emacs/body nil)
    ("f"     hydra-file/body nil)
    ("g"     hydra-git/body nil)
    ("i"     hydra-internet/body nil)
    ("j"     hydra-jump/body nil)
    ("k"     hydra-spell/body nil)
    ("l"     hydra-lisp/body nil)
    ("m"     hydra-media/body nil)
    ("n"     hydra-narrow/body nil)
    ("o"     hydra-organization/body nil)
    ("p"     hydra-project/body nil)
    ("q"     hydra-exit/body nil)
    ("r"     hydra-register/body nil)
    ("s"     hydra-search/body nil)
    ("t"     hydra-text/body nil)
    ("w"     ace-window nil)
    ("x"     hydra-system/body nil))

  (defhydra hydra-bookmarks (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
    "
                                                                   ╭───────────┐
       List                          Do                            │ Bookmarks │
╭──────────────────────────────────────────────────────────────────┴───────────╯
  [_l_] list bookmarks            [_j_] jump to a bookmark
   ^ ^                            [_m_] set bookmark at point
   ^ ^                            [_s_] save bookmarks
--------------------------------------------------------------------------------
    "
    ("l" consult-bookmark)
    ("j" bookmark-jump)
    ("m" bookmark-set)
    ("s" bookmark-save))

  (defhydra hydra-buffers (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
    "
                                                                     ╭─────────┐
  Switch                 Do                                          │ Buffers │
╭────────────────────────────────────────────────────────────────────┴─────────╯
  [_b_] switch             [_d_] kill the buffer
  [_i_] ibuffer            [_r_] toggle read-only mode
  [_a_] alternate          [_u_] revert buffer changes
   ^ ^                     [_w_] save buffer
--------------------------------------------------------------------------------
    "
    ("a" joe-alternate-buffers)
    ;; ("b" ivy-switch-buffer)
    ("b" consult-buffer)
    ("d" kill-this-buffer)
    ("i" ibuffer)
    ("r" read-only-mode)
    ("u" joe-revert-buffer)
    ("w" save-buffer))

    (defhydra hydra-flycheck (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                    ╭──────────┐
   Navigate          Show Errors                  Do                │ Flycheck │
╭───────────────────────────────────────────────────────────────────┴──────────╯
   ^_p_^revious     [_l_] list errors           [_t_] toggle Flycheck
      ^^↑^^         [_d_] clear all errors      [_c_] select checker
    ^_f_^irst        ^ ^                        [_r_] run via compile
      ^^↓^^          ^ ^                        [_h_] describe checker
    ^_n_^ext
--------------------------------------------------------------------------------
      "
      ("c" flycheck-select-checker)
      ("h" flycheck-describe-checker)
      ("d" flycheck-clear)
      ("f" flycheck-first-error)
      ("l" flycheck-list-errors)
      ("n" flycheck-next-error :color red)
      ("p" flycheck-previous-error :color red)
      ("r" flycheck-compile)
      ("t" flycheck-mode))

    (defhydra hydra-development (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                 ╭─────────────┐
     Code                   Web                 Quickrun         │ Development │
╭────────────────────────────────────────────────────────────────┴─────────────╯
  [_d_] search docs (at point) [_c_] Web Colors          [_q_] buffer
   ^ ^                         [_h_] HTTP header         [_v_] region
   ^ ^                         [_m_] HTTP method         [_x_] shell
   ^ ^                         [_r_] HTTP relation       [_p_] with arg
   ^ ^                         [_s_] HTTP status code    [_o_] only compile
   ^ ^                         [_t_] Media types         [_R_] replace
   ^ ^                         [_g_] RESTclient          [_e_] eval/print
   ^ ^                         [_f_] RFC doc
  [_l_] lines of code          [_F_] RFC index
--------------------------------------------------------------------------------
      "
      ("d" devdocs-search)
      ("c" counsel-colors-web)
      ("g" restclient-mode)
      ("f" irfc-visit)
      ("F" irfc-index)
      ("q" quickrun)
      ("v" quickrun-region)
      ("x" quickrun-shell)
      ("p" quickrun-with-arg)
      ("o" quickrun-compile-only)
      ("R" quickrun-replace-region)
      ("e" quickrun-eval-print)
      ("h" http-header)
      ("m" http-method)
      ("r" http-relation)
      ("s" http-status-code)
      ("t" media-type)
      ("l" cloc))

  (defhydra hydra-emacs (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                       ╭───────┐
   Execute       Packages         Help                     Misc        │ Emacs │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_x_] counsel M-x [_p_] list      [_f_] describe function [_t_] change theme
   ^ ^              [_i_] install   [_v_] describe variable [_l_] list emacs process
   ^ ^              [_u_] upgrade   [_m_] info manual       [_c_] init time
   ^ ^               ^ ^            [_k_] bindings          [_e_] benchmark init
   ^ ^               ^ ^            [_b_] personal bindings [_o_] unbound commands
   ^ ^               ^ ^             ^ ^                    [_y_] emacs colors
   ^ ^               ^ ^             ^ ^                    [_z_] list faces
--------------------------------------------------------------------------------
      "
      ("C-h b" counsel-descbinds "bindings")
      ("f" counsel-describe-function)
      ("v" counsel-describe-variable)
      ("b" describe-personal-keybindings)
      ("c" emacs-init-time)
      ("i" package-install)
      ("k" counsel-descbinds)
      ("l" list-processes)
      ("m" info-display-manual)
      ("p" paradox-list-packages)
      ("t" counsel-load-theme)
      ("u" paradox-upgrade-packages)
      ("e" esup)
      ("o" smex-show-unbound-commands)
      ("y" counsel-colors-emacs)
      ("z" counsel-faces)
      ("x" counsel-M-x))

  (defhydra hydra-file (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
     Ivy                    Dired        Ztree                          │ File │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_o_] open file        [_d_] dired         [_z_] diff dirs
  [_e_] open file extern [_r_] ranger
--------------------------------------------------------------------------------
      "
      ("o" counsel-find-file)
      ("e" counsel-find-file-extern)
      ("z" ztree-diff)
      ("d" dired)
      ("r" ranger))


  (defhydra hydra-text (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
 Size  Toggle              Unicode                        Do            │ Text │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  _k_  [_f_] fill column     [_d_] unicode character           [_a_] align with regex
  ^↑^  [_h_] hidden chars    [_e_] evil digraphs table         [_w_] remove trailing ' '
  ^ ^  [_l_] line numbers    [_s_] specific code block         [_n_] count words
  ^↓^  [_t_] trailing ' '    [_u_] unicode character           [_i_] lorem ipsum
  _j_  [_v_] font space      [_p_] character code              [_x_] comment box
  ^ ^  [_c_] comment          ^ ^                              [_q_] boxquote
  ^ ^  [_b_] multibyte chars  ^ ^                              [_m_] iedit (multiple)
  ^ ^   ^ ^                   ^ ^                              [_r_] expand region
  ^ ^   ^ ^                   ^ ^                              [_U_] tabs to spaces
--------------------------------------------------------------------------------
      "
      ("a" align-regexp)
      ("b" toggle-enable-multibyte-characters)
      ("c" comment-line)
      ("d" insert-char)
      ("e" evil-ex-show-digraphs)
      ("f" fci-mode)
      ("h" whitespace-mode)
      ("i" lorem-ipsum-insert-paragraphs)
      ("k" text-scale-increase :color red)
      ("j" text-scale-decrease :color red)
      ("l" linum-mode)
      ("n" count-words)
      ("m" iedit)
      ("p" describe-char)
      ("r" er/expand-region)
      ("s" charmap)
      ("t" joe-toggle-show-trailing-whitespace)
      ("u" counsel-unicode-char)
      ("v" variable-pitch-mode)
      ("w" whitespace-cleanup)
      ("U" untabify)
      ("q" hydra-boxquote/body)
      ("x" comment-box))

  (defhydra hydra-git (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                         ╭─────┐
   Magit                          VC                    Timemachine      │ Git │
╭────────────────────────────────────────────────────────────────────────┴─────╯
  [_s_] status              [_d_] diffs between revisions  [_t_] timemachine
  [_B_] blame mode          [_b_] edition history
  [_l_] file log
--------------------------------------------------------------------------------
      "
      ("B" magit-blame-mode)
      ("b" vc-annotate)
      ("d" vc-diff)
      ("l" magit-file-log)
      ("s" magit-status)
      ("t" git-timemachine))

  (defhydra hydra-internet (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                    ╭──────────┐
    Browse       Search              Social               Post      │ Internet │
╭───────────────────────────────────────────────────────────────────┴──────────╯
  [_w_] eww      [_b_] DuckDuckGo       [_f_] elfeed            [_i_] imgur
  [_u_] url      [_e_] DuckDuckGo (eww) [_x_] stack overflow
   ^ ^           [_m_] google maps
   ^ ^           [_d_] wordnik
--------------------------------------------------------------------------------
      "
      ("w" eww)
      ("u" browse-url-at-point)
      ("b" (joe-duckduckgo-search t))
      ("e" (joe-duckduckgo-search nil))
      ("m" google-maps)
      ("d" define-word-at-point)
      ("f" elfeed)
      ("x" sx-tab-newest)
      ("i" imgur-post))

  (defhydra hydra-jump (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
  Window          Word/Char        Line         iSearch                 │ Jump │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_w_] jump        [_j_] word         [_l_] jump     [_i_] jump
  [_d_] close       [_p_] all words    [_y_] copy
  [_z_] maximize    [_b_] subword      [_m_] move
  [_s_] swap        [_c_] char         [_v_] copy region
   ^ ^              [_a_] two chars
--------------------------------------------------------------------------------
      "
      ("w" ace-window)
      ("d" ace-delete-window)
      ("z" ace-maximize-window)
      ("s" ace-swap-window)
      ("j" avy-goto-word-1)
      ("p" avy-goto-word-0)
      ("b" avy-goto-subword-0)
      ("c" avy-goto-char)
      ("a" avy-goto-char-2)
      ("l" avy-goto-line)
      ("y" avy-copy-line)
      ("m" avy-move-line)
      ("v" avy-copy-region)
      ("i" avy-isearch))

  (defhydra hydra-spell (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                       ╭───────┐
    Flyspell               Ispell                      Gtranslate      │ Spell │
╭──────────────────────────────────────────────────────────────────────┴───────╯
  [_k_] correct word       [_w_] check word            [_g_] en ⇆ es
  [_n_] next error         [_t_] toggle dictionary     [_G_] any lang
  [_f_] toggle flyspell    [_d_] change dictionary
  [_p_] toggle prog mode
--------------------------------------------------------------------------------
      "
      ("w" ispell-word)
      ("d" ispell-change-dictionary)
      ("t" joe-switch-dictionary)
      ("g" google-translate-smooth-translate)
      ("G" google-translate-query-translate)
      ("f" flyspell-mode)
      ("p" flyspell-prog-mode)
      ("k" flyspell-correct-word-generic)
      ("n" flyspell-goto-next-error))

  (defhydra hydra-lisp (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
    Elisp              Bug hunter                                       │ Lisp │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_r_] eval region    [_f_] file
  [_s_] eval sexp      [_i_] init-file
  [_b_] eval buffer
--------------------------------------------------------------------------------
      "
      ("f" bug-hunter-file)
      ("i" bug-hunter-init-file)
      ("r" eval-region)
      ("b" eval-buffer)
      ("s" eval-last-sexp))

  (defhydra hydra-narrow (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                      ╭────────┐
    Narrow                                                            │ Narrow │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_f_] narrow to defun
  [_p_] narrow to page
  [_r_] narrow to region
  [_w_] widen
--------------------------------------------------------------------------------
      "
      ("f" narrow-to-defun)
      ("p" narrow-to-page)
      ("r" narrow-to-region)
      ("w" widen))

  (defhydra hydra-project (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                  ╭────────────┐
  Files             Search          Buffer             Do         │ Projectile │
╭─────────────────────────────────────────────────────────────────┴────────────╯
  [_f_] file          [_a_] ag          [_b_] switch         [_g_] magit
  [_l_] file dwim     [_A_] grep        [_v_] show all       [_p_] commander
  [_r_] recent file   [_s_] occur       [_V_] ibuffer        [_i_] info
  [_d_] dir           [_S_] replace     [_K_] kill all
  [_o_] other         [_t_] find tag
  [_u_] test file     [_T_] make tags
  [_h_] root
                                                                      ╭────────┐
  Other Window      Run             Cache              Do             │ Fixmee │
╭──────────────────────────────────────────────────╯ ╭────────────────┴────────╯
  [_F_] file          [_U_] test        [_kc_] clear         [_x_] TODO & FIXME
  [_L_] dwim          [_m_] compile     [_kk_] add current   [_X_] toggle
  [_D_] dir           [_c_] shell       [_ks_] cleanup
  [_O_] other         [_C_] command     [_kd_] remove
  [_B_] buffer
--------------------------------------------------------------------------------
      "
      ("a"   projectile-ag)
      ("A"   projectile-grep)
      ("b"   projectile-switch-to-buffer)
      ("B"   projectile-switch-to-buffer-other-window)
      ("c"   projectile-run-async-shell-command-in-root)
      ("C"   projectile-run-command-in-root)
      ("d"   projectile-find-dir)
      ("D"   projectile-find-dir-other-window)
      ("f"   projectile-find-file)
      ("F"   projectile-find-file-other-window)
      ("g"   projectile-vc)
      ("h"   projectile-dired)
      ("i"   projectile-project-info)
      ("kc"  projectile-invalidate-cache)
      ("kd"  projectile-remove-known-project)
      ("kk"  projectile-cache-current-file)
      ("K"   projectile-kill-buffers)
      ("ks"  projectile-cleanup-known-projects)
      ("l"   projectile-find-file-dwim)
      ("L"   projectile-find-file-dwim-other-window)
      ("m"   projectile-compile-project)
      ("o"   projectile-find-other-file)
      ("O"   projectile-find-other-file-other-window)
      ("p"   projectile-commander)
      ("r"   projectile-recentf)
      ("s"   projectile-multi-occur)
      ("S"   projectile-replace)
      ("t"   projectile-find-tag)
      ("T"   projectile-regenerate-tags)
      ("u"   projectile-find-test-file)
      ("U"   projectile-test-project)
      ("v"   projectile-display-buffer)
      ("V"   projectile-ibuffer)
      ("X"   fixmee-mode)
      ("x"   fixmee-view-listing))

  (defhydra hydra-exit (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                        ╭──────┐
   Quit                                                                 │ Exit │
╭───────────────────────────────────────────────────────────────────────┴──────╯
  [_c_] exit emacs (standalone or client)
  [_s_] shutdown the emacs daemon
--------------------------------------------------------------------------------
      "
      ("c" save-buffers-kill-terminal)
      ("s" save-buffers-kill-emacs))

  (defhydra hydra-register (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                    ╭──────────┐
   Logs                        Registers                Undo        │ Register │
╭───────────────────────────────────────────────────────────────────┴──────────╯
  [_c_] commands history       [^e^] emacs registers    [_u_] undo tree
  [_o_] messages               [_r_] evil registers
  [_l_] lossage (keystrokes)   [_m_] evil marks
  [_d_] diff buffer with file  [_k_] kill ring
--------------------------------------------------------------------------------
      "
      ("d" joe-diff-buffer-with-file)
      ("k" counsel-yank-pop)
      ("l" view-lossage)
      ("c" counsel-command-history)
      ("m" evil-show-marks)
      ("o" view-echo-area-messages)
      ("r" evil-show-registers)
      ("u" undo-tree-visualize))

  (defhydra hydra-search (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                      ╭────────┐
   Files                             Buffer                           │ Search │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_a_] regex search (Ag)           [_b_] by word
  [_r_] regex search (rg)           [_o_] by word (opened buffers)
  [_p_] regex search (pt)           [_w_] by word (multi)
  [_g_] regex search (grep)         [_h_] by word (grep or swiper)
  [^f^] find                        [_t_] tags & titles
  [_l_] locate                      [_s_] semantic
--------------------------------------------------------------------------------
      "
      ("a" (let ((current-prefix-arg "-."))
             (call-interactively 'counsel-ag)))
      ("r" (let ((current-prefix-arg "-."))
             (call-interactively 'counsel-rg)))
      ("p" (let ((current-prefix-arg "-."))
             (call-interactively 'counsel-pt)))
      ("g" rgrep)
      ("l" counsel-locate)
      ("b" swiper)
      ("o" swiper-all)
      ("h" counsel-grep-or-swiper)
      ("t" counsel-imenu)
      ("s" counsel-semantic)
      ("w" swiper-multi))

  (defhydra hydra-system (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                      ╭────────┐
   Terminals                     System                               │ System │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_s_] new multi-term           [_c_] shell command
  [_n_] next multi-term          [_a_] aync shell command
  [_p_] previous multi-term      [_m_] man page
  [_d_] dedicated multi-term     [_l_] list system process
  [_e_] eshell
--------------------------------------------------------------------------------
      "
      ("a" async-shell-command)
      ("c" shell-command)
      ("e" eshell)
      ("m" man)
      ("l" proced)
      ("s" multi-term)
      ("n" multi-term-next)
      ("p" multi-term-previous)
      ("d" multi-term-dedicated-toggle))

  (defhydra hydra-media (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                       ╭───────┐
   Mingus              Mpd                     Volume                  │ Media │
╭──────────────────────────────────────────────────────────────────────┴───────╯
 [_m_] mingus         [_n_] next song          [_-_] volume down
 [_f_] search         [_p_] previous song      [_+_] volume up
 [_l_] playlist       [_c_] clear playlist
 [_a_] All            [_t_] pause
  ^ ^                 [_s_] stop
  ^ ^                 [_d_] start daemon
--------------------------------------------------------------------------------
      "
      ("m" mingus)
      ("f" mingus-search)
      ("c" mingus-clear)
      ("n" mingus-next)
      ("p" mingus-prev)
      ("t" mingus-toggle)
      ("s" mingus-stop)
      ("d" mingus-start-daemon)
      ("l" mingus-load-playlist)
      ("a" mingus-load-all)
      ("-" mingus-vol-down)
      ("\+" mingus-vol-up))

  (defhydra hydra-organization (:color blue :hint nil :idle 0.4 :inherit (hydra-common/heads))
      "
                                                                ╭──────────────┐
     Tasks            Org mode               Comms      Others  │ Organization │
╭───────────────────────────────────────────────────────────────┴──────────────╯
  [_a_] agenda      [_c_] capture             [_m_] mail      [_x_] speed type
  [_l_] agenda list [_p_] pomodoro            [_t_] contacts
  [_d_] calendar    [_s_] search headings     [_h_] add location
   ^ ^              [_g_] open location gmaps
   ^ ^              [_f_] archive subtree
--------------------------------------------------------------------------------
      "
      ("a" org-agenda)
      ("c" org-capture)
      ("s" counsel-org-agenda-headlines)
      ("d" cfw:open-org-calendar)
      ("g" org-location-google-maps)
      ("h" org-address-google-geocode-set)
      ("l" org-agenda-list)
      ("f" org-archive-subtree)
      ("m" mu4e)
      ("p" org-pomodoro)
      ("t" org-contacts)
      ("x" speed-type-text))

   (defhydra hydra-leader ( :color blue :hint nil :idle 0.4)
       "
                                                                      ╭────────┐
   Toggle                        Do                                   │ Leader │
╭─────────────────────────────────────────────────────────────────────┴────────╯
  [_c_] comment                  [_a_] align with regex
  [_f_] fill column              [_p_] show character code
  [_h_] hidden chars             [_i_] insert unicode character
  [_e_] trailing whitespace      [_<SPC>_] remove trailing whitespaces
  [_v_] font space               [_u_] undo tree
   ^ ^                           [_j_] jump word
   ^ ^                           [_x_] comment box
   ^ ^                           [_r_] expand region
   ^ ^                           [_m_] iedit (multiple edit)
   ^ ^                           [_g_] google translate
   ^ ^                           [_s_] swiper
   ^ ^                           [_t_] counsel imenu
   ^ ^                           [_q_] quick-calc
--------------------------------------------------------------------------------
      "
      ("<escape>" nil "quit")
      ("a" align-regexp)
      ("c" comment-line)
      ("r" er/expand-region)
      ("f" fci-mode)
      ("g" google-translate-smooth-translate)
      ("h" whitespace-mode)
      ("i" counsel-unicode-char)
      ("j" avy-goto-word-1)
      ("m" iedit-mode)
      ("n" count-words)
      ("p" describe-char)
      ("e" joe-toggle-show-trailing-whitespace)
      ("u" undo-tree-visualize)
      ("v" variable-pitch-mode)
      ("<SPC>" whitespace-cleanup)
      ("s" joe-swiper)
      ("t" counsel-imenu)
      ("q" (quick-calc t))
      ("x" comment-box)))
#+end_src

#+RESULTS:
: t

** karthydra
#+begin_src emacs-lisp

;;;----------------------------------------------------------------
;; ** HYDRAS
;;;----------------------------------------------------------------
(use-package! hydra
  :defer
  :ensure t
  :config
  (with-eval-after-load 'ediff
    (defhydra hydra-ediff (:color blue :hint nil)
      "
^Buffers           Files           VC                     Ediff regions
----------------------------------------------------------------------
_b_uffers           _f_iles (_=_)       _r_evisions              _l_inewise
_B_uffers (3-way)   _F_iles (3-way)                          _w_ordwise
                  _c_urrent file
"
      ("b" ediff-buffers)
      ("B" ediff-buffers3)
      ("=" ediff-files)
      ("f" ediff-files)
      ("F" ediff-files3)
      ("c" ediff-current-file)
      ("r" ediff-revision)
      ("l" ediff-regions-linewise)
      ("w" ediff-regions-wordwise)))

  (with-eval-after-load 'smerge-mode
    (defhydra hydra-smerge
      (:color pink :hint nil :post (smerge-auto-leave))
      "
^Move^       ^Keep^               ^Diff^                 ^Other^
^^-----------^^-------------------^^---------------------^^-------
_n_ext       _b_ase               _<_: upper/base        _C_ombine
_p_rev       _u_pper              _=_: upper/lower       _r_esolve
^^           _l_ower              _>_: base/lower        _k_ill current
^^           _a_ll                _R_efine
^^           _RET_: current       _E_diff
"
      ("n" smerge-next)
      ("p" smerge-prev)
      ("b" smerge-keep-base)
      ("u" smerge-keep-upper)
      ("l" smerge-keep-lower)
      ("a" smerge-keep-all)
      ("RET" smerge-keep-current)
      ("\C-m" smerge-keep-current)
      ("<" smerge-diff-base-upper)
      ("=" smerge-diff-upper-lower)
      (">" smerge-diff-base-lower)
      ("R" smerge-refine)
      ("E" smerge-ediff)
      ("C" smerge-combine-with-next)
      ("r" smerge-resolve)
      ("k" smerge-kill-current)
      ("ZZ" (lambda ()
              (interactive)
              (save-buffer)
              (bury-buffer))
       "Save and bury buffer" :color blue)
      ("q" nil "cancel" :color blue)))

  (with-eval-after-load 'outline
    (defhydra hydra-outline (:color pink :hint nil)
      "
^Hide^             ^Show^           ^Move
^^^^^^------------------------------------------------------
_q_: sublevels     _a_: all         _u_: up
_t_: body          _e_: entry       _n_: next visible
_o_: other         _i_: children    _p_: previous visible
_c_: entry         _k_: branches    _f_: forward same level
_l_: leaves        _s_: subtree     _b_: backward same level
_d_: subtree

"
      ;; Hide
      ("q" outline-hide-sublevels)    ; Hide everything but the top-level headings
      ("t" outline-hide-body)         ; Hide everything but headings (all body lines)
      ("o" outline-hide-other)        ; Hide other branches
      ("c" outline-hide-entry)        ; Hide this entry's body
      ("l" outline-hide-leaves)       ; Hide body lines in this entry and sub-entries
      ("d" outline-hide-subtree)      ; Hide everything in this entry and sub-entries
      ;; Show
      ("a" outline-show-all)          ; Show (expand) everything
      ("e" outline-show-entry)        ; Show this heading's body
      ("i" outline-show-children)     ; Show this heading's immediate child sub-headings
      ("k" outline-show-branches)     ; Show all sub-headings under this heading
      ("s" outline-show-subtree)      ; Show (expand) everything in this heading & below
      ;; Move
      ("u" outline-up-heading)                ; Up
      ("n" outline-next-visible-heading)      ; Next
      ("p" outline-previous-visible-heading)  ; Previous
      ("f" outline-forward-same-level)        ; Forward - same level
      ("b" outline-backward-same-level)       ; Backward - same level
      ("z" nil "leave")))

  :general
  (:keymaps 'smerge-mode-map
            "C-c s" 'hydra-smerge/body)
  (:keymaps 'space-menu-window-map
            "u" '(hydra-winner/body
                  :wk "winner-mode"))
  (:states '(motion)
           "C-w u" 'hydra-winner/body)
  ("C-c <tab>" 'hydra-outline/body)
  (:keymaps 'space-menu-map
            "t" 'hydra-toggle-menu/body)
  (:keymaps 'space-menu-map
            :prefix "f"
            "=" 'hydra-ediff/body))

 #+end_src

 #+RESULTS:

** git-time-machine
#+begin_src emacs-lisp :tangle no
(use-package! git-timemachine
  ;; :ensure t
  :commands git-timemachine
  :config
  (progn
    (bind-keys :map git-timemachine-mode
               ("c" . git-timemachine-show-current-revision)
               ("b" . git-timemachine-switch-branch))
    (when (package-installed-p 'hydra)
        (bind-keys :map git-timemachine-mode
                ("\\" . hydra-timemachine/body))
        (defhydra hydra-timemachine (:hint nil :color blue)
                "
                                                                        ╭──────────────────┐
              Rev.   Do                                                 │ Git time-machine │
            ╭───────────────────────────────────────────────────────────┴──────────────────╯
              _n_      [_w_] abbrv hash
              ^↑^      [_W_] full hash
              ^|^      [_g_] go to revision
              ^↓^      [_c_] show current
              _p_      [_b_] switch branch
              ^ ^      [_q_] quit
            --------------------------------------------------------------------------------
                "
                ("\\" hydra-master/body "back")
                ("<ESC>" nil "quit")
                ("q"       git-timemachine-quit)
                ("n"       git-timemachine-show-next-revision)
                ("p"       git-timemachine-show-previous-revision)
                ("g"       git-timemachine-show-nth-revision)
                ("c"       git-timemachine-show-current-revision)
                ("w"       git-timemachine-kill-abbreviated-revision)
                ("W"       git-timemachine-kill-revision)
                ("b"       git-timemachine-switch-branch)))
    (defadvice git-timemachine-mode (after toggle-evil activate)
      "Turn off `evil-local-mode' when enabling `git-timemachine-mode',
      and turn it back on when disabling `git-timemachine-mode'."
      (evil-local-mode (if git-timemachine-mode -1 1)))))
#+end_src
* Avy
** general avy
I definitely need to use it more. It allows to quickly jump around, both in the same and in other buffers.

The =avy= package by Oleh Krehel lets you select a location on the screen
to move the cursor to.  It does so by producing an overlay with
characters that need to be typed to specify the location.  By default,
the overlay covers the candidate, though I change the =avy-style= to have
it appear as a prefix instead.

There are several commands on offer which narrow down the candidates.
My favourite is =avy-goto-char-timer= (closely followed by =avy-goto-char-2=
and =avy-goto-word-1=).  It prompts for a character and then has a time
window lasting =avy-timeout-seconds= during which it can read more
characters.  Once Avy receives the input, it overlays every word that
contains those characters in succession.  If there is a single match, it
jumps directly to it.

Avy has the ability to act on the candidate rather than simply jump to
it.  Karthik Chikmagalur has a comprehensive essay on the matter, which
I consider essential reading for anyone wanting to make best use of this
package: [[https://karthinks.com/software/avy-can-do-anything/][Avy can do anything]] (2021-10-21).  I still am not sure whether
I need all that power though, as in my workflow I jump to a point and
then invoke =embark-act= (see [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions (embark.el)]]).

Finally, we can use Avy to select a candidate from the =*Completions*=
buffer (see [[#h:c110e399-3f43-4555-8427-b1afe44c0779][Minibuffer configurations and my extras (mct.el)]]).

#+begin_src emacs-lisp :tangle no

(use-package! avy
  :config
  (setq avy-all-windows nil) ; only the current window
  (setq avy-all-windows-alt t) ; all windows with C-u
  (setq avy-single-candidate-jump t)
  (setq avy-background nil)
  (setq avy-case-fold-search nil) ; case is significant
  (setq avy-timeout-seconds 0.5)
  (setq avy-style 'pre) ; prefixes candidate; otherwise use `at-full'
  ;; (define-key global-map (kbd "C-.") #'avy-goto-char-timer))
  :bind (("C-c s" . avy-goto-char-timer)
        ("M-g c" . avy-goto-char)
         ("M-g C" . avy-goto-char-2)
         ("M-g w" . avy-goto-word-1)
         ("M-g f" . avy-goto-line)
         :map isearch-mode-map
         ("C-'" . avy-isearch))

  :custom
  (avy-keys '(?h ?a ?t ?e ?i ?s ?c ?n))
  (avy-dispatch-alist
   '((?k . avy-action-kill-move)
     (?K . avy-action-kill-stay)
     (?t . avy-action-teleport)
     (?m . avy-action-mark)
     (?w . avy-action-copy)
     (?y . avy-action-yank)
     (?Y . avy-action-yank-Line)
     (?z . avy-action-zap-to-char)))
            (avy-background t)
            (avy-all-windows t)
            (avy-style 'at-full)
            (avy-case-fold-search nil)
  (avy-single-candidate-jump t))
#+end_src

#+RESULTS:
: avy-isearch

** pro avy
#+begin_src emacs-lisp
;; ** AVY
;;;----------------------------------------------------------------
(use-package! avy
  :ensure t
  :commands (avy-goto-word-1 avy-goto-char-2 avy-goto-char-timer)
  :config
  (setq avy-timeout-seconds 0.24)
  (setq avy-keys '(?a ?s ?d ?f ?g ?j ?l ;?x
                   ?v ?b ?n ?, ?/ ?u ?p ?e ?.
                   ?c ?q ?2 ?3 ?' ?\;))
  (setq avy-dispatch-alist '((?m . avy-action-mark)
                             (?  . avy-action-mark-to-char)
                             (?i . avy-action-ispell)
                             (?z . avy-action-zap-to-char)
                             (?o . avy-action-embark)
                             (?= . avy-action-define)
                             (67108925 . avy-action-tuxi)
                             ;; (?W . avy-action-tuxi)
                             (?h . avy-action-helpful)
                             (?x . avy-action-exchange)

                             (11 . avy-action-kill-line)
                             (25 . avy-action-yank-line)

                             (?w . avy-action-easy-copy)
                             ;; (134217847  . avy-action-easy-copy)
                             (?k . avy-action-kill-stay)
                             (?y . avy-action-yank)
                             (?t . avy-action-teleport)

                             (?W . avy-action-copy-whole-line)
                             (?K . avy-action-kill-whole-line)
                             (?Y . avy-action-yank-whole-line)
                             (?T . avy-action-teleport-whole-line)))

  (defun avy-action-easy-copy (pt)
        (require 'easy-kill)
        (goto-char pt)
        (cl-letf (((symbol-function 'easy-kill-activate-keymap)
                   (lambda ()
                     (let ((map (easy-kill-map)))
                       (set-transient-map
                        map
                        (lambda ()
                          ;; Prevent any error from activating the keymap forever.
                          (condition-case err
                              (or (and (not (easy-kill-exit-p this-command))
                                       (or (eq this-command
                                               (lookup-key map (this-single-command-keys)))
                                           (let ((cmd (key-binding
                                                       (this-single-command-keys) nil t)))
                                             (command-remapping cmd nil (list map)))))
                                  (ignore
                                   (easy-kill-destroy-candidate)
                                   (unless (or (easy-kill-get mark) (easy-kill-exit-p this-command))
                                     (easy-kill-save-candidate))))
                            (error (message "%s:%s" this-command (error-message-string err))
                                   nil)))
                        (lambda ()
                          (let ((dat (ring-ref avy-ring 0)))
                            (select-frame-set-input-focus
                             (window-frame (cdr dat)))
                            (select-window (cdr dat))
                            (goto-char (car dat)))))))))
          (easy-kill)))

  (defun avy-action-exchange (pt)
  "Exchange sexp at PT with the one at point."
  (set-mark pt)
  (transpose-sexps 0))

  (defun avy-action-helpful (pt)
    (save-excursion
      (goto-char pt)
      (helpful-at-point))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-define (pt)
    (cl-letf (((symbol-function 'keyboard-quit)
            #'abort-recursive-edit))
      (save-excursion
        (goto-char pt)
        (dictionary-search-dwim))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)

  (defun avy-action-tuxi (pt)
    (cl-letf (((symbol-function 'keyboard-quit)
            #'abort-recursive-edit))
      (save-excursion
        (goto-char pt)
        (google-search-at-point))
      (select-window
       (cdr (ring-ref avy-ring 0))))
    t)

  (defun avy-action-embark (pt)
    (unwind-protect
        (save-excursion
          (goto-char pt)
          (embark-act)))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-kill-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-line))
    (select-window
     (cdr (ring-ref avy-ring 0)))
    t)

  (defun avy-action-copy-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (cl-destructuring-bind (start . end)
          (bounds-of-thing-at-point 'line)
        (copy-region-as-kill start end)))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)

  (defun avy-action-kill-whole-line (pt)
    (save-excursion
      (goto-char pt)
      (kill-whole-line))
    (select-window
     (cdr
      (ring-ref avy-ring 0)))
    t)

  (defun avy-action-yank-whole-line (pt)
    (avy-action-copy-whole-line pt)
    (save-excursion (yank))
    t)

  (defun avy-action-teleport-whole-line (pt)
    (avy-action-kill-whole-line pt)
    (save-excursion (yank)) t)

  (defun avy-action-mark-to-char (pt)
    (activate-mark)
    (goto-char pt))

  (defun my/avy-goto-char-this-window (&optional arg)
    "Goto char in this window with hints."
    (interactive "P")
    (let ((avy-all-windows t)
          (current-prefix-arg (if arg 4)))
      (call-interactively 'avy-goto-word-1)))

  (defun my/avy-isearch (&optional arg)
    "Goto isearch candidate in this window with hints."
    (interactive "P")
    (let ((avy-all-windows)
          (current-prefix-arg (if arg 4)))
      (call-interactively 'avy-isearch)))

  (defun my/avy--read-char-2 (char1 char2)
    "Read two characters from the minibuffer."
    (interactive (list (let ((c1 (read-char "char 1: " t)))
                         (if (memq c1 '(? ?\b))
                             (keyboard-quit)
                           c1))
                       (let ((c2 (read-char "char 2: " t)))
                         (cond ((eq c2 ?)
                                (keyboard-quit))
                               ((memq c2 '(8 127))
                                (keyboard-escape-quit)
                                (call-interactively 'my/avy-next-char-2))
                               (t
                                c2)))))

    (when (eq char1 ?) (setq char1 ?\n))
    (when (eq char2 ?) (setq char2 ?\n))
    (string char1 char2))

  (defun my/avy-next-char-2 (&optional str2 arg)
    "Go to the next occurrence of two characters"
    (interactive (list
                  (call-interactively 'my/avy--read-char-2)
                  current-prefix-arg))
    (let* ((ev last-command-event)
           (echo-keystrokes nil))
      (push-mark (point) t)
      (if (search-forward str2 nil t
                           (+ (if (looking-at (regexp-quote str2))
                                  1 0)
                              (or arg 1)))
           (backward-char 2)
        (pop-mark)))

    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (define-key map (kbd ";") (lambda (&optional arg) (interactive)
                                   (my/avy-next-char-2 str2 arg)))
       (define-key map (kbd ",") (lambda (&optional arg) (interactive)
                                   (my/avy-previous-char-2 str2 arg)))
       map)))

  (defun my/avy-previous-char-2 (&optional str2 arg)
    "Go to the next occurrence of two characters"
       (interactive (list
                  (call-interactively 'my/avy--read-char-2)
                  current-prefix-arg))
       (let* ((ev last-command-event)
              (echo-keystrokes nil))
         (push-mark (point) t)
         (unless (search-backward str2 nil t (or arg 1))
           (pop-mark)))

    (set-transient-map
     (let ((map (make-sparse-keymap)))
       (define-key map (kbd ";") (lambda (&optional arg) (interactive)
                                   (my/avy-next-char-2 str2 arg)))
       (define-key map (kbd ",") (lambda (&optional arg) (interactive)
                                   (my/avy-previous-char-2 str2 arg)))
       map)))

  (defun my/avy-copy-line-no-prompt (arg)
    (interactive "p")
    (avy-copy-line arg)
    (beginning-of-line)
    (zap-to-char 1 32)
    (delete-forward-char 1)
    (move-end-of-line 1))

  :general
  ("C-'"        '(my/avy-goto-char-this-window :wk "Avy goto char")
   "M-s j"      '(avy-goto-char-2            :wk "Avy goto char 2")
   "M-s y"      '(avy-copy-line              :wk "Avy copy line above")
   "M-s M-y"    '(avy-copy-region            :wk "Avy copy region above")
   "M-s M-k"    '(avy-kill-whole-line        :wk "Avy copy line as kill")
   "M-j"        '(avy-goto-char-timer        :wk "Avy goto char timer")
   "M-s C-w"    '(avy-kill-region            :wk "Avy kill region")
   "M-s M-w"    '(avy-kill-ring-save-region  :wk "Avy copy as kill")
   "M-s t"      '(avy-move-line              :wk "Avy move line")
   "M-s M-t"    '(avy-move-region            :wk "Avy move region")
   "M-s s"      '(my/avy-next-char-2         :wk "Avy snipe forward")
   "M-s r"      '(my/avy-previous-char-2     :wk "Avy snipe backward")
   "M-g l"      '(avy-goto-end-of-line       :wk "Avy goto line")
   "M-s z"      '(my/avy-copy-line-no-prompt :wk "Avy copy and zap"))
  ;; (:states '(normal visual)
  ;;  :prefix "g"
  ;;  "s" 'avy-goto-char-timer)
  :bind (:map isearch-mode-map
         ("C-'" . my/avy-isearch)
         ("M-j" . my/avy-isearch)))
#+end_src

#+RESULTS:
: my/avy-isearch
* Internet & services
** DONE Network Manager
CLOSED: [2022-03-30 Wed 09:36]

#+begin_src emacs-lisp

(defvar counsel-network-manager-history nil
  "Network manager history.")

(defun counsel-network-manager (&optional initial-input)
  "Connect to wifi network."
  (interactive)
  (shell-command "nmcli device wifi rescan")
  (let ((networks-list (s-split "\n" (shell-command-to-string "nmcli device wifi list"))))
    (ivy-read "Select network" networks-list
              :initial-input initial-input
              :require-match t
              :history counsel-network-manager-history
              :sort nil
              :caller 'counsel-network-manager
              :action (lambda (line)
                        (let ((network (car (s-split " " (s-trim (s-chop-prefix "*" line)) t))))
                          (message "Connecting to \"%s\".." network)
                          (async-shell-command
                           (format "nmcli device wifi connect %s" (shell-quote-argument network))))))))
#+end_src

#+RESULTS:
: counsel-network-manager

** DONE url util
CLOSED: [2022-03-30 Wed 09:31]
#+begin_src emacs-lisp
;;; URLs
(require 'url-util)
(use-package! goto-addr
  :hook ((compilation-mode . goto-address-mode)
          (prog-mode . goto-address-prog-mode)
          (magit-mode . goto-address-mode)
          (yaml-mode . goto-address-prog-mode)
          (mu4e-view-mode . goto-address-mode))
  :commands (goto-address-prog-mode
             goto-address-mode))


#+end_src
** DONE Wolfram alpha
CLOSED: [2022-03-30 Wed 09:32]
#+BEGIN_SRC emacs-lisp
;; wolfram alpha queries (M-x wolfram-alpha)
(use-package! wolfram
  :defer t
  :config
  (setq wolfram-alpha-app-id "KTKV36-2LRW2LELV8"))
#+END_SRC

#+RESULTS:
: t

** DONE Webpaste
CLOSED: [2022-04-01 Fri 16:00]
#+begin_src emacs-lisp
;; It's useful to send a buffer, or part of it, to a bin online and then send the corresponding link to someone. The clbin package does that, in a DWIM manner: send the current region (if any) or the whole buffer, and save the corresponding url in the kill-ring.
;; (use-package! clbin
;;   ;; :straight nil
;;   :bind ("C-c w" . clbin-dwim))
(use-package! webpaste
  ;; :ensure t
  :bind (("C-c C-p C-b" . webpaste-paste-buffer)
         ("C-c C-p C-r" . webpaste-paste-region)
         ("C-c C-p C-p" . webpaste-paste-buffer-or-region))
  :config
  (progn
    ;; (setq webpaste-provider-priority '("ix.io" "dpaste.org"))))
;; Choosing githup gist only
(setq webpaste-provider-priority '("gist.github.com"))

;; Choosing ix.io as first provider and dpaste.org as second
(setq webpaste-provider-priority '("ix.io" "dpaste.org"))

;; Choosing 1) ix.io, 2) dpaste.org, 3) dpaste.com
(setq webpaste-provider-priority '("ix.io" "dpaste.org" "dpaste.com"))))

;; You can always append this list as much as you like, and which providers
;; that exists is documented below in the readme.
;; Require confirmation before doing paste
(setq webpaste-paste-confirmation t)
;; Do maximum 13 retries instead of standard 10
(setq webpaste-max-retries 13)
(setq webpaste-add-to-killring nil);; Simple hook to just message the URL, this is more or less the default
;; already. But if you disable the default and still want a message, this
;; would work fine.
(add-hook 'webpaste-return-url-hook 'message)

;; To build your own send-to-browser hook, you could do like this:
(add-hook 'webpaste-return-url-hook
          (lambda (url)
            (message "Opened URL in browser: %S" url)
            (browse-url-generic url)))

;; Simple hook to replicate the `webpaste-copy-to-clipboard' option
(add-hook 'webpaste-return-url-hook 'simpleclip-set-contents)
#+end_src

#+RESULTS:
| simpleclip-set-contents | (lambda (url) (message Opened URL in browser: %S url) (browse-url-generic url)) | message |

** DONE 0x0
CLOSED: [2022-04-01 Fri 15:59]
#+begin_src emacs-lisp
(use-package! 0x0
  :ensure
  :commands (0x0-upload 0x0-dwim)
  :bind ("C-x U" . 0x0-dwim))
#+end_src
** DONE OpenStreetMap viewer (osm.el)
CLOSED: [2022-04-01 Fri 16:01]
:PROPERTIES:
:CUSTOM_ID: h:db40bd63-fe98-42b2-a10d-83966a59be4e
:END:

This is yet another brilliant package by Daniel Mendler.  It uses Emacs'
image viewing facilities in combination with asynchronous =curl= calls
to fetch and present maps from the OpenStreetMap project.

Viewing maps is just the beginning.  It is also possible to use the
standard bookmark facility to store the coordinates of a location and
visit them on demand ([[#h:79cd6177-a81b-420f-8759-e6927b974377][Built-in bookmarking framework]]).  Or invoke the
=org-store-link= command to capture the information about the current
coordinates and produce a direct link out of them with =org-insert-link=
([[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]]).

What I like the most about =osm= is that it pushes the boundaries of
what we can do with Emacs.  It does so in a way that feels natural and
actually useful.  Well done, Daniel!

#+begin_src emacs-lisp :tangle no
(use-package! osm
  :config

  (let ((map global-map))
    (define-key map (kbd "C-c \" h") #'osm-home)
    (define-key map (kbd "C-c \" s") #'osm-search)
    (define-key map (kbd "C-c \" t") #'osm-server)
    (define-key map (kbd "C-c \" g") #'osm-goto)
    (define-key map (kbd "C-c \" j") #'osm-bookmark-jump))

  ;; Load Org link support
  (with-eval-after-load 'org
    (require 'osm-ol)))
#+end_src

#+RESULTS:
: t

** DONE launch firefox
CLOSED: [2022-04-14 Thu 17:30]
#+begin_src emacs-lisp :tangle yes

    (defun my/launch-firefox-private (&optional arg)
      "Launch Firefox.
  With `\\[universal-argument]' prefix argument ARG, create private
  window."
      (interactive "P")
      (make-process
       :name "firefox"
       :command `("firefox" ,(if arg "--private-window" "--new-window"))))
#+end_src

#+RESULTS:
: my/launch-firefox-private

** ERC
ERC is a built-in Emacs IRC client.

To get started, run =M-x irc= and confirm your choice at the prompts.  The
defaults for the server and the connection port should be fine.  In my
case, those steps are skipped because of the values specified in the
=rcirc-server-alist=.  Note the presence of =prot-mail-auth-get-field=.
This is a function that queries my =~/.authinfo.gpg= file to retrieve
encrypted information stored there (see [[#h:8d0bd754-8a31-431b-b112-f541cc0144ac][Sample of authinfo.gpg]]).  I use
this method to (i) automate the process of logging in while (ii) not
divulging sensitive data (also see the mega-section on [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]]).

IRC is fairly easy to use: you just type your message at the command
prompt and everyone in the channel can see it.  Some things I learnt:

+ Join a channel like =#emacs= by typing at the prompt =/join #emacs=.
+ Leave a channel with =/leave #vim= 😉.
+ To quit IRC do =/quit=, or optionally =/quit Going for a brisk walk=.
+ You can mention another user in the channel just by including their
  nick in your message, like =Hello protesilaos=.  When replying to
  someone, do it like this =protesilaos: My reply here=.
+ Start a private channel with, say, =protesilaos= by running the command
  =/msg protesilaos My message here=.  Then use the channel like any
  other.


| COMMAND | DESCRIPTION                                 | KEYBINDING |
|---------+---------------------------------------------+------------|
| erc-tls | /Launch ERC using more secure TLS connection/ | SPC e E    |

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("e". "evaluate/ERC/EWW")
       :desc "Launch ERC with TLS connection" "E" #'erc-tls))

(setq erc-prompt (lambda () (concat "[" (buffer-name) "]"))
      erc-server "irc.libera.chat"
      erc-nick "akhil3417"
      erc-user-full-name "Akhil Pratap Singh"
      erc-track-shorten-start 24
      erc-autojoin-channels-alist '(("irc.libera.chat" "#unixtube" "#emacs"))
      erc-kill-buffer-on-part t
      erc-fill-column 100
      erc-fill-function 'erc-fill-static
      erc-fill-static-center 20
      ;; erc-auto-query 'bury
      )

#+end_src
** telega
#+begin_src emacs-lisp :tangle yes

(use-package! telega
    :commands (telega)
    :init
        (defun my/telega/olivetti () (setq-local olivetti-body-width 100))
        (defun my/telega/company-backends ()
            (setq-local company-backends
                (append '(telega-company-username telega-company-botcmd )
                        company-backends)))
    ;; :hook (telega-chat-mode . olivetti-mode)
          ;; (telega-chat-mode . my/telega/olivetti)
      :hook   (telega-chat-mode . my/telega/company-backends)
    :config
    ;; (telega-mode-line-mode)
    ;; (telega-notifications-mode 1)
  ;; clear all bindings (he willl introduce many conflicting bindings again :/)
  (setf (cdr telega-chat-mode-map) nil)
  (setf (cdr telega-msg-button-map) nil)
  ;; (setf (cdr telega-root-mode-map) nil)
  ;; (setq telega-root-mode-map nil)
  ;;Easy closing
  (map! :map telega-root-mode-map
        :n "q" 'bury-buffer)
  (map! :map telega-chat-mode-map
        :n "q" 'bury-buffer)
  ;;Open Telega
  (map! :leader
        :prefix "o"
        :desc "Telega" "g" #'telega)
  ;; :desc "Telega" "g" #'=telegram)
  (map! :after telega
        :mode telega-root-mode
        "C-j" 'telega-button-forward
        "C-k" 'telega-button-backward

        "C-/" 'telega-filter-undo
        "C-_" 'telega-filter-undo
        "C-x C-/" 'telega-filter-redo
        "C-x C-_" 'telega-filter-redo

        [?\t] 'telega-button-forward
        "\e\t" 'telega-button-backward
        [backtab] 'telega-button-backward

        ;; "M-g u" 'telega-root-next-unread
        ;; "M-g i" 'telega-root-next-important
        ;; "M-g m" 'telega-root-next-mention
        ;; "M-g @" 'telega-root-next-mention

        (:localleader
         ;; "q" 'bury-buffer
         ;; "Q" 'telega-kill
         "J" 'telega-chat-join-by-link
         "N" 'telega-chat-create

         ;; NOTE: Deleting all chats is very-very-very dangerous, so
         ;; disabled, use M-x telega-chats-filtered-delete RET if you know
         ;; what you are doing
         ;; (define-key map (kbd "D") 'telega-chats-filtered-delete)

         "K" 'telega-chats-filtered-kill-chatbuf
         "R" 'telega-chats-filtered-toggle-read

         :desc "sort" "\\" telega-sort-map

         :desc "filter" "/" telega-filter-map

         (:prefix ("?" . "describe")
          "w" 'telega-describe-connected-websites
          "s" 'telega-describe-active-sessions
          "n" 'telega-describe-network
          "y" 'telega-describe-notifications
          "N" 'telega-describe-notifications
          "p" 'telega-describe-privacy-settings)

         (:prefix ("F" . "folder")
          "+" 'telega-folder-create
          "-" 'telega-folder-delete
          "=" 'telega-folders-reorder
          "R" 'telega-folder-rename
          "a" 'telega-chat-add-to-folder
          "d" 'telega-chat-remove-from-folder)

         (:prefix ("c". "call")
          "a" 'telega-voip-accept
          "d" 'telega-voip-discard
          "b" 'telega-voip-buffer-show
          "l" 'telega-voip-list-calls)

         (:prefix ("v" . "View")
          "s" 'telega-view-search
          "s" 'telega-view-search
          "n" 'telega-view-nearby
          "v" 'telega-view-reset
          "0" 'telega-view-compact
          "1" 'telega-view-one-line
          "2" 'telega-view-two-lines
          "t" 'telega-view-topics
          "T" 'telega-view-top
          "S" 'telega-view-settings
          "c" 'telega-view-contacts
          "C" 'telega-view-calls
          "l" 'telega-view-last-messages
          "f" 'telega-view-folders
          "^" 'telega-view-pinned-messages
          "p" 'telega-view-pinned-messages
          "d" 'telega-view-deleted-chats)))

  (map! :mode telega-chat-mode
        :map telega-chat-mode-map
        "C-l" 'telega-chatbuf-recenter-1

        ;; ;; C-M-[ - cancels edit/reply
        "\e\e" 'telega-chatbuf-cancel-aux
        "C-c C-k" 'telega-chatbuf-cancel-aux
        "C-M-c" 'telega-chatbuf-cancel-aux
        "C-M-a" 'telega-chatbuf-beginning-of-thing

        "C-c ?" 'telega-describe-chat

        "RET" 'telega-chatbuf-newline-or-input-send
        "M-p" 'telega-chatbuf-edit-prev
        "M-n" 'telega-chatbuf-edit-next
        "M-r" 'telega-chatbuf-input-search

        ;; ;;; ellit-org: chatbuf-attach-bindings
        ;; ;; - {{{where-is(telega-chatbuf-attach,telega-chat-mode-map)}}} ::
        ;; ;;   {{{fundoc(telega-chatbuf-attach,2)}}}
        ;; (define-key map (kbd "C-c C-a") 'telega-chatbuf-attach)
        ;; ;;; ellit-org: chatbuf-attach-bindings
        ;; ;; - {{{where-is(telega-chatbuf-attach-media,telega-chat-mode-map)}}} ::
        ;; ;;   {{{fundoc(telega-chatbuf-attach-media,2)}}}
        ;; (define-key map (kbd "C-c C-f") 'telega-chatbuf-attach-media)
        ;; ;;; ellit-org: chatbuf-attach-bindings
        ;; ;; - {{{where-is(telega-chatbuf-attach-clipboard,telega-chat-mode-map)}}} ::
        ;; ;;   {{{fundoc(telega-chatbuf-attach-clipboard,2)}}}
        ;; (define-key map (kbd "C-c C-v") 'telega-chatbuf-attach-clipboard)

        ;; ;;; ellit-org: chatbuf-filtering-bindings
        ;; ;; - {{{where-is(telega-chatbuf-filter,telega-chat-mode-map)}}} ::
        ;; ;;   {{{fundoc(telega-chatbuf-filter,2)}}}
        ;; (define-key map (kbd "C-c /") 'telega-chatbuf-filter)
        ;; ;;; ellit-org: chatbuf-filtering-bindings
        ;; ;; - {{{where-is(telega-chatbuf-filter-cancel,telega-chat-mode-map)}}} ::
        ;; ;;   {{{fundoc(telega-chatbuf-filter-cancel, 2)}}}
        ;; (define-key map (kbd "C-c C-c") 'telega-chatbuf-filter-cancel)
        ;; ;;; ellit-org: chatbuf-filtering-bindings
        ;; ;; - {{{where-is(telega-chatbuf-filter-search,telega-chat-mode-map)}}} ::
        ;; ;;   {{{fundoc(telega-chatbuf-filter-search, 2)}}}
        ;; (define-key map (kbd "C-c C-s") 'telega-chatbuf-filter-search)
        ;; (define-key map (kbd "C-c C-r") 'telega-chatbuf-filter-search)

        ;; ;; jumping around links
        "TAB" 'telega-chatbuf-complete-or-next-link
        "<backtab>" 'telega-chatbuf-prev-link

        ;; Additional prefix keymaps
        "M-g" telega-chatbuf-fastnav-map
        (:localleader
         ;; "i" 'telega-describe-chat
         ;; "h" 'telega-describe-chat
         ;; "a" 'telega-chat-add-member
         ;; "o" 'telega-chat-set-custom-order
         ;; "r" 'telega-chat-toggle-read
         ;; "d" 'telega-chat-delete
         ;; "P" 'telega-chat-toggle-pin
         ;; "^" 'telega-chat-toggle-pin
         ;; "C" 'telega-chat-call
         ;; "DEL" 'telega-chat-delete

         :desc "Filter" "/" #'telega-chatbuf-filter
         :desc "Describe" "?" #'telega-chatbuf-describe
         :desc "Attach from clipboard" "p" #'telega-chatbuf-attach-clipboard
         :desc "Attach" "a" #'telega-chatbuf-attach
         :desc "Attach File" "f" #'telega-chatbuf-attach-fille
         :desc "Filter cancel" "c" #'telega-chatbuf-filter-cancel
         :desc "Cancel aux" "k" #'telega-chatbuf-cancel-aux
         :desc "Filter search" "s" #'telega-chatbuf-filter-search
         :desc "My search" "S" #'+hydra/telega-search/body
         ))

  (map! :map telega-msg-button-map
        "r" #'telega-msg-reply
        "c" 'telega-msg-copy-text
        "n" #'evil-ex-search-next
        "C-j" #'telega-button-forward
        "C-k" #'telega-button-backward
        "c" #'telega-msg-edit
        (:localleader
         "k" #'telega-chatbuf-cancel-aux
         ;; ;; ffplay media controls for some media messages
         "," 'telega-msg--vvnote-rewind-10-backward
         "<" 'telega-msg--vvnote-rewind-10-backward
         "." 'telega-msg--vvnote-rewind-10-forward
         ">" 'telega-msg--vvnote-rewind-10-forward
         "x" 'telega-msg--vvnote-play-speed-toggle

         "0" 'telega-msg--vvnote-stop
         "1" 'telega-msg--vvnote-rewind-part
         "2" 'telega-msg--vvnote-rewind-part
         "3" 'telega-msg--vvnote-rewind-part
         "4" 'telega-msg--vvnote-rewind-part
         "5" 'telega-msg--vvnote-rewind-part
         "6" 'telega-msg--vvnote-rewind-part
         "7" 'telega-msg--vvnote-rewind-part
         "8" 'telega-msg--vvnote-rewind-part
         "9" 'telega-msg--vvnote-rewind-part
         "B" 'telega-msg-ban-sender
         "F" 'telega-msg-forward-marked-or-at-point-to-multiple-chats
         "L" 'telega-msg-redisplay
         "U" 'telega-chatbuf-msg-marks-toggle
         ;; ;; Menu for right mouse on a message
         ;; (define-key map [down-mouse-3] telega-msg-button-menu-map)
         ;; (define-key map [mouse-3] #'ignore)
         "DEL" 'telega-msg-delete-marked-or-at-point
         "*" 'telega-msg-favorite-toggle
         "m" #'telega-msg-mark-toggle
         "U" #'telega-chatbuf-unmark-all
         "i" #'telega-describe-message
         "e" #'telega-msg-edit
         "f" #'telega-msg-forward-marked-or-at-point
         "d" #'telega-msg-delete-marked-or-at-point
         ;; "k" #'telega-msg-delete-marked-or-at-point
         "l" #'telega-msg-redisplay
         "T" #'telega-msg-open-thread
         "=" #'telega-msg-diff-edits
         "y" #'telega-msg-copy-text
         "Y" #'telega-chatbuf-copy-link
         "j" #'+hydra/telega-search/body/body
         "R" #'telega-msg-resend
         "S" #'telega-msg-save
         "P" #'telega-msg-pin-toggle
         "^" #'telega-msg-pin-toggle))

  ;; (map! :leader "G" telega-prefix-map)
  (map! :leader "y" telega-prefix-map)
  (map! :map telega-prefix-map
        :leader
        :prefix "y"
        :desc "View folders" "F" #'telega-view-folders
        :desc "Kill telega" "k" #'telega-kill)

  (setq telega-chat-input-markups '("markdown1" nil "markdown2"))

  ;; (setq telega-completing-read-function 'ivy-completing-read)
  (setq telega-completing-read-function 'completing-read)

  ;;FIXME the path is in nix store!
  ;;;;;;;Contributed packages
  (add-load-path! (concat doom-emacs-dir ".local/straight/repos/telega.el/contrib"))
  (require 'telega-mnz) ;;;syntax highlight for code blocks
  (add-hook! 'telega-root-mode-hook 'global-telega-mnz-mode)
  (require 'telega-url-shorten) ;;;Url shortening with small svg icons
  (add-hook! 'telega-root-mode-hook 'global-telega-url-shorten-mode)
  (require 'telega-dired-dwim) ;;; select multiple files from dired
  ;; (require 'telega-transient)
  ;; (telega-transient-mode 1)

  ;; font some icons
  (set-fontset-font t 'unicode "Symbola" nil 'append)

  (setq telega-notifications-mode 1)

  (after! doom-modeline
    ;; (setq telega-mode-line--logo-image-cache
    ;;       (doom-modeline-icon 'fileicon "telegram" "✈️" "#"
    ;;                           :face
    ;;                           'all-the-icons-blue
    ;;                           'mode-line-inactive))
    ;; (defun telega-mode-line-logo-image()
    ;;   (doom-modeline-icon 'fileicon "telegram" "✈️" "#"
    ;;                       :face
    ;;                       (if (telega-user-online-p (telega-user-me))
    ;;                           'all-the-icons-blue
    ;;                         'all-the-icons-red
    ;;                         )
    ;;                       'mode-line-inactive))
    (setq telega-mode-line-string-format
          '(" "
            (:eval
             (telega-mode-line-icon))
            (:eval
             (when telega-use-tracking-for
               (telega-mode-line-tracking)))
            (:eval
             (telega-mode-line-unread-unmuted))
            (:eval
             (telega-mode-line-mentions 'messages))))
    (telega-mode-line-mode))

  ;; ;; '(image :type svg
  ;; ;;         :file "/home/striker/.config/emacs/.local/straight/build-28.0.50/telega/etc/telega-logo.svg"
  ;; ;;         :ascent center :background "#191729" :height 18))

  (add-to-list 'display-buffer-alist
               '((lambda (bufname _action)
                   (with-current-buffer bufname
                     (eq major-mode 'telega-image-mode)))
                 (display-buffer-in-side-window)
                 (reusable-frames     . visible)
                 (side                . right)
                 ;; (window-height       . 0.33)
                 (window-width        . 0.45)
                 ))

  ;; fallback buffer
  ;; (add-hook! 'telega-image-mode-hook #'doom-mark-buffer-as-real-h)
  ;; (add-hook! 'telega-chat-mode-hook #'doom-mark-buffer-as-real-h)
  ;; (doom-set-buffer-real (get-buffer "*Telega Root*") t)

  ;; (add-to-list 'display-buffer-alist
  ;;              '("^\\*Image\\*$"
  ;;                (reusable-frames     . visible)
  ;;                (side                . right)
  ;;                (window-height       . 0.33)
  ;;                )))

  ;; Found %count messages with %query
  (after! hydra
    (defhydra +hydra/telega-search
      (:hint nil)
      "
     Found %(plist-get telega-chatbuf--msg-filter 'total-count) messages with
     [_g_] First    [_l_] Show list
     [_k_] Previous [_s_] seach in another chat     ╭─────────────────────
     [_j_] Next     [_c_] change query              │[_q_] quit
     [_G_] Last                                   │[_q_] Quit and go back"
      ;; ("j" (progn (git-gutter:next-hunk 1) (recenter)))
      ("j" (progn (telega-chatbuf--input-search-next) (recenter)))
      ("k" (progn (telega-chatbuf--input-search-next) (recenter)))
      ("g" (progn (goto-char (point-min)) (git-gutter:next-hunk 1)))
      ("G" (progn (goto-char (point-min)) (git-gutter:previous-hunk 1)))
      ("l" git-gutter:popup-hunk)
      ("s" telega-chatbuf-filter)
      ("c" telega-chatbuf-filter-search)
      ("q"
       telega-chatbuf-filter-cancel
       ;; (when (get-buffer git-gutter:popup-buffer)
       ;;   (kill-buffer (get-buffer git-gutter:popup-buffer)))
       nil
       :color blue)
      ))

    :custom (telega-server-libs-prefix "/usr/local")
            (telega-chat-bidi-display-reordering 'right-to-left)
            (telega-sticker-size '(10 . 24))
            (telega-emoji-use-images nil))

;; (setq telega-tdlib-max-version "1.8.5")
#+end_src


#+RESULTS:
| telega-mnz-mode--maybe | telega-url-shorten-mode--maybe | my/telega/company-backends |
** DONE Google Translate
CLOSED: [2022-09-22 Thu 12:05]
#+begin_src emacs-lisp

     (use-package! google-translate
       :demand t
       :init
            (require 'google-translate)
       :functions (my-google-translate-at-point google-translate--search-tkk)
       :custom
       (google-translate-backend-method 'curl)
       :config
       (defun google-translate--search-tkk () "Search TKK." (list 430675 2721866130))
       (defun my-google-translate-at-point()
         "reverse translate if prefix"
         (interactive)
         (if current-prefix-arg
             (google-translate-at-point)
           (google-translate-at-point-reverse)))
       :bind
       ("C-c t". my-google-translate-at-point))
#+end_src

#+RESULTS:
: my-google-translate-at-point

** Youtube
#+begin_src emacs-lisp

;; YouTube Download
;; yt-dlp
;; python-pycryptodome
;; atomicparsley
;; mpv
(use-package! youtube-dl
  :defer t
  :init
  (setq youtube-dl-directory "~/Downloads/youtube-dl")
  :config
  (setq youtube-dl-program "yt-dlp")
  (setq youtube-dl-arguments
        '("--no-mtime" "--restrict-filenames" "--format" "best" "--mark-watched")))
#+end_src

** google answer
#+begin_src emacs-lisp

;; *** GOOGLE ANSWERS
;; Query Google's knowledge graph. This is the answer that shows up before the
;; first result in Google searches. For this purpose we use tuxi, an external
;; tool that queries Google.
(use-package! emacs
  :config
  (defvar google-search-history nil
    "List of queries to google-search-string.")
  (defun google-search-string (search-string)
    "Read SEARCH-STRING from the minibuffer and call the shell
command tuxi on it."
    (interactive (list (read-string "Google: " nil
                                    google-search-history
                                    (thing-at-point 'sexp))))
    (unless (executable-find "tuxi")
      (user-error "Cannot find shell command: tuxi"))
    (let ((search-output (string-trim-right
                          (shell-command-to-string
                           (concat
                            "tuxi -r "
                            (shell-quote-argument search-string))))))
      (with-current-buffer (get-buffer-create "*Tuxi Output*")
        (goto-char (point-max))
        (unless (bobp) (insert "\n\n* * *\n"))
        (insert (capitalize search-string) ":\n\n")
        (push-mark)
        (insert search-output)
        (let ((lines (count-lines (or (mark) (point-min)) (point-max))))
          (if (<= lines 1)
              (message search-output)
            (let ((win (display-buffer (current-buffer))))
              (set-window-start win (mark))
              (set-window-parameter win 'window-height (min lines 10))
              (goto-address-mode 1)))))))
  (defun google-search-at-point (&optional beg end)
    "Call the shell command tuxi on the symbol at point. With an
active region use it instead."
    (interactive "r")
    (if-let ((search-string (if (use-region-p)
                                (buffer-substring-no-properties beg end)
                              (thing-at-point 'symbol))))
        (google-search-string search-string)
      ;; (message "No symbol to search for at point!")
      (call-interactively #'google-search-string)))
  :bind (:map help-map
              ("g" . google-search-string)
              ("C-=" . google-search-at-point)))

#+end_src

#+RESULTS:
: google-search-at-point

** Custom Helper
#+begin_src emacs-lisp :tangle yes

;; * PATHS

;; I avoid defining too many custom helpers, =dir-concat= is an exception.
(use-package! emacs
  :config
  (defun dir-concat (dir file)
    "join path DIR with filename FILE correctly"
    (concat (file-name-as-directory dir) file))

  ;; ;; Adds ~/.emacs.d to the load-path
  ;; (push (dir-concat user-emacs-directory "plugins/") load-path)
  ;; (push (dir-concat user-emacs-directory "lisp/") load-path)

  ;; cache directory
  (defvar user-cache-directory "~/.cache/emacs/"
  "Location where files created by emacs are placed."))
#+end_src

#+RESULTS:
: t

** EWW
*** oantolin'eww
#+begin_src emacs-lisp
;; consult-eww-source.el --- eww bookmark source for consult-buffer   -*- lexical-binding: t; -*-

(require 'consult)
(require 'eww)

;;; consult-buffer source
;; Taken with very minor modifications from the Consult wiki
(defvar consult--source-eww
  (list
   :name     "Eww"
   :narrow   ?e
   :category 'eww-bookmark
   :action   (lambda (bm)
               (eww-browse-url (get-text-property 0 'url bm)))
   :items    (lambda ()
               (eww-read-bookmarks)
               (mapcar (lambda (bm)
                         (propertize
                          (plist-get bm :title)
                          'url (plist-get bm :url)))
                       eww-bookmarks))))

;;; annotate with URL
(add-to-list 'consult-buffer-sources 'consult--source-eww 'append)

(defun annotate-eww-bookmark (bm)
  (concat
   (propertize " " 'display `(space :align-to (- right 50)))
   (propertize (get-text-property 0 'url bm) 'face 'completions-annotations)))

(defvar marginalia-annotator-registry)
(with-eval-after-load 'marginalia
  (add-to-list 'marginalia-annotator-registry
               '(eww-bookmark annotate-eww-bookmark builtin none)))

;;; Have Embark treat them as just URLs
(defun transform-eww-bookmark-to-url (target)
  (if (eq (car target) 'eww-bookmark)
      (cons 'url (get-text-property 0 'url (cdr target)))
    target))

(with-eval-after-load 'embark
  (advice-add 'embark--refine-multi-category
              :filter-return #'transform-eww-bookmark-to-url))

(provide 'consult-eww-source)
#+end_src

#+RESULTS:
: consult-eww-source

*** Engine mode

EWW is the Emacs Web Wowser, the builtin browser in Emacs.  Below I set urls to open in a specific browser (eww) with browse-url-browser-function.  By default, Doom Emacs does not use 'SPC e' for anything, so I choose to use the format 'SPC e' plus 'key' for these (I also use 'SPC e' for 'eval' keybindings).  I chose to use 'SPC s w' for eww-search-words because Doom Emacs uses 'SPC s' for 'search' commands.

#+begin_src emacs-lisp
;; To open .onion links from eww, run ‘torsocks emacs’ from the commandline. From then, you should be able to load .onion addresses from within ERC and eww.
;; (setq browse-url-browser-function 'eww-browse-url)
;; (map! :leader
;;       :desc "Search web for text between BEG/END"
;;       "s w" #'eww-search-words
;;       (:prefix ("e" . "evaluate/EWW")
;;        :desc "Eww web browser" "w" #'eww
;;        :desc "Eww reload page" "R" #'eww-reload))

   ;; :browser 'browse-url-qutebrowser) this can be used to open specific urls with specific brouwser
(use-package! eww
  :ensure nil
  :config
  ;; (setq browse-url-handlers
  ;;       '(("." . browse-url-firefox)))
  ;; (setq browse-url-browser-function 'browse-url-generic
  ;;     browse-url-generic-program "qutebrowser")

 ;; (setq browse-url-browser-function 'w3m-browse-url)
;;Open a url embedded in any buffer
 ;; (setq browse-url-browser-function  'w3m-goto-url-new-session)
 ;; (setq browse-url-browser-function  'w3m-new-buffer)
 ;; (autoload 'w3m-browse-url  "w3m"  "Ask a WWW browser to show a URL." t)

  ;; (setq engine/browser-function 'w3m-browse-url);;  browse-url-default-browser open firefox
  (setq engine/browser-function 'eww-browse-url);;  browse-url-default-browser open firefox

  :custom
  (eww-use-external-browser-for-content-type
   "\\`\\(video/\\|audio/\\|application/ogg\\|application/pdf\\)"))

(use-package! engine-mode
  :config
  (defengine duckduckgo
    "https://lite.duckduckgo.com/lite/?q=%s&kf=-1&kz=-1&kq=-1&kv=-1&k1=-1&kp=-2&kaf=1&kd=-1"
    :keybinding "d")
  (defengine github
    "https://github.com/search?ref=simplesearch&q=%s"
:keybinding "g")
  (defengine cern-gitlab
    "https://gitlab.cern.ch/search?search=%s"
    :keybinding "l")
  (defengine google
    "http://www.google.com/search?hl=en&ie=utf-8&oe=utf-8&q=%s"
    :keybinding "O")
  (defengine duckduckgo-first
    "https://duckduckgo.com/html?q=\\%s"
    :keybinding "f")
  (defengine google-maps
    "https://www.google.com/maps/search/%s/"
    :keybinding "M")
  (defengine openstreetmap
    "https://www.openstreetmap.org/search?query=%s"
    :keybinding "m")
  (defengine wordreference
    "https://www.wordreference.com/es/translation.asp?tranword=%s"
    :keybinding "r")
  (defengine wikipedia
    "http://www.wikipedia.org/search-redirect.php?language=en&go=Go&search=%s"
    :keybinding "w")
  (defengine youtube
    "http://www.youtube.com/results?aq=f&oq=&search_query=%s"
    :keybinding "y"
   :browser 'browse-url-firefox)
  (defengine invidious
    "https://invidious.garudalinux.org/search?q=%s"
    :keybinding "v")
  (defengine url
    "https:%s"
    :keybinding "u")


;; # Search Engines

;; websearch[bing]="https://www.bing.com/search?q="
  (defengine bing
"https://www.bing.com/search?q=%s"
:keybinding "b")
;; websearch[googlenews]="https://news.google.com/search?q="
  (defengine googlenews
"https://news.google.com/search?q=%s"
:keybinding "n")


;; websearch[wiktionary]="https://en.wiktionary.org/w/index.php?search="
  (defengine wiktionary
"https://en.wiktionary.org/w/index.php?search=%s"
:keybinding "D")

;; # Social Media
;; websearch[reddit]="https://www.reddit.com/search/?q="
  (defengine reddit
"https://www.reddit.com/search/?q=%s"
:keybinding "r")

;; # Online Shopping
;; websearch[amazon]="https://www.amazon.in/s?k="
  (defengine amazon
"https://www.amazon.in/s?k=%s"
:keybinding "a"
:browser 'browse-url-firefox)

;; websearch[ebay]="https://www.ebay.com/sch/i.html?&_nkw="
  (defengine ebay
"https://www.ebay.com/sch/i.html?&_nkw=%s"
:keybinding "e")
;; # Linux
;; websearch[archaur]="https://aur.archlinux.org/packages/?O=0&K="
  (defengine archaur
"https://aur.archlinux.org/packages/?O=0&K=%s"
:keybinding "U")

;; websearch[archpkg]="https://archlinux.org/packages/?sort=&q="
  (defengine archpackages
"https://archlinux.org/packages/?sort=&q=%s"
:keybinding "P")

;; websearch[archwiki]="https://wiki.archlinux.org/index.php?search="
  (defengine archlinux
"https://wiki.archlinux.org/index.php?search=%s"
:keybinding "W")

;; websearch[gitlab]="https://gitlab.com/search?search="
  (defengine gitlab
"https://gitlab.com/search?search=%s"
:keybinding "G")

;; websearch[googleOpenSource]="https://opensource.google/projects/search?q="
  (defengine opensource
"https://opensource.google/projects/search?q=%s"
:keybinding "o")

;; websearch[sourceforge]="https://sourceforge.net/directory/?q="
  (defengine sourceforge
"https://sourceforge.net/directory/?q=%s"
:keybinding "S")

;; websearch[stackoverflow]="https://stackoverflow.com/search?q="
  (defengine stackoverflow
"https://stackoverflow.com/search?q=%s"
:keybinding "s")

;; websearch[craigslist]="https://www.craigslist.org/search/sss?query="
;;   (defengine craigslist
;; "https://www.craigslist.org/search/sss?query="
;; :keybinding "c")


;; websearch[gumtree]="https://www.gumtree.com/search?search_category=all&q="
;;   (defengine gumtree
;; "https://www.gumtree.com/search?search_category=all&q="
;; :keybinding "g")


;; websearch[debianpkg]="https://packages.debian.org/search?suite=default&section=all&arch=any&searchon=names&keywords="
;;   (defengine debian
;; "https://packages.debian.org/search?suite=default&section=all&arch=any&searchon=names&keywords="
;; :keybinding "D")

;; websearch[brave]="https://search.brave.com/search?q="
;;   (defengine brave
;; "https://search.brave.com/search?q="
;; :keybinding "b")


;; websearch[gemini search \(https\)]="https://portal.mozz.us/gemini/geminispace.info/search%3F"
;;   (defengine gemini
;; "https://portal.mozz.us/gemini/geminispace.info/search%3F"
;; :keybinding "G")


;; websearch[qwant]="https://www.qwant.com/?q="
;;   (defengine qwant
;; "https://www.qwant.com/?q="
;; :keybinding "q")

;; websearch[swisscows]="https://swisscows.com/web?query="
;;   (defengine swisscows
;; "https://swisscows.com/web?query="
;; :keybinding "s")

;; websearch[yandex]="https://yandex.com/search/?text="
;;   (defengine yandex
;; "https://yandex.com/search/?text="
;; :keybinding "Y")

;; # Information/News
;; websearch[bbcnews]="https://www.bbc.co.uk/search?q="
;;   (defengine bbc
;; "https://www.bbc.co.uk/search?q="
;; :keybinding "b")

;; websearch[cnn]="https://www.cnn.com/search?q="
;;   (defengine cnn
;; "https://www.cnn.com/search?q="
;; :keybinding "c")

  (engine/set-keymap-prefix (kbd "C-c w "))
  (engine/set-keymap-prefix (kbd "s-b"))
  (engine-mode t))
#+END_SRC

#+RESULTS:
: t

*** Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el
**** desc
TODO 2021-09-08: This section needs to be expanded to cover the
integration with the built-in =bookmark.el= framework as well as the
third-party =elpher= package (Elpher is an Internet browser for the Gopher
and Gemini protocols).


The following code block encompasses libraries that power Emacs' web
browsing experience.

+ =browse-url= determines what Emacs should do when the user follows a
  link to the Internet.  For my purposes, I configure it to open the web
  page inside of Emacs, while I let the Desktop Environment's default
  graphical browser be declared as a secondary option.  Put simply, when
  I click on a URL, I go to an EWW or Elpher buffer.  If the page is
  part of the World Wide Web (=https?= protocol) I can opt to open it in
  the GUI browser via =eww-browse-with-external-browser=, which is bound
  to =&= in =eww-mode-map=.  That is only ever needed for websites that do
  not work well in a text-centric interface.  For pages that implement
  the Gopher or Gemini protocols, there is no need whatsoever to open
  them externally as they are plain text anyway.

+ =shr= is the "Simple HTML Renderer", which basically means to interpret
  the underlying code of a web page and show it in the way it is
  intended for the end user.  Unlike graphical web browsers, =shr=
  capabilities are limited, because it does not use style sheets (CSS)
  and more demanding resources (javascript, embedded multimedia, etc.).

+ =eww= is what we use to browse the Web.  It effectively is the front-end
  to =shr=, adding on top of it the layer of interactivity that is
  expected of a basic browser, such as to keep a history of visited
  pages, handle bookmarks, navigate through links, and the like.  As
  always, remember to read the manual of EWW, such as by evaluating this
  form: =(info "(eww) Top")=.  It is short and should give you an idea of
  what its features are.

+ =prot-eww= adds commands that align EWW with my expectations and make it
  do what I want to achieve in a primarily text-based web browsing
  experience.  It also provides the layer of integration between EWW and
  Elpher, making the resulting browsing experience consistent as one
  follows links that are implemented in the relevant protocols.

My configurations for =browse-url= and =shr= are straightforward and are
meant to keep things simple.  I want EWW to behave like the rest of
Emacs, which means that it should not try to introduce random colours
from web pages, nor use its own fonts.  Both intefere with the
consistency I seek in my computing environment (and why I use Emacs to
begin with).

For =eww=, I repurpose some of its key bindings that I never plan to use,
such as the toggle for proportional fonts, while I move around a few
others.  Just to make things easier for me.

As for =prot-eww=, it includes functionality that makes EWW good enough
for my day-to-day needs.

In particular:

+ It includes an unconditional internal mechanism that renames EWW
  buffers based on the rendered web page's title or, when that is not
  available, the URL.  This ensures that I can maintain multiple buffers
  without getting lost in the noise of what would otherwise be an
  awkward naming scheme in the form of =*eww*=, =*eww<2>*= and so on.  Now
  it looks like =*Emacs - ArchWiki # eww*=, with a possible number
  identifier added only for duplicate entries.

+ The variable =prot-eww-visited-history= records the URL of every
  rendered page.  This is then used by =prot-eww-browse-dwim= (more
  below).  To keep things in check, =prot-eww-visited-history= is
  implemented as a minibuffer history which is ultimately limited to the
  value of =history-length= (read: [[#h:2733674b-51f9-494e-b34d-e8842ac4ef96][Minibuffer history (savehist-mode)]]).
  Remember that each command can have its own history and this is common
  in a lot of my extras.

+ The =prot-eww-browse-dwim= is my main point of entry to EWW.  When I
  call it from a random place inside of Emacs, it just offers a prompt
  that asks for a URL or search terms with which to query DuckDuckGo.
  In addition, it reads through a history of such inputs, so that =M-p=,
  =M-n= can quickly give me something I tried before.  Plus it supports
  completion (check the mega-section [[#h:98d3abcc-f34e-4029-aabc-740f0b6421f8][Completion framework and extras]]).
  When this command is called from inside an EWW buffer it retains the
  aforementioned functionality, but its prompt is pre-populated with the
  URL of the current page.  This is particularly useful for editing the
  path directly, such as to go from =https://protesilaos.com/contact= to
  =https://protesilaos.com=.  When called with a universal prefix argument
  (=C-u=), it opens a new EWW buffer instead of using the last one.

+ =prot-eww-search-engine= offers selection among the custom search
  commands I define, such as to query Wikipedia directly or search for a
  bug number in the Emacs issue tracker.  Those search engine commands
  can be invoked on their own, while each of them has its own minibuffer
  history (so if you searched for "elephant" in Wikipedia, you will not
  get that for the Arch Wiki).

+ =prot-eww-bookmark-page= does what its name suggests though, unlike the
  built-in equivalent, it first asks for how to name the bookmarked
  entry before storing it in the relevant memory compartment.

+ =prot-eww-visit-bookmark= prompts with completion to visit an entry in
  EWW's bookmark list.  A =C-u= prefix means to open it in a new EWW
  buffer.

+ =prot-eww-visit-url-on-page= traverses the entire web page to construct
  a list of all links and their anchor text.  The list can be narrowed
  with completion.  Selecting a item with visit its corresponding web
  page.

+ =prot-eww-jump-to-url-on-page= is similar to the above, with the major
  difference that it only stores buffer positions and jumps to them.
  This makes it ideal for generating an ad-hoc index of "points of
  interest" in the current buffer with the help of Embark's ability to
  collect a list of candidates into a bespoke buffer (make sure to check
  [[#h:d67ed8d0-d711-48b0-9f40-f88ae2e5c984][Extended minibuffer actions and more (embark.el and prot-embark.el)]]).
  Of course, it can be used on its own to jump around the web page.

+ =prot-eww-find-feed= inspects the source code of the current web page
  and produces an =occur= buffer with links that represent RSS or Atom
  feeds.  This command is quite useful for retrieving the feed of a
  website whose designers failed to provide a user-facing link for it
  (which is the norm nowadays).  I read feeds on a daily basis: it is
  the best way to keep track of updates to web pages (read section
  [[#h:0cd8ddab-55d1-40df-b3db-1234850792ba][Elfeed feed reader, prot-elfeed.el and prot-elfeed-bongo.el]]).

+ =prot-eww-readable= is a more opinionated take on the built-in option.
  It specifies a narrower =shr-width=, specifically at the 72 character
  limit which is my =current-fill-column=.  Furthermore, it reduces images
  to a maximum of 0.35 of the window's width/height.  This is not always
  a good approach, though it works most of the time for the kind of
  content I am interested in: text-heavy articles.

+ =prot-eww-download-html= downloads the current web page as an =.html=
  file.  It asks for a name to give to it, defaulting to the title of
  the page, and it also prepends the current date and time.  To ensure
  that the file name is easily accessible with Unix tools, all
  punctuation marks and spaces are removed or replaced with hyphens.  So
  if the page is titled ="GNU Emacs manual | My ‘cool’ “website”!?"= the
  saved file will be processed and stored as a filesystem path like
  =~/Downloads/eww/20210324_185035--gnu-emacs-manual-my-cool-website.html=.
  I find that this is superior to the generic =eww-download= which neither
  asks for a name, nor adds a date and file type extension.  Where
  =eww-download= still excels is for downloading the link at point, when
  that is not an HTML file (e.g. a pdf or zip archive).

+ =prot-eww-open-in-other-window= is meant to open the link at point in a
  new buffer and in another window.  It complements the default =M-RET=
  (=eww-open-in-new-buffer=) which re-uses the same window.

Some final tips:

+ =g= reloads the web page by fetching it anew over the network, while its
  =C-u g= counterpart re-renders what has already been downloaded.  The
  latter is useful when, for example, you have a new window
  configuration and wish to fit the EWW buffer's contents in the window.

+ As already noted above, several commands that open an EWW buffer
  accept a =C-u= prefix to put their contents in a new buffer rather than
  re-use the existing one.  With =M-RET= over a link in an EWW buffer, you
  can do the same.

+ When point is over an image, the =shr-image-map= gets activated.  This
  allows you to run commands such as =image-increase-size=, bound to =+=,
  and =image-decrease-size= on =-=.  This means that you can always view an
  image at an appropriate size, regardless of whether its initial
  dimensions were affected by =shr-max-image-proportion= and the size of
  the window holding the EWW buffer.

Also watch [[https://protesilaos.com/codelog/2021-03-25-emacs-eww/][EWW and my extras]] (2021-03-25) for a video demonstration of
some of the above.

**** code
#+begin_src emacs-lisp
;;; Simple HTML Renderer (shr), Emacs Web Wowser (eww), Elpher, and prot-eww.el
(use-package! browse-url
  :config
  (setq browse-url-browser-function 'eww-browse-url)
  ;; (setq browse-url-secondary-browser-function 'browse-url-default-browser))

  (setq browse-url-secondary-browser-function 'browse-url-generic
      browse-url-generic-program "qutebrowser"))
(use-package! shr
  :config
  (setq shr-use-colors nil)             ; t is bad for accessibility
  (setq shr-use-fonts nil)              ; t is not for me
  (setq shr-max-image-proportion 0.6)
  (setq shr-image-animate nil)          ; No GIFs, thank you!
  (setq shr-indentation 2)                           ; Left-side margin
  (setq shr-width nil)                  ; check `prot-eww-readable'
  (setq shr-discard-aria-hidden t)
  (setq shr-cookie-policy nil))

(use-package! url-cookie
  :config
  (setq url-cookie-untrusted-urls '(".*")))

(use-package! eww
  :config
  (setq eww-restore-desktop t)
  (setq eww-desktop-remove-duplicates t)
  (setq eww-header-line-format nil)
  (setq eww-search-prefix "https://duckduckgo.com/html/?q=")
  (setq eww-download-directory (expand-file-name "~/Documents/eww-downloads"))
  (setq eww-suggest-uris
        '(eww-links-at-point
          thing-at-point-url-at-point))
  ;; (setq eww-bookmarks-directory (locate-user-emacs-file "eww-bookmarks/"))
  (setq eww-bookmarks-directory (expand-file-name "~/.config/eww-bookmarks/"))
  (setq bookmark-file (expand-file-name "~/.config/eww-bookmarks/emacs-bookmarks"))
  (setq eww-history-limit 150)
  (setq eww-use-external-browser-for-content-type
        "\\`\\(video/\\|audio\\)") ; On GNU/Linux check your mimeapps.list
  (setq eww-browse-url-new-window-is-tab nil)
  (setq eww-form-checkbox-selected-symbol "[X]")
  (setq eww-form-checkbox-symbol "[ ]")
  ;; NOTE `eww-retrieve-command' is for Emacs28.  I tried the following
  ;; two values.  The first would not render properly some plain text
  ;; pages, such as by messing up the spacing between paragraphs.  The
  ;; second is more reliable but feels slower.  So I just use the
  ;; default (nil), though I find wget to be a bit faster.  In that case
  ;; one could live with the occasional errors by using `eww-download'
  ;; on the offending page, but I prefer consistency.
  ;;
  ;; '("wget" "--quiet" "--output-document=-")
  ;; '("chromium" "--headless" "--dump-dom")
  ;; (setq eww-retrieve-command nil)

;; list buffers gt

  (define-key eww-link-keymap (kbd "v") nil) ; stop overriding `eww-view-source'
  (define-key eww-mode-map (kbd "L") #'eww-list-bookmarks) ;g b
  (define-key dired-mode-map (kbd "E") #'eww-open-file) ; to render local HTML files
  (define-key eww-buffers-mode-map (kbd "d") #'eww-buffer-kill)   ; it actually deletes
  (define-key eww-bookmark-mode-map (kbd "d") #'eww-bookmark-kill)) ; same

(use-package! elpher)    ; NOTE 2021-07-24: work-in-progress

(load "prot-eww")
(use-package! prot-eww
  :config
  (setq prot-eww-save-history-file
        (locate-user-emacs-file "prot-eww-visited-history"))
  (setq prot-eww-save-visited-history t)
  (setq prot-eww-bookmark-link nil)

  (add-hook 'prot-eww-history-mode-hook #'hl-line-mode)

  (define-prefix-command 'prot-eww-map)
  ;; (define-key global-map (kbd "C-c w") 'prot-eww-map)
  (define-key global-map (kbd "s-B") 'prot-eww-map)
  (let ((map prot-eww-map))
    (define-key map (kbd "B") #'prot-eww-visit-bookmark)
    (define-key map (kbd "e") #'prot-eww-browse-dwim)
    (define-key map (kbd "s") #'prot-eww-search-engine)
    (define-key map (kbd "h") #'prot-eww-list-history)))
;;keybinding are almost same to qutebrowser for consistency
(map! :leader
      :desc "Eww" "@ " #'prot-eww-map)
(evil-define-key 'normal eww-mode-map  (kbd "m") #'prot-eww-bookmark-page
                                               (kbd "D") #'prot-eww-download-html
                                               (kbd "C-F") #'prot-eww-find-feed
                                              (kbd ".") #'prot-eww-list-history ;key fine
                                              (kbd "H") #'eww-back-url ;key fine
                                              (kbd "L") #'eww-forward-url ;key fine
                                               (kbd "O") #'prot-eww-visit-bookmark
                                               (kbd "o") #'eww-search-words
                                               (kbd "r") #'eww-reload
                                               (kbd "g t") #'eww-switch-to-buffer
                                               (kbd "g T") #'eww-list-buffer
                                               (kbd "t") #'prot-eww-search-engine
                                               (kbd "C-E") #'eww-browse-with-external-browser
                                               (kbd "M") #'browse-url-at-point-umpv
                                               (kbd "C-e") #'prot-eww-browse-dwim
                                               (kbd "C-f") #'prot-eww-visit-url-on-page
                                               (kbd "f") #'prot-eww-jump-to-url-on-page;;visible
                                               (kbd "C-r") #'prot-eww-readable
                                               (kbd "C-Y") #'link-hint-copy-link-at-point
                                               (kbd "y l") #'link-hint-copy-link-at-point
                                               (kbd "y p") #'eww-copy-page-url
                                               (kbd "Q") #'prot-eww-quit)


(evil-define-key 'normal prot-eww-history-mode-map  (kbd "RET") #'prot-eww-history-browse
                                               (kbd "o") #'prot-eww-open-in-other-window)

#+end_src

#+RESULTS:

**** langauge detection in eww
#+begin_src emacs-lisp :tangle packages.el
(package! language-detection)
#+end_src

#+begin_src emacs-lisp
(defun eww-tag-pre (dom)
  (let ((shr-folding-mode 'none)
        (shr-current-font 'default))
    (shr-ensure-newline)
    (insert (eww-fontify-pre dom))
    (shr-ensure-newline)))

(defun eww-fontify-pre (dom)
  (with-temp-buffer
    (shr-generic dom)
    (let ((mode (eww-buffer-auto-detect-mode)))
      (when mode
        (eww-fontify-buffer mode)))
    (buffer-string)))

(defun eww-fontify-buffer (mode)
  (delay-mode-hooks (funcall mode))
  (font-lock-default-function mode)
  (font-lock-default-fontify-region (point-min)
                                    (point-max)
                                    nil))

(defun eww-buffer-auto-detect-mode ()
  (let* ((map '((ada ada-mode)
                (awk awk-mode)
                (c c-mode)
                (cpp c++-mode)
                (clojure clojure-mode lisp-mode)
                (csharp csharp-mode java-mode)
                (css css-mode)
                (dart dart-mode)
                (delphi delphi-mode)
                (emacslisp emacs-lisp-mode)
                (erlang erlang-mode)
                (fortran fortran-mode)
                (fsharp fsharp-mode)
                (go go-mode)
                (groovy groovy-mode)
                (haskell haskell-mode)
                (html html-mode)
                (java java-mode)
                (javascript javascript-mode)
                (json json-mode javascript-mode)
                (latex latex-mode)
                (lisp lisp-mode)
                (lua lua-mode)
                (matlab matlab-mode octave-mode)
                (objc objc-mode c-mode)
                (perl perl-mode)
                (php php-mode)
                (prolog prolog-mode)
                (python python-mode)
                (r r-mode)
                (ruby ruby-mode)
                (rust rust-mode)
                (scala scala-mode)
                (shell shell-script-mode)
                (smalltalk smalltalk-mode)
                (sql sql-mode)
                (swift swift-mode)
                (visualbasic visual-basic-mode)
                (xml sgml-mode)))
         (language (language-detection-string
                    (buffer-substring-no-properties (point-min) (point-max))))
         (modes (cdr (assoc language map)))
         (mode (cl-loop for mode in modes
                        when (fboundp mode)
                        return mode)))
    (message (format "%s" language))
    (when (fboundp mode)
      mode)))

(setq shr-external-rendering-functions
      '((pre . eww-tag-pre)))
#+end_src

#+RESULTS:
: ((pre . eww-tag-pre))

*** eww toggle  images
#+begin_src emacs-lisp

(with-eval-after-load 'eww

(setq-local endless/display-images t)

(defun endless/toggle-image-display ()
  "Toggle images display on current buffer."
  (interactive)
  (setq endless/display-images
        (null endless/display-images))
  (endless/backup-display-property endless/display-images))

(defun endless/backup-display-property (invert &optional object)
  "Move the 'display property at POS to 'display-backup.
Only applies if display property is an image.
If INVERT is non-nil, move from 'display-backup to 'display
instead.
Optional OBJECT specifies the string or buffer. Nil means current
buffer."
  (let* ((inhibit-read-only t)
         (from (if invert 'display-backup 'display))
         (to (if invert 'display 'display-backup))
         (pos (point-min))
         left prop)
    (while (and pos (/= pos (point-max)))
      (if (get-text-property pos from object)
          (setq left pos)
        (setq left (next-single-property-change pos from object)))
      (if (or (null left) (= left (point-max)))
          (setq pos nil)
        (setq prop (get-text-property left from object))
        (setq pos (or (next-single-property-change left from object)
                      (point-max)))
        (when (eq (car prop) 'image)
          (add-text-properties left pos (list from nil to prop) object))))))


(defun my/eww-toggle-images ()
  "Toggle whether images are loaded and reload the current page fro cache."
  (interactive)
  (setq-local shr-inhibit-images (not shr-inhibit-images))
  (eww-reload t)
  (message "Images are now %s"
           (if shr-inhibit-images "off" "on")))

(define-key eww-mode-map (kbd "I") #'my/eww-toggle-images)
(define-key eww-link-keymap (kbd "I") #'my/eww-toggle-images)

;; minimal rendering by default
(setq-default shr-inhibit-images t)   ; toggle with `I`
(setq-default shr-use-fonts nil)      ; toggle with `F`

);end with eveal after load eww
#+end_src

#+RESULTS:

** browse url
#+begin_src emacs-lisp

;;;----------------------------------------------------------------
;; ** BROWSE-URL
;;;----------------------------------------------------------------
(use-package! browse-url
  :commands (browse-url-at-point-umpv browse-url-umpv)
  :config
  (when IS-LINUX
    (defun browse-url-umpv (url &optional single)
      (start-process "mpv" nil (if single "mpv" "mpv")
                     (shell-quote-wildcard-pattern url)))

    (defun browse-url-mpv (url)
      (browse-url-umpv url t))

    (defun browse-url-at-point-umpv (&optional single)
      "Open link in mpv"
      (interactive "P")
      (let ((browse-url-browser-function
             (if single
                 (lambda (url &optional _new-window) (browse-url-umpv url t))
               #'browse-url-umpv)))
        (browse-url-at-point)))

    (setq browse-url-generic-program "/usr/bin/qutebrowser")
    ;; (setq browse-url-browser-function
    ;;       '(("https:\\/\\/www\\.youtu\\.*be." . browse-url-umpv)
    ;;         ("." . browse-url-generic)))
    ))
#+end_src

#+RESULTS:
: t

** Email settings

Once you delve into the technical details, email is hard as it consists
of arcane specs and protocols.  Combined with Emacs' open-endedness as
well as the wealth of free software command-line programs on offer,
there are seemingly infinite ways to set things up.  The toolset for my
current setup consists of the following:

+ The external =mbsync= program to periodically synchronise my remote
  email server and my local mail directories.  This allows me to keep a
  copy of my correspondence, while it removes the burden of updating
  mail sources from the client.  The latter benefit is particularly
  important to avoid slowing down Emacs.

+ The Notmuch package which includes the CLI program and the Emacs
  library that implements a Mail User Agent.  Notmuch is a mail indexer
  that can search through the database using a strictly tags-only
  workflow.  I was using Gnus in the past (between early 2020 and May
  2021), but ultimately decided to upgrade my workflow by going with the
  more flexible approach of Notmuch (I had also used Mu4e before, which
  is closer in spirit to Notmuch and is a good choice overall---in the
  source code of my dotfiles, from where you can find this document,
  there is the =prot-mu4e-deprecated-conf.el= file in case you need it;
  same for =prot-gnus-deprecated-conf.org=).

+ The built-in capabilities to compose and send email.

+ Other extensions to integrate email composition with encryption tools,
  Dired, Org, contact-completion (EBDB)...

*This is a mega section that encompasses all of the aforementioned.*
Please study it carefully.

*** Client-agnostic email settings (and prot-mail.el)
:PROPERTIES:
:CUSTOM_ID: h:a82766be-daab-4925-b23a-1c5ffd47e599
:END:

Before configuring any mail user agent, we need to establish the
absolute essentials: who we are, where our authentication credentials
are stored, and whether encryption is to be supported.  We must also
define how message composition should work.  This is what the following
configurations are about.

+ The =mail-user-agent= and =message-mail-user-agent= concern the default
  email composition buffer, called with =C-x m= or any other facility that
  falls back to the =compose-mail= function.  The default is =message-mode=.

  - When notmuch is in use, it will insert a special "Fcc" header whose
    task is to copy the outgoing message to the appropriate maildir path
    (this part is done in [[#h:a196812e-1644-4536-84ba-687366867def][the Notmuch section]]).

+ The value of =message-citation-line-format= is expanded into something
  like /"On 2020-02-19, 13:54 +0200, NAME <EMAIL> wrote:"/.  To learn
  about all the date-related specifiers, it is better to read the
  documentation with =M-x describe-variable RET format-time-string RET=.

+ The =mm-encode= and =mml-sec= are meant to come into effect when
  encrypting and signing an outgoing message, such as with =C-c C-m C-e=
  (=mml-secure-message-sign-encrypt=).  The optional guided key selection
  will ask for confirmation on who to encrypt to.  It presents a list
  with the available keys.  Items are marked with =m= and then the mail
  can be sent with the standard commands (e.g. =C-c C-c=).  I used that
  setup for a while, but ultimately decided that the extra steps did not
  make any difference to my workflow, as I always double-check before
  sending out an email.

+ The =gnus-dired= library can be used independently of Gnus (and should
  thus be refactored as "message-dired.el" or something).  It provides
  glue code that integrates Dired buffers with message composition, so
  that one can attach either the file at point or the marked ones with
  =C-c C-m C-a= (=gnus-dired-attach=).

#+begin_src emacs-lisp :tangle no
;;; Client-agnostic email settings (and prot-mail.el)
(prot-emacs-builtin-package 'auth-source
  (setq auth-sources '("~/.authinfo.gpg"))
  (setq user-full-name "Protesilaos Stavrou")
  (setq user-mail-address "public@protesilaos.com"))

(prot-emacs-builtin-package 'mm-encode
  (setq mm-encrypt-option nil) ; use 'guided if you need more control
  (setq mm-sign-option nil))   ; same

(prot-emacs-builtin-package 'mml-sec
  (setq mml-secure-openpgp-encrypt-to-self t)
  (setq mml-secure-openpgp-sign-with-sender t)
  (setq mml-secure-smime-encrypt-to-self t)
  (setq mml-secure-smime-sign-with-sender t))

(prot-emacs-builtin-package 'message
  (setq mail-user-agent 'message-user-agent)
  (setq mail-header-separator (purecopy "*****"))
  (setq message-elide-ellipsis ">\n> [... %l lines elided]\n>\n>") ; NOTE 2021-07-13: experimental
  (setq compose-mail-user-agent-warnings nil)
  (setq message-mail-user-agent t)      ; use `mail-user-agent'
  (setq mail-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-signature "Protesilaos Stavrou\nhttps://protesilaos.com\n")
  (setq message-citation-line-format "On %Y-%m-%d, %R %z, %f wrote:\n")
  (setq message-citation-line-function
        'message-insert-formatted-citation-line)
  (setq message-confirm-send nil)
  (setq message-kill-buffer-on-exit t)
  (setq message-wide-reply-confirm-recipients t)
  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))

  (add-hook 'message-setup-hook #'message-sort-headers))

(prot-emacs-builtin-package 'gnus-dired ; does not require `gnus'
  (add-hook 'dired-mode-hook #'gnus-dired-mode))

(prot-emacs-builtin-package 'prot-mail
  ;; NOTE 2021-05-14: This is a generic indicator for new mail in the
  ;; maildir.  As I now use notmuch (see relevant section in this
  ;; document) I have an alternative approach in prot-notmuch.el.
  (setq prot-mail-maildir-path-regexp "~/.mail/*/Inbox/new/") ; shell regexp
  (setq prot-mail-mode-line-indicator-commands
        '(notmuch-refresh-this-buffer))
  ;; mode line indicator with the number of new mails
  (prot-mail-mail-indicator -1))
#+end_src

**** Sample of authinfo.gpg
:PROPERTIES:
:CUSTOM_ID: h:8d0bd754-8a31-431b-b112-f541cc0144ac
:END:

Below is a sample with the contents of my =authinfo.gpg=.  This is read,
inter alia, by =notmuch= and =smtpmail= to be able to both fetch and send
messages from the given account.  By default, one can use a generic
=authinfo= file though I consider that reckless: I strongly encourage you
to *encrypt this file* if you add your login credentials there.  Do it
from inside =dired= with =: e= while the point is over the file.  Emacs can
decrypt all encrypted files automatically.

#+begin_example
machine prv port 993 login MAIL password SECRET
machine inf port 993 login MAIL password SECRET
machine pub port 993 login MAIL password SECRET

machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
machine mail.gandi.net port 465 login MAIL password SECRET
#+end_example

Refer to your email provider's documentation in order to determine the
port number and server address you need to use for sending and receiving
messages.  The =MAIL= is either your email address or some username for
logging into the account.

Note that the terms I use above for =prv=, =inf=, and =pub= are just arbitrary
names for the given =MAIL= and =SECRET= combination.  This allows me to
reference each name in the various package configurations in this
document, and share them publicly without worrying about leaking
sensitive data.

Which brings us to the point of actually retrieving those values.  The
=prot-mail-auth-get-field= is designed to return a field from the authinfo
file (this function is defined in my =prot-mail.el=, which is reproduced
at the end of [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).  You
will find this function used elsewhere in this document.  For example,
to get the username and password for host =inf= we do:

#+begin_example emacs-lisp :tangle no
(prot-mail-auth-get-field "inf" :user)   ; login name
(prot-mail-auth-get-field "inf" :secret) ; password
#+end_example

**** .mbsyncrc
:PROPERTIES:
:CUSTOM_ID: h:88a605b8-d5b5-486f-87c9-0c80b423ae36
:END:

I already noted in the introduction to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]] that my emails are
synced locally using the =mbsync= executable.  This program is part of a
package that, depending on your operating system, is called "isync".
Read the [[https://wiki.archlinux.org/index.php/Isync][Arch Wiki entry on mbsync]].

My =~/.mbsyncrc= is furnished below.  Note that the =awk= call reads from
the =~/.authinfo.gpg= (see [[#h:8d0bd754-8a31-431b-b112-f541cc0144ac][Sample of authinfo.gpg]]).


*** Notmuch (mail indexer and mail user agent (MUA))
:PROPERTIES:
:CUSTOM_ID: h:a196812e-1644-4536-84ba-687366867def
:END:

Also watch the video of what you are about to read in the following
paragraphs: [[https://protesilaos.com/codelog/2021-05-15-emacs-notmuch/][Demo of the Emacs front-end to Notmuch]] (2021-05-15).


At its core, Notmuch is a command-line program that maintains an index
of a maildir directory structure and is capable to search through it
using a tag-based method.  Notmuch is both minimalist and powerful:

1. its clearly delimited role as a mail indexer allows it to be used in
   a variety of setups that involve different tools on how to handle
   email traffic;

2. while its tag-centric design lifts the inherent restrictions of
   complex filesystem paths on where a file must be stored, as messages
   can be grouped together dynamically depending on the search criteria.

In terms of overall setup, I use Notmuch together with =mbsync= to
synchronise my maildir with the IMAP server (consult my [[#h:88a605b8-d5b5-486f-87c9-0c80b423ae36][.mbsyncrc]]).
While I send messages with Emacs' own facility which relies on the
=sendmail= program (refer to [[#h:2d793cf8-83f5-4830-b73d-78385d9b96dd][Sending email (SMTP)]]).  The latter may change
in the future, as I weigh the pros and cons of programs like =msmtp=,
though this is low on my list of priorities.  As for the actual
composition of emails, it is done by Emacs' =message.el= library
([[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

Tagging is integral to the Notmuch experience, because it allows you to
cope with evolving circumstances.  It is best to consider this by means
of an example.  Suppose that you are working on some project: (1) there
is an email in your private account from a close friend that contains
valuable information but which is part of an otherwise long thread that
is not pertinent in its entirety to the task at hand, (2) there is
another message from a mailing list you do not actively participate in
and this message lives in your "throwaway" account that you use only for
mailing lists and the like, and (3) there is yet another mail from some
client or employer that is specific to the project and which is kept in
your designated "professional" inbox.  Lets say that those correspond to
"private@example.tld", "lists@example.tld", "work@example.tld".  In a
folder-based approach, it is hard to combine those otherwise unrelated
files.  Whereas with tags, say, =+project=, we can get everything into
focus with a simple search for =tag:project=.

While we will be using the Emacs interface to Notmuch, it is important
to spend some time reading the man pages for the CLI tools.  Some
examples for searching:

#+begin_example
$ notmuch search from:prot*
$ notmuch search from:protesilaos tag:todo
$ notmuch search from:protesilaos or from:socrates
$ notmuch search 'from:"/(info|public)@protesilaos.com/"'
$ notmuch search 'from:"/(info|public)@protesilaos.com/"' date:yesterday..today
$ notmuch search '(from:"*@protesilaos.com*" not to:"*@protesilaos.com*")' date:today
$ notmuch search from:"*@protesilaos.com*" date:today..08:00
$ notmuch search body:recrudescence
$ notmuch search path:inf/Inbox/** date:2021-05
#+end_example

There is no need to develop expertise in that syntax at the outset.
Just learn the basics and let the rest grow organically through regular
usage.  Though do read the man pages as they include important
information such as what "stemming" is and how it affects your search
results.

Now let's focus on the Emacs side of things, starting with the
"notmuch-hello" buffer (it runs =notmuch-hello-mode=).  What exactly shows
up here depends on =notmuch-hello-sections=.  I like to keep it clean.  At
any rate, from here we can switch to results from saved searches or
tags, or perform a new search:

+ Type =j= to invoke =notmuch-jump-search=: it will produce a prompt for a
  key binding that corresponds to one of your saved searches (controlled
  by the variable =notmuch-saved-searches=).

+ With =t= for =notmuch-search-by-tag= you get minibuffer completion against
  all known tags.

+ Hit =s= to call =notmuch-search= which lets you type a query such as one
  of the aforementioned examples.  In the "notmuch-hello" buffer I keep
  a list of recent searches, which can be helpful to re-use at a later
  point, though we can always benefit from minibuffer history
  navigation, such as =M-n= and =M-p= while at the =notmuch-search= prompt.

+ Same principle for =z= (=notmuch-tree=) only it differs from the above
  search in the overall presentation where it visualises each thread
  using indentation and arrows to show what belongs where.  It also
  reduces the subject line to the first entry in each thread, making it
  easier to follow the results.

All of those will put you in a buffer that runs =notmuch-search-mode=.  As
always, you should use =C-h m= (=describe-mode=) to learn about everything
related to the current major mode (as well as all active minor modes).

To further limit the results to an arbitrary list of search criteria,
use =l= (=notmuch-search-filter=) and then supply whatever terms are needed.
Or use =t=, which is here bound to =notmuch-search-filter-by-tag= to filter
directly by tag using completion.  For example, I can start from the
"notmuch-hello" buffer with =notmuch-search-by-tag=, select "todo", and
then use =l= or =t= to further narrow to, say, a "replied" tag or
=date:today=.

Filtering of search results is the best way to narrow the list to
relevant matches.  You can try supplying just a search term without any
keywords and you are likely to get what you are looking for.  For
example, I was in a search that included results from the emacs-devel
and bug-gnu-emacs mailing lists and had several unread threads, though I
only wanted to read about "group-function".  So I just hit =l=
(=notmuch-search-filter=) and then typed in that query.  Same principle if
you wish to exclude something, such as with =not tag:flag=.

The Notmuch presentation is compact when it comes to longer threads as
it reduces them to a single line.  We can still get a sense of context
by viewing the total count of messages in the thread: this is controlled
by the variable =notmuch-search-result-format=.  While I like this as a
default, there are cases where we need to visualise the email exchanges:
=notmuch-tree-from-unthreaded-current-query= can do just that and is bound
to =Z= in =notmuch-search-mode-map=.  A similar variant is =U= for
=notmuch-unthreaded-from-search-current-query=, as it expands the view
without adding the tree indicators and without de-duplicating subject
lines across the threads.  Go back to the standard search view with =S=
(=notmuch-search-from-tree-current-query=).

All those changes in presentation happen in new buffers: you do not lose
anything, unless you explicitly kill those buffers.  For the sake of
convenience, Notmuch provides the =notmuch-bury-or-kill-this-buffer=
command, bound to =q= in all those views.  Read its doc string to know
when it kills and when it buries the buffer.  Of course, you may always
use commands like =previous-buffer= as well as minibuffer completion and
=M-x ibuffer= or whatever else you normally use.  The point is that you
can easily switch views to get the job done.

Speaking of multiple buffers, Notmuch provides two commands to refresh
those: (i) =notmuch-refresh-this-buffer=, which is bound by default to the
usual =g= key as well as ===, and (ii) =notmuch-refresh-all-buffers= which is
assigned to =M-g=.  My =prot-notmuch-refresh-buffer= is a wrapper of those
two and is mapped to =g=: when called with a =C-u= prefix argument, it
refreshes all buffers, else it operates on the current one.  There is
also =G= (=notmuch-poll-and-refresh-this-buffer=) which runs =notmuch new=
externally and then refreshes the buffer---personally I don't need this
as mbsync automatically does that every few minutes.

To read a thread, hit =RET= (=notmuch-search-show-thread=) with point over
it in any those search/tree views.  That puts you in =notmuch-show-mode=
(did I tell you about =C-h m=?).  Notmuch organises all messages in the
thread as headings, where the first line with the summary of the message
uses a special face (a background colour, though that depends on the
theme).  With point over the heading's line =RET= expands or contracts the
body of the message.  The =n= and =p= keys move between expanded messages in
the thread, while =N= and =P= always go to the next and previous items,
respectively.  An Imenu index is also available, so you can jump to any
heading using minibuffer completion (with =M-x imenu= or some third-party
extension like the =consult-imenu= that I use).

When you compose an email, such as by replying with =r= or =R=, you are
taken to a buffer that leverages functionality provided by the built-in
=message.el=.  As always, run =C-h m= to get a sense of how things work and
what commands you may call: =C-c C-c= dispatches the email, =C-c C-a=
prompts for an attachment, =C-c C-m C-e= encrypts and signs, =C-c C-m C-a=
from a Dired buffer attaches the file at point or any marked ones (refer
to [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][Client-agnostic email settings (and prot-mail.el)]]).

For searching to be productive, we must apply tags in accordance with a
defined method of organising our workflow (more about my approach
further below).  Too many over-specialised or poorly considered tags
will likely make things more difficult, while too few will probably
prevent you from finding what you need.  How you go about it is up to
you.  Notmuch is just a tool: don't believe in the hype of magical
exominds or second brains that do the work on your behalf---maximise the
potential of the one mind you have and the rest will follow from there.

Tag addition or removal is denoted by a plus or minus prefix to the name
of the tag.  The =k= binding exists in all relevant mode maps: it offers a
shortcut to the "keys" (tags) that can be used to mark a give entry.
That command will prompt for a choice among =notmuch-tagging-keys=.  For
example =k d= will do =+del -inbox=, based on what I currently have.  Invert
the meaning of those terms by prefixing the command with a =C-u= argument.

To freely tag all items in the current view (search, tree, show) use =*=.
That gives you a completion prompt where multiple terms can be supplied,
each delimited by a space (internally this is =completing-read-multiple=
and the space is governed by a let-bound =crm-separator=).  Combine that
with the aforementioned methods for limiting the view to a given subset
for maximum effect.

Other ways to perform tagging operations involve the =+= and =-= keys.  They
also use =completing-read-multiple=.  What those commands offer, beside
the minibuffer interface, is the ability to operate on the entries
encompassed by the active region, where point and mark delimit the lines
to be affected.  There are cases where marking a region is faster than
narrowing the view with new search criteria, so use whatever makes sense
at the moment.

Remember the governing principle of Notmuch: it does not touch your
mail.  All those tags are specific to the Notmuch database (with the
exception of some basic tags that are understood by the IMAP server and
can be optionally affected by Notmuch ([[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] has the
=synchronize_flags=true= directive).

As Notmuch is not a traditional mail client, it has neither opinions nor
capabilities on how one handles their maildir.  It does not move files
around nor does it have its own deletion and anti-spam mechanisms.  It
is up to the user to provide those.  While this may seem needlessly
limited at first, it is consistent with the precise function that
Notmuch performs in the broader email toolkit.  To actually delete mail,
we can tag it accordingly (e.g. "del") and then run this command either
manually or from a script with some cron job or systemd timer:

#+begin_example
notmuch search --output=files --format=text0 tag:del | xargs -r0 rm
#+end_example

I actually prefer the manual method: mark items with =+del= and perform
their removal from the disk whenever it is expedient.  This has the
upside of offering me the chance to review the messages, in case I have
mislabelled some item: I have deleted legitimate mail before, so it is
not a bad idea to be extra careful.

I have no pressing need to define commands for moving my mail files
between different directories: I did not do that even while I was using
Gnus.  Though I might eventually do it just for the sake of
completeness.  As such, consider the following package configurations a
work-in-progress, though they already offer all I need to get things
done.

With regard to the use of tags for day-to-day usage, I like to employ
the =tag:inbox and tag:unread= search as well as =tag:inbox= for practically
everything that is unsorted or of general interest.  Then I have
specialised tags like "list" for mailing lists which should not belong
in the inbox and "todo" for messages that require some further action
(those can always be complemented by other tags for greater precision
such as =+list +emacs=).  To keep things in check, a "post-new" script
outside the Emacs setup performs initial tagging on new mail.  For
example, my sent messages are marked as =-unread= while new mailing list
traffic goes to its right place with tags like =-inbox +list= (refer to
the sections on [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]] and [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).  Those that
I manually mark as =+todo= can optionally be combined with =org-capture= to
record a task that may appear in the Org agenda: call the =org-capture=
command while viewing such a message and Org will create a direct link
back to it: the glue code is found in [[#h:a7580136-cf32-44e8-81f6-590dbdd7f8f9][the section on ol-notmuch.el]] while
my =org-capture-templates= and their =org-capture-templates-contexts= are
defined in [[#h:4e8347de-415e-4804-b383-d61499e05ca1][Org-mode (personal information manager)]]).

Unlike most Emacs packages, I install =notmuch= from my distro's repos.
This is because (i) the CLI program is independent of Emacs, and (ii)
=notmuch.el= is bundled up together with the command-line tool because the
two are developed by the same group of people.  All good!  There is also
this note in =M-x find-library RET notmuch RET=:

#+begin_quote
Note for MELPA users (and others tracking the development version
of notmuch-emacs):

This emacs package needs a fairly closely matched version of the
notmuch program. If you use the MELPA version of notmuch.el (as
opposed to MELPA stable), you should be prepared to track the
master development branch (i.e. build from git) for the notmuch
program as well. Upgrading notmuch-emacs too far beyond the notmuch
program can CAUSE YOUR EMAIL TO STOP WORKING.

TL;DR: notmuch-emacs from MELPA and notmuch from distro packages is
NOT SUPPORTED.
#+end_quote

Finally, my =prot-notmuch.el= contains various commands and some minor
stylistic extras including a mode line indicator that shows a count of
all items matching the search terms =tag:unread and tag:inbox= (can be
configured by the variable =prot-notmuch-mode-line-search-args=).

#+begin_src emacs-lisp :tangle no
;;; Notmuch (mail indexer and mail user agent (MUA))
;; I install notmuch from the distro's repos because the CLI program is
;; not dependent on Emacs.  Though the package also includes notmuch.el
;; which is what we use here (they are maintained by the same people).
(add-to-list 'load-path "/usr/share/emacs/site-lisp/")
(prot-emacs-builtin-package 'notmuch

;;; Account settings
  (setq notmuch-identities
        (let ((identities))
          (dolist (m `(,(prot-mail-auth-get-field "prv" :user)
                       ,(prot-mail-auth-get-field "inf" :user)
                       ,(prot-mail-auth-get-field "pub" :user)))
            (push (format "%s <%s>" user-full-name m) identities))
          identities))
  (setq notmuch-fcc-dirs
        `((,(prot-mail-auth-get-field "prv" :user) . "prv/Sent")
          (,(prot-mail-auth-get-field "inf" :user) . "inf/Sent")
          (,(prot-mail-auth-get-field "pub" :user) . "pub/Sent")))

;;; General UI
  (setq notmuch-show-logo nil)
  (setq notmuch-column-control t)
  (setq notmuch-hello-auto-refresh t)
  (setq notmuch-hello-recent-searches-max 20)
  (setq notmuch-hello-thousands-separator "")
  ;; ;; See my variant of it in `prot-notmuch' below.
  ;; (setq notmuch-hello-sections '(notmuch-hello-insert-saved-searches))
  (setq notmuch-show-all-tags-list nil)

;;; Search
  (setq notmuch-search-oldest-first nil)
  (setq notmuch-search-result-format
        '(("date" . "%12s  ")
          ("count" . "%-7s  ")
          ("authors" . "%-20s  ")
          ("subject" . "%-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-tree-result-format
        '(("date" . "%12s  ")
          ("authors" . "%-20s  ")
          ((("tree" . "%s")
            ("subject" . "%s"))
           . " %-80s  ")
          ("tags" . "(%s)")))
  (setq notmuch-search-line-faces
        '(("unread" . notmuch-search-unread-face)
          ("flag" . notmuch-search-flagged-face)))
  (setq notmuch-show-empty-saved-searches t)
  (setq notmuch-saved-searches
        `(( :name "inbox"
            :query "tag:inbox"
            :sort-order newest-first
            :key ,(kbd "i"))
          ( :name "unread (inbox)"
            :query "tag:unread and tag:inbox"
            :sort-order newest-first
            :key ,(kbd "u"))
          ( :name "unread all"
            :query "tag:unread not tag:archived"
            :sort-order newest-first
            :key ,(kbd "U"))
          ( :name "references"
            :query "tag:ref not tag:archived"
            :sort-order newest-first
            :key ,(kbd "r"))
          ( :name "todo"
            :query "tag:todo not tag:archived"
            :sort-order newest-first
            :key ,(kbd "t"))
          ( :name "mailing lists"
            :query "tag:list not tag:archived"
            :sort-order newest-first
            :key ,(kbd "m"))
          ;; Emacs
          ( :name "emacs-devel"
            :query "(from:emacs-devel@gnu.org or to:emacs-devel@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e d"))
          ( :name "emacs-orgmode"
            :query "(from:emacs-orgmode@gnu.org or to:emacs-orgmode@gnu.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "e o"))
          ( :name "emacs-bugs"
            :query "'to:\"/*@debbugs.gnu.org*/\"' not tag:archived"
            :sort-order newest-first :key ,(kbd "e b"))
          ( :name "emacs-humanities"
            :query "(from:emacs-humanities@gnu.org or to:emacs-humanities@gnu.org) not tag:archived"
            :sort-order newest-first :key ,(kbd "e h"))
          ( :name "emacs-elpher"
            :query "(from:~michel-slm/elpher@lists.sr.ht or to:~michel-slm/elpher@lists.sr.ht) not tag:archived"
            :sort-order newest-first :key ,(kbd "e e"))
          ;; CLI tools
          ( :name "notmuch"
            :query "(from:notmuch@notmuchmail.org or to:notmuch@notmuchmail.org) not tag:archived"
            :sort-order newest-first
            :key ,(kbd "cn"))))

;;; Tags
  (setq notmuch-archive-tags '("-inbox" "+archived"))
  (setq notmuch-message-replied-tags '("+replied"))
  (setq notmuch-message-forwarded-tags '("+forwarded"))
  (setq notmuch-show-mark-read-tags '("-unread"))
  (setq notmuch-draft-tags '("+draft"))
  (setq notmuch-draft-folder "drafts")
  (setq notmuch-draft-save-plaintext 'ask)
  ;; ;; NOTE 2021-06-18: See an updated version in the `prot-notmuch'
  ;; ;; section below.
  ;; (setq notmuch-tagging-keys
  ;;       `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
  ;;         (,(kbd "c") ("+archived" "-inbox" "-list" "-todo" "-ref" "-unread") "Complete and archive")
  ;;         (,(kbd "d") ("+del" "-inbox" "-archived" "-unread") "Mark for deletion")
  ;;         (,(kbd "f") ("+flag" "-unread") "Flag as important")
  ;;         ;; (,(kbd "r") notmuch-show-mark-read-tags "Mark as read")
  ;;         (,(kbd "r") ("+ref" "-unread") "Reference for the future")
  ;;         (,(kbd "s") ("+spam" "+del" "-inbox" "-unread") "Mark as spam")
  ;;         (,(kbd "t") ("+todo" "-unread") "To-do")
  ;;         (,(kbd "u") ("+unread") "Mark as unread")))
  (setq notmuch-tag-formats
        '(("unread" (propertize tag 'face 'notmuch-tag-unread))
          ("flag" (propertize tag 'face 'notmuch-tag-flagged))))
  (setq notmuch-tag-deleted-formats
        '(("unread" (notmuch-apply-face bare-tag `notmuch-tag-deleted))
          (".*" (notmuch-apply-face tag `notmuch-tag-deleted))))

;;; Email composition
  (setq notmuch-mua-compose-in 'current-window)
  (setq notmuch-mua-hidden-headers nil) ; TODO 2021-05-12: Review hidden headers
  (setq notmuch-address-command nil)    ; FIXME 2021-05-13: Make it work with EBDB
  (setq notmuch-always-prompt-for-sender t)
  (setq notmuch-mua-cite-function 'message-cite-original-without-signature)
  (setq notmuch-mua-reply-insert-header-p-function 'notmuch-show-reply-insert-header-p-never)
  (setq notmuch-mua-user-agent-function #'notmuch-mua-user-agent-full)
  (setq notmuch-maildir-use-notmuch-insert t)
  (setq notmuch-crypto-process-mime t)
  (setq notmuch-crypto-get-keys-asynchronously t)
  (setq notmuch-mua-attachment-regexp   ; see `notmuch-mua-send-hook'
        (concat "\\b\\(attache\?ment\\|attached\\|attach\\|"
                "pi[èe]ce\s+jointe?\\|"
                "συνημμ[εέ]νο\\|επισυν[αά]πτω\\)\\b"))

;;; Reading messages
  (setq notmuch-show-relative-dates t)
  (setq notmuch-show-all-multipart/alternative-parts nil)
  (setq notmuch-show-indent-messages-width 0)
  (setq notmuch-show-indent-multipart nil)
  (setq notmuch-show-part-button-default-action 'notmuch-show-save-part)
  (setq notmuch-show-text/html-blocked-images ".") ; block everything
  (setq notmuch-wash-citation-lines-prefix 6)
  (setq notmuch-wash-citation-lines-suffix 6)
  (setq notmuch-wash-wrap-lines-length 100)
  (setq notmuch-unthreaded-show-out nil)
  (setq notmuch-message-headers '("To" "Cc" "Subject" "Date"))
  (setq notmuch-message-headers-visible t)

;;; Hooks and key bindings
  (add-hook 'notmuch-mua-send-hook #'notmuch-mua-attachment-check)
  (remove-hook 'notmuch-show-hook #'notmuch-show-turn-on-visual-line-mode)
  (add-hook 'notmuch-show-hook (lambda () (setq-local header-line-format nil)))

  (let ((map global-map))
    (define-key map (kbd "C-c m") #'notmuch)
    (define-key map (kbd "C-x m") #'notmuch-mua-new-mail)) ; override `compose-mail'
  (define-key notmuch-search-mode-map (kbd "/") #'notmuch-search-filter) ; alias for l
  (define-key notmuch-hello-mode-map (kbd "C-<tab>") nil))

(prot-emacs-builtin-package 'prot-notmuch
  ;; Those are for the actions that are available after pressing 'k'
  ;; (`notmuch-tag-jump').  For direct actions, refer to the key
  ;; bindings below.
  (setq notmuch-tagging-keys
        `((,(kbd "a") notmuch-archive-tags "Archive (remove from inbox)")
          (,(kbd "c") prot-notmuch-mark-complete-tags "Complete and archive")
          (,(kbd "d") prot-notmuch-mark-delete-tags "Mark for deletion")
          (,(kbd "f") prot-notmuch-mark-flag-tags "Flag as important")
          (,(kbd "s") prot-notmuch-mark-spam-tags "Mark as spam")
          (,(kbd "t") prot-notmuch-mark-todo-tags "To-do")
          (,(kbd "x") prot-notmuch-mark-reference-tags "Reference for the future")
          (,(kbd "r") ("-unread") "Mark as read")
          (,(kbd "u") ("+unread") "Mark as unread")))

  (setq prot-notmuch-search-field-width 100)
  (setq notmuch-hello-sections '(prot-notmuch-hello-insert-saved-searches
                                 ;; prot-notmuch-hello-insert-recent-searches
                                 ))

  (add-to-list 'notmuch-tag-formats
               '("encrypted" (propertize tag 'face 'prot-notmuch-encrypted-tag)))
  (add-to-list 'notmuch-tag-formats
               '("sent" (propertize tag 'face 'prot-notmuch-sent-tag)))
  (add-to-list 'notmuch-tag-formats
               '("ref" (propertize tag 'face 'prot-notmuch-ref-tag)))
  (add-to-list 'notmuch-tag-formats
               '("todo" (propertize tag 'face 'prot-notmuch-todo-tag)))
  (add-to-list 'notmuch-tag-formats
               '("spam" (propertize tag 'face 'prot-notmuch-spam-tag)))

  ;; NOTE 2021-05-14: I have an alternative method of finding new mail
  ;; in a maildir tree by using the find command.  It is somewhat
  ;; simplistic, though it worked just fine: see prot-mail.el.  I prefer
  ;; this implementation instead, as it leverages notmuch and so I can
  ;; pass arbitrary search terms to it.
  (setq prot-notmuch-mode-line-count-args "tag:unread and tag:inbox")
  (setq prot-notmuch-mode-line-indicator-commands
        '(notmuch notmuch-refresh-this-buffer))
  ;; Mode line indicator with the number of new mails.
  (prot-notmuch-mail-indicator 1)

  (add-hook 'notmuch-hello-mode-hook #'prot-notmuch-widget-field-face-remap)

  (let ((map notmuch-search-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-search-archive-thread)
    (define-key map (kbd "D") #'prot-notmuch-search-delete-thread)
    (define-key map (kbd "T") #'prot-notmuch-search-todo-thread)
    (define-key map (kbd "X") #'prot-notmuch-search-reference-thread)
    (define-key map (kbd "C") #'prot-notmuch-search-complete-thread)
    (define-key map (kbd "S") #'prot-notmuch-search-spam-thread)
    (define-key map (kbd "g") #'prot-notmuch-refresh-buffer))
  (let ((map notmuch-show-mode-map))
    (define-key map (kbd "a") nil) ; the default is too easy to hit accidentally
    (define-key map (kbd "A") #'notmuch-show-archive-message-then-next-or-next-thread)
    (define-key map (kbd "D") #'prot-notmuch-show-delete-message)
    (define-key map (kbd "T") #'prot-notmuch-show-todo-message)
    (define-key map (kbd "X") #'prot-notmuch-show-reference-message)
    (define-key map (kbd "C") #'prot-notmuch-show-complete-message)
    (define-key map (kbd "S") #'prot-notmuch-show-spam-message)))
#+end_src


**** .notmuch-config
:PROPERTIES:
:CUSTOM_ID: h:79803e19-1150-49a6-a3df-1cffe3d0cbc5
:END:

What follows is my =~/.notmuch-config=.  The =tags=new= configuration is
what enables the use of initial tagging, as explained in the upstream
documentation (basically you want to tag some mail right after a
=notmuch new= such as, for example, to remove mailist list messages from
the inbox---see [[#h:70d60d41-cb63-4950-bbd9-9157c4d186dc][notmuch post-new rules]]).

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].


**** notmuch post-new rules
:PROPERTIES:
:CUSTOM_ID: h:70d60d41-cb63-4950-bbd9-9157c4d186dc
:END:

And here are the rules that apply after running =notmuch new=.  Its file
system path is =$maildir/.notmuch/hooks/post-new= where =$maildir= is the
database path specified in =.notmuch-config= (see [[#h:79803e19-1150-49a6-a3df-1cffe3d0cbc5][.notmuch-config]]).
Remember that this file needs to be an executable.

The Emacs configs: [[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]].


**** Org+Notmuch integration (ol-notmuch.el)
:PROPERTIES:
:CUSTOM_ID: h:a7580136-cf32-44e8-81f6-590dbdd7f8f9
:END:

The =ol-notmuch.el= is part of the =org-contrib= package which can be found
in the NonGNU ELPA (that archive is configured out-of-the-box for
Emacs28, same as with GNU ELPA).  However, that package contains
approximately one zillion things I do not need, so I prefer to copy the
file here and handle it on its own.

#+begin_src emacs-lisp :tangle no
;;; ol-notmuch.el --- Links to notmuch messages

;; Copyright (C) 2010-2014  Matthieu Lemerre

;; Author: Matthieu Lemerre <racin@free.fr>
;; Keywords: outlines, hypermedia, calendar, wp
;; Homepage: https://orgmode.org

;; This file is not part of GNU Emacs.

;; This file is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation; either version 2, or (at your option)
;; any later version.

;; This file is distributed in the hope that it will be useful,
;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;; GNU General Public License for more details.

;; You should have received a copy of the GNU General Public License
;; along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.

;;; Commentary:

;; This file implements links to notmuch messages and "searches". A
;; search is a query to be performed by notmuch; it is the equivalent
;; to folders in other mail clients. Similarly, mails are referred to
;; by a query, so both a link can refer to several mails.

;; Links have one the following form
;; notmuch:<search terms>
;; notmuch-search:<search terms>.

;; The first form open the queries in notmuch-show mode, whereas the
;; second link open it in notmuch-search mode. Note that queries are
;; performed at the time the link is opened, and the result may be
;; different from when the link was stored.

;;; Code:

(require 'ol)

;; customisable notmuch open functions
(defcustom org-notmuch-open-function
  'org-notmuch-follow-link
  "Function used to follow notmuch links.

Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(defcustom org-notmuch-search-open-function
  'org-notmuch-search-follow-link
  "Function used to follow notmuch-search links.
Should accept a notmuch search string as the sole argument."
  :group 'org-notmuch
  :version "24.4"
  :package-version '(Org . "8.0")
  :type 'function)

(make-obsolete-variable 'org-notmuch-search-open-function nil "9.3")



;; Install the link type
(org-link-set-parameters "notmuch"
			 :follow #'org-notmuch-open
			 :store #'org-notmuch-store-link)

(defun org-notmuch-store-link ()
  "Store a link to a notmuch search or message."
  (when (memq major-mode '(notmuch-show-mode notmuch-tree-mode))
    (let* ((message-id (notmuch-show-get-message-id t))
	   (subject (notmuch-show-get-subject))
	   (to (notmuch-show-get-to))
	   (from (notmuch-show-get-from))
	   (date (org-trim (notmuch-show-get-date)))
	   desc link)
      (org-link-store-props :type "notmuch" :from from :to to :date date
       			    :subject subject :message-id message-id)
      (setq desc (org-link-email-description))
      (setq link (concat "notmuch:id:" message-id))
      (org-link-add-props :link link :description desc)
      link)))

(defun org-notmuch-open (path _)
  "Follow a notmuch message link specified by PATH."
  (funcall org-notmuch-open-function path))

(defun org-notmuch-follow-link (search)
  "Follow a notmuch link to SEARCH.

Can link to more than one message, if so all matching messages are shown."
  (require 'notmuch)
  (notmuch-show search))



(org-link-set-parameters "notmuch-search"
			 :follow #'org-notmuch-search-open
			 :store #'org-notmuch-search-store-link)

(defun org-notmuch-search-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-search-mode)
    (let ((link (concat "notmuch-search:" notmuch-search-query-string))
	  (desc (concat "Notmuch search: " notmuch-search-query-string)))
      (org-link-store-props :type "notmuch-search"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-search-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-search-follow-link path))

(defun org-notmuch-search-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-search mode."
  (require 'notmuch)
  (notmuch-search search))



(org-link-set-parameters "notmuch-tree"
			 :follow #'org-notmuch-tree-open
			 :store #'org-notmuch-tree-store-link)

(defun org-notmuch-tree-store-link ()
  "Store a link to a notmuch search or message."
  (when (eq major-mode 'notmuch-tree-mode)
    (let ((link (concat "notmuch-tree:" (notmuch-tree-get-query)))
	  (desc (concat "Notmuch tree: " (notmuch-tree-get-query))))
      (org-link-store-props :type "notmuch-tree"
			    :link link
			    :description desc)
      link)))

(defun org-notmuch-tree-open (path _)
  "Follow a notmuch message link specified by PATH."
  (message "%s" path)
  (org-notmuch-tree-follow-link path))

(defun org-notmuch-tree-follow-link (search)
  "Follow a notmuch link by displaying SEARCH in notmuch-tree mode."
  (require 'notmuch)
  (notmuch-tree search))

(provide 'ol-notmuch)

;;; ol-notmuch.el ends here
#+end_src


#+begin_src emacs-lisp :tangle no
(require 'ol-notmuch)
#+end_src

*** Sending email (SMTP)
:PROPERTIES:
:CUSTOM_ID: h:2d793cf8-83f5-4830-b73d-78385d9b96dd
:END:

These are the base settings for the SMTP functionality.  Passwords and
other critical information are stored in =~/.authinfo.gpg=, as
demonstrated in [[#h:a82766be-daab-4925-b23a-1c5ffd47e599][the base email settings]].  What follows is just a
mirroring of the contents of that file.

#+begin_src emacs-lisp :tangle no
;;; Sending email (SMTP)
(prot-emacs-builtin-package 'smtpmail
  (setq smtpmail-default-smtp-server "mail.gandi.net")
  (setq smtpmail-smtp-server "mail.gandi.net")
  (setq smtpmail-stream-type 'ssl)
  (setq smtpmail-smtp-service 465)
  (setq smtpmail-queue-mail nil))

(prot-emacs-builtin-package 'sendmail
  (setq send-mail-function 'smtpmail-send-it))
#+end_src

*** EBDB (mail contacts)
:PROPERTIES:
:CUSTOM_ID: h:d386e14b-dcf7-46a2-851f-867cd84c6cae
:END:

EBDB is a contacts' manager by Eric Abrahamsen that integrates with Mail
User Agents inside of Emacs.  I used to use it as part of my Gnus setup
but as of 2021-05-13 my plan is to make it work with Notmuch as I have
switched to it ([[#h:a196812e-1644-4536-84ba-687366867def][Notmuch (mail indexer and mail user agent (MUA))]]).

What I need from it is to perform the task of storing every address that
I exchange messages with.  When I send someone a message, their email
should be saved automatically.  While if I merely read an item, say, on
the emacs-devel mailing list, I prefer to only update existing records
else do nothing.

One could set everything to automatically update in all contexts, though
I find that such an approach will either create too many false positives
that will distract you from the immediate task of handling your
correspondence, or they will simply contribute to the creation of a
database that contains a lot of largely useless information.  Save only
what matters---ignore the rest.

While "ignore the rest" can mean to simply pass it over in silence, EBBD
actually provides a mechanism to permanently exclude individual
addresses or domain names from ever being recorded.  Those are stored in
the file specified by the variable =ebdb-permanent-ignores-file=: you can
edit it manually, adding one address per line with no attached name or
angled brackets, or a domain name that starts with the =@= sign.  No
regexp notation is accepted.  For example:

#+begin_example
@debbugs.gnu.org
help-debbugs@gnu.org
@reply.github.com
#+end_example

EBDB binds some common commands to the semicolon (=;=) prefix key inside
Gnus' summary and article buffers.  For example, =; := will update all
records that are found in the message at point, while =; s= will scan
(called "snarf") the body of the message for names and email addresses
in an attempt to create records of any findings.  As always, append =C-h=
to the prefix key to get help about all key bindings that complete the
sequence and what commands they call.

The =ebdb-mua-pop-up= controls whether a window with relevant contact
information should be displayed automatically.  Perhaps it is good to
have some extra feedback on what we know or what has been collected thus
far, though I prefer not to see anything by default (it can still be
displayed with the various commands under the =;= prefix key).  Its
informative nature aside, this window can be used to further edit
entries.  With point over a field, type =e= to edit it or =C-k= to remove it
(I bind =D= to delete).  The latter command behaves differently when the
point is before the record's main field, typically the name, where it
will prompt to delete the whole entry altogether.  For more about that
specific major mode and its associated buffers, use =C-h m= (which invokes
=describe-mode=).

To view all of your contacts, or just those matching a pattern (or
string), use =M-x ebdb=, which will prompt for a search.  Input an empty
query if you prefer to view everything in the database.  While in the
=*EBDB*= buffer, you gain access to commands for operating on the records.
Same principle as with the aforementioned =ebdb-mua-pop-up=: =c= to create a
new entry, =e= to edit the field at point, =i= to insert a new datum to the
current record, =C-k= (or my preferred =D=) to delete...  Again, =C-h m= is
your friend.

Apart from gathering data and operating on it, EBDB can auto-complete
email addresses in the message composition buffer: hit TAB in a "To:",
"Cc:" or equivalent header and then use the completion framework's
interaction model to retrieve what you want.

Finally, note that this package is fairly comprehensive as it defines
lots of options and commands: make sure to read its official manual.

#+begin_src emacs-lisp :tangle no
;;; EBDB (mail contacts)
(prot-emacs-elpa-package 'ebdb
  (require 'ebdb-message)
  (require 'ebdb-notmuch) ; FIXME 2021-05-13: does not activate the corfu-mode UI
  (setq ebdb-sources (locate-user-emacs-file "ebdb"))
  (setq ebdb-permanent-ignores-file (locate-user-emacs-file "ebdb-permanent-ignores"))

  (setq ebdb-mua-pop-up nil)
  (setq ebdb-default-window-size 0.25)
  (setq ebdb-mua-default-formatter ebdb-default-multiline-formatter)

  (setq ebdb-mua-auto-update-p 'existing)
  (setq ebdb-mua-reader-update-p 'existing)
  (setq ebdb-mua-sender-update-p 'create)
  (setq ebdb-message-auto-update-p 'create)

  (setq ebdb-message-try-all-headers t)
  (setq ebdb-message-headers
        '((sender "From" "Resent-From" "Reply-To" "Sender")
          (recipients "Resent-To" "Resent-Cc" "Resent-CC" "To" "Cc" "CC" "Bcc" "BCC")))
  (setq ebdb-message-all-addresses t)

  (setq ebdb-complete-mail 'capf)
  (setq ebdb-mail-avoid-redundancy t)
  (setq ebdb-completion-display-record nil)
  (setq ebdb-complete-mail-allow-cycling nil)

  (setq ebdb-record-self "ace719a4-61f8-4bee-a1ca-2f07e2292305")
  (setq ebdb-user-name-address-re 'self) ; match the above
  (setq ebdb-save-on-exit t)

  (with-eval-after-load 'prot-mail ; check my `prot-mail.el'
    (add-hook 'message-setup-hook #'prot-mail-ebdb-message-setup))

  (let ((map ebdb-mode-map))
    (define-key map (kbd "D") #'ebdb-delete-field-or-record)
    (define-key map (kbd "M") #'ebdb-mail) ; disables `ebdb-mail-each'
    (define-key map (kbd "m") #'ebdb-toggle-record-mark)
    (define-key map (kbd "t") #'ebdb-toggle-all-record-marks)
    (define-key map (kbd "T") #'ebdb-toggle-records-format) ; disables `ebdb-toggle-all-records-format'
    (define-key map (kbd "U") #'ebdb-unmark-all-records)))
#+end_src

** simple httpd
#+begin_src emacs-lisp :tangle yes
(use-package simple-httpd
  :ensure t)
#+end_src

#+RESULTS:
: simple-httpd

Now you can run M-x httpd-serve-directory. It will prompt you for a directory to serve from within Emacs.
Select the path of your public/ directory and then open your browser to http://localhost:8080 to see the preview of your site! Set httpd-port to change the default port if necessary.
Any time you regenerate the site files, you can just reload the page to see the result of changes you made!

** Elfeed goodies
An RSS newsfeed reader for Emacs.
Elfeed enables the nicest podcast integration I know: Treat podcast entries as regular RSS entries, but hit A to enqueue them in emms.

Usage:

+  Prepare emms with M-x emms-playlist-mode-go
+  Update your feeds with M-x elfeed-update
+  Read your feeds with M-x elfeed; hit enter to open an entry, then n and p to switch between them quickly (that’s the speed I wish to have everywhere).
+  Hit A to enqueue the file in emms.
+  Start listening to media with M-x emms-start.
+  Keep queueing up further interesting entries from elfeed.
+  Pause emms with M-x emms-pause when needed.

 #+BEGIN_SRC emacs-lisp :tangle no
;; (use-package! elfeed-goodies)
;; (elfeed-goodies/setup)
;; (setq elfeed-goodies/entry-pane-size 0.5)
(add-hook 'elfeed-show-mode-hook 'visual-line-mode)
(evil-define-key 'normal elfeed-show-mode-map
  (kbd "J") 'elfeed-goodies/split-show-next
  (kbd "K") 'elfeed-goodies/split-show-prev)
(evil-define-key 'normal elfeed-search-mode-map
  (kbd "J") 'elfeed-goodies/split-show-next
  (kbd "K") 'elfeed-goodies/split-show-prev)
(setq elfeed-feeds (quote
          (("https://www.reddit.com/r/linux.rss" reddit linux)
          ("https://www.reddit.com/r/commandline.rss" reddit commandline)
          ("https://www.reddit.com/r/distrotube.rss" reddit distrotube)
          ("https://www.reddit.com/r/emacs.rss" reddit emacs)
          ("https://www.gamingonlinux.com/article_rss.php" gaming linux)
          ("https://hackaday.com/blog/feed/" hackaday linux)
          ("https://opensource.com/feed" opensource linux)
          ("https://linux.softpedia.com/backend.xml" softpedia linux)
          ("https://itsfoss.com/feed/" itsfoss linux)
          ("https://www.zdnet.com/topic/linux/rss.xml" zdnet linux)
          ("https://www.phoronix.com/rss.php" phoronix linux)
          ("http://feeds.feedburner.com/d0od" omgubuntu linux)
          ("https://www.computerworld.com/index.rss" computerworld linux)
          ("https://www.networkworld.com/category/linux/index.rss" networkworld linux)
          ("https://www.techrepublic.com/rssfeeds/topic/open-source/" techrepublic linux)
          ("https://betanews.com/feed" betanews linux)
          ("http://lxer.com/module/newswire/headlines.rss" lxer linux)
          ("http://endlessparentheses.com/atom.xml" emacs)
          ("http://planet.emacsen.org/atom.xml" emacs)
          ("https://www.reddit.com/r/emacs/.rss" emacs)
          ("https://www.reddit.com/r/orgmode/.rss" emacs)
          ("http://www.blackhats.es/wordpress/?feed=rss2" emacs)
          ("http://www.howardism.org/index.xml" emacs)
          ("http://www.masteringemacs.org/feed/" emacs))))

#+END_SRC

** Newsfeed

RSS feeds are still a thing. Why not make use of them with =elfeed=.
I really like what [[https://github.com/fuxialexander/doom-emacs-private-xfu/tree/master/modules/app/rss][fuxialexander]] has going on, but I don't think I need a custom
module. Let's just try to patch on the main things I like the look of.

*** Keybindings

#+begin_src emacs-lisp
(map! :map elfeed-search-mode-map
      :after elfeed-search
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :n "q" #'+rss/quit
      :n "e" #'elfeed-update
      :n "r" #'elfeed-search-untag-all-unread
      :n "u" #'elfeed-search-tag-all-unread
      :n "s" #'elfeed-search-live-filter
      :n "RET" #'elfeed-search-show-entry
      :n "p" #'elfeed-show-pdf
      :n "+" #'elfeed-search-tag-all
      :n "-" #'elfeed-search-untag-all
      :n "S" #'elfeed-search-set-filter
      :n "b" #'elfeed-search-browse-url
      :n "y" #'elfeed-search-yank)
(map! :map elfeed-show-mode-map
      :after elfeed-show
      [remap kill-this-buffer] "q"
      [remap kill-buffer] "q"
      :n doom-leader-key nil
      :nm "q" #'+rss/delete-pane
      :nm "o" #'ace-link-elfeed
      :nm "RET" #'org-ref-elfeed-add
      :nm "n" #'elfeed-show-next
      :nm "N" #'elfeed-show-prev
      :nm "p" #'elfeed-show-pdf
      :nm "+" #'elfeed-show-tag
      :nm "-" #'elfeed-show-untag
      :nm "s" #'elfeed-show-new-live-search
      :nm "y" #'elfeed-show-yank)
#+end_src

#+RESULTS:

*** Usability enhancements

#+begin_src emacs-lisp
(after! elfeed-search
  (set-evil-initial-state! 'elfeed-search-mode 'normal))
(after! elfeed-show-mode
  (set-evil-initial-state! 'elfeed-show-mode   'normal))

(after! evil-snipe
  (push 'elfeed-show-mode   evil-snipe-disabled-modes)
  (push 'elfeed-search-mode evil-snipe-disabled-modes))
#+end_src

*** Visual enhancements

#+begin_src emacs-lisp
(after! elfeed

  (elfeed-org)
  (use-package! elfeed-link)

  (setq elfeed-search-filter "@1-week-ago +unread"
        elfeed-search-print-entry-function '+rss/elfeed-search-print-entry
        elfeed-search-title-min-width 80
        elfeed-show-entry-switch #'pop-to-buffer
        elfeed-show-entry-delete #'+rss/delete-pane
        elfeed-show-refresh-function #'+rss/elfeed-show-refresh--better-style
        shr-max-image-proportion 0.6)

  (add-hook! 'elfeed-show-mode-hook (hide-mode-line-mode 1))
  (add-hook! 'elfeed-search-update-hook #'hide-mode-line-mode)

  (defface elfeed-show-title-face '((t (:weight ultrabold :slant italic :height 1.5)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (defface elfeed-show-author-face `((t (:weight light)))
    "title face in elfeed show buffer"
    :group 'elfeed)
  (set-face-attribute 'elfeed-search-title-face nil
                      :foreground 'nil
                      :weight 'light)

  (defadvice! +rss-elfeed-wrap-h-nicer ()
    "Enhances an elfeed entry's readability by wrapping it to a width of
`fill-column' and centering it with `visual-fill-column-mode'."
    :override #'+rss-elfeed-wrap-h
    (setq-local truncate-lines nil
                shr-width 120
                visual-fill-column-center-text t
                default-text-properties '(line-height 1.1))
    (let ((inhibit-read-only t)
          (inhibit-modification-hooks t))
      (visual-fill-column-mode)
      ;; (setq-local shr-current-font '(:family "Merriweather" :height 1.2))
      (set-buffer-modified-p nil)))

  (defun +rss/elfeed-search-print-entry (entry)
    "Print ENTRY to the buffer."
    (let* ((elfeed-goodies/tag-column-width 40)
           (elfeed-goodies/feed-source-column-width 30)
           (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
           (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
           (feed (elfeed-entry-feed entry))
           (feed-title
            (when feed
              (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
           (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
           (tags-str (concat (mapconcat 'identity tags ",")))
           (title-width (- (window-width) elfeed-goodies/feed-source-column-width
                           elfeed-goodies/tag-column-width 4))

           (tag-column (elfeed-format-column
                        tags-str (elfeed-clamp (length tags-str)
                                               elfeed-goodies/tag-column-width
                                               elfeed-goodies/tag-column-width)
                        :left))
           (feed-column (elfeed-format-column
                         feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width
                                                  elfeed-goodies/feed-source-column-width)
                         :left)))

      (insert (propertize feed-column 'face 'elfeed-search-feed-face) " ")
      (insert (propertize tag-column 'face 'elfeed-search-tag-face) " ")
      (insert (propertize title 'face title-faces 'kbd-help title))
      (setq-local line-spacing 0.2)))

  (defun +rss/elfeed-show-refresh--better-style ()
    "Update the buffer to match the selected entry, using a mail-style."
    (interactive)
    (let* ((inhibit-read-only t)
           (title (elfeed-entry-title elfeed-show-entry))
           (date (seconds-to-time (elfeed-entry-date elfeed-show-entry)))
           (author (elfeed-meta elfeed-show-entry :author))
           (link (elfeed-entry-link elfeed-show-entry))
           (tags (elfeed-entry-tags elfeed-show-entry))
           (tagsstr (mapconcat #'symbol-name tags ", "))
           (nicedate (format-time-string "%a, %e %b %Y %T %Z" date))
           (content (elfeed-deref (elfeed-entry-content elfeed-show-entry)))
           (type (elfeed-entry-content-type elfeed-show-entry))
           (feed (elfeed-entry-feed elfeed-show-entry))
           (feed-title (elfeed-feed-title feed))
           (base (and feed (elfeed-compute-base (elfeed-feed-url feed)))))
      (erase-buffer)
      (insert "\n")
      (insert (format "%s\n\n" (propertize title 'face 'elfeed-show-title-face)))
      (insert (format "%s\t" (propertize feed-title 'face 'elfeed-search-feed-face)))
      (when (and author elfeed-show-entry-author)
        (insert (format "%s\n" (propertize author 'face 'elfeed-show-author-face))))
      (insert (format "%s\n\n" (propertize nicedate 'face 'elfeed-log-date-face)))
      (when tags
        (insert (format "%s\n"
                        (propertize tagsstr 'face 'elfeed-search-tag-face))))
      ;; (insert (propertize "Link: " 'face 'message-header-name))
      ;; (elfeed-insert-link link link)
      ;; (insert "\n")
      (cl-loop for enclosure in (elfeed-entry-enclosures elfeed-show-entry)
               do (insert (propertize "Enclosure: " 'face 'message-header-name))
               do (elfeed-insert-link (car enclosure))
               do (insert "\n"))
      (insert "\n")
      (if content
          (if (eq type 'html)
              (elfeed-insert-html content base)
            (insert content))
        (insert (propertize "(empty)\n" 'face 'italic)))
      (goto-char (point-min))))

  )
#+end_src

#+RESULTS:
: +rss/elfeed-show-refresh--better-style

*** Functionality enhancements

#+begin_src emacs-lisp
(after! elfeed-show
  (require 'url)

  (defvar elfeed-pdf-dir
    (expand-file-name "pdfs/"
                      (file-name-directory (directory-file-name elfeed-enclosure-default-dir))))

  (defvar elfeed-link-pdfs
    '(("https://www.jstatsoft.org/index.php/jss/article/view/v0\\([^/]+\\)" . "https://www.jstatsoft.org/index.php/jss/article/view/v0\\1/v\\1.pdf")
      ("http://arxiv.org/abs/\\([^/]+\\)" . "https://arxiv.org/pdf/\\1.pdf"))
    "List of alists of the form (REGEX-FOR-LINK . FORM-FOR-PDF)")

  (defun elfeed-show-pdf (entry)
    (interactive
     (list (or elfeed-show-entry (elfeed-search-selected :ignore-region))))
    (let ((link (elfeed-entry-link entry))
          (feed-name (plist-get (elfeed-feed-meta (elfeed-entry-feed entry)) :title))
          (title (elfeed-entry-title entry))
          (file-view-function
           (lambda (f)
             (when elfeed-show-entry
               (elfeed-kill-buffer))
             (pop-to-buffer (find-file-noselect f))))
          pdf)

      (let ((file (expand-file-name
                   (concat (subst-char-in-string ?/ ?, title) ".pdf")
                   (expand-file-name (subst-char-in-string ?/ ?, feed-name)
                                     elfeed-pdf-dir))))
        (if (file-exists-p file)
            (funcall file-view-function file)
          (dolist (link-pdf elfeed-link-pdfs)
            (when (and (string-match-p (car link-pdf) link)
                       (not pdf))
              (setq pdf (replace-regexp-in-string (car link-pdf) (cdr link-pdf) link))))
          (if (not pdf)
              (message "No associated PDF for entry")
            (message "Fetching %s" pdf)
            (unless (file-exists-p (file-name-directory file))
              (make-directory (file-name-directory file) t))
            (url-copy-file pdf file)
            (funcall file-view-function file))))))

  )
#+end_src

#+RESULTS:
: elfeed-show-pdf

*** easier tagging
By default you can tag an entry from the search results by typing “+” followed by the tag name. This is too much work for a central organizational feature, so a little helper sorts things out.

#+begin_src emacs-lisp :tangle no

(defun elfeed-tag-selection-as (mytag)
    "Returns a function that tags an elfeed entry or selection as
MYTAG"
    (lambda ()
      "Toggle a tag on an Elfeed search selection"
      (interactive)
      (elfeed-search-toggle-all mytag)))

;; Tag with a single letter keybind:

(define-key elfeed-search-mode-map "l" (elfeed-tag-selection-as 'readlater))
(define-key elfeed-search-mode-map "d" (elfeed-tag-selection-as 'junk))


;; We can take this idea further. The following snippet will ensure that Emacs (and thus Elfeed) defaults to opening Youtube links in mpv (or the video player of your choice), cutting the browser out of the loop entirely. 3

(setq browse-url-handlers
      '(("https:\\/\\/www\\.youtu\\.*be." . browse-url-mpv)
        ("." . browse-url-generic)))
(defun browse-url-mpv (url &optional single)
  (start-process "mpv" nil "mpv" (shell-quote-argument url)))

#+end_src

#+RESULTS:
: browse-url-mpv

* Applications and utilities

This section includes configurations for programs like email clients,
news reader, music players…  Anything you would normally see in a
standalone application.  The end goal is to eventually integrate every
aspect of my computing inside of Emacs.
** DONE red shift
CLOSED: [2022-03-30 Wed 00:03]
#+begin_src emacs-lisp
(setq my/redshift-min 500)
(setq my/redshift-max 6000)
(setq my/redshift-step 250)
;; Since get-redshift is slow
(setq my/redshift-val-cache nil)
(defun my/set-redshift (redness brightness-percent)
  (interactive "nRedshift level: \nnBrightess percent: ")
  (let* ((safe-redness
          (cond ((< redness my/redshift-min) my/redshift-min)
                ((> redness my/redshift-max) my/redshift-max)
                (t redness)))
         (safe-brightness-percent
          (cond ((< brightness-percent 10) 10)
                ((> brightness-percent 100) 100)
                (t brightness-percent)))
         (redshift-command (format "redshift -P -O %s -b %s" safe-redness (/ safe-brightness-percent 100.0))))
    (message redshift-command)
    (save-window-excursion
      (shell-command redshift-command nil nil))))

#+end_src

#+RESULTS:
: my/set-redshift

** Exercism
Exercism is a useful site for learning a programming language by performing
various exercises. You can opt to use either an in-browser editor or your own
via a local CLI.

Which do you think I want?

#+begin_src elisp :tangle packages.el
(package! exercism
  :recipe (:host github :repo "elken/exercism.el"))
#+end_src

#+RESULTS:
| exercism | :modules | ((:user) (:user . modules)) | :recipe | (:host github :repo elken/exercism.el) |

#+begin_src emacs-lisp :tangle yes
(load "~/.emacs.d/.local/straight/repos/exercism.el/exercism-modern.el")
#+end_src

#+RESULTS:
: t
** generate password

#+BEGIN_SRC emacs-lisp
  (defun generate-password-non-interactive ()
     (string-trim (shell-command-to-string "pwgen -A 24")))

  (defun generate-password ()
    "Generates and inserts a new password"
    (interactive)
    (insert
     (shell-command-to-string
      (concat "pwgen -A " (read-string "Length: " "24") " 1"))))
#+END_SRC

** Info pages
Slightly improve the look and feel of Info pages, might actually encourage me to /read/ them.

#+begin_src elisp :tangle packages.el
(package! info-colors :pin "2e237c301ba62f0e0286a27c1abe48c4c8441143")
#+end_src

#+begin_src emacs-lisp
(use-package! info-colors
  :commands (info-colors-fontify-node))

(add-hook 'Info-selection-hook 'info-colors-fontify-node)
#+end_src

** qutebrowser session save and restore
#+begin_src emacs-lisp :tangle yes
(require 'yaml)
(require 'cl-lib)

(defvar qbs/*qbs-db* "~/qb-session.org")
(defvar qbs/*qbs-source* "~/.local/share/qutebrowser/sessions/default.yml")
;; (defvar qbs/*qbs-source* "~/.local/share/qutebrowser/sessions/_autosave.yml")

(defun qbs/file<-string (s file)
  (with-temp-buffer
    (insert s)
    (write-region (point-min) (point-max) file t)))

(defun qbs/string<-file (file)
  (with-temp-buffer
    (insert-file-contents file)
    (buffer-string)))

(defun qbs/title-urls<-yaml-string (str)
  (let* ((ht (yaml-parse-string str))
         (tabs (ht-get (elt (ht-get ht 'windows) 0) 'tabs)))
    (seq-map (lambda (tab)
               `(:title ,(ht-get (elt (ht-get tab 'history) 0) 'title)
                 :url ,(ht-get (elt (ht-get tab 'history) 0) 'url)))
             tabs)))

(defun qbs/format-title-urls (data)
  (eval `(concat
          "\n"
          "* "
          ,(format-time-string "%Y%m%dT%H%M%S")
          "\n"
          ,@(cl-loop for entry in data
                     collect (format "- [[%s][%s]]\n"
                                     (cl-getf entry :url)
                                     (cl-getf entry :title)))
          "\n")))

(defun qbs/save-qb-session ()
  "Reads qb current default session and generate org-mode heading
with items."
  (interactive)
  (let ((max-lisp-eval-depth 10000))
    (qbs/file<-string
     (qbs/format-title-urls
      (qbs/title-urls<-yaml-string
       (qbs/string<-file qbs/*qbs-source*)))
     qbs/*qbs-db*)))

(defun qbs/restore-qb-session ()
  "Restore session for qutebrowser. Make sure to put cursor on
date heading that contains list of urls."
  (interactive)
  (save-excursion
    (beginning-of-line)
    (when (looking-at "^\\*")
      (forward-line 1)
      (while (looking-at "^[-+][ ]+")
        (progn (end-of-line)
               (backward-char)
               (org-open-at-point))
        (forward-line 1)))))

(provide 'qbs)
#+end_src

#+RESULTS:
: qbs
** Mini-buffer editing more space
Sometimes you want to be able to do fancy things with the text that you're entering into the minibuffer. Sometimes you just want to be able to read it, especially when it comes to lots of text. This binds C-M-e in a minibuffer) so that you can edit the contents of the minibuffer before submitting it.
#+begin_src emacs-lisp :tangle packages.el
(package! miniedit)
#+end_src
#+begin_src emacs-lisp
(use-package miniedit
  :commands minibuffer-edit
  :init (miniedit-install))
#+end_src
** Copy filename to clipboard
#+begin_src emacs-lisp
(defun my/copy-file-name-to-clipboard ()
  "Copy the current buffer file name to the clipboard."
  (interactive)
  (let ((filename (if (equal major-mode 'dired-mode)
                      default-directory
                    (buffer-file-name))))
    (when filename
      (kill-new filename)
      (message "Copied buffer file name '%s' to the clipboard." filename))))

#+end_src

#+RESULTS:
: my/copy-file-name-to-clipboard
** open current file with external program
#+begin_src emacs-lisp

(defun my/open-with (arg)
  "Open visited file in default external program.

      With a prefix ARG always prompt for command to use."
  (interactive "P")
  (when buffer-file-name
    (shell-command (concat
                    (cond
                     ((and (not arg) (eq system-type 'darwin)) "open")
                     ((and (not arg) (member system-type '(gnu gnu/linux gnu/kfreebsd))) "xdg-open")
                     (t (read-shell-command "Open current file with: ")))
                    " "
                    (shell-quote-argument buffer-file-name)))))
#+end_src

** Org Mode: Insert YouTube video with separate caption
#+begin_src emacs-lisp :tangle packages.el
(package! dash)
#+end_src
#+begin_src emacs-lisp
(require 'dash)

(defun my-msecs-to-timestamp (msecs)
  "Convert MSECS to string in the format HH:MM:SS.MS."
  (concat (format-seconds "%02h:%02m:%02s" (/ msecs 1000))
          "." (format "%03d" (mod msecs 1000))))

(defun my-org-insert-youtube-video-with-transcript (url)
  (interactive "MURL: ")
  (let* ((id (if (string-match "\\(?:v=\\|youtu\\.be/\\)\\([^&]+\\)" url) (match-string 1 url) url))
         (temp-file (make-temp-name "org-youtube-"))
         (temp-file-name (concat temp-file ".en.srv1"))
         data)
    (when (and (call-process "yt-dlp" nil nil nil
                             "--write-sub" "--write-auto-sub"  "--no-warnings" "--sub-lang" "en" "--skip-download" "--sub-format" "srv1"
                             "-o" temp-file
                             (format "https://youtube.com/watch?v=%s" id))
               (file-exists-p temp-file-name))
      (insert
       (format "#+begin_export html
<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/%s\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n#+end_export\n" id)
       "\n"
       (mapconcat (lambda (o)
                    (format "| [[https://youtube.com/watch?v=%s&t=%ss][%s]] | %s |\n"
                            id
                            (dom-attr o 'start)
                            (my-msecs-to-timestamp (* 1000 (string-to-number (dom-attr o 'start))))
                            (->> (dom-text o)
                                 (replace-regexp-in-string "[ \n]+" " ")
                                 (replace-regexp-in-string "&#39;" "'")
                                 (replace-regexp-in-string "&quot;" "\""))))
                  (dom-by-tag (xml-parse-file temp-file-name) 'text)
                  ""))
      (delete-file temp-file-name))))

#+end_src

#+RESULTS:
: my-org-insert-youtube-video-with-transcript
** org roam qutebrowser
#+begin_src emacs-lisp :tangle yes
(require 'org-roam-protocol)
(setq org-roam-capture-ref-templates
        '(("r" "ref" plain (function org-roam-capture--get-point)
           "%?"
           :file-name "${slug}"
           :head "#+TITLE: ${title}
#+ROAM_KEY: ${ref}"
           :unnarrowed t)))

#+end_src

#+RESULTS:
| r | ref | plain | #'org-roam-capture--get-point | %? | :file-name | ${slug} | :head | #+TITLE: ${title} |
**
#+begin_src python :tangle ~/.config/doom/org-roam-protocol-handler.py
import os
import sys
import urllib.parse

url   = urllib.parse.quote(sys.argv[1])
title = urllib.parse.quote(sys.argv[2])

command = "emacsclient \"org-protocol://roam-ref?template=r&ref="+url+"&title="+title+"\""
os.system(command)
#+end_src

** CLIPPY
Gives us a popup box with "Clippy, the paper clip". You can make him say various things by calling 'clippy-say' function.  But the more useful functions of clippy are the two describe functions provided: 'clippy-describe-function' and 'clippy-describe-variable'.  Hit the appropriate keybinding while the point is over a function/variable to call it.  A popup with helpful clippy will appear, telling you about the function/variable (using describe-function and describe-variable respectively).

| COMMAND                  | DESCRIPTION                           | KEYBINDING |
|--------------------------+---------------------------------------+------------|
| clippy-describe-function | /Clippy describes function under point/ | SPC c h f  |
| clippy-describe-variable | /Clippy describes variable under point/ | SPC c h v  |

#+begin_src emacs-lisp
(map! :leader
      (:prefix ("c h" . "Help info from Clippy")
       :desc "Clippy describes function under point" "f" #'clippy-describe-function
       :desc "Clippy describes variable under point" "v" #'clippy-describe-variable))

#+end_src

** DONE System Package Managment (Arch)
CLOSED: [2022-04-15 Fri 11:43]

This one is a pleasant surprise to have honestly. Having Emacs handle system packages as well as its own makes life a million times easier. Since I use yay on Arch, I configure an entry for it and use it if it’s installed.

#+begin_src emacs-lisp :tangle no
(require 'system-packages)
(use-package! system-packages
  :ensure t
  :defer t
  :init
  (when (executable-find "yay")
    ;; (pdumper-require 'system-packages)
    (add-to-list 'system-packages-supported-package-managers
                 '(yay .
                       ((default-sudo . nil)
                        (install . "yay -S")
                        (search . "yay -Ss")
                        (uninstall . "yay -Rs")
                        (update . "yay -Syu")
                        (clean-cache . "yay -Sc")
                        (log . "car /var/log/pacman.log")
                        (get-info . "yay -Qi")
                        (get-info-remote . "yay -Si")
                        (list-files-provided-by . "yay -Ql")
                        (verify-all-packages . "yay -Qkk")
                        (verify-all-dependencies . "yay -Dk")
                        (remove-orphaned . "yay -Rns $(yay -Qtdq)")
                        (list-installed-packages . "yay -Qe")
                        (list-installed-packages-all . "yay -Q")
                        (list-dependencies-of . "yay -Qi")
                        (noconfirm . "--noconfirm"))))
    (setq system-packages-use-sudo nil
          system-packages-package-manager 'yay))
  :custom (system-packages-noconfirm t)
  :bind (("C-c P i" . system-packages-install)
         ("C-c P e" . system-packages-ensure)
         ("C-c P u" . system-packages-update)
         ("C-c P r" . system-packages-uninstall)
         ("C-c P o" . system-packages-remove-orphaned)
         ("C-c P c" . system-packages-clean-cache)
         ("C-c P l" . system-packages-log)
         ("C-c P s" . system-packages-search)
         ("C-c P g" . system-packages-get-info)
         ("C-c P d" . system-packages-list-dependencies-of)
         ("C-c P f" . system-packages-list-files-provided-by)
         ("C-c P p" . system-packages-list-installed-packages)
         ("C-c P f" . system-packages-verify-all-dependencies)
         ("C-c P v" . system-packages-verify-all-packages)))

(setq system-packages-use-sudo t)
;; (setq system-packages-package-manager 'pacaur)
(setq system-packages-package-manager 'yay)
#+end_src

#+RESULTS:
: yay

** DONE System Package Managment void
CLOSED: [2022-04-15 Fri 11:43]

This one is a pleasant surprise to have honestly. Having Emacs handle system packages as well as its own makes life a million times easier. Since I use yay on Arch, I configure an entry for it and use it if it’s installed.

#+begin_src emacs-lisp
(require 'system-packages)
(use-package! system-packages
  :ensure t
  :defer t
  :init
  (when (executable-find "xbps-install")
    (add-to-list 'system-packages-supported-package-managers
                 '(xbps .
                       ((default-sudo . nil)
                        (install . "xbps-install -S")
                        (search . "xbps-query -Rs")
                        (uninstall . "xbps-remove -R")
                        (update . "xbps-install -S")
                        (upgrade . "xbps-install -Su")
                        (clean-cache . "xbps-remove -Ov")
                        (log . "car /var/log/pacman.log")
                        (remove-orphaned . "xbps-remove -ov")
                        (list-installed-packages . "xbps-query -l | awk '{ print $2 }' | xargs -n1 xbps-uhelper getpkgname >/home/shiva/myvoidpkgs.txt"))))

    (setq system-packages-use-sudo nil
          system-packages-package-manager 'xbps))
  :custom (system-packages-noconfirm nil)
  :bind (("C-c P i" . system-packages-install)
         ("C-c P u" . system-packages-update)
         ("C-c P r" . system-packages-uninstall)
         ("C-c P o" . system-packages-remove-orphaned)
         ("C-c P c" . system-packages-clean-cache)
         ("C-c P l" . system-packages-log)
         ("C-c P s" . system-packages-search)
         ("C-c P p" . system-packages-list-installed-packages)))

#+end_src

#+RESULTS:
: system-packages-list-installed-packages

** Custom extensions for "focus mode" (logos.el)

Also watch: [[https://protesilaos.com/codelog/2022-03-11-emacs-logos-demo/][Emacs: demonstration of logos.el]] (2022-03-11).

=logos= (or =logos.el=) is a new library of mine (as of 2022-03-02)
which provides a set of utilities for handling presentations and/or
focusing your attention on the current buffer's contents:
https://protesilaos.com/emacs/logos.  It supersedes the =prot-logos.el=
I had before and will soon be available via =M-x package-install=.

With all user options disabled (the out-of-the-box design), this package
provides a simple approach to handling presentations using nothing but
the =page-delimiter= together with some commands to move between pages
whether narrowing is in effect or not.

What constitutes a page delimiter is determined by the user options
=logos-outlines-are-pages= and =logos-outline-regexp-alist=.  By
default, this only corresponds to the =^L= character (which can be
inserted using the standard keys with =C-q C-l=).

Logos does not define any key bindings. Though I do so in the
configuration block further below.

Additionally, Logos provides some optional aesthetic tweaks which come
into effect when the buffer-local =logos-focus-mode= is enabled.  These
will hide the mode line (=logos-hide-mode-line=), enable
=scroll-lock-mode= (=logos-scroll-lock=), and use =variable-pitch-mode=
in non-programming buffers (=logos-variable-pitch=).  All these
variables are buffer-local.

To position the buffer in the center of the window, I install the
=olivetti= package by Paul W. Rankin.  =logos.el= does not need to
reinvent what already works well: all that is required is some glue code
to integrate the two packages.

"Logos" is the familiar word derived from Greek (watch my presentation
on philosophy about /Cosmos, Logos, and the living universe/:
https://protesilaos.com/books/2022-02-05-cosmos-logos-living-universe/),
though it also stands for these two perhaps equally insightful
backronyms about the mechanics of this package:

1. =^L= Only Generates Ostensible Slides
2. Logos Optionally Garners Outline Sections

Other potentially relevant parts of my dotemacs:

+ [[#h:1ae84fae-efc1-4bcc-9542-55b4ab8391a3][Paragraphs and fill-mode (prot-fill.el)]]
+ [[#h:e03b6415-a18f-4058-b9b0-5721d38c6c50][Font configurations (prot-fonts.el)]]

#+begin_src emacs-lisp :tangle yes
;;; Custom extensions for "focus mode" (logos.el)
(use-package! olivetti
  :config
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 80)
  (setq olivetti-recall-visual-line-mode-entry-state t))

(use-package! logos
  :config
  (setq logos-outlines-are-pages t)
  (setq logos-outline-regexp-alist
        `((emacs-lisp-mode . ,(format "\\(^;;;+ \\|%s\\)" logos--page-delimiter))
          (org-mode . ,(format "\\(^\\*+ +\\|^-\\{5\\}$\\|%s\\)" logos--page-delimiter))
          (t . ,(or outline-regexp logos--page-delimiter))))

  ;; These apply when `logos-focus-mode' is enabled.  Their value is
  ;; buffer-local.
  (setq-default logos-hide-mode-line t)
  (setq-default logos-scroll-lock nil)
  (setq-default logos-variable-pitch nil)
  (setq-default logos-buffer-read-only nil)
  (setq-default logos-olivetti t)

  (let ((map global-map))
    (define-key map [remap narrow-to-region] #'logos-narrow-dwim)
    (define-key map [remap forward-page] #'logos-forward-page-dwim)
    (define-key map [remap backward-page] #'logos-backward-page-dwim)
    ;; I don't think I ever saw a package bind M-] or M-[...
    (define-key map (kbd "M-]") #'logos-forward-page-dwim)
    (define-key map (kbd "M-[") #'logos-backward-page-dwim)
    (define-key map (kbd "<f9>") #'logos-focus-mode))

;;;; Extra tweaks
  ;; Read the logos manual: <https://protesilaos.com/emacs/logos>.

  ;; place point at the top when changing pages, but not in `prog-mode'
  (defun prot/logos--recenter-top ()
    "Use `recenter' to reposition the view at the top."
    (unless (derived-mode-p 'prog-mode)
      (recenter 1))) ; Use 0 for the absolute top

  (add-hook 'logos-page-motion-hook #'prot/logos--recenter-top))
#+end_src

#+RESULTS:
: t
** Auto git clone
#+begin_src emacs-lisp :tangle yes

;; Misc git functions
(use-package! emacs
  :config
  ;; From http://xenodium.com/emacs-clone-git-repo-from-clipboard/
  ;; Auto-git-clone url in clipboard
  (defun my/git-clone-clipboard-url ()
    "Clone git URL in clipboard asynchronously and open in dired when finished."
    (interactive)
    (cl-assert (or (string-match-p "^git@github.com" (current-kill 0))
                   (string-match-p "^git@.*\\.org" (current-kill 0))
                   (string-match-p "^\\(http\\|https\\|ssh\\)://" (current-kill 0)))
               nil
               "No URL in clipboard")
    (let* ((url (current-kill 0))
           (download-dir (expand-file-name "~/gitclones/"))
           (project-dir (concat (file-name-as-directory download-dir)
                                (file-name-base url)))
           (default-directory download-dir)
           (command (format "git clone %s" url))
           (buffer (generate-new-buffer (format "*%s*" command)))
           (proc))
      (when (file-exists-p project-dir)
        (if (y-or-n-p (format "%s exists. delete?" (file-name-base url)))
            (delete-directory project-dir t)
          (user-error "Bailed")))
      (switch-to-buffer buffer)
      (setq proc (start-process-shell-command
                  (shell-quote-argument (nth 0 (split-string command)))
                  buffer command))
      (with-current-buffer buffer
        (setq default-directory download-dir)
        (shell-command-save-pos-or-erase)
        (require 'shell)
        (shell-mode)
        (view-mode +1))
      (set-process-sentinel proc (lambda (process state)
                                   (let ((output (with-current-buffer (process-buffer process)
                                                   (buffer-string))))
                                     (kill-buffer (process-buffer process))
                                     (if (= (process-exit-status process) 0)
                                         (progn
                                           (message "finished: %s" command)
                                           (dired project-dir))
                                       (user-error (format "%s\n%s" command output))))))
      (set-process-filter proc #'comint-output-filter))))
#+end_src

#+RESULTS:
: t

** Games

Games
I also use Emacs to play games and do other fun things. Using swiper means I don’t need too many search functions bound, so I can bind the games prefix to C-c g without breaking too much of my workflow.
#+begin_src emacs-lisp
(global-unset-key (kbd "C-c g"))
;; Yahtzee
;; Fun dice game. Now I can get mad at Emacs instead of my sister.

(use-package! yahtzee
  ;; :ensure t
  :defer t
  :bind ("C-c g y" . yahtzee))
;; Sudoku
;; I love sudoku puzzles.

(use-package! sudoku
  ;; :ensure t
  :defer t
  :bind (("C-c g s" . sudoku)
  :map sudoku-mode-map
  ("j" . sudoku-move-point-down)
  ("J" . sudoku-move-point-downmost)
  ("k" . sudoku-move-point-up)
  ("K" . sudoku-move-point-upmost)
  ("h" . sudoku-move-point-left)
  ("H" . sudoku-move-point-leftmost)
  ("l" . sudoku-move-point-right)
  ("L" . sudoku-move-point-rightmost)

  ;; Start/quit/print game
  ("N" . sudoku)
  ("q" . sudoku-quit)
  ("Q" . sudoku-quit-immediately)
  ("P" . sudoku-print)

  ;; Undo/redo
  ("u"    . sudoku-undo)
  ("\C-r" . sudoku-redo)

  ;; Inserting values
  ("1" . sudoku-change-point)
  ("2" . sudoku-change-point)
  ("3" . sudoku-change-point)
  ("4" . sudoku-change-point)
  ("5" . sudoku-change-point)
  ("6" . sudoku-change-point)
  ("7" . sudoku-change-point)
  ("8" . sudoku-change-point)
  ("9" . sudoku-change-point)))
;; Tetris
;; Tetris is my childhood. No way I wouldn’t set it up to be nice and comfy.

(use-package! tetris
  :defer t
  :bind (("C-c g t" . 'tetris)
         :map tetris-mode-map
         ("J" . tetris-move-bottom)
         ("h" . tetris-move-left)
         ("j" . tetris-mode-down)
         ("l" . tetris-move-right)
         ([left] . tetris-rotate-next)
         ("r" . tetris-rotate-next)
         ([right] . tetris-rotate-prev)
         ("R" . tetris-rotate-prev)
         ([?\t] . tetris-pause-game)
         ("p" . tetris-pause-game)
         ("@" . tetris-start-game)
         ("Q" . tetris-end-game)))
  ;; Chess
  ;; Just for fun. I suck at chess but it’s nice to have.

  (use-package! chess
    ;; :ensure t
    :defer t
    :bind ("C-c g c" . chess))
  ;; 2048
  ;; A simple and fun game. Was a big deal when I was in high school. I still play it from time to time, to pass the time and remember my powers of 2.

  (use-package! 2048-game
    ;; :ensure t
    :defer t
    :bind (("C-c g 2" . 2048-game)
    :map 2048-mode-map
    ("j" . 2048-down)
    ("k" . 2048-up)
    ("h" . 2048-left)
    ("l" . 2048-right)))


  (use-package! pacmacs
    ;; :ensure t
    :defer t
    :bind (("C-c g p" . pacmacs)
    :map pacmacs-mode-map
    ("h" . pacmacs-left)
    ("j" . pacmacs-down)
    ("k" . pacmacs-up)
    ("l" . pacmacs-right)))
#+end_src

#+RESULTS:

** TODO tmr.el (TMR Must Recur)

Sometimes I need to set off a timer with a notification.  I used to rely
on a homegrown shell script for such a task, but where is the fun in
that?

This package of mine provides a single command for setting a timer: =tmr=.

The command prompts for a unit of time, which is represented as a string
that consists of a number and, optionally, a single character suffix
which specifies the unit of time.

Valid formats:

| Input | Meaning   |
|-------+-----------|
| 5     | 5 minutes |
| 5m    | 5 minutes |
| 5s    | 5 seconds |
| 5h    | 5 hours   |

If =tmr= is called with an optional prefix argument (=C-u=), it also asks
for a description which accompanies the given timer.  Preconfigured
candidates are specified in the user option =tmr-descriptions-list=,
though any arbitrary input is acceptable at the minibuffer prompt.

When the timer is set, a message is sent to the echo area recording the
current time and the point in the future when the timer elapses.  Echo
area messages can be reviewed with the =view-echo-area-messages= which is
bound to =C-h e= by default.

Once the timer runs its course, it produces a desktop notification and
plays an alarm sound.  The notification's message is practically the
same as that which is sent to the echo area.  The sound file for the
alarm is defined in =tmr-sound-file=, while the urgency of the
notification can be set through the =tmr-notification-urgency= option.

The =tmr-cancel= command cancels the last =tmr=.  Note that for the time
being it has no notion of multiple timers---just the last one.

#+begin_src emacs-lisp
;;; TMR Must Recur (just my generic timer)
(use-package! tmr
:config
  (setq tmr-sound-file
        "~/.config/doom/NotificationSound.opus")
  (setq tmr-notification-urgency 'normal)
  (setq tmr-descriptions-list (list "Boil water" "Prepare tea" "Bake bread"))
  (let ((map global-map))
    (define-key map (kbd "C-c n t") #'tmr)
    (define-key map (kbd "C-c n c") #'tmr-cancel)))
#+end_src

#+RESULTS:
: t

** Smerge

For repeated operations, a hydra would be helpful. But I prefer transient.
#+begin_src emacs-lisp
(defun smerge-repeatedly ()
  "Perform smerge actions again and again"
  (interactive)
  (smerge-mode 1)
  (smerge-transient))
(after! transient
  (transient-define-prefix smerge-transient ()
    [["Move"
      ("n" "next" (lambda () (interactive) (ignore-errors (smerge-next)) (smerge-repeatedly)))
      ("p" "previous" (lambda () (interactive) (ignore-errors (smerge-prev)) (smerge-repeatedly)))]
     ["Keep"
      ("b" "base" (lambda () (interactive) (ignore-errors (smerge-keep-base)) (smerge-repeatedly)))
      ("u" "upper" (lambda () (interactive) (ignore-errors (smerge-keep-upper)) (smerge-repeatedly)))
      ("l" "lower" (lambda () (interactive) (ignore-errors (smerge-keep-lower)) (smerge-repeatedly)))
      ("a" "all" (lambda () (interactive) (ignore-errors (smerge-keep-all)) (smerge-repeatedly)))
      ("RET" "current" (lambda () (interactive) (ignore-errors (smerge-keep-current)) (smerge-repeatedly)))]
     ["Diff"
      ("<" "upper/base" (lambda () (interactive) (ignore-errors (smerge-diff-base-upper)) (smerge-repeatedly)))
      ("=" "upper/lower" (lambda () (interactive) (ignore-errors (smerge-diff-upper-lower)) (smerge-repeatedly)))
      (">" "base/lower" (lambda () (interactive) (ignore-errors (smerge-diff-base-lower)) (smerge-repeatedly)))
      ("R" "refine" (lambda () (interactive) (ignore-errors (smerge-refine)) (smerge-repeatedly)))
      ("E" "ediff" (lambda () (interactive) (ignore-errors (smerge-ediff)) (smerge-repeatedly)))]
     ["Other"
      ("c" "combine" (lambda () (interactive) (ignore-errors (smerge-combine-with-next)) (smerge-repeatedly)))
      ("r" "resolve" (lambda () (interactive) (ignore-errors (smerge-resolve)) (smerge-repeatedly)))
      ("k" "kill current" (lambda () (interactive) (ignore-errors (smerge-kill-current)) (smerge-repeatedly)))
      ("q" "quit" (lambda () (interactive) (smerge-auto-leave)))]]))
#+end_src

#+RESULTS:
| [1 transient-columns nil ([1 transient-column (:description Move) ((1 transient-suffix (:key n :description next :command transient:smerge-transient:next)) (1 transient-suffix (:key p :description previous :command transient:smerge-transient:previous)))] [1 transient-column (:description Keep) ((1 transient-suffix (:key b :description base :command transient:smerge-transient:base)) (1 transient-suffix (:key u :description upper :command transient:smerge-transient:upper)) (1 transient-suffix (:key l :description lower :command transient:smerge-transient:lower)) (1 transient-suffix (:key a :description all :command transient:smerge-transient:all)) (1 transient-suffix (:key RET :description current :command transient:smerge-transient:current)))] [1 transient-column (:description Diff) ((1 transient-suffix (:key < :description upper/base :command transient:smerge-transient:upper/base)) (1 transient-suffix (:key = :description upper/lower :command transient:smerge-transient:upper/lower)) (1 transient-suffix (:key > :description base/lower :command transient:smerge-transient:base/lower)) (1 transient-suffix (:key R :description refine :command transient:smerge-transient:refine)) (1 transient-suffix (:key E :description ediff :command transient:smerge-transient:ediff)))] [1 transient-column (:description Other) ((1 transient-suffix (:key c :description combine :command transient:smerge-transient:combine)) (1 transient-suffix (:key r :description resolve :command transient:smerge-transient:resolve)) (1 transient-suffix (:key k :description kill current :command transient:smerge-transient:kill current)) (1 transient-suffix (:key q :description quit :command transient:smerge-transient:quit)))])] |

** Projectile
#+begin_quote
From the =:core packages= module.
#+end_quote

Looking at documentation via =SPC h f= and =SPC h v= and looking at the source can
add package src directories to projectile. This isn't desirable in my opinion.
#+begin_src emacs-lisp
(setq projectile-ignored-projects '("~/" "/tmp" "~/.emacs.d/.local/straight/repos/"))
(defun projectile-ignored-project-function (filepath)
  "Return t if FILEPATH is within any of `projectile-ignored-projects'"
  (or (mapcar (lambda (p) (s-starts-with-p p filepath)) projectile-ignored-projects)))
#+end_src

#+RESULTS:
: projectile-ignored-project-function

** CALENDAR
Let's make a 12-month calendar available so we can have a calendar app that, when we click on time/date in xmobar, we get a nice 12-month calendar to view.

This is a modification of: http://homepage3.nifty.com/oatu/emacs/calendar.html
See also: https://stackoverflow.com/questions/9547912/emacs-calendar-show-more-than-3-months

#+begin_src emacs-lisp
;; https://stackoverflow.com/questions/9547912/emacs-calendar-show-more-than-3-months
(defun dt/year-calendar (&optional year)
  (interactive)
  (require 'calendar)
  (let* (
      (current-year (number-to-string (nth 5 (decode-time (current-time)))))
      (month 0)
      (year (if year year (string-to-number (format-time-string "%Y" (current-time))))))
    (switch-to-buffer (get-buffer-create calendar-buffer))
    (when (not (eq major-mode 'calendar-mode))
      (calendar-mode))
    (setq displayed-month month)
    (setq displayed-year year)
    (setq buffer-read-only nil)
    (erase-buffer)
    ;; horizontal rows
    (dotimes (j 4)
      ;; vertical columns
      (dotimes (i 3)
        (calendar-generate-month
          (setq month (+ month 1))
          year
          ;; indentation / spacing between months
          (+ 5 (* 25 i))))
      (goto-char (point-max))
      (insert (make-string (- 10 (count-lines (point-min) (point-max))) ?\n))
      (widen)
      (goto-char (point-max))
      (narrow-to-region (point-max) (point-max)))
    (widen)
    (goto-char (point-min))
    (setq buffer-read-only t)))

(defun dt/scroll-year-calendar-forward (&optional arg event)
  "Scroll the yearly calendar by year in a forward direction."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     last-nonmenu-event))
  (unless arg (setq arg 0))
  (save-selected-window
    (if (setq event (event-start event)) (select-window (posn-window event)))
    (unless (zerop arg)
      (let* (
              (year (+ displayed-year arg)))
        (dt/year-calendar year)))
    (goto-char (point-min))
    (run-hooks 'calendar-move-hook)))

(defun dt/scroll-year-calendar-backward (&optional arg event)
  "Scroll the yearly calendar by year in a backward direction."
  (interactive (list (prefix-numeric-value current-prefix-arg)
                     last-nonmenu-event))
  (dt/scroll-year-calendar-forward (- (or arg 1)) event))

(map! :leader
      :desc "Scroll year calendar backward" "<left>" #'dt/scroll-year-calendar-backward
      :desc "Scroll year calendar forward" "<right>" #'dt/scroll-year-calendar-forward)

(defalias 'year-calendar 'dt/year-calendar)
#+end_src

Let's also play around with calfw.
#+begin_src emacs-lisp
(use-package! calfw)
(use-package! calfw-org)
#+end_src

#+RESULTS:
: calfw-org

** Calendar and Diary (and prot-diary.el)

Relevant information for what you are about to read in this section
(the list will be updated accordingly):

+ [[https://protesilaos.com/codelog/2021-04-14-emacs-diary-calendar/][Video of Emacs Diary and Calendar for tracking appointments]] (2021-04-14).
+ [[https://protesilaos.com/codelog/2021-04-15-emacs-diary-outline-minor-mode/][Make the Emacs Diary work as an Outline (outline-minor-mode)]] (2021-04-15).
+ [[https://www.youtube.com/watch?v=n8o66i08fzs][Video on using Hyperbole with the Emacs Diary]] by the Emacs Elements
  channel (Raoul Comninos) (2021-04-16).

Emacs provides a suite of tools for planning events or recording dates
of interest in your life.  These are part of the same workflow, but are
divided into several smaller libraries.  The two main ones are
=diary-lib.el= and =calendar.el=.  I extend them with =prot-diary.el=, which
is reproduced at the end of this section, after the package
configurations.

=diary-lib.el= defines everything that pertains to the =diary-file=
(defaults to =~/.emacs.d/diary=, which is what I want).  The Diary has a
two-fold purpose: (i) to store entries about calendar events, and (ii)
to display such events for the given day or range thereof.

In the first case, the Diary functions as a regular buffer that you may
edit freely.  This is where you can write one-off or recurring events
using various date and time formats expressed in natural language or as
Elisp forms (a sexp or "symbolic expression").

When it comes to single events for a given day, I prefer to input them
on a whole line using the ISO 8601 standard and a 24-hour clock, like
this: =2021-04-13 15:00 Description of event=.

For multiple events that are clustered on the same day, I write the date
on its own line and below it place a description of each event
optionally preceded by a timestamp.  Entries with no timestamp come
first, followed by those that are time sensitive.  This is just a matter
of personal style.

In this scenario of grouped events under a given date, each entry below
the date has to start with at least one empty space, otherwise the Diary
will try to interpret them as two distinct expressions (the exact number
of spaces is a matter of preference).  So the format looks like this
(use =C-x TAB= (=indent-rigidly=) to incrementally adjust the indentation of
the active region, or =C-u C-x TAB= to increase by four spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

The following is also possible, but looks too busy for no good reason:

#+begin_example
2021-04-13 This event is not time sensitive
2021-04-13 06:30-09:00 Hiking
2021-04-13 10:00 Prepare sourdough bread
2021-04-13 11:00-13:00 Write stuff
#+end_example

Though not required, you can separate events by an empty line.  Keeps
things easy to read.  Remember that lines that contain at least one
space are thought to belong to the closest date entry above them.  Which
means that for multiple events on a given day you can use something like
this, if you need to (here dots represent empty spaces):

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
....
    10:00 Prepare sourdough bread
....
    11:00-13:00 Write stuff
#+end_example

Furthermore, it is possible to use nested levels of indentation or, in
my case, call =prot-simple-cite-region= and indent it accordingly (check
the source code: [[#h:ae48fe61-a3c3-4132-8986-785f9bfbeafb][Common custom functions (prot-simple.el)]]).  For
example:

#+begin_example
2021-04-13
    This event is not time sensitive
....
    06:30-09:00 Hiking
    +----[ Sample text ]
    | This is some random text
    | It relates to the above event
    +----
....
    10:00 Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

Remember that these are mere stylistic considerations.  I generally
prefer to keep things simple, though I appreciate the flexibility of
adapting the view of my evolving needs.

I prefer to defer all formatting related decisions until after I have
typed in all the information.  My =prot-diary-align-timestamped-entries=
lets me align the negative space between an entry's timestamp and its
description.  Consider the following block and suppose that the region
starts from the line below the date and ends at the end of the line with
the last entry (demarcated by the =|= characters).

#+begin_example
2021-04-13
|This event is not time sensitive
06:30-09:00 Hiking
10:00 Prepare sourdough bread
11:00-13:00 Write stuff|

...becomes...

2021-04-13
    This event is not time sensitive
    06:30-09:00 Hiking
    10:00       Prepare sourdough bread
    11:00-13:00 Write stuff
#+end_example

For anniversaries or cyclic events, I rely on Elisp.  It is better to
read the Emacs manual on the technicalities as there are lots of
examples that should help you get started.  Just bear in mind that the
exact order for the =YEAR=, =MONTH=, =DATE= arguments depends on the value
assigned to the variable =calendar-date-style=.  As I already noted, I
follow the ISO style (evaluate this: =(format-time-string "%F")=).

The second use case of the Diary, namely, of showing the events it holds
is controlled by the variable =diary-display-function=.  On my setup it
should present the information in a read-only buffer that is internally
referred to as the "fancy" style.  To bring up that interface, you can
either use the Calendar as a starting point (more on that later) or call
a command directly, such as =prot-diary-display-entries=.  The resulting
buffer is fairly straightforward: there is a date header (or many
depending on the prefix numeric argument) and below that one or more
entries related to it.  Those retain the indentation of the underlying
Diary file, as described above.  Hit =RET= over an entry to visit the
editable version of the Diary.

Apart from displaying that buffer on demand, it is possible to get its
information emailed to you.  The built-in command for that is
=diary-mail-days=, however it has the downside of sending a mail even when
there are no events for the day[s] specified.  I do not see the utility
of such behaviour: what is the purpose of drawing attention to my email
client, only to waste my time with some "nothing to see here" message?
Whereas =prot-diary-mail-entries= only sends a message when that is the
right thing to do, i.e. when there is something that requires our
attention (for N days or =diary-mail-days=).  It also has the benefit of
not popping up the Diary display in another window as a side effect of
sending the email (check =prot-diary--mail-fn= for the technicalities).  I
set it up to automatically try to send me an email briefing each morning
when I launch Emacs.

Email briefings just offer an overview of events in the immediate
future.  We still need a mechanism to alert us some minutes in advance
of a time sensitive appointment.  This is where the =appt.el= library
comes in handy.  It already knows how to scan the Diary in search for
time expressions and produce reminders for them: all it needs is to be
activated with =(appt-activate 1)=.  Unlike email, this is a more
persistent method of producing notifications inside of Emacs in the form
of a pop-up window and a complementary modeline indicator with a
countdown to the event.  The default notification time is specified in
the variable =appt-message-warning-time=, though individual Diary entries
can declare their own time (in minutes), by holding some extra text as
defined in =appt-warning-time-regexp=.  Put that in a comment
(=diary-comment-start=) to disambiguate it from the entry's description.
For example, this Diary entry will work as expected with my
configurations: =2021-04-13 18:00 Some task ;; appt 5=.  The =;; appt 5=
part will not be shown in the Diary display, but will still activate the
reminder.  Nice and simple!

To recapitulate, the Diary is flexible enough to accommodate a variety
of preferences on how to organise one's life events.  The key to get
started is to learn how to edit the actual file, which is fairly easy.
It then is trivial to either display that information on demand or be
notified about it.

Let us now cover the other major component of this suite of tools: the
Calendar.  The main point of entry is =M-x calendar=.  It displays a
horizontal three-month view centred on the current month.  Moving in the
calendar is consistent with regular Emacs motions: =C-f= and =C-b= move one
day forward/backward, =C-n= and =C-p= go down and up one week, =C-a= and =C-e=
place the point at the beginning or end of the week, respectively.  Then
we have the equivalent of paragraph and page motions: =M-{= and =M-}= which
travel forward/backward a full month, with =C-v= and =M-v= moving to the
next and previous three-month set.  To merely scroll the horizontal
calendar strip, use =<= and =>= to do so in the given direction.  As always,
do not forget to type =C-h m= (=describe-mode=) in any major-mode buffer you
are unfamiliar with to get help for it: you will learn about those
motions and some more of them (and always check the manual as well).

The Calendar offers an overview of your Diary entries, as noted above,
and, optionally, of all holidays that you have opted in to.  For the
latter, check the variable =calendar-holidays=.  I set it to only a small
set of records largely for experimental purposes, as I am not interested
in either religious or secular special days.  Consider this, if you
will, an attempt at introducing the illusion of eventfulness in my
calendar.  I really don't care about any of this.

To mark Diary entries in the Calendar, use =m= (=diary-mark-entries=).  That
accepts a prefix argument (=C-u=) in case you wish to redraw those marks.
Here we should clarify that "marks" are Emacs faces by default, unless
you explicitly override them with characters.  I prefer faces, which
leave a more pleasant, less noisy impression.  Similarly, use =x=
(=calendar-mark-holidays=) to mark holidays.  Both of those tasks can be
performed automatically upon accessing the Calendar, by setting the
variables =calendar-mark-diary-entries-flag=, =calendar-mark-holidays-flag=
to non-nil values (which is what I do).

Events that should not appear in the Calendar when Diary entries are
marked must be preceded with a special character, which is configurable
by means of =diary-nonmarking-symbol=.  I personally have no use for this,
because if something is not worth being marked, then it is not pointless
to keep track of it in my day-to-day planner.

While in the Calendar, you can move the point over a marked day and type
=d= (=diary-view-entries=) to show the read-only variant of the Diary, as
outlined above.  Or pass a number to it to encompass the Nth days
(e.g. typing =7 d= will show Diary entries for seven days starting from
the current one).  If the mark pertains to a holiday, type =h= to get a
message in the echo area about it (=calendar-cursor-holidays=).

If you opt to use my settings, the best way to learn how to disambiguate
the two marks is to access the Calendar and hit =u= (=calendar-unmark=).
Follow it up with =m= to mark Diary entries and =x= to render holiday marks.

Other than viewing what happens on a given day or date range, you can
use the Calendar to record new entries in the Diary.  I group those
under the =i= prefix key: so type, =i= and then =C-h= to get help about all
possible keys that complete that sequence and references to the commands
they call.  Note that to insert a block event you need to hit =C-SPC= on
the starting date and then move point to the ending day at which you
should do =i b= (=diary-insert-block-entry=).

It is possible to use more faces than the ones which are provided by
default.  To do so, you need to specify a face argument to the various
Elisp expressions that can be written to the Diary.  For example, my
=prot-diary.el= (reproduced further below) has a bespoke face for
"administrative tasks", which can be assigned to the given expression
like this (new line and indentation are optional, as mentioned above,
otherwise keep everything on one line):

#+begin_example
 %%(diary-date t t 13 'prot-diary-calendar-administrative-mark)
     Some administrative monthly task
 %%(diary-anniversary 1900 4 13 'prot-diary-calendar-anniversary-mark)
     Some anniversary is %d years
#+end_example

The manual covers a lot of other potentially useful tasks you may
accomplish with those tools.  For example, it is possible to import an
iCalendar, convert from one calendar to another (e.g. Gregorian to
Chinese), get the phases of the moon, sunset and sunrise times in the
given geographic coordinates...  Evaluate this expression to start
reading the relevant Info nodes: =(info "(emacs) Calendar/Diary")=.

For the integration with =outline-minor-mode= that =prot-diary.el= provides,
refer to the relevant section (in short: you get header folding like in
Org for every line that starts with =;;;=, given my =diary-comment-start= is
=;;=): [[#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1][Outline mode, outline minor mode (prot-outline.el)]].

Finally, note that I control the placement of those buffers in the
=display-buffer-alist= (read: [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks]]).

#+begin_src emacs-lisp :tangle yes
;;; Calendar and Diary (and prot-diary.el)
(use-package! calendar
  :config
;; (prot-emacs-builtin-package 'calendar
  (setq calendar-mark-diary-entries-flag t)
  (setq calendar-mark-holidays-flag t)
  (setq calendar-mode-line-format nil)
  (setq calendar-time-display-form
        '(24-hours ":" minutes
                   (when time-zone
                     (format "(%s)" time-zone))))
  (setq calendar-week-start-day 1)      ; Monday
  (setq calendar-date-style 'iso)
  (setq calendar-date-display-form calendar-iso-date-display-form)
  (setq calendar-time-zone-style 'numeric) ; Emacs 28.1

  (require 'solar)
  (setq calendar-latitude 35.17         ; Not my actual coordinates
        calendar-longitude 33.36)

  (require 'cal-dst)
  (setq calendar-standard-time-zone-name "+0200")
  (setq calendar-daylight-time-zone-name "+0300")

  (require 'diary-lib)
  (setq diary-mail-addr user-mail-address)
  (setq diary-date-forms diary-iso-date-forms)
  (setq diary-comment-start ";;")
  (setq diary-comment-end "")
  (setq diary-nonmarking-symbol "!")
  (setq diary-show-holidays-flag t)
  (setq diary-display-function #'diary-fancy-display) ; better than its alternative
  (setq diary-header-line-format nil)
  (setq diary-list-include-blanks nil)
  (setq diary-number-of-entries 2)
  (setq diary-mail-days 2)
  (setq diary-abbreviated-year-flag nil)

  (add-hook 'calendar-today-visible-hook #'calendar-mark-today)
  (add-hook 'diary-list-entries-hook 'diary-sort-entries t)
  (add-hook 'diary-mode-hook #'goto-address-mode) ; buttonise plain text links

  ;; Those presuppose (setq diary-display-function #'diary-fancy-display)
  (add-hook 'diary-list-entries-hook 'diary-include-other-diary-files)
  (add-hook 'diary-mark-entries-hook 'diary-mark-included-diary-files)

  ;; Prevent Org from interfering with my key bindings.
  (remove-hook 'calendar-mode-hook #'org--setup-calendar-bindings)

  (let ((map calendar-mode-map))
    (define-key map (kbd "s") #'calendar-sunrise-sunset)
    (define-key map (kbd "l") #'lunar-phases)
    (define-key map (kbd "i") nil) ; Org sets this, much to my chagrin (see `remove-hook' above)
    (define-key map (kbd "i a") #'diary-insert-anniversary-entry)
    (define-key map (kbd "i b") #'diary-insert-block-entry)
    (define-key map (kbd "i c") #'diary-insert-cyclic-entry)
    (define-key map (kbd "i d") #'diary-insert-entry) ; for current "day"
    (define-key map (kbd "i i") #'diary-insert-entry) ; most common action, easier to type
    (define-key map (kbd "i m") #'diary-insert-monthly-entry)
    (define-key map (kbd "i w") #'diary-insert-weekly-entry)
    (define-key map (kbd "i y") #'diary-insert-yearly-entry)
    (define-key map (kbd "M-n") #'calendar-forward-month)
    (define-key map (kbd "M-p") #'calendar-backward-month)))

(use-package! appt
  :config
  (setq appt-display-diary nil)
  (setq appt-disp-window-function #'appt-disp-window)
  (setq appt-display-mode-line t)
  (setq appt-display-interval 3)
  (setq appt-audible nil)
  (setq appt-warning-time-regexp "appt \\([0-9]+\\)")
  (setq appt-message-warning-time 6)

  (run-at-time 10 nil #'appt-activate 1))

(load "prot-diary")
(use-package! appt
  :config
  ;; The idea is to get a reminder via email when I launch Emacs in the
  ;; morning and this file is evaluated.  Obviously this is not a super
  ;; sophisticated approach, though I do not need one.
  (let ((time (string-to-number (format-time-string "%H"))))
    (when (and (> time 4) (< time 9))
      (run-at-time (* 60 5) nil #'prot-diary-mail-entries)))

  (require 'holidays)
  (setq calendar-holidays (append holiday-solar-holidays prot-diary-local-holidays))

  (with-eval-after-load 'prot-outline
    (add-hook 'diary-mode-hook #'prot-outline-minor-mode-safe))

  (let ((map diary-mode-map))
    (define-key map (kbd "<M-return>") #'prot-diary-newline-indent)
    (define-key map (kbd "M-n") #'prot-diary-heading-next)
    (define-key map (kbd "M-p") #'prot-diary-heading-previous)
    (define-key map (kbd "C-c C-a") #'prot-diary-align-timestamped-entries))


  (define-prefix-command 'prot-diary-map)
  (define-key global-map (kbd "C-c d") 'prot-diary-map)
  (let ((map global-map))
    (define-key map (kbd "C-c d c") #'calendar)
    (define-key map (kbd "C-c d d") #'prot-diary-display-entries)
    (define-key map (kbd "C-c d e") #'prot-diary-edit-diary)
    (define-key map (kbd "C-c d i") #'prot-diary-insert-entry)
    (define-key map (kbd "C-c d m") #'prot-diary-mail-entries)))

#+end_src

#+RESULTS:
: t

** Screenshot

This makes it a breeze to take lovely screenshots.
#+begin_src emacs-lisp :tangle packages.el
(package! screenshot :recipe (:host github :repo"tecosaur/screenshot" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+RESULTS:
| screenshot | :modules | ((:private . config) (:private . modules)) | :recipe | (:host github :repo tecosaur/screenshot :files (*.el filters preprocessors)) |


Some light configuring is all we need, so we can make use of the [[https://github.com/Calinou/0x0][0x0]] wrapper
file uploading script (which I've renamed to ~upload~).
#+begin_src emacs-lisp
(use-package! screenshot
  :defer t
  :config (setq screenshot-upload-fn "upload %s 2>/dev/null"))
#+end_src

#+RESULTS:
: t

** Dictionary

Doom already loads =define-word=, and provides it's own definition service using
[[https://github.com/gromnitsky/wordnut][wordnut]]. However, using an offline dictionary possess a few compelling
advantages, namely:
+ speed
+ integration of multiple dictionaries
[[http://goldendict.org/][GoldenDict]] seems like the best option currently available, but lacks a CLI.
Hence, we'll fall back to [[https://dushistov.github.io/sdcv/][sdcv]] (a CLI version of StarDict) for now.
To interface with this, we'll use a my =lexic= package.


#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "packages.el" "no")
(package! lexic :recipe (:host github :repo"tecosaur/lexic" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+RESULTS:
| lexic | :modules | ((:user) (:user . modules)) | :recipe | (:host github :repo tecosaur/lexic :files (*.el filters preprocessors)) |

Given that a request for a CLI is the [[https://github.com/goldendict/goldendict/issues/37][most upvoted issue]] on GitHub for
GoldenDict, it's likely we'll be able to switch from ~sdcv~ to that in the future.

Since GoldenDict supports StarDict files, I expect this will be a relatively
painless switch.

We start off by loading =lexic=, then we'll integrate it into pre-existing
definition functionality (like ~+lookup/dictionary-definition~).
#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "yes" "no")
(use-package! lexic
  :commands lexic-search lexic-list-dictionary
  :config
  (map! :map lexic-mode-map
        :n "q" #'lexic-return-from-lexic
        :nv "RET" #'lexic-search-word-at-point
        :n "a" #'outline-show-all
        :n "h" (cmd! (outline-hide-sublevels 3))
        :n "o" #'lexic-toggle-entry
        :n "n" #'lexic-next-entry
        :n "N" (cmd! (lexic-next-entry t))
        :n "p" #'lexic-previous-entry
        :n "P" (cmd! (lexic-previous-entry t))
        :n "E" (cmd! (lexic-return-from-lexic) ; expand
                     (switch-to-buffer (lexic-get-buffer)))
        :n "M" (cmd! (lexic-return-from-lexic) ; minimise
                     (lexic-goto-lexic))
        :n "C-p" #'lexic-search-history-backwards
        :n "C-n" #'lexic-search-history-forwards
        :n "/" (cmd! (call-interactively #'lexic-search))))
#+end_src

#+RESULTS:

Now let's use this instead of wordnet.
#+begin_src emacs-lisp :tangle (if (executable-find "sdcv") "yes" "no")
(defadvice! +lookup/dictionary-definition-lexic (identifier &optional arg)
  "Look up the definition of the word at point (or selection) using `lexic-search'."
  :override #'+lookup/dictionary-definition
  (interactive
   (list (or (doom-thing-at-point-or-region 'word)
             (read-string "Look up in dictionary: "))
         current-prefix-arg))
  (lexic-search identifier nil nil t))
#+end_src

#+RESULTS:

Lastly, I want to make sure I have some dictionaries set up. I've put a tarball
of dictionaries online which we can download if none seem to be present on the
system.
#+begin_src shell :tangle (if (and (executable-find "sdsv") (not (file-exists-p (concat (or (getenv "STARDICT_DATA_DIR") (concat (or "~/.local/share" (getenv "XDG_DATA_HOME")) "/stardict")) "/dic")))) "setup.sh" "no")
DIC_FOLDER=${STARDICT_DATA_DIR:-${XDG_DATA_HOME:-$HOME/.local/share}/stardict}/dic
if [ ! -d "$DIC_FOLDER" ]; then
    TMP="$(mktemp -d /tmp/dict-XXX)"
    cd "$TMP"
    curl -A "Mozilla/4.0" -o "stardict.tar.gz" "https://tecosaur.com/resources/config/stardict.tar.gz"
    tar -xf "stardict.tar.gz"
    rm "stardict.tar.gz"
    mkdir -p "$DIC_FOLDER"
    mv * "$DIC_FOLDER"
fi
#+end_src

** Ebooks

For managing my ebooks, I'll hook into the well-established ebook library
manager [[https://calibre-ebook.com/][calibre]]. A number of Emacs clients for this exist, but this seems like a
good option.

Then for reading them, the only currently viable options seems to be [[https://depp.brause.cc/nov.el/][nov.el]].
#+begin_src emacs-lisp :tangle packages.el
 ;; (package! calibredb :pin "cb93563d0ec9e0c653210bc574f9546d1e7db437")
 (package! calibredb)
#+end_src

PS: If sqlite3 and calibredb is in not in your system path, set them with

#+begin_src emacs-lisp :tangle packages.el
(package! nov :pin "cb5f45cbcfbcf263cdeb2d263eb15edefc8b07cb")
#+end_src

#+begin_src emacs-lisp

(setq sql-sqlite-program "/usr/bin/sqlite3")
(setq calibredb-program "/usr/bin/calibredb")

(setq calibredb-library-alist '(("~/Documents/EBooks Library")
                                  ("~/Documents/LIB1")))
#+end_src

#+RESULTS:
| ~/Documents/EBooks Library |
| ~/Documents/LIB1           |

Together these should give me a rather good experience reading ebooks.

Virtual libraries are some convenient shortcuts for quick filtering the Ebooks by setting the calibredb-search-filter.
#+begin_src emacs-lisp
(setq calibredb-virtual-library-alist '(("1. Development - work" . "work \\(pdf\\|epub\\)")
                                        ("2. Read it later" . "Readit epub")
                                        ("3. Development - rust" . "rust")))
#+end_src
=calibredb= lets us use calibre through Emacs, because who wouldn't want to use
something through Emacs?
#+begin_src emacs-lisp

(use-package! calibredb
  :commands calibredb
  :config
  (setq calibredb-root-dir "~/Documents/Ebooks/"
        calibredb-db-dir (expand-file-name "metadata.db" calibredb-root-dir))
  (map! :map calibredb-show-mode-map
        :ne "?" #'calibredb-entry-dispatch
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "q" #'calibredb-entry-quit
        :ne "." #'calibredb-dired-open
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments)
  (map! :map calibredb-search-mode-map
        :ne [mouse-3] #'calibredb-search-mouse
        :ne "RET" #'calibredb-find-file
        :ne "?" #'calibredb-dispatch
        :ne "a" #'calibredb-add
        :ne "A" #'calibredb-add-dir
        :ne "c" #'calibredb-clone
        :ne "d" #'calibredb-remove
        :ne "D" #'calibredb-remove-marked-items
        :ne "j" #'calibredb-next-entry
        :ne "k" #'calibredb-previous-entry
        :ne "l" #'calibredb-virtual-library-list
        :ne "L" #'calibredb-library-list
        :ne "n" #'calibredb-virtual-library-next
        :ne "N" #'calibredb-library-next
        :ne "p" #'calibredb-virtual-library-previous
        :ne "P" #'calibredb-library-previous
        :ne "s" #'calibredb-set-metadata-dispatch
        :ne "S" #'calibredb-switch-library
        :ne "o" #'calibredb-find-file
        :ne "O" #'calibredb-find-file-other-frame
        :ne "v" #'calibredb-view
        :ne "V" #'calibredb-open-file-with-default-tool
        :ne "." #'calibredb-dired-open
        :ne "b" #'calibredb-catalog-bib-dispatch
        :ne "e" #'calibredb-export-dispatch
        :ne "r" #'calibredb-search-refresh-and-clear-filter
        :ne "R" #'calibredb-search-clear-filter
        :ne "q" #'calibredb-search-quit
        :ne "m" #'calibredb-mark-and-forward
        :ne "f" #'calibredb-toggle-favorite-at-point
        :ne "x" #'calibredb-toggle-archive-at-point
        :ne "h" #'calibredb-toggle-highlight-at-point
        :ne "u" #'calibredb-unmark-and-forward
        :ne "i" #'calibredb-edit-annotation
        :ne "DEL" #'calibredb-unmark-and-backward
        :ne [backtab] #'calibredb-toggle-view
        :ne [tab] #'calibredb-toggle-view-at-point
        :ne "M-n" #'calibredb-show-next-entry
        :ne "M-p" #'calibredb-show-previous-entry
        :ne "/" #'calibredb-search-live-filter
        :ne "M-t" #'calibredb-set-metadata--tags
        :ne "M-a" #'calibredb-set-metadata--author_sort
        :ne "M-A" #'calibredb-set-metadata--authors
        :ne "M-T" #'calibredb-set-metadata--title
        :ne "M-c" #'calibredb-set-metadata--comments))
#+end_src

#+RESULTS:
: t

Then, to actually read the ebooks we use =nov=.

#+begin_src emacs-lisp
(use-package! nov
  :mode ("\\.epub\\'" . nov-mode)
  :config
  (map! :map nov-mode-map
        :n "RET" #'nov-scroll-up)

  (defun doom-modeline-segment--nov-info ()
    (concat
     " "
     (propertize
      (cdr (assoc 'creator nov-metadata))
      'face 'doom-modeline-project-parent-dir)
     " "
     (cdr (assoc 'title nov-metadata))
     " "
     (propertize
      (format "%d/%d"
              (1+ nov-documents-index)
              (length nov-documents))
      'face 'doom-modeline-info)))

  (advice-add 'nov-render-title :override #'ignore)

  (defun +nov-mode-setup ()
    "Tweak nov-mode to our liking."
    (face-remap-add-relative 'variable-pitch
                             :family "Merriweather"
                             :height 1.4
                             :width 'semi-expanded)
    (face-remap-add-relative 'default :height 1.3)
    (setq-local line-spacing 0.2
                next-screen-context-lines 4
                shr-use-colors nil)
    (require 'visual-fill-column nil t)
    (setq-local visual-fill-column-center-text t
                visual-fill-column-width 81
                nov-text-width 80)
    (visual-fill-column-mode 1)
    (hl-line-mode -1)
    ;; Re-render with new display settings
    (nov-render-document)
    ;; Look up words with the dictionary.
    (add-to-list '+lookup-definition-functions #'+lookup/dictionary-definition)
    ;; Customise the mode-line to make it more minimal and relevant.
    (setq-local
     mode-line-format
     `((:eval
        (doom-modeline-segment--workspace-name))
       (:eval
        (doom-modeline-segment--window-number))
       (:eval
        (doom-modeline-segment--nov-info))
       ,(propertize
         " %P "
         'face 'doom-modeline-buffer-minor-mode)
       ,(propertize
         " "
         'face (if (doom-modeline--active) 'mode-line 'mode-line-inactive)
         'display `((space
                     :align-to
                     (- (+ right right-fringe right-margin)
                        ,(* (let ((width (doom-modeline--font-width)))
                              (or (and (= width 1) 1)
                                  (/ width (frame-char-width) 1.0)))
                            (string-width
                             (format-mode-line (cons "" '(:eval (doom-modeline-segment--major-mode))))))))))
       (:eval (doom-modeline-segment--major-mode)))))

  (add-hook 'nov-mode-hook #'+nov-mode-setup))
#+end_src

#+RESULTS:
: ((\.odc\' . archive-mode) (\.odf\' . archive-mode) (\.odi\' . archive-mode) (\.otp\' . archive-mode) (\.odp\' . archive-mode) (\.otg\' . archive-mode) (\.odg\' . archive-mode) (\.ots\' . archive-mode) (\.ods\' . archive-mode) (\.odm\' . archive-mode) (\.ott\' . archive-mode) (\.odt\' . archive-mode) (\.epub\' . nov-mode) (\.[pP][dD][fF]\' . pdf-view-mode) (authinfo.gpg\' . authinfo-color-mode) (/bspwmrc\' . sh-mode) (\.\(?:zunit\|env\)\' . sh-mode) (\.bats\' . sh-mode) (/README\(?:\.md\)?\' . gfm-mode) (\.Cask\' . emacs-lisp-mode) (\.pdf\' . pdf-view-mode) (\(?:\(?:\.\(?:b\(?:\(?:abel\|ower\)rc\)\|json\(?:ld\)?\)\|composer\.lock\)\'\) . json-mode) (\.kbd\' . kbd-mode) (\.pgn\' . chess-pgn-mode) (/systemd/[^z-a]+?\.d/[^/]+?\.conf\' . systemd-mode) (\.#\(?:[.0-9@-Z\_a-z-]+?\.\(?:automount\|busname\|link\|mount\|net\(?:dev\|work\)\|s\(?:ervice\|lice\|ocket\|wap\)\|t\(?:arget\|imer\)\)\|override\.conf\)[[:xdigit:]]\{16\}\' . systemd-mode) ([.0-9@-Z\_a-z-]+?\.\(?:automount\|busname\|link\|mount\|net\(?:dev\|work\)\|s\(?:ervice\|lice\|ocket\|wap\)\|t\(?:arget\|imer\)\)\' . systemd-mode) (\.nspawn\' . systemd-mode) (\.\(?:md\|markdown\|mkd\|mdown\|mkdn\|mdwn\)\' . markdown-mode) (\.hsc\' . haskell-mode) (\.l[gh]s\' . haskell-literate-mode) (\.hsig\' . haskell-mode) (\.[gh]s\' . haskell-mode) (\.cabal\'\|/cabal\.project\|/\.cabal/config\' . haskell-cabal-mode) (\.chs\' . haskell-c2hs-mode) (\.ghci\' . ghci-script-mode) (\.dump-simpl\' . ghc-core-mode) (\.hcr\' . ghc-core-mode) (/git-rebase-todo\' . git-rebase-mode) (\.dockerfile\' . dockerfile-mode) (/Dockerfile\(?:\.[^/\]*\)?\' . dockerfile-mode) (/git/ignore\' . gitignore-mode) (/info/exclude\' . gitignore-mode) (/\.gitignore\' . gitignore-mode) (/etc/gitconfig\' . gitconfig-mode) (/\.gitmodules\' . gitconfig-mode) (/git/config\' . gitconfig-mode) (/modules/.*/config\' . gitconfig-mode) (/\.git/config\' . gitconfig-mode) (/\.gitconfig\' . gitconfig-mode) (/git/attributes\' . gitattributes-mode) (/info/attributes\' . gitattributes-mode) (/\.gitattributes\' . gitattributes-mode) (\.gpg\(~\|\.~[0-9]+~\)?\' nil epa-file) (\.elc\' . elisp-byte-code-mode) (\.vr[hi]?\' . vera-mode) (\(?:\.\(?:rbw?\|ru\|rake\|thor\|jbuilder\|rabl\|gemspec\|podspec\)\|/\(?:Gem\|Rake\|Cap\|Thor\|Puppet\|Berks\|Brew\|Vagrant\|Guard\|Pod\)file\)\' . ruby-mode) (\.re?st\' . rst-mode) (\.py[iw]?\' . python-mode) (\.m\' . octave-maybe-mode) (\.less\' . less-css-mode) (\.scss\' . scss-mode) (\.awk\' . awk-mode) (\.\(u?lpc\|pike\|pmod\(\.in\)?\)\' . pike-mode) (\.idl\' . idl-mode) (\.java\' . java-mode) (\.m\' . objc-mode) (\.ii\' . c++-mode) (\.i\' . c-mode) (\.lex\' . c-mode) (\.y\(acc\)?\' . c-mode) (\.h\' . c-or-c++-mode) (\.c\' . c-mode) (\.\(CC?\|HH?\)\' . c++-mode) (\.[ch]\(pp\|xx\|\+\+\)\' . c++-mode) (\.\(cc\|hh\)\' . c++-mode) (\.\(bat\|cmd\)\' . bat-mode) (\.[sx]?html?\(\.[a-zA-Z_]+\)?\' . mhtml-mode) (\.svgz?\' . image-mode) (\.svgz?\' . xml-mode) (\.x[bp]m\' . image-mode) (\.x[bp]m\' . c-mode) (\.p[bpgn]m\' . image-mode) (\.tiff?\' . image-mode) (\.gif\' . image-mode) (\.png\' . image-mode) (\.jpe?g\' . image-mode) (\.te?xt\' . text-mode) (\.[tT]e[xX]\' . tex-mode) (\.ins\' . tex-mode) (\.ltx\' . latex-mode) (\.dtx\' . doctex-mode) (\.org\' . org-mode) (\.dir-locals\(?:-2\)?\.el\' . lisp-data-mode) (eww-bookmarks\' . lisp-data-mode) (tramp\' . lisp-data-mode) (/archive-contents\' . lisp-data-mode) (places\' . lisp-data-mode) (\.emacs-places\' . lisp-data-mode) (\.el\' . emacs-lisp-mode) (Project\.ede\' . emacs-lisp-mode) (\.\(scm\|stk\|ss\|sch\)\' . scheme-mode) (\.l\' . lisp-mode) (\.li?sp\' . lisp-mode) (\.[fF]\' . fortran-mode) (\.for\' . fortran-mode) (\.p\' . pascal-mode) (\.pas\' . pascal-mode) (\.\(dpr\|DPR\)\' . delphi-mode) (\.\([pP]\([Llm]\|erl\|od\)\|al\)\' . perl-mode) (Imakefile\' . makefile-imake-mode) (Makeppfile\(?:\.mk\)?\' . makefile-makepp-mode) (\.makepp\' . makefile-makepp-mode) (\.mk\' . makefile-gmake-mode) (\.make\' . makefile-gmake-mode) ([Mm]akefile\' . makefile-gmake-mode) (\.am\' . makefile-automake-mode) (\.texinfo\' . texinfo-mode) (\.te?xi\' . texinfo-mode) (\.[sS]\' . asm-mode) (\.asm\' . asm-mode) (\.css\' . css-mode) (\.mixal\' . mixal-mode) (\.gcov\' . compilation-mode) (/\.[a-z0-9-]*gdbinit . gdb-script-mode) (-gdb\.gdb . gdb-script-mode) ([cC]hange\.?[lL]og?\' . change-log-mode) ([cC]hange[lL]og[-.][0-9]+\' . change-log-mode) (\$CHANGE_LOG\$\.TXT . change-log-mode) (\.scm\.[0-9]*\' . scheme-mode) (\.[ckz]?sh\'\|\.shar\'\|/\.z?profile\' . sh-mode) (\.bash\' . sh-mode) (/PKGBUILD\' . sh-mode) (\(/\|\`\)\.\(bash_\(profile\|history\|log\(in\|out\)\)\|z?log\(in\|out\)\)\' . sh-mode) (\(/\|\`\)\.\(shrc\|zshrc\|m?kshrc\|bashrc\|t?cshrc\|esrc\)\' . sh-mode) (\(/\|\`\)\.\([kz]shenv\|xinitrc\|startxrc\|xsession\)\' . sh-mode) (\.m?spec\' . sh-mode) (\.m[mes]\' . nroff-mode) (\.man\' . nroff-mode) (\.sty\' . latex-mode) (\.cl[so]\' . latex-mode) (\.bbl\' . latex-mode) (\.bib\' . bibtex-mode) (\.bst\' . bibtex-style-mode) (\.sql\' . sql-mode) (\(acinclude\|aclocal\|acsite\)\.m4\' . autoconf-mode) (\.m[4c]\' . m4-mode) (\.mf\' . metafont-mode) (\.mp\' . metapost-mode) (\.vhdl?\' . vhdl-mode) (\.article\' . text-mode) (\.letter\' . text-mode) (\.i?tcl\' . tcl-mode) (\.exp\' . tcl-mode) (\.itk\' . tcl-mode) (\.icn\' . icon-mode) (\.sim\' . simula-mode) (\.mss\' . scribe-mode) (\.f9[05]\' . f90-mode) (\.f0[38]\' . f90-mode) (\.indent\.pro\' . fundamental-mode) (\.\(pro\|PRO\)\' . idlwave-mode) (\.srt\' . srecode-template-mode) (\.prolog\' . prolog-mode) (\.tar\' . tar-mode) (\.\(arc\|zip\|lzh\|lha\|zoo\|[jew]ar\|xpi\|rar\|cbr\|7z\|squashfs\|ARC\|ZIP\|LZH\|LHA\|ZOO\|[JEW]AR\|XPI\|RAR\|CBR\|7Z\|SQUASHFS\)\' . archive-mode) (\.oxt\' . archive-mode) (\.\(deb\|[oi]pk\)\' . archive-mode) (\`/tmp/Re . text-mode) (/Message[0-9]*\' . text-mode) (\`/tmp/fol/ . text-mode) (\.oak\' . scheme-mode) (\.sgml?\' . sgml-mode) (\.x[ms]l\' . xml-mode) (\.dbk\' . xml-mode) (\.dtd\' . sgml-mode) (\.ds\(ss\)?l\' . dsssl-mode) (\.js[mx]?\' . javascript-mode) (\.har\' . javascript-mode) (\.json\' . javascript-mode) (\.[ds]?va?h?\' . verilog-mode) (\.by\' . bovine-grammar-mode) (\.wy\' . wisent-grammar-mode) ([:/\]\..*\(emacs\|gnus\|viper\)\' . emacs-lisp-mode) (\`\..*emacs\' . emacs-lisp-mode) ([:/]_emacs\' . emacs-lisp-mode) (/crontab\.X*[0-9]+\' . shell-script-mode) (\.ml\' . lisp-mode) (\.ld[si]?\' . ld-script-mode) (ld\.?script\' . ld-script-mode) (\.xs\' . c-mode) (\.x[abdsru]?[cnw]?\' . ld-script-mode) (\.zone\' . dns-mode) (\.soa\' . dns-mode) (\.asd\' . lisp-mode) (\.\(asn\|mib\|smi\)\' . snmp-mode) (\.\(as\|mi\|sm\)2\' . snmpv2-mode) (\.\(diffs?\|patch\|rej\)\' . diff-mode) (\.\(dif\|pat\)\' . diff-mode) (\.[eE]?[pP][sS]\' . ps-mode) (\.\(?:PDF\|DVI\|OD[FGPST]\|DOCX\|XLSX?\|PPTX?\|pdf\|djvu\|dvi\|od[fgpst]\|docx\|xlsx?\|pptx?\)\' . doc-view-mode-maybe) (configure\.\(ac\|in\)\' . autoconf-mode) (\.s\(v\|iv\|ieve\)\' . sieve-mode) (BROWSE\' . ebrowse-tree-mode) (\.ebrowse\' . ebrowse-tree-mode) (#\*mail\* . mail-mode) (\.g\' . antlr-mode) (\.mod\' . m2-mode) (\.ses\' . ses-mode) (\.docbook\' . sgml-mode) (\.com\' . dcl-mode) (/config\.\(?:bat\|log\)\' . fundamental-mode) (/\.\(authinfo\|netrc\)\' . authinfo-mode) (\.\(?:[iI][nN][iI]\|[lL][sS][tT]\|[rR][eE][gG]\|[sS][yY][sS]\)\' . conf-mode) (\.la\' . conf-unix-mode) (\.ppd\' . conf-ppd-mode) (java.+\.conf\' . conf-javaprop-mode) (\.properties\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-javaprop-mode) (\.toml\' . conf-toml-mode) (\.desktop\' . conf-desktop-mode) (/\.redshift\.conf\' . conf-windows-mode) (\`/etc/\(?:DIR_COLORS\|ethers\|.?fstab\|.*hosts\|lesskey\|login\.?de\(?:fs\|vperm\)\|magic\|mtab\|pam\.d/.*\|permissions\(?:\.d/.+\)?\|protocols\|rpc\|services\)\' . conf-space-mode) (\`/etc/\(?:acpid?/.+\|aliases\(?:\.d/.+\)?\|default/.+\|group-?\|hosts\..+\|inittab\|ksysguarddrc\|opera6rc\|passwd-?\|shadow-?\|sysconfig/.+\)\' . conf-mode) ([cC]hange[lL]og[-.][-0-9a-z]+\' . change-log-mode) (/\.?\(?:gitconfig\|gnokiirc\|hgrc\|kde.*rc\|mime\.types\|wgetrc\)\' . conf-mode) (/\.\(?:asound\|enigma\|fetchmail\|gltron\|gtk\|hxplayer\|mairix\|mbsync\|msmtp\|net\|neverball\|nvidia-settings-\|offlineimap\|qt/.+\|realplayer\|reportbug\|rtorrent\.\|screen\|scummvm\|sversion\|sylpheed/.+\|xmp\)rc\' . conf-mode) (/\.\(?:gdbtkinit\|grip\|mpdconf\|notmuch-config\|orbital/.+txt\|rhosts\|tuxracer/options\)\' . conf-mode) (/\.?X\(?:default\|resource\|re\)s\> . conf-xdefaults-mode) (/X11.+app-defaults/\|\.ad\' . conf-xdefaults-mode) (/X11.+locale/.+/Compose\' . conf-colon-mode) (/X11.+locale/compose\.dir\' . conf-javaprop-mode) (\.~?[0-9]+\.[0-9][-.0-9]*~?\' nil t) (\.\(?:orig\|in\|[bB][aA][kK]\)\' nil t) ([/.]c\(?:on\)?f\(?:i?g\)?\(?:\.[a-zA-Z0-9._-]+\)?\' . conf-mode-maybe) (\.[1-9]\' . nroff-mode) (\.art\' . image-mode) (\.avs\' . image-mode) (\.bmp\' . image-mode) (\.cmyk\' . image-mode) (\.cmyka\' . image-mode) (\.crw\' . image-mode) (\.dcr\' . image-mode) (\.dcx\' . image-mode) (\.dng\' . image-mode) (\.dpx\' . image-mode) (\.fax\' . image-mode) (\.hrz\' . image-mode) (\.icb\' . image-mode) (\.icc\' . image-mode) (\.icm\' . image-mode) (\.ico\' . image-mode) (\.icon\' . image-mode) (\.jbg\' . image-mode) (\.jbig\' . image-mode) (\.jng\' . image-mode) (\.jnx\' . image-mode) (\.miff\' . image-mode) (\.mng\' . image-mode) (\.mvg\' . image-mode) (\.otb\' . image-mode) (\.p7\' . image-mode) (\.pcx\' . image-mode) (\.pdb\' . image-mode) (\.pfa\' . image-mode) (\.pfb\' . image-mode) (\.picon\' . image-mode) (\.pict\' . image-mode) (\.rgb\' . image-mode) (\.rgba\' . image-mode) (\.tga\' . image-mode) (\.wbmp\' . image-mode) (\.webp\' . image-mode) (\.wmf\' . image-mode) (\.wpg\' . image-mode) (\.xcf\' . image-mode) (\.xmp\' . image-mode) (\.xwd\' . image-mode) (\.yuv\' . image-mode) (/LICENSE\' . text-mode) (\.log\' . text-mode) (rc\' . conf-mode) (\.\(?:hex\|nes\)\' . hexl-mode))

** Calculator
Emacs includes the venerable =calc=, which is a pretty impressive RPN (Reverse
Polish Notation) calculator. However, we can do a bit to improve the experience.
Any sane person prefers radians and exact values.

*** CalcTeX

Everybody knows that mathematical expressions look best with LaTeX, so =calc='s
ability to create LaTeX representations of its expressions provides a lovely
opportunity which is taken advantage of in the CalcTeX package.

#+begin_src emacs-lisp :tangle packages.el
(package! calctex :recipe (:host github :repo "johnbcoughlin/calctex"
                           :files ("*.el" "calctex/*.el" "calctex-contrib/*.el" "org-calctex/*.el" "vendor"))
  :pin "67a2e76847a9ea9eff1f8e4eb37607f84b380ebb")
#+end_src


We'd like to use CalcTeX too, so let's set that up, and fix some glaring
inadequacies --- why on earth would you commit a hard-coded path to an executable
that /only works on your local machine/, consequently breaking the package for
everyone else!?

#+begin_src emacs-lisp
(use-package! calctex
  :commands calctex-mode
  :init
  (add-hook 'calc-mode-hook #'calctex-mode)
  :config
  (setq calctex-additional-latex-packages "
\\usepackage[usenames]{xcolor}
\\usepackage{soul}
\\usepackage{adjustbox}
\\usepackage{amsmath}
\\usepackage{amssymb}
\\usepackage{siunitx}
\\usepackage{cancel}
\\usepackage{mathtools}
\\usepackage{mathalpha}
\\usepackage{xparse}
\\usepackage{arevmath}"
        calctex-additional-latex-macros
        (concat calctex-additional-latex-macros
                "\n\\let\\evalto\\Rightarrow"))
  (defadvice! no-messaging-a (orig-fn &rest args)
    :around #'calctex-default-dispatching-render-process
    (let ((inhibit-message t) message-log-max)
      (apply orig-fn args)))
  ;; Fix hardcoded dvichop path (whyyyyyyy)
  (let ((vendor-folder (concat (file-truename doom-local-dir)
                               "straight/"
                               (format "build-%s" emacs-version)
                               "/calctex/vendor/")))
    (setq calctex-dvichop-sty (concat vendor-folder "texd/dvichop")
          calctex-dvichop-bin (concat vendor-folder "texd/dvichop")))
  (unless (file-exists-p calctex-dvichop-bin)
    (message "CalcTeX: Building dvichop binary")
    (let ((default-directory (file-name-directory calctex-dvichop-bin)))
      (call-process "make" nil nil nil))))
#+end_src
*** Embedded calc

Embedded calc is a lovely feature which let's us use calc to operate on LaTeX
maths expressions. The standard keybinding is a bit janky however (=C-x * e=), so
we'll add a localleader-based alternative.

#+begin_src emacs-lisp
(map! :map calc-mode-map
      :after calc
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
(map! :map org-mode-map
      :after org
      :localleader
      :desc "Embedded calc (toggle)" "E" #'calc-embedded)
(map! :map latex-mode-map
      :after latex
      :localleader
      :desc "Embedded calc (toggle)" "e" #'calc-embedded)
#+end_src

Unfortunately this operates without the (rather informative) calculator and
trail buffers, but we can advice it that we would rather like those in a side
panel.

#+begin_src emacs-lisp
(defvar calc-embedded-trail-window nil)
(defvar calc-embedded-calculator-window nil)

(defadvice! calc-embedded-with-side-pannel (&rest _)
  :after #'calc-do-embedded
  (when calc-embedded-trail-window
    (ignore-errors
      (delete-window calc-embedded-trail-window))
    (setq calc-embedded-trail-window nil))
  (when calc-embedded-calculator-window
    (ignore-errors
      (delete-window calc-embedded-calculator-window))
    (setq calc-embedded-calculator-window nil))
  (when (and calc-embedded-info
             (> (* (window-width) (window-height)) 1200))
    (let ((main-window (selected-window))
          (vertical-p (> (window-width) 80)))
      (select-window
       (setq calc-embedded-trail-window
             (if vertical-p
                 (split-window-horizontally (- (max 30 (/ (window-width) 3))))
               (split-window-vertically (- (max 8 (/ (window-height) 4)))))))
      (switch-to-buffer "*Calc Trail*")
      (select-window
       (setq calc-embedded-calculator-window
             (if vertical-p
                 (split-window-vertically -6)
               (split-window-horizontally (- (/ (window-width) 2))))))
      (switch-to-buffer "*Calculator*")
      (select-window main-window))))
#+end_src

*** calc
#+begin_src emacs-lisp :tangle no

(setq calc-angle-mode 'rad  ; radians are rad
      calc-symbolic-mode t) ; keeps expressions like \sqrt{2} irrational for as long as possible
;; ** CALC
;;;----------------------------------------------------------------
(use-package! calc
  :bind (("C-x c" . calc)
         ("H-S-c" . calc)
         ("H-*" . calc-dispatch)
         ("C-S-e" . latex-math-from-calc))
  :config
  (defun latex-math-from-calc ()
    "Evaluate `calc' on the contents of line at point."
    (interactive)
    (let ((lang (when (member major-mode '(org-mode latex-mode))
                  'latex)))
      (cond ((region-active-p)
             (let* ((beg (region-beginning))
                    (end (region-end))
                    (string (buffer-substring-no-properties beg end)))
               (kill-region beg end)
               (insert (calc-eval `(,string calc-language ,lang
                                            calc-prefer-frac t
                                            calc-angle-mode rad)))))
            (t (let ((l (thing-at-point 'line)))
                 (end-of-line 1) (kill-line 0)
                 (insert (calc-eval `(,l
                                      calc-language ,lang
                                      calc-prefer-frac t
                                      calc-angle-mode rad)))))))))
#+end_src

#+RESULTS:
: latex-math-from-calc

** Version control tools
*** Diff-mode (and prot-diff.el extensions)

This covers the standard =diff-mode.el=, which I use quite often, such as
while interfacing with the built-in Version Control framework (see the
section on [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]), or while
browsing various code-related mailing lists through notmuch (refer to
the [[#h:5ad80664-3163-4d9d-be65-462637d77903][email settings]]).

Overview of my preferences for how diffs should look:

+ Always start the buffer in a read-only state.  A typo will mess things
  up when trying to apply a patch.
+ After applying a diff hunk (=diff-apply-hunk= with =C-c C-a=) move on to
  the next one.
+ Update hunk headers automatically following an edit to the diff.
+ Do not show word-wise ("refined") changes upon activation.  I prefer
  to do so manually.  All such highlights are removed if you generate
  the buffer again (with =g= as expected) and the default is to not show
  word-wise changes.
+ Do not prettify headers.  I like the standard "patch" looks.  It also
  makes it easier to copy the diff elsewhere.

Now some notes on my =prot-diff.el= extensions, combined with a
description of the basics of =diff-mode= (as always you can get
documentation about the current buffer's major mode with =C-h m=---read
[[#h:83730fe8-d917-4d94-96f4-bbc5c900fe38][How do you learn Emacs?]] in the FAQ section appended to this document):

+ =prot-diff-buffer-dwim= will produce a diff that compares the current
  buffer to the last saved state of the underlying file.  If the buffer
  has no unsaved edits, the command will produce a diff that compares
  the file to its last registered version-controlled state.  Calling the
  command with an optional prefix argument (=C-u=) will enable word-wise
  highlighting across the diff.

+ =prot-diff-refine-cycle= is how I manually control word-wise diff
  highlights.  This command has a buffer-local cyclic behaviour.  The
  first time it is called, it acts on the diff hunk at point.  Upon
  second invocation, it operates on the entire buffer.  And on third
  call it removes the word-wise diffs altogether.

+ =prot-diff-narrow-dwim= narrows to the diff hunk at point.  If narrowing
  is already present, it widens the buffer.  When invoked with an
  optional prefix argument, it narrows to the current file.

+ =C-c C-c= or =M-o= takes you to the point of the changes in the source
  file.  If you run this of the diff hunk's heading, you go to the
  beginning of the context.  But if you place the point somewhere inside
  of the diff's added changes or context, you will visit that exact
  position in the original file (does not work for removed text because
  technically it does not exist).

+ When working with patches to source code, which are distributed
  e.g. through email, you can apply the current hunk with =C-c C-a= or
  test for compatibility with =C-c C-t=.  This is a nice way to easily
  merge contributions from others, without having to go through the
  workflow of some proprietary Git/Version-Control forge.

+ With =M-n= and =M-p= you move between hunks.  With =M-}= and =M-{= or =M-N=, =M-P=
  do the same between files.

The =prot-diff-*= commands are part of my =prot-diff.el= library, reproduced
in its entirety after this set of package configurations.

*Pro tip:* enable =outline-minor-mode= to make diff sections foldable.
Check [[#h:a8e737b8-7c90-4c68-8814-acf2f637ffa1][Outline mode, outline minor mode, and extras (prot-outline.el)]].

Also read these sections:

+ [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]].
+ [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]].

Changes to all tracked files are optionally highlighted in the fringe
thanks to the =diff-hl= package by Dmitry Gutov (refer to the section on
[[#h:cb76fcee-e304-4b86-a764-6c3c6775da51][Line numbers and relevant indicators (prot-sideline.el)]]).  Any rules
that control the placement of VC-related (and other) buffers are defined
in the section on [[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][window rules and basic tweaks]] (specifically, refer to
the variable =display-buffer-alist=).

#+begin_src emacs-lisp :tangle yes
;;; Diff-mode (and prot-diff.el extensions)
(use-package! diff-mode
  :config
  (setq diff-default-read-only t)
  (setq diff-advance-after-apply-hunk t)
  (setq diff-update-on-the-fly t)
  ;; The following are from Emacs 27.1
  (setq diff-refine nil)                ; I do it on demand
  (setq diff-font-lock-prettify nil)    ; better for patches
  ;; The following is further controlled by
  ;; `prot-diff-modus-themes-diffs'
  (setq diff-font-lock-syntax 'hunk-also))
(add-to-list 'load-path "~/.config/doom/lisp/")

(load "prot-diff")
 (use-package! prot-diff
   :config
   ;; (prot-diff-modus-themes-diffs)
   (add-hook 'modus-themes-after-load-theme-hook #'prot-diff-modus-themes-diffs)

   (prot-diff-extra-keywords 1)

   ;; `prot-diff-buffer-dwim' replaces the default for `vc-diff' (which I
   ;; bind to another key---see VC section).
   (define-key global-map (kbd "C-x v =") #'prot-diff-buffer-dwim)
   (let ((map diff-mode-map))
     (define-key map (kbd "C-c C-b") #'prot-diff-refine-cycle) ; replace `diff-refine-hunk'
     (define-key map (kbd "C-c C-n") #'prot-diff-narrow-dwim)))
 #+end_src

#+RESULTS:
: t

*** Version control framework (vc.el and prot-vc.el)

VC consists of set of libraries that provide the means for working with
several version control systems, else "backends".  It is built into
Emacs.  Compared with =magit= (see section on [[#h:76d1b392-e693-40dc-b320-d4c1047115ab][Magit configs]]), =vc= offers a
more abstract, buffer-oriented paradigm that does a fine job at covering
all basic versioning needs.  It however never stands as Magit's peer
when it comes to the sheer coverage of Git features.

To my mind, VC and Magit can be used as part of the same setup.  Employ
the former for common tasks such as viewing diffs and logs, committing
changes in bulk, pushing and pulling from a remote.  And let Magit
handle the more involved and specialised cases of staging a partial
diff, rebasing commits interactively, writing a commit fixup, and so on.

Also refer to the section on [[#h:2ff46d23-09d5-4d92-b0af-2339dc19719f][Diff-mode (and prot-diff.el extensions)]]
which includes various neat extras, such as extra fontification rules
for diff buffers.  And watch my videos on this topic:

1. [[https://protesilaos.com/codelog/2020-03-30-emacs-intro-vc/][Introduction to the Emacs Version Control framework]] (2020-03-30).
2. [[https://protesilaos.com/codelog/2021-01-22-emacs-vc-git-extras/][Extensions for Emacs' vc-git]] (2021-01-22).
3. [[https://protesilaos.com/codelog/2021-02-08-emacs-vc-workflow/][My workflow with VC for Git projects]] (2021-02-08).

Here is an overview of the keys I define, with only a few of them being
left to their default values (note that =prot-diff-buffer-dwim= is part of
the =prot-diff.el= that I linked to above):

| Command                          | C-x v prefix | Mnemonic          |
|----------------------------------+--------------+-------------------|
| vc-update                        | F            | Fetch and Fuse    |
| vc-push                          | P            |                   |
| vc-log-incoming                  | f            | Fetch only        |
| vc-log-outgoing                  | O            |                   |
| vc-create-tag                    | t            |                   |
| vc-retrieve-tag                  | b            | Branch/tag switch |
| vc-diff                          | d            | Diff current file |
| vc-root-diff                     | D            | Diff project      |
| prot-diff-buffer-dwim            | =            | Equality check    |
| prot-vc-project-or-dir           | p            | Project status    |
| prot-vc-custom-log               | SPC          |                   |
| prot-vc-git-patch-apply          | a            | Apply patch       |
| prot-vc-git-patch-create-dwim    | c            | Create patch      |
| prot-vc-git-show                 | s            | Show commit       |
| prot-vc-git-grep                 | g            |                   |
| prot-vc-git-log-grep             | G            |                   |
| prot-vc-git-find-revision        | r            | Revisit version   |
| prot-vc-git-blame-region-or-file | B            | Blame             |
| prot-vc-git-log-insert-commits   | i            | Insert commit log |
| prot-vc-git-reset                | R            | Reset (--soft)    |

My =prot-vc.el= library (reproduced after the package configurations)
defines several commands that extend VC to suit my needs as a Git user.
Check the key maps I assign those commands to, in order to further
appreciate the scope of each action.  In short:

+ =prot-vc-git-grep= is a simple wrapper around =vc-git-grep=.  Instead of
  asking for a directory and a file extension pattern, it just prompts
  for a regexp and performs the search across the entire VC-controlled
  directory tree.  All matches are placed directly in a buffer.

+ =prot-vc-git-log-edit-extract-file-name= is used in log-edit buffers to
  derive the file name of the item being committed.  For example, as I
  am writing this, I may want to compose a summary of my changes like
  "prot-emacs: expand VC section docs".  The "prot-emacs: " part comes
  directly from this command, which reads from the "prot-emacs.org"
  file.  If there are multiple files to be committed, then a minibuffer
  prompt asks to pick one among them.  This helps me write clean and
  meaningful summaries.

+ The commands =prot-vc-git-log-edit-{next,previous,complete}-comment= are
  used to access information about previous commit messages that are
  stored in the dedicated ring.  The next/previous operations will cycle
  through the ring in the given direction.  While the "complete" command
  will use minibuffer completion to insert the select item at point.

+ =prot-vc-git-log-insert-commits= will simply insert at point N number of
  commits starting from the HEAD of the current project.  The number is
  inserted at the minibuffer following a prompt.  This runs the =git log=
  shell command in the background.  If the command is not called from
  inside a version-controlled directory or if it is invoked with a
  prefix argument (=C-u=), it first asks for a project and eventually
  prints a log for it.  Again, this is useful while writing the message
  of a commit, as I occasionally need to reference earlier changes.

+ =prot-vc-git-patch-apply= prompts for a file system path to a patch
  file.  By default, it applies the patch directly to the current git
  repo.  If no such repository is found or if called with an optional
  prefix argument the command prompts for a project to use.  This makes
  it very simple to apply a patch from anywhere, such as while reading
  my email (also refer to [[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]]).  Arguments that are passed to
  it are those specified in =prot-vc-git-patch-apply-args=, unless the
  command is called from Lisp, in which case it accepts ARGS as a list
  of strings (read the =git am= man pages if you ever need this).

+ =prot-vc-git-patch-create-dwim= produces a properly formatted patch for
  a given commit.  The outputted file is saved in a directory that is
  selected via a minibuffer completion prompt: default candidates are
  stored in =prot-vc-patch-output-dirs= and are complemented by the root
  of the current project.

  - When browsing a =log-view= buffer, the commit is the one around point.

  - When the region is active in Log View buffers, the command will
    capture the included range of commits, instead of just the one at
    point.

  - With a prefix argument (=C-u=), a minibuffer completion prompt will
    ask for a commit to use as the base in a range against HEAD.  This
    will skip the check for the commit at point, though an active region
    in Log View buffers will still take precedence.

  - Beware of how Git interprets those ranges: the base commit is the
    one before the earliest in the range, so if you need to produce
    patches for the topmost 4 commits, you must include the last 5 in
    the region.

  - That granted, I also use [[#h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301][git-email.el for preparing patches]] that
    must be sent via email outright.

+ =prot-vc-git-checkout-remote= prompts for a remote branch and proceeds
  to checkout a local branch that is set up to track it.  So if you have
  a remote named =origin/dev= it will do =git checkout -b dev origin/dev=.
  I only use this command inside VC-dir buffers.

+ =prot-vc-custom-log= prints a log of commits that matches a custom file
  set.  This is of great value when you need to inspect the history of
  only some files rather than that of the entire repository.  What files
  to choose is determined in two ways: (1) the file-at-point in Dired
  buffers, or all marked files, and (2) files in the current directory
  selected with minibuffer completion.

+ =prot-vc-log-view-toggle-entry-all= will toggle the visibility of all
  commits in a compact log view.  I often employ this in tandem with
  =prot-vc-custom-log=.

+ =prot-vc-git-show= lets you read a given commit that you access with
  completion.  A simple and effective wrapper for =git show=.

+ =prot-vc-git-log-grep= provides a search utility for commit logs.  It
  accepts a regular expression, which may just be a string, and shows
  all commits whose message includes that pattern.  When called with a
  universal prefix argument (=C-u=), the log will also include the
  corresponding diff of each commit.

+ =prot-vc-git-find-revision= allows you to revisit a previous state of the
  current file, by selecting a commit with completion.  Quite powerful
  when you want to search, for example, my dotemacs from when I first
  introduced a certain package, say, =prot-vc.el=.

+ =prot-vc-git-reset= prompts for a commit to reset back to, using
  minibuffer completion.  This is a "soft" undo process in that all
  changes are kept in place while any commits are removed.  Remember to
  only do this for local logs as it is not good practice to reset
  publicly available histories: it will break the local copies of other
  users.

+ =prot-vc-git-log-reset= is like the above command, only that it is meant
  to be called from inside a Log View buffer (e.g.  =vc-print-root-log=
  which is bound to =C-x v L= by default).  The commit to reset back to is
  the one at point.  Calling the command with a prefix argument (=C-u=)
  will change the meaning of the reset operation from a soft to a hard
  one.  The latter deletes all commits up to the selected commit /and
  removes all changes/, so please be careful.

+ =prot-vc-project-or-dir= produces a =vc-dir= buffer for the current
  project (also see [[#h:7862f39e-aed0-4d02-9f1e-60c4601a9734][Projects (project.el and prot-project.el)]]).  With a
  =C-u= prefix argument the command limits the matches to the present
  directory.

+ =prot-vc-log-kill-hash= appends to the kill-ring the hash of the commit
  around point.  It is meant to be used in =log-view= buffers.

+ =prot-vc-git-setup-mode= is a minor mode that refashions the log edit
  buffer while adding a small tweak to the log view buffers.

  - Normally the log edit buffer (what you use to write the commit
    message) will pop up in a window with a smaller window below it
    showing the files to be committed.  The window layout does not
    automatically show the corresponding diff, while there is no readily
    available information as to what branch we are about to commit the
    changes to.  So my minor mode removes the small window with the
    files and in its stead adds a comment block in the main message
    composition buffer (like the standard =git commit=).  It then displays
    the diff window on one side and the edit buffer on the other (yes,
    just like Magit, though the order of the windows is always the
    same).  The prior window configuration and the point are saved
    before entering the log edit session and immediately restored upon
    exit (either by committing the changes or aborting).

  - The behaviour of cycling the ring of prior commits is reworked to
    account for the custom git comment.  In addition to back/forth
    motions through the ring's items (=M-p=, =M-n=), a command for picking a
    commit message with minibuffer completion is also made available in
    the stead of the generic commands for searching through the ring,
    with =M-s= or =M-r= (the defaults lack visual feedback and are, in my
    opinion, not appropriate for the task).

  - The =Amend= pseudo header is displayed by default to make it easier to
    edit the last commit, if necessary, and to raise awareness about
    this possibility.

  - For the log view buffers (commit logs) the minor mode instructs the
    command that expands the message of a commit on the current line to
    include more information from =git log= than what it normally would.
    It shows diff stats and affected file names, while also creating
    some much needed negative space for better usability.  Those file
    names are not purely cosmetic, as they can now serve to power Emacs'
    contextuality and "future history" such as when you put point over
    the name and type =C-x p f= (=project-find-file=): the file at point
    becomes the default choice and the one you will also get with =M-n= in
    the minibuffer (=next-history-element=).

Finally, a few tips for acting in the log-edit buffer (remember to use
=C-h m= (=M-x describe-mode=) in every unfamiliar major mode and read the
manual for more on the matter):

+ Use =C-c C-d= (=log-edit-show-diff=) to produce a diff of the changes
  to-be-committed.  Of course this is of no use if my aforementioned
  minor mode is enabled.  Still, it is good to know (by the way, this
  command also works in Magit's commit composition buffers).

+ With =C-c C-w= (=log-edit-generate-changelog-from-diff=) generate an
  overview of documented changes to the given file set.  While this may
  not be useful for everyday commits, it is mandatory when preparing
  patches for upstream Emacs (and probably other GNU projects).

+ Normally the window layout is set up to include files for the given
  commit, but I disable that via my minor mode.  You can opt to display
  them with =C-c C-f= (=log-edit-show-files=).

+ =C-c C-k= (=log-edit-kill-buffer=) cancels the log editing process.

+ =M-n= (=log-edit-next-comment=) and =M-p= (=log-edit-previous-comment=) let
  you cycle through prior commit messages.

#+begin_src emacs-lisp :tangle no
;;; Version control framework (vc.el and prot-vc.el)
(prot-emacs-builtin-package 'vc
  ;; Those offer various types of functionality, such as blaming,
  ;; viewing logs, showing a dedicated buffer with changes to affected
  ;; files.
  (require 'vc-annotate)
  (require 'vc-dir)
  (require 'vc-git)
  (require 'add-log)
  (require 'log-view)

  ;; This one is for editing commit messages.
  (require 'log-edit)
  (setq log-edit-confirm 'changed)
  (setq log-edit-keep-buffer nil)
  (setq log-edit-require-final-newline t)
  (setq log-edit-setup-add-author nil)

  ;; Note that `prot-vc-git-setup-mode' will run the following when
  ;; activated:
  ;;
  ;;   (remove-hook 'log-edit-hook #'log-edit-show-files)
  ;;
  ;; If you need the window to pop back up, do it manually with C-c C-f
  ;; which calls `log-edit-show-files'.

  (setq vc-find-revision-no-save t)
  (setq vc-annotate-display-mode 'scale) ; scale to oldest
  ;; I use a different account for git commits
  (setq add-log-mailing-address "info@protesilaos.com")
  (setq add-log-keep-changes-together t)
  (setq vc-git-diff-switches '("--patch-with-stat" "--histogram"))
  (setq vc-git-print-log-follow t)
  (setq vc-git-revision-complete-only-branches nil) ; Emacs 28
  (setq vc-git-root-log-format
        '("%d %h %ad %an: %s"
          ;; The first shy group matches the characters drawn by --graph.
          ;; We use numbered groups because `log-view-message-re' wants the
          ;; revision number to be group 1.
          "^\\(?:[*/\\|]+\\)\\(?:[*/\\| ]+\\)?\
\\(?2: ([^)]+) \\)?\\(?1:[0-9a-z]+\\) \
\\(?4:[0-9]\\{4\\}-[0-9]\\{2\\}-[0-9]\\{2\\}\\) \
\\(?3:.*?\\):"
          ((1 'log-view-message)
           (2 'change-log-list nil lax)
           (3 'change-log-name)
           (4 'change-log-date))))

  (add-hook 'log-view-mode-hook #'hl-line-mode)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v b") #'vc-retrieve-tag)  ; "branch" switch
    (define-key map (kbd "C-x v t") #'vc-create-tag)
    (define-key map (kbd "C-x v f") #'vc-log-incoming)  ; the actual git fetch
    (define-key map (kbd "C-x v o") #'vc-log-outgoing)
    (define-key map (kbd "C-x v F") #'vc-update)        ; "F" because "P" is push
    (define-key map (kbd "C-x v d") #'vc-diff))
  (let ((map vc-dir-mode-map))
    (define-key map (kbd "b") #'vc-retrieve-tag)
    (define-key map (kbd "t") #'vc-create-tag)
    (define-key map (kbd "O") #'vc-log-outgoing)
    (define-key map (kbd "o") #'vc-dir-find-file-other-window)
    (define-key map (kbd "f") #'vc-log-incoming) ; replaces `vc-dir-find-file' (use RET)
    (define-key map (kbd "F") #'vc-update)       ; symmetric with P: `vc-push'
    (define-key map (kbd "d") #'vc-diff)         ; parallel to D: `vc-root-diff'
    (define-key map (kbd "k") #'vc-dir-clean-files)
    (define-key map (kbd "G") #'vc-revert)
    (let ((prot-vc-git-branch-map (make-sparse-keymap)))
      (define-key map "B" prot-vc-git-branch-map)
      (define-key prot-vc-git-branch-map "n" #'vc-create-tag) ; new branch/tag
      (define-key prot-vc-git-branch-map "s" #'vc-retrieve-tag) ; switch branch/tag
      (define-key prot-vc-git-branch-map "c" #'prot-vc-git-checkout-remote) ; "checkout" remote
      (define-key prot-vc-git-branch-map "l" #'vc-print-branch-log))
    (let ((prot-vc-git-stash-map (make-sparse-keymap)))
      (define-key map "S" prot-vc-git-stash-map)
      (define-key prot-vc-git-stash-map "c" 'vc-git-stash) ; "create" named stash
      (define-key prot-vc-git-stash-map "s" 'vc-git-stash-snapshot)))
  (let ((map vc-git-stash-shared-map))
    (define-key map "a" 'vc-git-stash-apply-at-point)
    (define-key map "c" 'vc-git-stash) ; "create" named stash
    (define-key map "D" 'vc-git-stash-delete-at-point)
    (define-key map "p" 'vc-git-stash-pop-at-point)
    (define-key map "s" 'vc-git-stash-snapshot))
  (let ((map vc-annotate-mode-map))
    (define-key map (kbd "M-q") #'vc-annotate-toggle-annotation-visibility)
    (define-key map (kbd "C-c C-c") #'vc-annotate-goto-line)
    (define-key map (kbd "<return>") #'vc-annotate-find-revision-at-line))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<tab>") #'log-view-toggle-entry-display)
    (define-key map (kbd "<return>") #'log-view-find-revision)
    (define-key map (kbd "s") #'vc-log-search)
    (define-key map (kbd "o") #'vc-log-outgoing)
    (define-key map (kbd "f") #'vc-log-incoming)
    (define-key map (kbd "F") #'vc-update)
    (define-key map (kbd "P") #'vc-push)))

(prot-emacs-builtin-package 'prot-vc
  (setq prot-vc-log-limit 100)
  (setq prot-vc-log-bulk-action-limit 50)
  (setq prot-vc-git-log-edit-show-commits t)
  (setq prot-vc-git-log-edit-show-commit-count 10)
  (setq prot-vc-shell-output "*prot-vc-output*")
  (setq prot-vc-patch-output-dirs (list "~/" "~/Desktop/"))
  (add-to-list' log-edit-headers-alist '("Amend"))

  ;; This refashions log view and log edit buffers
  (prot-vc-git-setup-mode 1)

  ;; NOTE: I override lots of the defaults
  (let ((map global-map))
    (define-key map (kbd "C-x v i") #'prot-vc-git-log-insert-commits)
    (define-key map (kbd "C-x v p") #'prot-vc-project-or-dir)
    (define-key map (kbd "C-x v SPC") #'prot-vc-custom-log)
    (define-key map (kbd "C-x v g") #'prot-vc-git-grep)
    (define-key map (kbd "C-x v G") #'prot-vc-git-log-grep)
    (define-key map (kbd "C-x v a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "C-x v c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "C-x v s") #'prot-vc-git-show)
    (define-key map (kbd "C-x v r") #'prot-vc-git-find-revision)
    (define-key map (kbd "C-x v B") #'prot-vc-git-blame-region-or-file)
    (define-key map (kbd "C-x v R") #'prot-vc-git-reset))
  (let ((map vc-git-log-edit-mode-map))
    (define-key map (kbd "C-C C-n") #'prot-vc-git-log-edit-extract-file-name)
    (define-key map (kbd "C-C C-i") #'prot-vc-git-log-insert-commits)
    ;; Also done by `prot-vc-git-setup-mode', but I am putting it here
    ;; as well for visibility.
    (define-key map (kbd "C-c C-c") #'prot-vc-git-log-edit-done)
    (define-key map (kbd "C-c C-a") #'prot-vc-git-log-edit-toggle-amend)
    (define-key map (kbd "M-p") #'prot-vc-git-log-edit-previous-comment)
    (define-key map (kbd "M-n") #'prot-vc-git-log-edit-next-comment)
    (define-key map (kbd "M-s") #'prot-vc-git-log-edit-complete-comment)
    (define-key map (kbd "M-r") #'prot-vc-git-log-edit-complete-comment))
  (let ((map log-view-mode-map))
    (define-key map (kbd "<C-tab>") #'prot-vc-log-view-toggle-entry-all)
    (define-key map (kbd "a") #'prot-vc-git-patch-apply)
    (define-key map (kbd "c") #'prot-vc-git-patch-create-dwim)
    (define-key map (kbd "R") #'prot-vc-git-log-reset)
    (define-key map (kbd "w") #'prot-vc-log-kill-hash)))
#+end_src


**** git-email.el for preparing patches
:PROPERTIES:
:CUSTOM_ID: h:81c71e25-d6c4-4ef2-ad21-4fd57b00c301
:END:

This neat library by Xinglu Chen streamlines the process of formatting
and sending Git patches via email, all from the comfort of Emacs.  Its
main point of entry is the command =git-email-format-patch=, which prompts
you for a commit that is read as the range between the current HEAD and
the one you specify.  In doing so, it allows you to prepare a series of
patches, using the correct message headers.

=git-email.el= is meant to work with the standard message composition
buffer, such as the one you get when you call =M-x compose-email= (by
default that command is bound to =C-x m= and I keep it that way).  Email
clients like Gnus and Notmuch are also supported.  For my case as a user
of the latter, I just activate =git-email-notmuch-mode= in order to add
the relevant settings to the message composition buffers.  For more on
Notmuch and all related configurations, refer to the mega-section on
[[#h:5ad80664-3163-4d9d-be65-462637d77903][Email settings]].

So here is the typical workflow with this package:

+ Visit a file and make some changes.
+ Commit those changes.
+ Invoke =git-email-format-patch= and select the base commit against which
  your commits are to be read.  So if your commit is the current HEAD,
  then just pick the one right before.
+ Pass any optional flags.  Multiple flags can be completed against
  using a comma as a separator (or whatever your =crm-separator= is).
+ Fill in the email details, which probably is just an email address
  (and a cover letter, if you use that option).
+ Send.  Done!

The maintainer of the project will then be able to apply your patch,
using standard git commands (read the manpages of =git-apply= for
attachments and =git-am= for mailbox-type patches).

Alternatively, you may already have a patch available and wish to email
it directly.  Visit its directory and with the point over it call the
command =git-email-send-email=.  This also works for the marked items of
the Dired buffer ([[#h:c519300f-8a9a-472b-b26d-c2f49adbdb5d][Dired (directory editor, file manager)]]).

Overall, =git-email.el= is a welcome addition to the ecosystem.  Apart
from also working with the built-in Version Control framework of Emacs
(consult [[#h:31deeff4-dfae-48d9-a906-1f3272f29bc9][Version control framework (vc.el and prot-vc.el)]]), it offers us
the means to conveniently implement a truly decentralised workflow for
collaboration: git and email empower you to utilise the tools you want,
instead of forcing you through some unwieldy pull/merge request process
that certain git forges encourage.  I prefer this approach and am eager
to see it getting more widespread adoption.

#+begin_src emacs-lisp :tangle no
;;; git-email.el for preparing patches
;; Project repo: <https://git.sr.ht/~yoctocell/git-email>.  This is one
;; of the packages I handle manually via git, at least until it becomes
;; available through an ELPA.
;;
;; `prot-emacs-manual-package' is defined in my init.el
(prot-emacs-manual-package 'git-email
  (with-eval-after-load 'notmuch
    (require 'git-email-notmuch)
    (git-email-notmuch-mode 1))
  (define-key global-map (kbd "C-x v RET") #'git-email-format-patch) ; VC prefix and C-m
  (define-key dired-mode-map (kbd "C-x v RET") #'git-email-send-email))
#+end_src

*** Smerge and Ediff

*Read this section, because it matters more than the code below it.*

Sometimes we face a situation where we have conflicting versions of a
file and the version control backend cannot solve them on its own.  This
can happen fairly often when collaborating with other people or, more
generally, when we keep our work spread across multiple feature branches
with diverging histories.  Whenever such conflicts arise, Emacs will
automatically annotate the offending files with special markers that
show the conflicting differences.  Visiting those files will then
activate =smerge-mode=.  At which point we are in control.

Smerge revolves around the concept of dividing the conflicting part into
an "upper" (red) and a "lower" section (green), possibly with their
common ancestor or last point of convergence in the middle (yellow).

With this in mind we can operate on the marked differences by relying on
the functions that Smerge provides, all of which are accessed by default
through the common prefix of =C-c ^=.  Start by typing the prefix followed
by =C-h= to see all possible key chords.  These are the commands I have
used the most:

+ =C-c ^ u= (=smerge-keep-upper=)
+ =C-c ^ l= (=smerge-keep-lower=)
+ =C-c ^ b= (=smerge-keep-base=)
+ =C-c ^ a= (=smerge-keep-all=)
+ =C-c ^ n= (=smerge-next=)
+ =C-c ^ p= (=smerge-prev=)

Proceed to edit the file the way you want until no more conflicts exist.
You can also do things through manual editing, with standard commands
and motions, but that can be prone to errors (which lead to more
conflicts).  At any moment in this process, you can switch to =ediff=,
which offers a more powerful way of working with differences.  Type the
key chord =C-c ^ E= (=smerge-ediff=).

Ediff is a powerhouse that is likely to cover all your needs in this
area (including those you are not aware of).  For our purposes, what
matters is to understand the basic concepts.

The way this tool works is that it starts by producing a layout of the
two conflicting versions with access to a "control panel" for operating
on them.  By default, the panel is positioned on a new frame, but I find
that rather awkward---my config puts it inside an Emacs window instead.
While focusing the control panel, you can move between each diff range
with =n= and =p=.  The focused section will be coloured using red, green,
and yellow, while all other diffs will be presented in gray.

On each diff, you have three options: to use the version of buffer A
(red), of buffer B (green), or a combination of the two.  The keys for
each of those are =a=, =b=, and =+= respectively.  Your choice will be
reflected in buffer C (the yellow one).  Use these to resolve all
conflicts and then quit the session with =q=.

Concerning the combination of versions between A and B, Ediff has the
behaviour of also inserting as plain text the annotation markers that
Smerge relied on.  As of this writing (2020-04-10), I am not aware of an
automatic or convenient way to omit those prior to confirming our edits.
To that end, I tweak the wording of the markers to some unique string
(see package below) and then run =flush-lines= to remove them before
saving the resulting buffer (so right after the =q=).  For more on this,
check =prot/ediff-flush-combination-pattern=.

For =git= users, to actually /reference the common ancestor/ (the point
before the branching paths started) we must run this command once in our
command-line prompt (writes to your global =.gitconfig= file):

#+begin_src sh :tangle no
# git config --global merge.conflictStyle diff3
#+end_src

This is optional, but I find that I like it.  At any rate, the
configurations I have below are straightforward (learn more about this
powerful tool by hitting =?= inside of its control panel and by consulting
its comprehensive manual):

+ Do not keep all the buffers after exiting the Ediff session.
+ Keep buffers in an editable state.  Otherwise it is impossible to
  perform the changes we are interested in.
+ Show the common ancestor in another buffer.  This helps provide
  further context of how things took their form.
+ Show only the conflicting parts.  This is not a review of all diffs.
+ Prefer putting windows side-by-side, rather than one below the other.
+ Do not enter the ediff session in a new frame.  This also means that
  the control panel will be inside an Emacs window (at the bottom part)
  rather than in a tiny frame of its own.

There actually is nothing in terms of Smerge-related configurations.
The package is small and does one thing well.

Also watch my video of [[https://protesilaos.com/codelog/2020-04-10-emacs-smerge-ediff/][Smerge and Ediff for git conflict resolution]]
(2020-04-10).

#+begin_src emacs-lisp :tangle no
;;; Smerge and Ediff
(use-package! smerge-mode)

(use-package! ediff
  :config
  (setq ediff-keep-variants nil)
  (setq ediff-make-buffers-readonly-at-startup nil)
  (setq ediff-merge-revisions-with-ancestor t)
  (setq ediff-show-clashes-only t)
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)

  ;; Tweak those for safer identification and removal
  (setq ediff-combination-pattern
        '("<<<<<<< prot-ediff-combine Variant A" A
          ">>>>>>> prot-ediff-combine Variant B" B
          "####### prot-ediff-combine Ancestor" Ancestor
          "======= prot-ediff-combine End"))

  ;; TODO automate process in a robust way, or at least offer a good key
  ;; binding.
  (defun prot/ediff-flush-combination-pattern ()
    "Remove my custom `ediff-combination-pattern' markers.

This is a quick-and-dirty way to get rid of the markers that are
left behind by `smerge-ediff' when combining the output of two
diffs.  While this could be automated via a hook, I am not yet
sure this is a good approach."
    (interactive)
    (flush-lines ".*prot-ediff.*" (point-min) (point-max) nil)))
#+end_src

#+RESULTS:
: t

** Convenience functions when working with PDF exports

When working on markdown or org-mode files that will be converted to
PDF, I use =pdf-tools= to preview the PDF and shortcuts to
automatically save, compile and reload on demand.

[[https://www.youtube.com/watch?v=Pd0JwOqh-gI][Here]] is a screencast showing how I edit Markdown or org-mode files in
Emacs whilst having a PDF preview.

In a screenshot, it looks like this:


#+BEGIN_SRC emacs-lisp :tangle no
  (defun md-compile ()
    "Compiles the currently loaded markdown file using pandoc into a PDF"
    (interactive)
    (save-buffer)
    (shell-command (concat "pandoc " (buffer-file-name) " -o "
                           (replace-regexp-in-string "md" "pdf" (buffer-file-name)))))

  (defun update-other-buffer ()
    (interactive)
    (other-window 1)
    (revert-buffer nil t)
    (other-window -1))

  (defun md-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a markdown-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (md-compile)
    (update-other-buffer))

  (defun latex-compile-and-update-other-buffer ()
    "Has as a premise that it's run from a latex-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (save-buffer)
    (shell-command (concat "pdflatex " (buffer-file-name)))
    (switch-to-buffer (other-buffer))
    (kill-buffer)
    (update-other-buffer))

  (defun org-compile-beamer-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-beamer-export-to-pdf)
    (update-other-buffer))

  (defun org-compile-latex-and-update-other-buffer ()
    "Has as a premise that it's run from an org-mode buffer and the
     other buffer already has the PDF open"
    (interactive)
    (org-latex-export-to-pdf)
    (update-other-buffer))

  (eval-after-load 'latex-mode
    '(define-key latex-mode-map (kbd "C-c r") 'latex-compile-and-update-other-buffer))

  (define-key org-mode-map (kbd "C-c lr") 'org-compile-latex-and-update-other-buffer)
  (define-key org-mode-map (kbd "C-c br") 'org-compile-beamer-and-update-other-buffer)

  (eval-after-load 'markdown-mode
    '(define-key markdown-mode-map (kbd "C-c r") 'md-compile-and-update-other-buffer))
#+END_SRC

#+RESULTS:

** Helper function to measure the running time of a function

For example =(measure-time (prettier-eslint))=.
#+BEGIN_SRC emacs-lisp
  (defmacro measure-time (&rest body)
    "Measure the time it takes to evaluate BODY."
    `(let ((time (current-time)))
       ,@body
       (message "%.06f" (float-time (time-since time)))))
#+END_SRC

#+RESULTS:
: measure-time
** Repeatable key chords (repeat-mode)

Emacs28 comes with a built-in utility for repeating selected commands in
a more convenient fashion.  Once =repeat-mode= is enabled, a key binding
or chord that invokes a command successfully can be repeated by typing
in its tail or whatever the developer specifies.  So =other-window= may be
used like this: =C-x o=, =o=, =o= to switch three windows, instead of =C-x o=,
=C-x o=, =C-x o=.

This is achieved by furnishing transient keymaps that get activated
right after the command they belong to and only once the command in
question has been added to the =repeat-map=.  Here is a sample from
=window.el=:

#+begin_example emacs-lisp :tangle no
(defvar resize-window-repeat-map
  (let ((map (make-sparse-keymap)))
    ;; Standard keys:
    (define-key map "^" 'enlarge-window)
    (define-key map "}" 'enlarge-window-horizontally)
    (define-key map "{" 'shrink-window-horizontally) ; prot note: those three are C-x KEY
    ;; Additional keys:
    (define-key map "v" 'shrink-window) ; prot note: this is not bound by default
    map)
  "Keymap to repeat window resizing commands.  Used in `repeat-mode'.")
(put 'enlarge-window 'repeat-map 'resize-window-repeat-map)
(put 'enlarge-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window-horizontally 'repeat-map 'resize-window-repeat-map)
(put 'shrink-window 'repeat-map 'resize-window-repeat-map)
#+end_example

Once the keymap exists and its commands are in the =repeat-map=, such as
with the above example, we do not have to recreate the entire setup if
all we need is to change key bindings: we just have to rebind the
commands to where it makes sense for us.  I actually do this for
=resize-window-repeat-map= ([[#h:3d8ebbb1-f749-412e-9c72-5d65f48d5957][Window rules and basic tweaks (window.el)]]).

At any rate, all we need here is to activate =repeat-mode= and then
implement the repetition mechanism wherever we want.

The =repeat= command is bound by default to =C-x z=, with =s-z= serving as my
alias for it (read [[#h:fbba4dea-9cc8-4e73-bffa-02aab10a6703][What is the meaning of the `s-KEY' bindings?]]).  With
the two variables I set in the following configurations, I make it so
that subsequent repetitions require only hitting another =z=.  Depending
on what you do, a =repeat= can save you from multiple key presses.  For
more demanding tasks you are better off with keyboard macros.

*Pro tip:* to make a keyboard macro out of your most recent commands, use
=C-x C-k l= which calls =kmacro-edit-lossage=.  The list is editable, so
remove any line that is not required and then save what is left.  The
result is stored as the latest keyboard macro (and you also have the
power to cycle through kmacros, store them in specific keys, etc.).

Moving on to the mark, which is affected by =set-mark-command-repeat-pop=,
practically every Emacs motion that operates on a portion of text will
set the mark automatically.  You can also do it manually with =C-SPC= (hit
it twice if you do not wish to activate the region).  It is then
possible to cycle through the marks in reverse order by passing a prefix
argument =C-u C-SPC=.  With =set-mark-command-repeat-pop= we can continue
cycling by repeated presses of =C-SPC=.  Again though, this is not the
type of functionality I rely on: for more deliberate actions of this
sort, consider Emacs' registers or bookmarks.

#+begin_src emacs-lisp
;;; Repeatable key chords (repeat-mode)
(use-package! repeat
  :config
  (setq repeat-on-final-keystroke t)
  (setq set-mark-command-repeat-pop t)

  (repeat-mode 1))
#+end_src
** Etrace

The /Emacs Lisp Profiler/ (ELP) does a nice job recording information, but it
isn't the best for looking at results. =etrace= converts ELP's results to the
"Chromium Catapult Trace Event Format". This means that the output of =etrace= can
be loaded in something like the [[https://www.speedscope.app/][speedscope]] webapp for easier profile
investigation.

#+begin_src emacs-lisp :tangle no
(package! etrace :recipe (:host github :repo "aspiers/etrace"))
#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! etrace
  :after elp)

#+end_src

** DONE Eros
CLOSED: [2022-03-30 Wed 15:16]
#+begin_quote
From the =:tools eval= module.
#+end_quote

This package enables the very nice inline evaluation with =gr= and =gR=. The prefix
could be slightly nicer though.
#+begin_src emacs-lisp
(setq eros-eval-result-prefix "⟹ ") ; default =>
#+end_src

#+RESULTS:
: ⟹

** DONE Tools for manual pages (manpages)
CLOSED: [2022-03-30 Wed 15:08]
:PROPERTIES:
:CUSTOM_ID: h:ce420306-c40c-4d9a-bc01-205c5e49a5d1
:END:

Emacs offers a couple of commands for reading manual pages: =man= and
=woman=.  The former relies on the standard Unix tools, while the latter
is an elisp implementation of the same idea.  As I only ever run a
GNU/Linux system, I am okay with just =man=.

Why bother?

+ All the goodies of consistency: fonts, themes, operating on text with
  your familiar Emacs functionality, handling buffers…
+ Each manpage provides direct links to other items it references.

What you can do inside such a buffer (with minor tweaks by me):

+ Hit =i= to go to the information node you want using completion (same
  principle as with the Info pages of =C-h i= and the like).
+ =g= will generate the buffer anew.  Do it to reformat the text manually,
  though this should also happen automatically when adjusting a window's
  size.
+ =n= and =p= move between section headings.
+ Hit =RET= while over a referenced manpage to produce a new buffer with
  its contents.
+ =s= takes you directly to the familiar "See Also" section.
+ Use =m= or =j= to search for another manpage using your completion framework.
  If you invoke this command while point is over a referenced manpage,
  it becomes the default choice (same concept as with common help
  commands, =C-h f=, =C-h v=, and with many others like =find-library=).

Need to filter out those =man= buffers?  Check [[#h:06290f9c-491c-45b2-b213-0248f890c83d][my Ibuffer entry]].

While there are customisation options for this tool, I find the defaults
to work as expected.  Note that the capitalisation of those symbols is
canonical.

#+begin_src emacs-lisp
;;; Tools for manual pages (manpages)
(use-package! man
   :ensure nil
  :config
  (let ((map Man-mode-map))
    (define-key map (kbd "i") #'Man-goto-section)
    (define-key map (kbd "g") #'Man-update-manpage)))
(evil-define-key 'normal Info-mode-map (kbd "n") 'Info-next)
(evil-define-key 'normal Info-mode-map (kbd "p") 'Info-prev)
(evil-define-key 'normal Info-mode-map (kbd "H") 'Info-up)
(evil-define-key 'normal Info-mode-map (kbd "f") 'Info-goto-node)
(evil-define-key 'normal Info-mode-map (kbd "C-f") 'Info-menu)
#+end_src

#+RESULTS:

** DONE Which-key
CLOSED: [2022-03-30 Wed 10:22]

#+begin_src emacs-lisp :tangle no

(setq which-key-idle-delay 0.3) ;; I need the help, I really do
(setq which-key-idle-secondary-delay 0.05)
(setq which-key-max-description-length 27)

(setq which-key-add-column-padding 0)

(setq which-key-max-display-columns 7)

(setq which-key-separator " " )
(setq which-key-unicode-correction 2)

(setq which-key-prefix-prefix "+" )

(setq which-key-special-keys '("SPC" "TAB" "RET" "ESC" "DEL"))
;; (setq which-key-special-keys nil)

(setq which-key-show-prefix 'left)

;; (setq which-key-show-remaining-keys 't)
  (use-package! which-key
    :after which-key
    :config
    ;; (advice-add 'repeat-post-hook :after
    ;;             (defun my/which-key-repeat ()
    ;;               (when-let ((cmd (or this-command real-this-command))
    ;;                          (keymap (repeat--command-property 'repeat-map)))
    ;;                 (run-at-time
    ;;                  which-key-idle-delay nil
    ;;                  (lambda ()
    ;;                    (which-key--create-buffer-and-show
    ;;                     nil (symbol-value keymap)))))))

    (defun my/which-key-repeat-mode-dispatch ()
      (interactive)
      (setq this-command last-command)
      (when-let (keymap (repeat--command-property 'repeat-map))
        (which-key--create-buffer-and-show
         nil (symbol-value keymap))))


    (defun my/which-key-repeat-mode-binding ()
      (when repeat-mode
        (when-let* ((rep-map-sym (or repeat-map (repeat--command-property 'repeat-map)))
                    (keymap (and (symbolp rep-map-sym) (symbol-value rep-map-sym))))
          (set-transient-map
           (let ((map (make-sparse-keymap)))
             (set-keymap-parent map keymap)
             (define-key map (kbd "C-h") #'my/which-key-repeat-mode-dispatch)
             map)))))
    (advice-add 'repeat-post-hook :after #'my/which-key-repeat-mode-binding))
#+end_src

#+RESULTS:
: t

I also think that having =evil-= appear in so many popups is a bit too verbose,
let's change that, and do a few other similar tweaks while we're at it.
#+begin_src emacs-lisp
(setq which-key-allow-multiple-replacements t)
(after! which-key
  (pushnew!
   which-key-replacement-alist
   '(("" . "\\`+?evil[-:]?\\(?:a-\\)?\\(.*\\)") . (nil . "◂\\1"))
   '(("\\`g s" . "\\`evilem--?motion-\\(.*\\)") . (nil . "◃\\1"))
   ))
#+end_src

* DONE Media
CLOSED: [2022-03-30 Wed 09:28]
** EMMS
One of the media players available for Emacs is emms, which stands for Emacs Multimedia System.  By default, Doom Emacs does not use 'SPC a',' so the format I use for these bindings is 'SPC a' plus 'key'.

| COMMAND               | DESCRIPTION                     | KEYBINDING |
|-----------------------+---------------------------------+------------|
| emms-playlist-mode-go | /Switch to the playlist buffer/   | SPC a a    |
| emms-pause            | /Pause the track/                 | SPC a x    |
| emms-stop             | /Stop the track/                  | SPC a s    |
| emms-previous         | /Play previous track in playlist/ | SPC a p    |
| emms-next             | /Play next track in playlist/     | SPC a n    |

#+begin_src emacs-lisp

(emms-all)
(emms-default-players)
(require 'emms-mode-line)
(emms-mode-line 1)
(require 'emms-playing-time)
(emms-playing-time-mode 1)
(use-package! versuri
  :config
  (defun my/versuri-select ()
    (interactive)
    (when-let (match (call-interactively #'versuri-search))
      (apply #'versuri-display match))))

(use-package! emms
  :commands (emms)
  :bind ("C-c e" . hydra-emms/body)
  :config
  (setq emms-source-file-default-directory "~/Music/"
        emms-mode-line-format "「%s」"
        emms-playlist-buffer-name "*Music*"
        emms-info-asynchronously t
        emms-show-format "NP: %s"
        emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find
        emms-browser-covers 'emms-browser-cache-thumbnail-async
        emms-player-list '(emms-player-mpv)
        emms-player-mpv-environment '("PULSE_PROP_media.role=music")
        emms-player-mpv-parameters '("--quiet" "--really-quiet" "--no-audio-display" "--force-window=no" "--vo=null")
        emms-browser-thumbnail-small-size 64
        emms-browser-thumbnail-medium-size 128)
       (emms-browser-make-filter "all" #'ignore)
       (emms-browser-make-filter "recent"
          (lambda (track) (< 30
             (time-to-number-of-days
       (time-subtract (current-time)
             (emms-info-track-file-mtime track))))))
       (emms-browser-set-filter (assoc "all" emms-browser-filters))
       ;; libre-fm
       ;; (emms-librefm-scrobbler-enable)

  (require 'emms-setup)
  (emms-all)
  ;; (emms-default-players)
  (emms-playing-time-disable-display)

  (add-to-list 'emms-player-base-format-list "opus")
  ;; re-compute the regxp for mpv
  (emms-player-set emms-player-mpv 'regex
                   (apply #'emms-player-simple-regexp emms-player-base-format-list))


;; ;; setup-mpd --not using cz having weird issues in runit
;; (require 'emms-player-mpd)

;; ;;Set the variables emms-player-mpd-server-name and emms-player-mpd-server-port to the location and port (respectively) of your MusicPD server. For example:

;; (setq emms-player-mpd-server-name "localhost")
;; (setq emms-player-mpd-server-port "6600")

;; ;;If your MusicPD setup requires a password, you will to set emms-player-mpd-server-password as follows.

;; ;; (setq emms-player-mpd-server-password "mypassword")

;; ;;Adding ‘emms-player-mpd’ to your Emms player list is accomplished by invoking:
;; (add-to-list 'emms-player-list 'emms-player-mpd)

  ;; save on quit and recover on startup
  (require 'emms-history)
  (emms-history-load)

  ;; use libtag to extract tracks info.
  ;;
  ;; XXX: this needs to be compiled from sources
  ;; (~/.emacs.d/straight/repos/emms/) and cp emms-print-metadata
  ;; ~/bin.
  (require 'emms-info-tinytag)
  ;; (require 'emms-info)
  ;; (require 'emms-info-libtag)
  ;; Choose one of these
  (setq emms-info-functions '(emms-info-tinytag))  ;; When using Tinytag pip install tinytag ,,you can check by python -m tinytag songlocation/songname
  ;; (setq emms-info-functions '(emms-info-exiftool)) When using Exiftool

;;To get track information from MusicPD, invoke the following:

;; (add-to-list 'emms-info-functions 'emms-info-mpd)


  ;; (setq emms-info-libtag-known-extensions
  ;;       (regexp-opt '("opus" "mp3" "mp4" "m4a" "ogg" "flac" "spx" "wma")))

 ;; emms mark -- some dired like stuff
 ;; (require 'emms-mark)
 ;; (setq emms-playlist-default-major-mode 'emms-mark-mode)

;; emms filters
;; Show everything:

(emms-browser-make-filter "all" 'ignore)

;; Set "all" as the default filter:

(emms-browser-set-filter (assoc "all" emms-browser-filters))

;; Show all files (no streamlists, etc):

(emms-browser-make-filter
 "all-files" (emms-browser-filter-only-type 'file))

;; Show only tracks in one folder:

(emms-browser-make-filter
 "90s" (emms-browser-filter-only-dir "~/Music/90s"))

;; Show all tracks played in the last month:

(emms-browser-make-filter
 "last-month" (emms-browser-filter-only-recent 30))

;; After executing the above commands, you can use M-x emms-browser-show-all, emms-browser-show-80s, etc to toggle between different collections. Alternatively you can use ’<’ and ’>’ to cycle through the available filters.
;; The second argument to make-filter is a function which returns t if a single track should be filtered. You can write your own filter functions to check the type of a file, etc.
;; Show only tracks not played in the last year:

(emms-browser-make-filter "not-played"
 (lambda (track)
  (not (funcall (emms-browser-filter-only-recent 365) track))))

;; Show all files that are not in the pending directory:


(emms-browser-make-filter
 "all"
 (lambda (track)
   (or
    (funcall (emms-browser-filter-only-type 'file) track)
    (not (funcall
          (emms-browser-filter-only-dir "~/Music/pending") track)))))

;To show a ’no cover’ image for albums which don’t have a cover, add the following code to your .emacs:
 ;; Suggested sizes are 100x100 for small, and 200x200 for medium.
(setq emms-browser-default-covers
  (list "/path/to/cover_small.jpg" nil nil))
; Customize emms-browser-covers to configure how EMMS should retrieve the covers.
;; Changing Looks
;; The Browser’s look can be customised. You can change the way the tree structure looks, the display format and display faces.
;; Changing Tree Structure
;; You can change the way the tree is displayed by modifying the function emms-browser-next-mapping-type.
;; The following code displays artist->track instead of artist->album->track when you switch to the ’singles’ filter:

(defadvice emms-browser-next-mapping-type
                                (after no-album (current-mapping))
  (when (eq ad-return-value 'info-album)
    (setq ad-return-value 'info-title)))

(defun toggle-album-display ()
  (if (string= emms-browser-current-filter-name "singles")
      (ad-activate 'emms-browser-next-mapping-type)
    (ad-deactivate 'emms-browser-next-mapping-type)))

(add-hook 'emms-browser-filter-changed-hook 'toggle-album-display)
;; Furthermore, you can customize emms-browser-get-track-field-function to choose which the metadata fields used for the different tree nodes ('info-artist, info-year, etc.). For instance, you can choose whether to organize the tree by artist, album artist or performer.

;; Changing Display Format

;; Format strings govern the way items are displayed in the browser and playlist. You can customize these if you wish.
;; emms-browser-default-format controls the format to use when no other format has been explicitly defined. By default, only track and albums deviate from the default.
;; To customise the format of a particular type, find the name of the field you want to use (eg ‘info-artist’, ‘info-title’, etc), and insert that into emms-browser-<type>-format or emms-browser-playlist-<type>-format. For example, if you wanted to remove track numbers from tracks in both the browser and playlist, you could do:

(defvar emms-browser-info-title-format "%i%n")
(defvar emms-browser-playlist-info-title-format
  emms-browser-info-title-format)

;; The format specifiers available include:

    ;; %i indent relative to the current level
    ;; %n the value of the item - eg -info-artist might be “pink floyd”
    ;; %y the album year
    ;; %A the album name
    ;; %a the artist name of the track
    ;; %t the title of the track
    ;; %T the track number
    ;; %cS a small album cover
    ;; %cM a medium album cover
    ;; %cL a big album cover

;; Note that if you use track-related items like %t, it will take the data from the first track.
;; Changing Display Faces
;; The faces used to display the various fields are also customizable. They are in the format emms-browser-<type>-face, where type is one of "year/genre", "artist", "album" or "track". Note that faces lack the initial "info-" part. For example, to change the artist face, type M-x customize-face emms-browser-artist-face.

;; Normally emms-history only restores playlists. If you want it to start playback afterwards, you can tweak this variable.
;; User Option: emms-history-start-playing
    ;; If non-nil emms starts playing the current track after ‘emms-history-load’ was invoked. The default value is nil.



;;Unless your MusicPD is configured to use absolute file names, you must set the emms-player-mpd-music-directory variable to the value of ’music_directory’ in your MusicPD configuration. There are additional options available as well, but the defaults should be sufficient for most uses.
;;Once you’ve done the above, run the M-x emms-cache-set-from-mpd-all command to fill the Emms cache with the contents of your MusicPD database. The music in your MusicPD database should then be accessible via the Emms browser.
;;You can set emms-player-mpd-sync-playlist to nil if your master Emms playlist contains only stored playlists.

  (defun my/tick-symbol (x)
    "Return a tick if X is true-ish."
    (if x "x" " "))

  (defun my/emms-player-status ()
    "Return the state of the EMMS player: `not-active', `playing', `paused' or `dunno'.

Modeled after `emms-player-pause'."
    (cond ((not emms-player-playing-p)
           ;; here we should return 'not-active.  The fact is that
           ;; when i change song, there is a short amount of time
           ;; where we are ``not active'', and the hydra is rendered
           ;; always during that short amount of time.  So we cheat a
           ;; little.
           'playing)

          (emms-player-paused-p
           (let ((resume (emms-player-get emms-player-playing-p 'resume))
                 (pause (emms-player-get emms-player-playing-p 'pause)))
             (cond (resume 'paused)
                   (pause  'playing)
                   (t      'dunno))))
          (t (let ((pause (emms-player-get emms-player-playing-p 'pause)))
               (if pause 'playing 'dunno)))))

  (defun my/emms-toggle-time-display ()
    "Toggle the display of time information in the modeline"
    (interactive)
    (if emms-playing-time-display-p
        (emms-playing-time-disable-display)
      (emms-playing-time-display-mode)))

  (defun my/emms-select-song ()
    "Select and play a song from the current EMMS playlist."
    (interactive)
    (with-current-emms-playlist
      (emms-playlist-mode-center-current)
      (let* ((current-line-number (line-number-at-pos))
             (lines (cl-loop
                     with min-line-number = (line-number-at-pos (point-min))
                     with buffer-text-lines = (split-string (buffer-string) "\n")
                     with lines = nil
                     for l in buffer-text-lines
                     for n = min-line-number then (1+ n)
                     do (push (cons l n)
                              lines)
                     finally return (nreverse lines)))
             (selected-line (completing-read "Song: " lines)))
        (when selected-line
          (let ((line (cdr (assoc selected-line lines))))
            (goto-line line)
            (emms-playlist-mode-play-smart)
            (emms-playlist-mode-center-current))))))

  (defun my/emms-current-lyrics ()
    "Find the lyrics for the current song."
    (interactive)
    (let* ((track  (cdr (emms-playlist-current-selected-track)))
           (artist (cdr (assoc 'info-artist (cdr (emms-playlist-current-selected-track)))))
           (title  (cdr (assoc 'info-title (cdr (emms-playlist-current-selected-track))))))
      (versuri-display artist title)))

  (defhydra hydra-emms (:hint nil)
    "
%(my/emms-player-status) %(emms-track-description (emms-playlist-current-selected-track))

^Volume^     ^Controls^       ^Playback^              ^Misc^
^^^^^^^^----------------------------------------------------------------
_d_: inc     _n_: next        _r_: repeat one [% s(my/tick-symbol emms-repeat-track)]     _t_oggle modeline
_o_: dec     _c_: prev        _R_: repeat all [% s(my/tick-symbol emms-repeat-playlist)]     _T_oggle only time
_v_: vol     _a_: seek bw     _#_: shuffle            _s_elect
^ ^          _h_: seek fw     _%_: sort               _g_oto EMMS buffer
^ ^        _SPC_: play/pause                        _l_yrics
^ ^        _DEL_: restart                           _L_yrics select
  "
    ;; ("v" sndio-win-open :exit t)
    ;; ("d" emms-volume-raise)
    ;; ("o" emms-volume-lower)
    ("d" my/volume-increase)
    ("o" my/volume-decrease)
    ("m" my/volume-mute)
    ("M" my/volume-unmute)
    ("v" my/set-volume)
    ("n" emms-next)
    ("c" emms-previous) ;;blame my keyboard layout for not beign mnemonic
    ("a" emms-seek-backward)
    ("h" emms-seek-forward)
    ("SPC" emms-pause)
    ;; ("n" emms-player-mpd-next)
    ;; ("c" emms-player-mpd-previous)
    ;; ("a" emms-player-mpd-seek)
    ;; ("h" emms-player-mpd-seek)
    ;; ("SPC" emms-player-mpd-pause)
    ("DEL" (emms-player-seek-to 0))
    ("<backspace>" (emms-player-seek-to 0))
    ("r" emms-toggle-repeat-track)
    ("R" emms-toggle-repeat-playlist)
    ("#" emms-shuffle)
    ("%" emms-sort)
    ("t" (progn (my/emms-toggle-time-display)
                (emms-mode-line-toggle)))
    ("T" my/emms-toggle-time-display)
    ("s" my/emms-select-song)
    ("g" (progn (emms)
                (with-current-emms-playlist
                  (emms-playlist-mode-center-current))))
    ("l" my/emms-current-lyrics :exit t)
    ("L" my/versuri-select :exit t)

    ("q" nil :exit t)))

#+end_src

#+RESULTS:
: hydra-emms/body

#+begin_src emacs-lisp

(defun track-title-from-file-name (file)
  "For using with EMMS description functions. Extracts the track
title from the file name FILE, which just means a) taking only
the file component at the end of the path, and b) removing any
file extension."
  (with-temp-buffer
    (save-excursion (insert (file-name-nondirectory (directory-file-name file))))
    (ignore-error 'search-failed
      (search-forward-regexp (rx "." (+ alnum) eol))
      (delete-region (match-beginning 0) (match-end 0)))
    (buffer-string)))

(defun my-emms-track-description (track)
  "Return a description of TRACK, for EMMS, but try to cut just
the track name from the file name, and just use the file name too
rather than the whole path."
  (let ((artist (emms-track-get track 'info-artist))
        (title (emms-track-get track 'info-title)))
    (cond ((and artist title)
           ;; Converting the artist/title to a string works around a bug in `emms-info-exiftool'
           ;; where, if your track name is a number, e.g. "1999" by Jeroen Tel, then it will be an
           ;; integer type here, confusing everything.
           ;;
           ;; I would fix the bug properly and submit a patch but I just cannot be bothered to
           ;; figure out how to do that.
           (concat (format "%s" artist) " - " (format "%s" title)))
          (title title)
          ((eq (emms-track-type track) 'file)
           (track-title-from-file-name (emms-track-name track)))
          (t (emms-track-simple-description track)))))

(setq emms-track-description-function 'my-emms-track-description)
#+end_src
#+RESULTS:
: my-emms-track-description

#+BEGIN_SRC emacs-lisp :tangle no
;; just in case above config breaks
(emms-all)
(emms-default-players)
(emms-mode-line-mode 1)
(emms-playing-time 1)
(setq emms-source-file-default-directory "~/Music/"
      emms-playlist-buffer-name "*Music*"
      emms-info-asynchronously t
      emms-source-file-directory-tree-function 'emms-source-file-directory-tree-find)
(map! :leader
      (:prefix ("y" . "EMMS audio player")
       :desc "Go to emms playlist" "a" #'emms-playlist-mode-go
       :desc "Emms pause track" "x" #'emms-pause
       :desc "Emms stop track" "s" #'emms-stop
       :desc "Emms play previous track" "p" #'emms-previous
       :desc "Emms play next track" "n" #'emms-next))
#+END_SRC

** emms dbus notification
#+begin_src emacs-lisp :tangle no
; choose D-Bus to disseminate messages, if it is running.
(cond
 ;; test to see if D-Bus notifications are available
 ((if (and (require 'dbus nil t)
	   (dbus-ping :session "org.freedesktop.Notifications"))
      (progn
	(setq notify-method 'notify-via-dbus-notifications)
	(require 'notifications))))
 ;; could use the message system otherwise
 (t (setq notify-method 'notify-via-message)))

(defun notify-via-notifications (title msg icon)
  "Send notification with TITLE, MSG via `D-Bus'."
  (notifications-notify
   :title title
   :body msg
   :app-icon icon
   :urgency 'low))

(defun notify-via-messages (title msg)
  "Send notification with TITLE, MSG to message."
  (message "APPOINTMENT: %s" msg))

(defun emms-notifications-dbus (track-name)
  "Share track name via `D-Bus'."
  (let ((icon "/usr/share/icons/gnome/24x24/categories/applications-multimedia.png"))
    (notify-via-notifications "EMMS is now playing:" track-name icon)))

(defun emms-notifications-message (track-name)
  "Share track name via Emacs minibuffer."
  (message "EMMS is now playing: %s" track-name))

(defun emms-start ()
  "Start playing the current track in the EMMS playlist."
  (interactive)
  (unless emms-player-playing-p
    (emms-player-start (emms-playlist-current-selected-track)))
  (let ((track-name (emms-track-description (emms-playlist-current-selected-track))))
    (cond
     ((eq notify-method 'notify-via-dbus-notifications)
      (emms-notifications-dbus track-name))
     (t (emms-notifications-message track-name)))))
#+end_src

#+RESULTS:
: emms-start

** emms kdialog notification (not the pleasing)

#+begin_src emacs-lisp :tangle no
;;;   Tested on void
(when (and window-system (executable-find "kdialog"))
  (setq emms-player-next-function
        (lambda ()
          (emms-next)
          (call-process "kdialog" nil nil nil "--title" "Emacs - EMMS"
                        "--passivepopup" (emms-show) "5"))))

(defun emms-next ()
  "Start playing the next track in the EMMS playlist.
This might behave funny if called from `emms-player-next-function',
so use `emms-next-noerror' in that case."
  (interactive)
  (when emms-player-playing-p
    (emms-stop))
  (emms-playlist-current-select-next)
  (emms-start)
          (call-process "kdialog" nil nil nil "--title" "Emacs - EMMS"
                        "--passivepopup" (emms-show) "5"))
#+end_src
** volume
#+begin_src emacs-lisp
(setq my/volume-min 1)
(setq my/volume-max 100)
(setq my/volume-step 5)

(defun my/get-volume ()
  (* my/volume-step (round (string-to-number
                                ;; (shell-command-to-string "awk -F\"[][]\" '/dB/ { print $2 }' <(amixer sget Master)"))
                                ;; (shell-command-to-string "awk -F\"[][]\" '/dB/ { print $2 }' <(pamixer --get-volume)"))
                                (shell-command-to-string "pamixer --get-volume"))
                               my/volume-step)))


(defun my/set-volume (level)
  (interactive "nVolume level: ")
  (let ((clipped-level
         (cond ((< level my/volume-min) my/volume-min)
               ((> level my/volume-max) my/volume-max)
               (t level))))
    (save-window-excursion
      (shell-command
       ;; (format "amixer set Master %s%% &" clipped-level) nil nil))))
       (format "pamixer --set-volume %s &" clipped-level) nil nil))))

(defun my/volume-mute()
  (interactive)
    (save-window-excursion
      (shell-command
       (format "pamixer --mute &" ))))

(defun my/volume-unmute()
  (interactive)
    (save-window-excursion
      (shell-command
       (format "pamixer --unmute &" ))))

(defun my/volume-step-change (delta)
  (my/set-volume (+ delta (my/get-volume))))

(defun my/volume-increase ()
  (interactive)
  (my/volume-step-change my/volume-step))

(defun my/volume-decrease ()
  (interactive)
  (my/volume-step-change (- my/volume-step)))

;; (map! "<XF86AudioRaiseVolume>" 'my/volume-increase)
;; (map! "<XF86AudioLowerVolume>" 'my/volume-decrease)
#+end_src

#+RESULTS:
: my/volume-decrease
** brightness (xradr)
#+begin_src emacs-lisp

(setq my/brightness-min .3)
(setq my/brightness-max 1)

(defun my/brightness (level)
  (interactive "nBrightness level: ")
  (let ((clipped-level
         (cond ((< level my/brightness-min) my/brightness-min)
               ((> level my/brightness-max) my/brightness-max)
               (t level))))
    (save-window-excursion
      (shell-command
       (format "xrandr --output DP-1 --brightness %s &" clipped-level) nil nil))))
#+end_src

#+RESULTS:
: my/brightness
** pipewire start
#+begin_src emacs-lisp

(defun my/pipewire-start()
  (interactive)
    (save-window-excursion
      (shell-command
       (format "pipewire & pipewire-pulse &" ))))


(defun my/pipewire-kill()
  (interactive)
    (save-window-excursion
      (shell-command
       (format "killall pipewire & killall pipewire-pulse  &" ))))
#+end_src

#+RESULTS:
: my/pipewire-restart

** mpv and emacs

mpv.el and org-timers modified to work with milliseconds

*** mpv show miliseconds in osd

edit your ~/.config/mpv/mpv.conf file
and add the following code to show miliseconds in the osd

#+BEGIN_EXAMPLE
osd-fractions
#+END_EXAMPLE

then press capital O in mpv to show the time

*** mpv and org timers code

#+begin_src emacs-lisp
;; mpv.el --------------------------------------------------------------------------------------------------

(org-link-set-parameters "mpv" :follow #'mpv-play)
(defun org-mpv-complete-link (&optional arg)
  (replace-regexp-in-string
   "file:" "mpv:"
   (org-link-complete-file arg)
   t t))

;; M-RET will insert a new item with the timestamp of the current playback position
(defun my:mpv/org-metareturn-insert-playback-position ()
  (when-let ((item-beg (org-in-item-p)))
    (when (and (not org-timer-start-time)
               (mpv-live-p)
               (save-excursion
                 (goto-char item-beg)
                 (and (not (org-invisible-p)) (org-at-item-timer-p))))
      (my/mpv-insert-playback-position t))))
(add-hook 'org-metareturn-hook #'my:mpv/org-metareturn-insert-playback-position)

;; mpv insert playback position
(with-eval-after-load 'mpv
  (defun my/mpv-insert-playback-position (&optional arg)
    "Insert the current playback position at point.

  When called with a non-nil ARG, insert a timer list item like `org-timer-item'."
    (interactive "P")
    (let ((time (mpv-get-playback-position)))
      (funcall
       (if arg #'mpv--position-insert-as-org-item #'insert)
       (my/org-timer-secs-to-hms (float time))))))


;; seek to position
(with-eval-after-load 'mpv
  (defun my/mpv-seek-to-position-at-point ()
    "Jump to playback position as inserted by `mpv-insert-playback-position'.

  This can be used with the `org-open-at-point-functions' hook."
    (interactive)
    (save-excursion
      (skip-chars-backward ":[:digit:]" (point-at-bol))
      (when (looking-at "[0-9]+:[0-9]\\{2\\}:[0-9]\\{2\\}\\([.]?[0-9]\\{0,3\\}\\)"))
        (let ((secs (my/org-timer-hms-to-secs (match-string 0))))
          (when (>= secs 0)
            (mpv-seek secs))))))

;; mpv seek to position at point
(define-key global-map (kbd "C-x ,") 'my/mpv-seek-to-position-at-point)

;; org-timer milliseconds for mpv ----------------------------------------------------------

;; org-timer covert seconds and milliseconds to hours, minutes, seconds, milliseconds
(with-eval-after-load 'org-timer
  (defun my/org-timer-secs-to-hms (s)
    "Convert integer S into hh:mm:ss.m
  If the integer is negative, the string will start with \"-\"."
    (let (sign m h)
      (setq x (number-to-string s)
            seconds (car (split-string x "[.]"))
            milliseconds (cadr (split-string x "[.]"))
            sec (string-to-number seconds)
            ms (string-to-number milliseconds))
      (setq sign (if (< sec 0) "-" "")
  	  sec (abs sec)
  	  m (/ sec 60) sec (- sec (* 60 m))
  	  h (/ m 60) m (- m (* 60 h)))
      (format "%s%02d:%02d:%02d.%02d" sign h m sec ms))))

;; org-timer covert hours, minutes, seconds, milliseconds to seconds, milliseconds
(with-eval-after-load 'org-timer
  (defun my/org-timer-hms-to-secs (hms)
    "Convert h:mm:ss string to an integer time.
  If the string starts with a minus sign, the integer will be negative."
    (if (not (string-match
  	    "\\([-+]?[0-9]+\\):\\([0-9]\\{2\\}\\):\\([0-9]\\{2\\}\\)\\([.]?[0-9]\\{0,3\\}\\)"
  	    hms))
        0
      (let* ((h (string-to-number (match-string 1 hms)))
  	   (m (string-to-number (match-string 2 hms)))
  	   (s (string-to-number (match-string 3 hms)))
  	   (ms (string-to-number (match-string 4 hms)))
  	   (sign (equal (substring (match-string 1 hms) 0 1) "-")))
        (setq h (abs h))
        (* (if sign -1 1) (+ s (+ ms (* 60 (+ m (* 60 h))))))))))

;; mpv commands -----------------------------------------------------------------------------------------

;; frame step forward
(with-eval-after-load 'mpv
  (defun mpv-frame-step ()
    "Step one frame forward."
    (interactive)
    (mpv--enqueue '("frame-step") #'ignore)))


;; frame step backward
(with-eval-after-load 'mpv
  (defun mpv-frame-back-step ()
    "Step one frame backward."
    (interactive)
    (mpv--enqueue '("frame-back-step") #'ignore)))


;; mpv take a screenshot
(with-eval-after-load 'mpv
  (defun mpv-screenshot ()
    "Take a screenshot"
    (interactive)
    (mpv--enqueue '("screenshot") #'ignore)))


;; mpv show osd
(with-eval-after-load 'mpv
  (defun mpv-osd ()
    "Show the osd"
    (interactive)
    (mpv--enqueue '("set_property" "osd-level" "3") #'ignore)))


;; add a newline in the current document
(defun end-of-line-and-indented-new-line ()
  (interactive)
  (end-of-line)
  (newline-and-indent))


;; hydra --------------------------------------------------------------------------------------------------

(defhydra hydra-mpv (global-map "<f2>")
  "
  ^Seek^                    ^Actions^                ^General^
  ^^^^^^^^---------------------------------------------------------------------------
  A__: seek back -5         _,_: back frame          _i_: insert playback position
  A__: seek back -60        _._: forward frame       _n_: insert a newline
  H__: seek forward 60      _SPC_: pause             _s_: take a screenshot
  h__: seek forward 5       _q_: quit mpv            _o_: show the osd
  ^
  "
  ("a" mpv-seek-backward "-5")
  ("A" mpv-seek-backward "-60")
  ("h" mpv-seek-forward "60")
  ("h" mpv-seek-forward "5")
  ("," mpv-frame-back-step)
  ("." mpv-frame-step)
  ("SPC" mpv-pause)
  ("q" mpv-kill)
  ("s" mpv-screenshot)
  ("i" my/mpv-insert-playback-position)
  ("o" mpv-osd)
  ("n" end-of-line-and-indented-new-line))
#+end_src

#+RESULTS:
: hydra-mpv/body
* Miscellaneous

#+begin_src emacs-lisp
;; Misc
(defun my/delete-word (arg)
  "Delete characters forward until encountering the end of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (delete-region (point) (progn (forward-word arg) (point))))

(defun my/backward-delete-word (arg)
  "Delete characters backward until encountering the beginning of a word.
With argument ARG, do this that many times."
  (interactive "p")
  (my/delete-word (- arg)))

;; Stolen from: https://stackoverflow.com/questions/2471557/how-to-undo-fill-paragraph-in-emacs
(defun my/unfill-region ()
  (interactive)
  (let ((fill-column (point-max)))
    (fill-region (region-beginning) (region-end) nil)))

(defun my/getenv-tramp (variable &optional keyvalue)
  "Similar to `getenv' but acting on `tramp-remote-process-environment'.
If KEYVALUE is not nil then VARIABLE=VALUE is returned, otherwise
VALUE. When there's no such a VARIABLE set then nil is returned."
  (let ((current-variable-value
        (seq-find (lambda (x)
                       (s-starts-with-p (concat variable "=") x))
                  tramp-remote-process-environment)))
    (when current-variable-value
      (if keyvalue
          current-variable-value
        (car (last (split-string current-variable-value "=")))))))

(defun my/setenv-tramp (variable &optional value)
  "Like `setenv' but acting on `tramp-remote-process-environment'.
Removes the first occurrence of VARIABLE in
`tramp-remote-process-environment' and then adds VARIABLE=VALUE
if VALUE is not nil."
  (setq
   tramp-remote-process-environment
   (delete (my/getenv-tramp variable t)
           tramp-remote-process-environment))
  (when value
    (let ((key-value-pair (format "%s=%s" variable value)))
      (add-to-list 'tramp-remote-process-environment key-value-pair))))

(defun my/switch-to-buffer-if-exists-back-and-forth (to-buffer-name)
  "Switches to to-buffer-name if it exists. If the current buffer is
to-buffer-name then it switches back to the previous buffer."
  (when (get-buffer to-buffer-name)
    (if (string-equal to-buffer-name (buffer-name))
        (switch-to-prev-buffer)
      (switch-to-buffer to-buffer-name))))

(setq my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist nil)
(defun my/bookmark-buffer-or-switch-to-bookmark (arg)
  "Switches to the buffer associated to `last-command-event'.
If there's no mapping configured it sets it. With prefix argument
remaps `last-command-event' to the current buffer. The mapping is
stored in
`my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist'"
  (interactive "P")
  (when arg
    (setq my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist
          (assq-delete-all last-command-event
                           my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist)))
  (let ((buffer (cdr
                 (assq last-command-event
                       my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist))))
    (if buffer
        (if (buffer-live-p buffer)
            (my/switch-to-buffer-if-exists-back-and-forth (buffer-name buffer))
          (ding)
          (message "This buffer has been killed"))
      (add-to-list 'my/bookmark-buffer-or-switch-to-bookmark--bookmarks-alist
                   (cons last-command-event (current-buffer)))
      (with-current-buffer (current-buffer)
        (my/exwm-toggle-or-set-buffer-protection nil t))
      (message (format "Added %s as shortcut for buffer <%s>"
                       (key-description (vector last-command-event))
                       (current-buffer))))))


#+end_src
* Language configuration
** General
*** File Templates

For some file types, we overwrite defaults in the [[file:./snippets][snippets]] directory, others
need to have a template assigned.

#+begin_src emacs-lisp
(set-file-template! "\\.tex$" :trigger "__" :mode 'latex-mode)
(set-file-template! "\\.org$" :trigger "__" :mode 'org-mode)
(set-file-template! "/LICEN[CS]E$" :trigger '+file-templates/insert-license)
#+end_src

** Plaintext
*** Ansi colours

It's nice to see ANSI colour codes displayed, however we don't want to disrupt
ANSI codes in Org src blocks.

#+begin_src emacs-lisp
(after! text-mode
  (add-hook! 'text-mode-hook
    (unless (derived-mode-p 'org-mode)
      ;; Apply ANSI color codes
      (with-silent-modifications
        (ansi-color-apply-on-region (point-min) (point-max) t)))))
#+end_src

*** Margin without line numbers

Display-wise, somehow I don't mind code buffers without any margin on the left,
but it feels a bit off with text buffers once the padding provided by line
numbers is stripped away.

#+begin_src emacs-lisp :tangle no
(defvar +text-mode-left-margin-width 1
  "The `left-margin-width' to be used in `text-mode' buffers.")

(defun +setup-text-mode-left-margin ()
  (when (and (derived-mode-p 'text-mode)
             (eq (current-buffer) ; Check current buffer is active.
                 (window-buffer (frame-selected-window))))
    (setq left-margin-width (if display-line-numbers
                                0 +text-mode-left-margin-width))
    (set-window-buffer (get-buffer-window (current-buffer))
                       (current-buffer))))

#+end_src

#+RESULTS:
: +setup-text-mode-left-margin

Now we just need to hook this up to all the events which could either indicate a
change in the conditions or require the setup to be re-applied.

#+begin_src emacs-lisp :tangle no
(add-hook 'window-configuration-change-hook #'+setup-text-mode-left-margin)
(add-hook 'display-line-numbers-mode-hook #'+setup-text-mode-left-margin)
(add-hook 'text-mode-hook #'+setup-text-mode-left-margin)
#+end_src

#+RESULTS:
| +spell-remove-run-together-switch-for-aspell-h | er/add-text-mode-expansions | auto-fill-mode | +setup-text-mode-left-margin | (lambda (&rest _) (if (derived-mode-p 'org-mode) nil (let* ((modified (buffer-modified-p)) (buffer-undo-list t) (inhibit-read-only t) (inhibit-modification-hooks t)) (unwind-protect (progn (ansi-color-apply-on-region (point-min) (point-max) t)) (if modified nil (restore-buffer-modified-p nil)))))) | flyspell-mode | auto-revert-mode | text-mode-hook-identify |

There's one little niggle with Doom, as ~doom/toggle-line-numbers~ doesn't run
~display-line-numbers-mode-hook~, so some advice is needed.

#+begin_src emacs-lisp :tangle no
(defadvice! +doom/toggle-line-numbers--call-hook-a ()
  :after #'doom/toggle-line-numbers
  (run-hooks 'display-line-numbers-mode-hook))
#+end_src

#+RESULTS:

Lastly, I think I actually like this enough that I'll go ahead and remove line
numbers in text mode.

#+begin_src emacs-lisp :tangle no
(remove-hook 'text-mode-hook #'display-line-numbers-mode)
#+end_src


** ORG MODE
*** Org
Finally, because this section is fairly expensive to initialise, we'll wrap it
in an *src_elisp* {(after! ...)} block.
#+begin_src emacs-lisp :noweb no-export :tangle yes :noweb-ref nil
(after! org
  <<org-conf>>
)
#+end_src
**** DONE System config
CLOSED: [2022-04-01 Fri 19:27]
***** Mime types
Org mode isn't recognised as it's own mime type by default, but that can easily
be changed with the following file. For system-wide changes try
~/usr/share/mime/packages/org.xml~.
#+begin_src xml :tangle ~/.local/share/mime/packages/org.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/org">
    <comment>Emacs Org-mode File</comment>
    <glob pattern="*.org"/>
    <alias type="text/org"/>
  </mime-type>
</mime-info>
#+end_src
What's nice is that Papirus [[https://github.com/PapirusDevelopmentTeam/papirus-icon-theme/commit/a10fb7f2423d5e30b9c4477416ccdc93c4f3849d][now]] has an icon for =text/org=.
One simply needs to refresh their mime database
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src
Then set Emacs as the default editor
#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/org") "emacs-client.desktop\n") "no" "setup.sh")
xdg-mime default emacs.desktop text/org
#+end_src
***** Git diffs
Protesilaos wrote a [[https://protesilaos.com/codelog/2021-01-26-git-diff-hunk-elisp-org/][very helpful article]] in which he explains how to change the
git diff chunk heading to something more useful than just the immediate line
above the hunk --- like the parent heading.

This can be achieved by first adding a new diff mode to git in =~/.config/git/attributes=
#+begin_src fundamental :tangle no
,*.org   diff=org
#+end_src

Then adding a regex for it to =~/.config/git/config=
#+begin_src gitconfig :tangle no
[diff "org"]
  xfuncname = "^(\\*+ +.*)$"
#+end_src

**** Packages
***** DONE Visuals
CLOSED: [2022-04-01 Fri 18:18]
****** Tables

Org tables aren't the prettiest thing to look at. This package is supposed to
redraw them in the buffer with box-drawing characters. Sounds like an
improvement to me! We'll make use of this with =writeroom-mode=.

#+begin_src emacs-lisp :tangle packages.el
(package! org-pretty-table
  :recipe (:host github :repo "Fuco1/org-pretty-table") :pin "7bd68b420d3402826fea16ee5099d04aa9879b78")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-pretty-table
  :commands (org-pretty-table-mode global-org-pretty-table-mode))
#+end_src

****** Emphasis markers
While ~org-hide-emphasis-markers~ is very nice, it can sometimes make edits which
occur at the border a bit more fiddley. We can improve this situation without
sacrificing visual amenities with the =org-appear= package.
#+begin_src emacs-lisp :tangle packages.el
(package! org-appear :recipe (:host github :repo "awth13/org-appear")
  :pin "303fcc8d5d85a4ebff2798dab50b2ccc0255ea5f")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-appear
  :hook (org-mode . org-appear-mode)
  :config
  (setq org-appear-autoemphasis t
        org-appear-autosubmarkers t
        org-appear-autolinks nil)
  ;; for proper first-time setup, `org-appear--set-elements'
  ;; needs to be run after other hooks have acted.
  (run-at-time nil nil #'org-appear--set-elements))
#+end_src

Allows you to jump in and out of latex fragments without using `C-c C-x C-l` all the time, beautiful.
#+begin_src emacs-lisp :tangle no
(use-package! org-fragtog
  :after org
  :hook (org-mode . org-fragtog-mode)
  )

#+end_src
****** Emphasis faces

Custom Highlighting -  so = becomes =red=.
#+begin_src emacs-lisp :tangle no
(after! org
  (setq org-emphasis-alist
        '(("*" (bold))
          ("/" italic)
          ("_" underline)
          ("=" org-verbatim verbatim)
          ("~" org-code verbatim)
          ("=" redd)
          ("~" code)
          ("+"
           (:strike-through t)))))

#+end_src

#+RESULTS:
| * | (bold)              |          |
| _ | underline           |          |
| = | org-verbatim        | verbatim |
| ~ | org-code            | verbatim |
| = | redd                |          |
| ~ | code                |          |
| + | (:strike-through t) |          |

****** Heading structure
Speaking of headlines, a nice package for viewing and managing the heading
structure has come to my attention.
#+begin_src emacs-lisp :tangle packages.el
(package! org-ol-tree :recipe (:host github :repo "Townk/org-ol-tree")
  :pin "207c748aa5fea8626be619e8c55bdb1c16118c25")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-ol-tree
  :commands org-ol-tree
  :config
  (setq org-ol-tree-ui-icon-set
        (if (and (display-graphic-p)
                 (fboundp 'all-the-icons-material))
            'all-the-icons
          'unicode))
  (org-ol-tree-ui--update-icon-set))

(map! :map org-mode-map
      :after org
      :localleader
      :desc "Outline" "O" #'org-ol-tree)
#+end_src

#+RESULTS:

****** Better indirect buffers
Copied from =Thomas Journa='s config to move around org-buffers.

#+begin_src emacs-lisp :tangle yes
(defun +org-tree-to-indirect-buffer-options (option)
    (let* ((old-value org-indirect-buffer-display))
          (progn
            (setq org-indirect-buffer-display option)
          (org-tree-to-indirect-buffer)
          (setq org-indirect-buffer-display old-value))))

(defun +org-tree-to-indirect-other-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'other-window))

(defun +org-tree-to-indirect-current-window ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'current-window))

(defun +org-tree-to-indirect-dedicated-frame ()
  (interactive)
  (+org-tree-to-indirect-buffer-options 'dedicated-frame))
#+end_src
***** Org Modern

Fontifying =org-mode= buffers to be as pretty as possible is of paramount importance,
and Minad's lovely =org-modern= goes a long way in this regard.

#+begin_src emacs-lisp :tangle packages.el
(package! org-modern :pin "59b2e3c94756b4e37b2cf7b9f81028c6d4758672")
#+end_src

...with a touch of configuration...

#+begin_src emacs-lisp :tangle no
(use-package! org-modern
  :hook (org-mode . org-modern-mode)
  :config
  (setq org-modern-star '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-modern-table-vertical 1
        org-modern-table-horizontal 0.2
        org-modern-list '((43 . "➤")
                          (45 . "–")
                          (42 . "•"))
        org-modern-todo-faces
        '(("TODO" :inverse-video t :inherit org-todo)
          ("PROJ" :inverse-video t :inherit +org-todo-project)
          ("STRT" :inverse-video t :inherit +org-todo-active)
          ("[-]"  :inverse-video t :inherit +org-todo-active)
          ("HOLD" :inverse-video t :inherit +org-todo-onhold)
          ("WAIT" :inverse-video t :inherit +org-todo-onhold)
          ("[?]"  :inverse-video t :inherit +org-todo-onhold)
          ("KILL" :inverse-video t :inherit +org-todo-cancel)
          ("NO"   :inverse-video t :inherit +org-todo-cancel))
        org-modern-footnote
        (cons nil (cadr org-script-display))
        org-modern-block-fringe nil
        org-modern-block-name
        '((t . t)
          ("src" "»" "«")
          ("example" "»–" "–«")
          ("quote" "❝" "❞")
          ("export" "⏩" "⏪"))
        org-modern-progress nil
        org-modern-priority nil
        org-modern-horizontal-rule (make-string 36 ?─)
        org-modern-keyword
        '((t . t)
          ("title" . "𝙏")
          ("subtitle" . "𝙩")
          ("author" . "𝘼")
          ("email" . #("" 0 1 (display (raise -0.14))))
          ("date" . "𝘿")
          ("property" . "☸")
          ("options" . "⌥")
          ("startup" . "⏻")
          ("macro" . "𝓜")
          ("bind" . #("" 0 1 (display (raise -0.1))))
          ("bibliography" . "")
          ("print_bibliography" . #("" 0 1 (display (raise -0.1))))
          ("cite_export" . "⮭")
          ("print_glossary" . #("ᴬᶻ" 0 1 (display (raise -0.1))))
          ("glossary_sources" . #("" 0 1 (display (raise -0.14))))
          ("include" . "⇤")
          ("setupfile" . "⇚")
          ("html_head" . "🅷")
          ("html" . "🅗")
          ("latex_class" . "🄻")
          ("latex_class_options" . #("🄻" 1 2 (display (raise -0.14))))
          ("latex_header" . "🅻")
          ("latex_header_extra" . "🅻⁺")
          ("latex" . "🅛")
          ("beamer_theme" . "🄱")
          ("beamer_color_theme" . #("🄱" 1 2 (display (raise -0.12))))
          ("beamer_font_theme" . "🄱𝐀")
          ("beamer_header" . "🅱")
          ("beamer" . "🅑")
          ("attr_latex" . "🄛")
          ("attr_html" . "🄗")
          ("attr_org" . "⒪")
          ("call" . #("" 0 1 (display (raise -0.15))))
          ("name" . "⁍")
          ("header" . "›")
          ("caption" . "☰")
          ("RESULTS" . "🠶")))
  (custom-set-faces! '(org-modern-statistics :inherit org-checkbox-statistics-todo)))
#+end_src

#+RESULTS:
| org-modern-mode | mixed-pitch-mode | org-fragtog-mode | locally-defer-font-lock | +org-pretty-mode | org-ref-org-menu | er/add-org-mode-expansions | turn-on-org-cdlatex | org-appear-mode | elpher-org-mode-integration | auto-revert-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | beginend-org-mode | +lookup--init-org-mode-handlers-h | (closure ((hook . org-mode-hook) (--dolist-tail--) t) (&rest _) (add-hook 'before-save-hook 'org-encrypt-entries nil t)) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-make-last-point-visible-h | org-fancy-priorities-mode | org-superstar-mode | evil-org-mode | toc-org-enable | flyspell-mode | embrace-org-mode-hook | org-eldoc-load | +literate-enable-recompile-h |

Since =org-modern='s tag face supplants Org's tag face, we need to adjust the
spell-check face ignore list

#+begin_src emacs-lisp
(after! spell-fu
  (cl-pushnew 'org-modern-tag (alist-get 'org-mode +spell-excluded-faces-alist)))
#+end_src
**** Behaviour
***** Tweaking defaults
#+begin_src emacs-lisp :tangle yes

(map! :leader
      :desc "Org babel tangle" "m B" #'org-babel-tangle)
#+end_src

#+RESULTS:
: org-babel-tangle

#+begin_src emacs-lisp
(setq org-directory "~/org"                      ; let's put files here
      org-use-property-inheritance t              ; it's convenient to have properties inherited
      org-log-done 'time                          ; having the time a item is done sounds convenient
      org-list-allow-alphabetical t               ; have a. A. a) A) list bullets
      org-export-in-background t                  ; run export processes in external emacs process
      org-export-allow-bind-keywords t     ; Bind keywords can be handy
      org-fold-catch-invisible-edits 'smart            ; try not to accidently do weird stuff in invisible regions
      org-export-with-sub-superscripts '{})       ; don't treat lone _ / ^ as sub/superscripts, require _{} / ^{}


(setq org-use-tag-inheritance nil)
(setq org-startup-indented t)
(setq org-hide-leading-stars t)
(setq org-treat-S-cursor-todo-selection-as-state-change t)
(setq org-hide-emphasis-markers t)
(setq org-support-shift-select t)
(require 'org-inlinetask)
(setq org-image-actual-width nil)
(setq org-time-stamp-custom-formats '("<%A, %B %d, %Y>" . "<%m/%d/%y %a %H:%M>"))
(setq org-archive-location (concat "org/archive-"
                                   (format-time-string "%Y%m" (current-time))
                                   ".org_archive::"))
(with-eval-after-load 'ox
  (require 'ox-pandoc))
(setq org-pandoc-options-for-beamer-pdf '((pdf-engine . "xelatex")))
(setq org-export-with-smart-quotes t)
#+end_src

#+RESULTS:
: t

I also like the src_elisp{:comments} header-argument, so let's make that a
default.
#+begin_src emacs-lisp
(setq org-babel-default-header-args
      '((:session . "none")
        (:results . "replace")
        (:exports . "code")
        (:cache . "no")
        (:noweb . "no")
        (:hlines . "no")
        (:tangle . "no")
        (:comments . "link")))
#+end_src

By default, ~visual-line-mode~ is turned =on=, and ~auto-fill-mode~ =off= by a hook.
However this messes with tables in Org-mode, and other plaintext files (e.g.
markdown, \LaTeX) so I'll turn it off for this, and manually enable it for more
specific modes as desired.
#+begin_src emacs-lisp
(remove-hook 'text-mode-hook #'visual-line-mode)
(add-hook 'text-mode-hook #'auto-fill-mode)
#+end_src

There also seem to be a few keybindings which use =hjkl=, but miss arrow key equivalents.
#+begin_src emacs-lisp
(map! :map evil-org-mode-map
      :after evil-org
      :n "g <up>" #'org-backward-heading-same-level
      :n "g <down>" #'org-forward-heading-same-level
      :n "g <left>" #'org-up-element
      :n "g <right>" #'org-down-element)
#+end_src
***** Extra functionality
****** Org buffer creation
Let's also make creating an org buffer just that little bit easier.
#+begin_src emacs-lisp
(evil-define-command evil-buffer-org-new (count file)
  "Creates a new ORG buffer replacing the current window, optionally
   editing a certain FILE"
  :repeat nil
  (interactive "P<f>")
  (if file
      (evil-edit file)
    (let ((buffer (generate-new-buffer "*new org*")))
      (set-window-buffer nil buffer)
      (with-current-buffer buffer
        (org-mode)))))
(map! :leader
      (:prefix "b"
       :desc "New empty ORG buffer" "o" #'evil-buffer-org-new))
#+end_src
****** The utility of zero-width spaces
Occasionally in Org you run into annoyances where you want to have two seperate
blocks right together without a space. For example, to *emp​h*​asise part of a word,
or put a currency symbol immediately before an inline source block.
There is a solution to this, it just sounds slightly hacky --- zero width spaces.
Because this is Emacs, we can make this feel much less hacky by making a minor
addition to the Org key map 🙂.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :nie "M-SPC M-SPC" (cmd! (insert "\u200B")))
#+end_src

We ​then want to stop the space from being included in exports, which can be done
with a little filter.
#+begin_src emacs-lisp
(defun +org-export-remove-zero-width-space (text _backend _info)
  "Remove zero width spaces from TEXT."
  (unless (org-export-derived-backend-p 'org)
    (replace-regexp-in-string "\u200B" "" text)))

(after! ox
  (add-to-list 'org-export-filter-final-output-functions #'+org-export-remove-zero-width-space t))
#+end_src
****** List bullet sequence
I think it makes sense to have list bullets change with depth
#+begin_src emacs-lisp
(setq org-list-demote-modify-bullet '(("+" . "-") ("-" . "+") ("*" . "+") ("1." . "a.")))
#+end_src
****** Spellcheck
My spelling is atrocious, so let's get flycheck going.
#+begin_src emacs-lisp :tangle no
(add-hook 'org-mode-hook 'turn-on-flyspell)
#+end_src
****** LSP support in ~src~ blocks
Now, by default, LSPs don't really function at all in ~src~ blocks.
#+begin_src emacs-lisp
(cl-defmacro lsp-org-babel-enable (lang)
  "Support LANG in org source code block."
  (setq centaur-lsp 'lsp-mode)
  (cl-check-type lang stringp)
  (let* ((edit-pre (intern (format "org-babel-edit-prep:%s" lang)))
         (intern-pre (intern (format "lsp--%s" (symbol-name edit-pre)))))
    `(progn
       (defun ,intern-pre (info)
         (let ((file-name (->> info caddr (alist-get :file))))
           (unless file-name
             (setq file-name (make-temp-file "babel-lsp-")))
           (setq buffer-file-name file-name)
           (lsp-deferred)))
       (put ',intern-pre 'function-documentation
            (format "Enable lsp-mode in the buffer of org source block (%s)."
                    (upcase ,lang)))
       (if (fboundp ',edit-pre)
           (advice-add ',edit-pre :after ',intern-pre)
         (progn
           (defun ,edit-pre (info)
             (,intern-pre info))
           (put ',edit-pre 'function-documentation
                (format "Prepare local buffer environment for org source block (%s)."
                        (upcase ,lang))))))))
(defvar org-babel-lang-list
  '("go" "python" "ipython" "bash" "sh"))
(dolist (lang org-babel-lang-list)
  (eval `(lsp-org-babel-enable ,lang)))
#+end_src
****** Importing with Pandoc

Sometimes I'm given non-org files, that's very sad. Luckily Pandoc offers a way
to make that right again, and this package makes that even easier to do.
#+begin_src emacs-lisp :tangle packages.el
(package! org-pandoc-import :recipe
  (:host github :repo "tecosaur/org-pandoc-import" :files ("*.el" "filters" "preprocessors")))
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-pandoc-import
  :after org)
#+end_src

****** Document comparison
It's quite nice to compare Org files, and the richest way to compare content is
probably =latexdiff=. There are a few annoying steps involved here, and so I've
written a package to streamline the process.

#+begin_src emacs-lisp :tangle packages.el
(package! orgdiff :recipe (:host github :repo "tecosaur/orgdiff"))
#+end_src

The only little annoyance is the fact that =latexdiff= uses ~#FF0000~ and ~#0000FF~ as
the red/blue change indication colours. We can make this a bit nicer by
post-processing the =latexdiff= result.

#+begin_src emacs-lisp :tangle yes
(use-package! orgdiff
  :defer t
  :config
  (defun +orgdiff-nicer-change-colours ()
    (goto-char (point-min))
    ;; Set red/blue based on whether chameleon is being used
    (if (search-forward "%% make document follow Emacs theme" nil t)
        (setq red  (substring (doom-blend 'red 'fg 0.8) 1)
              blue (substring (doom-blend 'blue 'teal 0.6) 1))
      (setq red  "c82829"
            blue "00618a"))
    (when (and (search-forward "%DIF PREAMBLE EXTENSION ADDED BY LATEXDIFF" nil t)
               (search-forward "\\RequirePackage{color}" nil t))
      (when (re-search-forward "definecolor{red}{rgb}{1,0,0}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{red}{HTML}{%s}" red)))
      (when (re-search-forward "definecolor{blue}{rgb}{0,0,1}" (cdr (bounds-of-thing-at-point 'line)) t)
        (replace-match (format "definecolor{blue}{HTML}{%s}" blue)))))
  (add-to-list 'orgdiff-latexdiff-postprocess-hooks #'+orgdiff-nicer-change-colours))
#+end_src

****** OKAY org-todo-keywords
CLOSED: [2022-10-07 Fri 20:58]
#+begin_src emacs-lisp

(setq org-todo-keywords
      '((sequence "TODO(t!)" "PROJ(p)" "LOOP(l)" "CLAR(L@)" "READ(R@/!)" "WAIT(w@/!)" "FIXME(f@/!)" "IDEA(i)" "STRT(s)" "NEXT(n)" "DUPLICATE(u@)" "|" "DONE(d!)" "KILL(k@/!)"  "HOLD(h@/!)" "BLOCKED(B@)")
       (sequence "BACKLOG(b)" "SOMEDAY(S)" "PLAN(P)" "READY(r)" "FOUND(F@/!)" "ACTIVE(a@)" "REVIEW(v!)" "|" "COMPLETED(c)" "CANC(C@)")
       (sequence "[ ](T)" "[-](B)" "[?](W)" "|" "[X](D)")
       (sequence "|" "OKAY(o)" "YES(y)" "NO(n)")))

#+end_src

****** Citation


#+begin_quote
Extending the =:tools biblio= module.
#+end_quote

References in Org are fairly easy now, thanks to =org-cite=. The =:tools biblio=
module gives a fairly decent basic setup, but it would be nice to take it a bit
further. This mostly consists of tweaking settings, but there is one extra
package I'll grab for prettier in-buffer citations.

#+begin_src emacs-lisp :tangle packages.el
(package! org-cite-csl-activate :recipe (:host github :repo "andras-simonyi/org-cite-csl-activate") :pin "9e68d9204469c674f49a20bdf7ea85da4f4bf720")
#+end_src

In particular, by setting ~org-cite-csl-activate-use-document-style~, we can have
the in-buffer displayed citations be the same as the exported form. Isn't that lovely!

Unfortunately, there's currently a potential for undesirable buffer
modifications, so we'll put all the activation code behind a function we can
call when we want it.

#+begin_src emacs-lisp
(use-package! oc-csl-activate
  :after oc
  :config
  (setq org-cite-csl-activate-use-document-style t)
  (defun +org-cite-csl-activate/enable ()
    (interactive)
    (setq org-cite-activate-processor 'csl-activate)
    (add-hook! 'org-mode-hook '((lambda () (cursor-sensor-mode 1)) org-cite-csl-activate-render-all))
    (defadvice! +org-cite-csl-activate-render-all-silent (orig-fn)
      :around #'org-cite-csl-activate-render-all
      (with-silent-modifications (funcall orig-fn)))
    (when (eq major-mode 'org-mode)
      (with-silent-modifications
        (save-excursion
          (goto-char (point-min))
          (org-cite-activate (point-max)))
        (org-cite-csl-activate-render-all)))
    (fmakunbound #'+org-cite-csl-activate/enable)))
#+end_src

Now that =oc-csl-activate= is set up, let's go ahead and customise some of the
packages already loaded. For starters, we can make use of the my Zotero files
with =citar=, and make the symbols a bit prettier.

#+begin_src emacs-lisp
(after! citar
  (setq citar-bibliography
        (let ((libfile-search-names '("library.json" "Library.json" "library.bib" "Library.bib"))
              (libfile-dir "~/Zotero")
              paths)
          (dolist (libfile libfile-search-names)
            (when (and (not paths)
                       (file-exists-p (expand-file-name libfile libfile-dir)))
              (setq paths (list (expand-file-name libfile libfile-dir)))))
          paths))
  (setq citar-symbols
        `((file ,(all-the-icons-faicon "file-o" :face 'all-the-icons-green :v-adjust -0.1) . " ")
          (note ,(all-the-icons-material "speaker_notes" :face 'all-the-icons-blue :v-adjust -0.3) . " ")
          (link ,(all-the-icons-octicon "link" :face 'all-the-icons-orange :v-adjust 0.01) . " "))))
#+end_src

We can also make the Zotero CSL styles available to use.

#+begin_src emacs-lisp
(after! oc-csl
  (setq org-cite-csl-styles-dir "~/Zotero/styles"))
#+end_src

Since CSL works so nicely everywhere, we might as well use it as the default
citation export processor for everything.

#+begin_src emacs-lisp
(after! oc
  (setq org-cite-export-processors '((t csl))))
#+end_src

Then, for convenience we'll cap things off by putting the citation command under
Org's localleader.

#+begin_src emacs-lisp
(map! :after org
      :map org-mode-map
      :localleader
      :desc "Insert citation" "@" #'org-cite-insert)
#+end_src

Lastly, just in case I come across any old citations of mine, I think it would
be nice to have a function to convert =org-ref= citations to =org-cite= forms.

#+begin_src emacs-lisp
(after! oc
  (defun org-ref-to-org-cite ()
    "Attempt to convert org-ref citations to org-cite syntax."
    (interactive)
    (let* ((cite-conversions '(("cite" . "//b") ("Cite" . "//bc")
                               ("nocite" . "/n")
                               ("citep" . "") ("citep*" . "//f")
                               ("parencite" . "") ("Parencite" . "//c")
                               ("citeauthor" . "/a/f") ("citeauthor*" . "/a")
                               ("citeyear" . "/na/b")
                               ("Citep" . "//c") ("Citealp" . "//bc")
                               ("Citeauthor" . "/a/cf") ("Citeauthor*" . "/a/c")
                               ("autocite" . "") ("Autocite" . "//c")
                               ("notecite" . "/l/b") ("Notecite" . "/l/bc")
                               ("pnotecite" . "/l") ("Pnotecite" . "/l/bc")))
           (cite-regexp (rx (regexp (regexp-opt (mapcar #'car cite-conversions) t))
                            ":" (group (+ (not (any "\n 	,.)]}")))))))
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward cite-regexp nil t)
          (message (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2)))
          (replace-match (format "[cite%s:@%s]"
                                 (cdr (assoc (match-string 1) cite-conversions))
                                 (match-string 2))))))))
#+end_src

****** cdlatex
#+begin_src emacs-lisp :tangle packages.el
(package! cdlatex)
#+end_src
It's also nice to be able to use ~cdlatex~.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'turn-on-org-cdlatex)
#+end_src

It's handy to be able to quickly insert environments with =C-c }=. I almost always
want to edit them afterwards though, so let's make that happen by default.
#+begin_src emacs-lisp
(defadvice! org-edit-latex-emv-after-insert ()
  :after #'org-cdlatex-environment-indent
  (org-edit-latex-environment))
#+end_src

At some point in the future it could be good to investigate [[https://scripter.co/splitting-an-org-block-into-two/][splitting org blocks]].
Likewise [[https://archive.casouri.cat/note/2020/insert-math-symbol-in-emacs/][this]] looks good for symbols.

****** View exported file
='localeader v= has no pre-existing binding, so I may as well use it with the same
functionality as in LaTeX. Let's try viewing possible output files with this.
#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader
      :desc "View exported file" "v" #'org-view-output-file)

(defun org-view-output-file (&optional org-file-path)
  "Visit buffer open on the first output file (if any) found, using `org-view-output-file-extensions'"
  (interactive)
  (let* ((org-file-path (or org-file-path (buffer-file-name) ""))
         (dir (file-name-directory org-file-path))
         (basename (file-name-base org-file-path))
         (output-file nil))
    (dolist (ext org-view-output-file-extensions)
      (unless output-file
        (when (file-exists-p
               (concat dir basename "." ext))
          (setq output-file (concat dir basename "." ext)))))
    (if output-file
        (if (member (file-name-extension output-file) org-view-external-file-extensions)
            (browse-url-xdg-open output-file)
          (pop-to-buffer (or (find-buffer-visiting output-file)
                             (find-file-noselect output-file))))
      (message "No exported file found"))))

(defvar org-view-output-file-extensions '("pdf" "md" "rst" "txt" "tex" "html")
  "Search for output files with these extensions, in order, viewing the first that matches")
(defvar org-view-external-file-extensions '("html")
  "File formats that should be opened externally.")
#+end_src
***** Org Capture
Let's setup some org-capture templates, and make them visually nice to access.


~doct~ (Declarative Org Capture Templates) seems to be a nicer way to
set up org-capture.
#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! doct
  :recipe (:host github :repo "progfolio/doct")
  :pin "9ed9b8c7f7e2ea2d2fb739d65ae4626a1cf16b9f")
#+end_src

#+begin_src emacs-lisp :noweb-ref none :tangle yes
(use-package! doct
  :commands doct)
#+end_src

#+begin_src emacs-lisp :noweb no-export
(require 'org-protocol-capture-html)

(after! org-capture
  <<prettify-capture>>

  (defun +doct-icon-declaration-to-icon (declaration)
    "Convert :icon declaration to icon"
    (let ((name (pop declaration))
          (set  (intern (concat "all-the-icons-" (plist-get declaration :set))))
          (face (intern (concat "all-the-icons-" (plist-get declaration :color))))
          (v-adjust (or (plist-get declaration :v-adjust) 0.01)))
      (apply set `(,name :face ,face :v-adjust ,v-adjust))))

  (defun +doct-iconify-capture-templates (groups)
    "Add declaration's :icon to each template group in GROUPS."
    (let ((templates (doct-flatten-lists-in groups)))
      (setq doct-templates (mapcar (lambda (template)
                                     (when-let* ((props (nthcdr (if (= (length template) 4) 2 5) template))
                                                 (spec (plist-get (plist-get props :doct) :icon)))
                                       (setf (nth 1 template) (concat (+doct-icon-declaration-to-icon spec)
                                                                      "\t"
                                                                      (nth 1 template))))
                                     template)
                                   templates))))

  (setq doct-after-conversion-functions '(+doct-iconify-capture-templates))

  (defvar +org-capture-recipies  "~/org/org-capture/recipies.org")
  (setq +org-capture-todo-file  "~/org/org-capture/todo.org")
  ;; (defvar +org-capture-notes-file  "~/org/org-capture/notes.org")
  ;; (defvar +org-capture-journal-file  "~/org/org-capture/journal.org")
  ;; (defvar +org-capture-projects-file  "~/org/org-capture/project.org")
  ;; (defvar +org-capture-changelog-file  "~/org/org-capture/changelog.org")

  (defun set-org-capture-templates ()
    (setq org-capture-templates
          (doct `(("Personal todo" :keys "t"
                   :icon ("checklist" :set "octicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %?"
                              "%i %a"))
                  ("Personal note" :keys "N"
                   :icon ("sticky-note-o" :set "faicon" :color "green")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* %?"
                              "%i %a"))

                  ("Web site" :keys "w"
                   :icon ("globe" :set "faicon" :color "blue")
                   :file "~/org/org-capture/webnotes.org"
                   :prepend t
                   :headline ""
                   :type entry
                   :template ("* %?\n%c\n%:initial"))
                  
                  ("Email" :keys "e"
                   :icon ("envelope" :set "faicon" :color "blue")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Inbox"
                   :type entry
                   :template ("* TODO %^{type|reply to|contact} %\\3 %? :email:"
                              "Send an email %^{urgancy|soon|ASAP|anon|at some point|eventually} to %^{recipiant}"
                              "about %^{topic}"
                              "%U %i %a"))
                  
                  ("Appointment" :keys "a"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Appointment"
                   :type entry
                   :template ("* %? \n:PROPERTIES:\n:calendar-id: akhilpratapsingh3417@gmail.com\n:LOCATION:\n:END:\n\n:org-gcal:\n%^T\n:END:\nLink: %a"))
                  
                  ("Interesting" :keys "i"
                   :icon ("eye" :set "faicon" :color "lcyan")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Interesting"
                   :type entry
                   :template ("* [ ] %{desc}%? :%{i-type}:"
                              "%i %a")
                   :children (("Webpage" :keys "w"
                               :icon ("globe" :set "faicon" :color "green")
                               :desc "%(org-cliplink-capture) "
                               :i-type "read:web")
                              ("Article" :keys "a"
                               :icon ("file-text" :set "octicon" :color "yellow")
                               :desc ""
                               :i-type "read:reaserch")
                              ("\tRecipie" :keys "r"
                               :icon ("spoon" :set "faicon" :color "dorange")
                               :file +org-capture-recipies
                               :headline "Unsorted"
                               :template "%(org-chef-get-recipe-from-url)")
                              ("Information" :keys "i"
                               :icon ("info-circle" :set "faicon" :color "blue")
                               :desc ""
                               :i-type "read:info")
                              ("Idea" :keys "I"
                               :icon ("bubble_chart" :set "material" :color "silver")
                               :desc ""
                               :i-type "idea")))
                  
                  ("Tasks" :keys "k"
                   :icon ("inbox" :set "octicon" :color "yellow")
                   :file +org-capture-todo-file
                   :prepend t
                   :headline "Tasks"
                   :type entry
                   :template ("* TODO %? %^G%{extra}"
                              "%i %a")
                   :children (("General Task" :keys "k"
                               :icon ("inbox" :set "octicon" :color "yellow")
                               :extra "")
                              ("Task with deadline" :keys "d"
                               :icon ("timer" :set "material" :color "orange" :v-adjust -0.1)
                               :extra "\nDEADLINE: %^{Deadline:}t")
                              ("Scheduled Task" :keys "s"
                               :icon ("calendar" :set "octicon" :color "orange")
                               :extra "\nSCHEDULED: %^{Start time:}t")))
                  
                  ("Project" :keys "p"
                   :icon ("repo" :set "octicon" :color "silver")
                   :prepend t
                   :type entry
                   :headline "Inbox"
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :file ""
                   :custom (:time-or-todo "")
                   :children (("Project-local todo" :keys "t"
                               :icon ("checklist" :set "octicon" :color "green")
                               :time-or-todo "TODO"
                               :file +org-capture-project-todo-file)
                              ("Project-local note" :keys "n"
                               :icon ("sticky-note" :set "faicon" :color "yellow")
                               :time-or-todo "%U"
                               :file +org-capture-project-notes-file)
                              ("Project-local changelog" :keys "c"
                               :icon ("list" :set "faicon" :color "blue")
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-project-changelog-file)))
                  
                  ("\tCentralised project templates"
                   :keys "o"
                   :type entry
                   :prepend t
                   :template ("* %{time-or-todo} %?"
                              "%i"
                              "%a")
                   :children (("Project todo"
                               :keys "t"
                               :prepend nil
                               :time-or-todo "TODO"
                               :heading "Tasks"
                               :file +org-capture-central-project-todo-file)
                              ("Project note"
                               :keys "n"
                               :time-or-todo "%U"
                               :heading "Notes"
                               :file +org-capture-central-project-notes-file)
                              ("Project changelog"
                               :keys "c"
                               :time-or-todo "%U"
                               :heading "Unreleased"
                               :file +org-capture-central-project-changelog-file)))))))

  (set-org-capture-templates)
  (unless (display-graphic-p)
    (add-hook 'server-after-make-frame-hook
              (defun org-capture-reinitialise-hook ()
                (when (display-graphic-p)
                  (set-org-capture-templates)
                  (remove-hook 'server-after-make-frame-hook
                               #'org-capture-reinitialise-hook))))))
#+end_src

#+RESULTS:

It would also be nice to improve how the capture dialogue looks
#+name: prettify-capture
#+begin_src emacs-lisp :noweb-ref none
(defun org-capture-select-template-prettier (&optional keys)
  "Select a capture template, in a prettier way than default
Lisp programs can force the template by setting KEYS to a string."
  (let ((org-capture-templates
         (or (org-contextualize-keys
              (org-capture-upgrade-templates org-capture-templates)
              org-capture-templates-contexts)
             '(("t" "Task" entry (file+headline "" "Tasks")
                "* TODO %?\n  %u\n  %a")))))
    (if keys
        (or (assoc keys org-capture-templates)
            (error "No capture template referred to by \"%s\" keys" keys))
      (org-mks org-capture-templates
               "Select a capture template\n━━━━━━━━━━━━━━━━━━━━━━━━━"
               "Template key: "
               `(("q" ,(concat (all-the-icons-octicon "stop" :face 'all-the-icons-red :v-adjust 0.01) "\tAbort")))))))
(advice-add 'org-capture-select-template :override #'org-capture-select-template-prettier)

(defun org-mks-pretty (table title &optional prompt specials)
  "Select a member of an alist with multiple keys. Prettified.

TABLE is the alist which should contain entries where the car is a string.
There should be two types of entries.

1. prefix descriptions like (\"a\" \"Description\")
   This indicates that `a' is a prefix key for multi-letter selection, and
   that there are entries following with keys like \"ab\", \"ax\"…

2. Select-able members must have more than two elements, with the first
   being the string of keys that lead to selecting it, and the second a
   short description string of the item.

The command will then make a temporary buffer listing all entries
that can be selected with a single key, and all the single key
prefixes.  When you press the key for a single-letter entry, it is selected.
When you press a prefix key, the commands (and maybe further prefixes)
under this key will be shown and offered for selection.

TITLE will be placed over the selection in the temporary buffer,
PROMPT will be used when prompting for a key.  SPECIALS is an
alist with (\"key\" \"description\") entries.  When one of these
is selected, only the bare key is returned."
  (save-window-excursion
    (let ((inhibit-quit t)
          (buffer (org-switch-to-buffer-other-window "*Org Select*"))
          (prompt (or prompt "Select: "))
          case-fold-search
          current)
      (unwind-protect
          (catch 'exit
            (while t
              (setq-local evil-normal-state-cursor (list nil))
              (erase-buffer)
              (insert title "\n\n")
              (let ((des-keys nil)
                    (allowed-keys '("\C-g"))
                    (tab-alternatives '("\s" "\t" "\r"))
                    (cursor-type nil))
                ;; Populate allowed keys and descriptions keys
                ;; available with CURRENT selector.
                (let ((re (format "\\`%s\\(.\\)\\'"
                                  (if current (regexp-quote current) "")))
                      (prefix (if current (concat current " ") "")))
                  (dolist (entry table)
                    (pcase entry
                      ;; Description.
                      (`(,(and key (pred (string-match re))) ,desc)
                       (let ((k (match-string 1 key)))
                         (push k des-keys)
                         ;; Keys ending in tab, space or RET are equivalent.
                         (if (member k tab-alternatives)
                             (push "\t" allowed-keys)
                           (push k allowed-keys))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) (propertize "›" 'face 'font-lock-comment-face) "  " desc "…" "\n")))
                      ;; Usable entry.
                      (`(,(and key (pred (string-match re))) ,desc . ,_)
                       (let ((k (match-string 1 key)))
                         (insert (propertize prefix 'face 'font-lock-comment-face) (propertize k 'face 'bold) "   " desc "\n")
                         (push k allowed-keys)))
                      (_ nil))))
                ;; Insert special entries, if any.
                (when specials
                  (insert "─────────────────────────\n")
                  (pcase-dolist (`(,key ,description) specials)
                    (insert (format "%s   %s\n" (propertize key 'face '(bold all-the-icons-red)) description))
                    (push key allowed-keys)))
                ;; Display UI and let user select an entry or
                ;; a sub-level prefix.
                (goto-char (point-min))
                (unless (pos-visible-in-window-p (point-max))
                  (org-fit-window-to-buffer))
                (let ((pressed (org--mks-read-key allowed-keys
                                                  prompt
                                                  (not (pos-visible-in-window-p (1- (point-max)))))))
                  (setq current (concat current pressed))
                  (cond
                   ((equal pressed "\C-g") (user-error "Abort"))
                   ;; Selection is a prefix: open a new menu.
                   ((member pressed des-keys))
                   ;; Selection matches an association: return it.
                   ((let ((entry (assoc current table)))
                      (and entry (throw 'exit entry))))
                   ;; Selection matches a special entry: return the
                   ;; selection prefix.
                   ((assoc current specials) (throw 'exit current))
                   (t (error "No entry available")))))))
        (when buffer (kill-buffer buffer))))))
(advice-add 'org-mks :override #'org-mks-pretty)
#+end_src

#+RESULTS: prettify-capture

The [[file:~/.emacs.d/bin/org-capture][org-capture bin]] is rather nice, but I'd be nicer with a smaller frame, and
no modeline.
#+begin_src emacs-lisp
(setf (alist-get 'height +org-capture-frame-parameters) 15)
;; (alist-get 'name +org-capture-frame-parameters) "❖ Capture") ;; ATM hardcoded in other places, so changing breaks stuff
(setq +org-capture-fn
      (lambda ()
        (interactive)
        (set-window-parameter nil 'mode-line-format 'none)
        (org-capture)))
#+end_src

#+RESULTS:
| lambda | nil | (interactive) | (set-window-parameter nil 'mode-line-format 'none) | (org-capture) |

***** Habit Tracking

https://orgmode.org/manual/Tracking-your-habits.html

#+begin_src emacs-lisp

(require 'org-habit)
(add-to-list 'org-modules 'org-habit)
(setq org-habit-graph-column 60)

#+end_src

#+RESULTS:
: 60
***** Super agenda

The agenda is nice, but a souped up version is nicer.
#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda :pin "f4f528985397c833c870967884b013cf91a1da4a")
#+end_src

#+begin_src emacs-lisp :tangle yes
(use-package! org-super-agenda
  :commands org-super-agenda-mode)

#+end_src

#+begin_src emacs-lisp :tangle no 
(after! org
  (setq org-agenda-files '("~/org/org-agenda/daily"
                           "~/org/org-agenda/incubate.org"
                           "~/org/org-agenda/openquestions.org"
                           "~/org/org-agenda/todo.org/"
                           "~/org/org-agenda/agenda.org"
                           "~/org/org-capture/todo.org"
                           "~/org/org-roam2/daily/"
                           "~/org/org-roam2/todo.org/")))

(custom-set-variables
 '(org-agenda-files
   '("~/org/org-agenda/daily"
     "~/org/org-agenda/incubate.org"
     "~/org/org-agenda/openquestions.org"
     "~/org/org-agenda/todo.org/"
     "~/org/org-agenda/agenda.org"
     "~/org/org-capture/todo.org"
     "~/org/org-roam2/daily/"
     "~/org/org-roam2/todo.org/")))
 (setq org-default-notes-file "~/org/notes/notes.org")
#+end_src

#+RESULTS:
| ~/org/notes/ |


#+RESULTS:

#+begin_src emacs-lisp :tangle no

(setq org-super-agenda-groups
      '((:name "Next Items"
               :time-grid t
               :tag ("NEXT" "outbox"))
        (:name "Important"
               :priority "A")
        (:name "Quick Picks"
               :effort< "0:30")
        (:priority<= "B"
                     :scheduled future
                     :order 1)))
#+end_src

#+RESULTS:
| :name       | Next Items  | :time-grid | t      | :tag   | (NEXT outbox) |
| :name       | Important   | :priority  | A      |        |               |
| :name       | Quick Picks | :effort<   | 0:30   |        |               |
| :priority<= | B           | :scheduled | future | :order |             1 |


#+RESULTS:
: prot-org-custom-daily-agenda

#+begin_src emacs-lisp :tangle yes
;; (after! org-agenda
;; (org-super-agenda-mode)

(after! org-agenda
  (let ((inhibit-message t))
    (org-super-agenda-mode)))

;; (setq org-agenda-buffer-name "Agenda")
;; (setq org-agenda-scheduled-leaders '("SCH: " "Sched.%2dx: "))
;; (setq org-agenda-hide-tags-regexp "work\\|paperwork\\|GCAL\\|refile\\|research\\|planner\\|noexport\\|health\\|ideas\\|notes\\|home\\|school\\|personal\\|tasks\\|proposal\\|habit")
;; ;; (setq diary-file "~/org/org-roam2/daily/")
;; ;; (setq org-agenda-deadline-leaders '("DUE TODAY: " "In %3d d.: " "%2d d. ago: "))
;; ;;(setq org-agenda-skip-scheduled-if-deadline-is-shown t)
;; ;; (setq org-agenda-todo-list-sublevels t)
;; ;;(setq org-agenda-todo-ignore-deadlines 'future)
;; (setq org-deadline-warning-days 7)

(setq org-agenda-skip-scheduled-if-done t
      org-agenda-skip-deadline-if-done t
      org-agenda-include-deadlines t
      org-agenda-block-separator nil
      org-agenda-tags-column 100 ;; from testing this seems to be a good value
      org-agenda-start-with-log-mode t
      calendar-latitude 34.034520
      calendar-longitude -84.456010
      calendar-location-name "Marietta, GA"
      org-agenda-compact-blocks t
      org-agenda-include-diary t)
;; org-agenda-start-with-log-mode t)

(setq org-agenda-custom-commands
      '(("o" "Overview"
         ((agenda "" ((org-agenda-span 'day)
                      (org-agenda-start-day nil)
                      (org-super-agenda-groups
                       '((:name "Today"
                          :time-grid t
                          :date today
                          :todo "TODAY"
                          :scheduled today
                          :order 1)))))
          (alltodo "" ((org-agenda-overriding-header "")
                       (org-super-agenda-groups
                        '((:name "Next to do"
                           :todo "NEXT"
                           :order 1)
                          (:name "Important"
                           :tag "Important"
                           :priority "A"
                           :order 6)
                          (:name "Due Today"
                           :deadline today
                           :order 2)
                          (:name "Due Soon"
                           :deadline future
                           :order 8)
                          (:name "Overdue"
                           :deadline past
                           :face error
                           :order 7)
                          (:name "Assignments"
                           :tag "Assignment"
                           :order 10)
                          (:name "Issues"
                           :tag "Issue"
                           :todo ("FIXME" "CLAR")
                           :order 12)
                          (:name "Emacs"
                           :tag "Emacs"
                           :order 13)
                          (:name "Projects"
                           :tag "Project"
                           :todo "PROJ"
                           :order 14)
                          (:name "Research"
                           :tag "Research"
                           :tag ("FOUND")
                           :order 15)
                          (:name "To read"
                           :tag ("Read" "learn")
                           :todo "READ"
                           :order 30)
                          (:name "Waiting"
                           :todo ("WAIT" "HOLD" "LOOP")
                           :order 20)
                          (:name "In Review"
                           :todo ("REVIEW" "DUPLICATE")
                           :order 21)
                          (:name "In Planning"
                           :todo ("PLAN" "IDEA")
                           :order 22)
                          (:name "Project Backlog"
                           :todo "BACKLOG"
                           :order 23)
                          (:name "Ready For Work"
                           :todo "READY"
                           :order 24)
                          (:name "Active Projects"
                           :todo ("ACTIVE" "STRT")
                           :order 25)
                          (:name "Completed Projects"
                           :todo ("COMPLETED" "KILL" "BLOCKED")
                           :order 26)
                          (:name "University"
                           :tag "uni"
                           :order 32)
                          (:name "Binge Watch"
                           :tag ("tvshow" "movie" "documentry")
                           :order 33)
                          (:name "Trivial"
                           :priority<= "E"
                           :tag ("Trivial" "Unimportant")
                           :todo ("SOMEDAY" )
                           :order 90)
                          (:discard (:tag ("Chore" "Routine" "Daily")))))))))
        ("d" "Dashboard"
          ((agenda "" ((org-deadline-warning-days 7)))
           (todo "NEXT"
                 ((org-agenda-overriding-header "Next Tasks")))
           (tags-todo "agenda/ACTIVE" ((org-agenda-overriding-header "Active Projects")))))

         ("n" "Next Tasks"
          ((todo "NEXT"
                 ((org-agenda-overriding-header "Next Tasks")))))


         ("w" "Work Tasks" tags-todo "+work")

         ;; Low-effort next actions
         ("e" tags-todo "+TODO=\"NEXT\"+Effort<15&+Effort>0"
          ((org-agenda-overriding-header "Low Effort Tasks")
           (org-agenda-max-todos 20)
           (org-agenda-files org-agenda-files)))

         ("W" "Workflow Status"
          ((todo "WAIT"
                 ((org-agenda-overriding-header "Waiting on External")
                  (org-agenda-files org-agenda-files)))
           (todo "REVIEW"
                 ((org-agenda-overriding-header "In Review")
                  (org-agenda-files org-agenda-files)))
           (todo "PLAN"
                 ((org-agenda-overriding-header "In Planning")
                  (org-agenda-todo-list-sublevels nil)
                  (org-agenda-files org-agenda-files)))
           (todo "BACKLOG"
                 ((org-agenda-overriding-header "Project Backlog")
                  (org-agenda-todo-list-sublevels nil)
                  (org-agenda-files org-agenda-files)))
           (todo "READY"
                 ((org-agenda-overriding-header "Ready for Work")
                  (org-agenda-files org-agenda-files)))
           (todo "ACTIVE"
                 ((org-agenda-overriding-header "Active Projects")
                  (org-agenda-files org-agenda-files)))
           (todo "COMPLETED"
                 ((org-agenda-overriding-header "Completed Projects")
                  (org-agenda-files org-agenda-files)))
           (todo "CANC"
                 ((org-agenda-overriding-header "Cancelled Projects")
                  (org-agenda-files org-agenda-files)))))))


(let ((map global-map))
  (define-key map (kbd "C-c a") #'org-agenda)
  (define-key map (kbd "C-c c") #'org-capture)
  (define-key map (kbd "C-c l") #'org-store-link)
  (define-key map (kbd "C-c L") #'org-insert-link-global)
  (define-key map (kbd "C-c O") #'org-open-at-point-global))
(let ((map org-mode-map))
  (define-key map (kbd "C-c M-l") #'org-insert-last-stored-link)
  (define-key map (kbd "C-c C-M-l") #'org-toggle-link-display))

(defun my-org-check-agenda ()
  "Peek at agenda."
  (interactive)
  (cond
   ((derived-mode-p 'org-agenda-mode)
    (if (window-parent) (delete-window) (bury-buffer)))
   ((get-buffer "*Org Agenda*")
    (switch-to-buffer-other-window "*Org Agenda*"))
   (t (org-agenda nil "a"))))

#+end_src

#+RESULTS:
: my-org-check-agenda


#+RESULTS:
| o | Overview | ((agenda  ((org-agenda-span 'day) (org-super-agenda-groups '((:name Today :time-grid t :date today :todo TODAY :scheduled today :order 1))))) (alltodo  ((org-agenda-overriding-header ) (org-super-agenda-groups '((:name Next to do :todo NEXT :order 1) (:name Important :tag Important :priority A :order 6) (:name Due Today :deadline today :order 2) (:name Due Soon :deadline future :order 8) (:name Overdue :deadline past :face error :order 7) (:name Assignments :tag Assignment :order 10) (:name Issues :tag Issue :order 12) (:name Emacs :tag Emacs :order 13) (:name Projects :tag Project :order 14) (:name Research :tag Research :order 15) (:name To read :tag Read :order 30) (:name Waiting :todo WAITING :order 20) (:name University :tag uni :order 32) (:name Trivial :priority<= E :tag (Trivial Unimportant) :todo (SOMEDAY) :order 90) (:discard (:tag (Chore Routine Daily)))))))) |
***** org capture academics

Set some capture templates, to work with GTD.
#+begin_src emacs-lisp :tangle no
(after! org
(setq org-capture-templates `(("i" "Inbox"
                                 entry (file "~/Dropbox/Org/references/notes/inbox.org")
                                 "* %?\n%U\n\n  %i"
                                 :kill-buffer t)
                                ("l" "Todo with link"
                                 entry (file "~/Dropbox/Org/references/notes/inbox.org")
                                 "* %?\n%U\n\n  %i\n  %a"
                                 :kill-buffer t)
                                ("m" "Meeting"
                                 entry (file+headline "/Dropbox/Org/references/notes/agenda.org" "Future")
                                ,(concat "* TODO %? :meeting:\n" "<%<%Y-%m-%d %a %H:00>>"))
                                ("o" "Open Question Thesis"
                                 entry (file+headline "~/Dropbox/Org/references/notes/openquestions.org" "Questions")
                                 "* OPEN %? \n %U\n")))
(set-face-attribute 'org-headline-done nil :strike-through t)
)
#+end_src
***** Roam
****** Basic settings

| COMMAND                         | DESCRIPTION                     | KEYBINDING  |
|---------------------------------+---------------------------------+-------------|
| org-roam-find-file              | org roam find file              | SPC n r f   |
| org-roam-insert                 | org roam insert                 | SPC n r i   |
| org-roam-dailies-find-date      | org roam dailies find date      | SPC n r d d |
| org-roam-dailies-find-today     | org roam dailies find today     | SPC n r d t |
| org-roam-dailies-find-tomorrow  | org roam dailies find tomorrow  | SPC n r d m |
| org-roam-dailies-find-yesterday | org roam dailies find yesterday | SPC n r d y |

I'll just set this to be within =Organisation= folder for now, in the future it
could be worth seeing if I could hook this up to a [[https://nextcloud.com/][Nextcloud]] instance.
#+begin_src emacs-lisp :tangle yes
;;(after! org-roam
(setq
      org-roam-directory "~/org/org-roam2/"
      org-roam-db-location (concat org-roam-directory "org-roam.db")
      org-roam-todo-file (concat org-roam-directory "todo/todo.org"))
(save-window-excursion
  (find-file org-roam-todo-file)
  (save-buffer))
#+end_src

#+RESULTS:

That said, if the directory doesn't exist we likely don't want to be using roam.
Since we don't want to trigger errors (which will happen as soon as roam tries
to initialise), let's not load roam.
#+begin_src emacs-lisp :tangle (if (file-exists-p "~/org/org-roam2/") "no" "packages.el")
(package! org-roam :disable t)
#+end_src
****** v2 baby
#+begin_src emacs-lisp :tangle no
(setq org-roam-v2-ack t)

(use-package! org-roam
  :after org
  :config
  (setq org-roam-v2-ack t)
  (setq org-roam-mode-sections
        (list #'org-roam-backlinks-insert-section
              #'org-roam-reflinks-insert-section
              #'org-roam-unlinked-references-insert-section))
  (org-roam-setup))
 #+end_src

 #+RESULTS:
 : t

****** Hotter Buffer
#+begin_src emacs-lisp :tangle no
(defun org-roam-buffer-setup ()
  "Function to make org-roam-buffer more pretty."
  (progn
    (setq-local olivetti-body-width 44)
    (variable-pitch-mode 1)
    (olivetti-mode 1)
    ;; (centaur-tabs-local-mode -1)

  (set-face-background 'magit-section-highlight (face-background 'default))))

(after! org-roam
(add-hook! 'org-roam-mode-hook #'org-roam-buffer-setup))
#+end_src

#+RESULTS:

****** Modeline file name
All those numbers! It's messy. Let's adjust this in a similar way that I have in
the [[*Window title][Window title]].
#+begin_src emacs-lisp
(defadvice! doom-modeline--buffer-file-name-roam-aware-a (orig-fun)
  :around #'doom-modeline-buffer-file-name ; takes no args
  (if (s-contains-p org-roam-directory (or buffer-file-name ""))
      (replace-regexp-in-string
       "\\(?:^\\|.*/\\)\\([0-9]\\{4\\}\\)\\([0-9]\\{2\\}\\)\\([0-9]\\{2\\}\\)[0-9]*-"
       "🢔(\\1-\\2-\\3) "
       (subst-char-in-string ?_ ?  buffer-file-name))
    (funcall orig-fun)))
#+end_src

****** Graph view

Org-roam is nice by itself, but there are so /extra/ nice packages which integrate
with it.
#+begin_src emacs-lisp :tangle packages.el
(package! org-roam-ui :recipe (:host github :repo "org-roam/org-roam-ui" :files ("*.el" "out")) :pin "6bf6a5eecc1fa7ddbb1fcda85e08fe9c393f9298")
(package! websocket :pin "fda4455333309545c0787a79d73c19ddbeb57980") ; dependency of `org-roam-ui'
#+end_src

#+begin_src emacs-lisp :tangle yes

(use-package! websocket
  :after org-roam)

(use-package! org-roam-ui
  :after org-roam
  :commands org-roam-ui-open
  :hook (org-roam . org-roam-ui-mode)
  :config
  (require 'org-roam) ; in case autoloaded
  (setq org-roam-ui-browser-function #'xwidget-webkit-browse-url)
  (defun org-roam-ui-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (unless org-roam-ui-mode (org-roam-ui-mode 1))
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-ui-port))))
#+end_src

#+RESULTS:
| org-roam-ui-mode |

****** Org-roam-capture templates

#+begin_src emacs-lisp :tangle yes

(after! org-roam
  (setq org-roam-capture-templates
        `(("s" "standard" plain "%?"
           :if-new
           (file+head "standard/%<%Y%m%d%H%M%S>--${slug}.org"
                      "#+title: ${title}\n#+date\n#+filetags: \n\n ")
           :unnarrowed t)

          ("d" "definition" plain
           "%?"
           :if-new
           (file+head "definition/${slug}.org" "#+title: ${title}\n#+filetags: definition \n\n* Definition\n\n\n* Examples\n")
           :unnarrowed t)
          ("r" "ref" plain "%?"
           :if-new
           (file+head "ref/${citekey}.org"
                      "#+title: ${slug}: ${title}\n
                      \n#+date : %<%Y%m%d%H%M%S>
                      \n#+filetags: reference ${keywords} \n
                      \n* ${title}\n\n
                      \n* Summary
                      \n\n\n* Rough note space\n")
           :unnarrowed t)
          ("P" "person" plain "%?"
           :if-new
           (file+head "${slug}.org" "%^{relation|some guy|family|friend|colleague}p %^{birthday}p %^{address}p
,#+title:${slug}\n#+filetags: :person: \n")
           :unnarrowed t)
          ("p" "project" plain "* Goals\n\n%?\n\n* Tasks\n\n** TODO Add initial tasks\n\n* Dates\n\n"
           :if-new (file+head "Projects/%<%Y%m%d%H%M%S>--${slug}.org" "#+title: ${title}\n#+filetags: Project")
           :unnarrowed t)
          ("b" "book notes" plain
           "\n* Source\n\nAuthor: %^{Author}\nTitle: ${title}\nYear: %^{Year}\n\n* Summary\n\n%?"
           :if-new (file+head "BookNotes/%<%Y%m%d%H%M%S>--${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)
          ;; templates can be used as well, which is pretty cool
          ;; ("b" "book notes" plain (file "~/org/org-roam2/Templates/BookNotesTemplate.org")
          ;;  :if-new (file+head "BookNotes/%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
          ;;  :unnarrowed t)
          ("l" "programming language" plain
           "* Characteristics\n\n- Family: %?\n- Inspired by: \n\n* Reference:\n\n"
           :if-new (file+head "ProgLangs/%<%Y%m%d%H%M%S>--${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)

          ("n" "notes" plain "%?"
           :if-new
           (file+head "Notes/%<%Y%m%d%H%M%S>--${title}.org" "#+title: ${title}\n#+STARTUP: content\n#+date : %<%Y-%m-%d>\n#+filetags: :%^{tags|article:note|learn|info|posix|web|intresting|emacs|gnu_linux|health|food|shopping|pentesting|tv_shows|elfeed|void_linux|internet} ")
           :immediate-finish t
           :unnarrowed t)

          ("a" "article" plain "%?"
           :if-new
           (file+head "Articles/%<%Y%m%d%H%M%S>--${title}.org" "#+title: ${title}\n#+STARTUP: content\n#+date : %<%Y-%m-%d>\n#+filetags: :%^{tags|article:read|learn|info|posix|web|intresting|emacs|gnu_linux|health|food|shopping|pentesting|tv_shows|elfeed|void_linux|internet} ")

           ;; (file+head "Articles/%<%Y%m%d%H%M%S>-${title}.org" "#+title: ${title}\n#+date : %<%Y%m%d%H%M%S>\n#+filetags: :article:%^{tags|read|learn|info}
            ;; \n\n%i %a")
           :immediate-finish t
           :unnarrowed t))))
(setq org-roam-dailies-capture-templates
      '(("d" "default" entry "* %<%I:%M %p>: %?"
         :if-new (file+head "%<%Y-%m-%d>.org" "#+title: %<%Y-%m-%d>\n"))))

;; ;; Creating the property “type” on my nodes.
(cl-defmethod org-roam-node-type ((node org-roam-node))
  "Return the TYPE of NODE."
  (condition-case nil
      (file-name-nondirectory
       (directory-file-name
        (file-name-directory
         (file-relative-name (org-roam-node-file node) org-roam-directory))))
    (error "")))

;; Modifying the display template to show the node “type”

;; (setq org-roam-node-display-template
;;        (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
;; #("${doom-type:15} ${doom-hierarchy:*}  ${doom-tags:42}" 20 35
;;   (face font-lock-keyword-face)
;;   36 51
;;   (face org-tag)))

(defun my/org-roam--backlinks-list (file)
  (if (org-roam--org-roam-file-p file)
      (--reduce-from
       (concat acc (format "- [[file:%s][%s]]\n"
                           (file-relative-name (car it) org-roam-directory)
                           (org-roam--get-title-or-slug (car it))))
       "" (org-roam-sql [:select [from]
                         :from links
                         :where (= to $s1)
                         :and from :not :like $s2] file "%private%"))
    ""))

(defun my/org-export-preprocessor (_backend)
  (let ((links (my/org-roam--backlinks-list (buffer-file-name))))
    (unless (string= links "")
      (save-excursion
        (goto-char (point-max))
        (insert (concat "\n* Backlinks\n" links))))))
#+end_src

#+RESULTS:
: my/org-export-preprocessor

****** Citations
#+begin_src emacs-lisp :tangle no

(use-package! org-ref
    ;:after org-roam
    :config
    (setq
         org-ref-completion-library 'org-ref-ivy-cite
         org-ref-get-pdf-filename-function 'org-ref-get-pdf-filename-helm-bibtex
         bibtex-completion-bibliography (list "~/org/references/library.bib")
         bibtex-completion-notes "~/org/references/notes/bibnotes.org"
         org-ref-note-title-format "* %y - %t\n :PROPERTIES:\n  :Custom_ID: %k\n  :NOTER_DOCUMENT: %F\n :ROAM_KEY: cite:%k\n  :AUTHOR: %9a\n  :JOURNAL: %j\n  :YEAR: %y\n  :VOLUME: %v\n  :PAGES: %p\n  :DOI: %D\n  :URL: %U\n :END:\n\n"
         org-ref-notes-directory "~/org/references/notes/"
         org-ref-notes-function 'orb-edit-notes
    ))

(after! org-ref
(setq
 bibtex-completion-notes-path "~/org/references/notes/"
 bibtex-completion-bibliography "~/org/references/library.bib"
 bibtex-completion-pdf-field "file"
 bibtex-completion-notes-template-multiple-files
 (concat
  "#+TITLE: ${title}\n"
  "#+ROAM_KEY: cite:${=key=}\n"
  "* TODO Notes\n"
  ":PROPERTIES:\n"
  ":Custom_ID: ${=key=}\n"
  ":NOTER_DOCUMENT: %(orb-process-file-field \"${=key=}\")\n"
  ":AUTHOR: ${author-abbrev}\n"
  ":JOURNAL: ${journaltitle}\n"
  ":DATE: ${date}\n"
  ":YEAR: ${year}\n"
  ":DOI: ${doi}\n"
  ":URL: ${url}\n"
  ":END:\n\n"
  )
 )
)

#+end_src

#+RESULTS:

#+begin_example
,#+TITLE: ${title}
,#+ROAM_KEY: cite:${=key=}
,* TODO Notes
:PROPERTIES:
:Custom_ID: ${=key=}
:NOTER_DOCUMENT: %(orb-process-file-field "${=key=}")
:AUTHOR: ${author-abbrev}
:JOURNAL: ${journaltitle}
:DATE: ${date}
:YEAR: ${year}
:DOI: ${doi}
:URL: ${url}
:END:

#+end_example
****** org roam agenda
#+begin_src emacs-lisp

;; The buffer you put this code in must have lexical-binding set to t!
;; See the final configuration at the end for more details.

(defun my/org-roam-filter-by-tag (tag-name)
  (lambda (node)
    (member tag-name (org-roam-node-tags node))))

(defun my/org-roam-list-notes-by-tag (tag-name)
  (mapcar #'org-roam-node-file
          (seq-filter
           (my/org-roam-filter-by-tag tag-name)
           (org-roam-node-list))))

(defun my/org-roam-refresh-agenda-list ()
  (interactive)
  (setq org-agenda-files (my/org-roam-list-notes-by-tag "Project")))

;; Build the agenda list the first time for the session
(my/org-roam-refresh-agenda-list)
#+end_src

#+RESULTS:
***** Nicer generated heading IDs
Thanks to alphapapa's [[https://github.com/alphapapa/unpackaged.el#export-to-html-with-useful-anchors][unpackaged.el]].

By default, Org generated heading IDs like =#org80fc2a5= which ... works, but has
two issues
+ It's completely uninformative, I have no idea what's being referenced
+ If I export the same file, everything will change.
  Now, while without hardcoded values it's impossible to set references in
  stone, it would be nice for there to be a decent chance of staying the same.

Both of these issues can be addressed by generating IDs like
=#language-configuration=, which is what I'll do here.

It's worth noting that alphapapa's use of ~url-hexify-string~ seemed to cause me
some issues. Replacing that in ~a53899~ resolved this for me. To go one step
further, I create a function for producing nice short links, like an inferior
version of ~reftex-label~.

#+begin_src emacs-lisp
(defvar org-reference-contraction-max-words 3
  "Maximum number of words in a reference reference.")
(defvar org-reference-contraction-max-length 35
  "Maximum length of resulting reference reference, including joining characters.")
(defvar org-reference-contraction-stripped-words
  '("the" "on" "in" "off" "a" "for" "by" "of" "and" "is" "to")
  "Superfluous words to be removed from a reference.")
(defvar org-reference-contraction-joining-char "-"
  "Character used to join words in the reference reference.")

(defun org-reference-contraction-truncate-words (words)
  "Using `org-reference-contraction-max-length' as the total character 'budget' for the WORDS
and truncate individual words to conform to this budget.

To arrive at a budget that accounts for words undershooting their requisite average length,
the number of characters in the budget freed by short words is distributed among the words
exceeding the average length.  This adjusts the per-word budget to be the maximum feasable for
this particular situation, rather than the universal maximum average.

This budget-adjusted per-word maximum length is given by the mathematical expression below:

max length = \\floor{ \\frac{total length - chars for seperators - \\sum_{word \\leq average length} length(word) }{num(words) > average length} }"
  ;; trucate each word to a max word length determined by
  ;;
  (let* ((total-length-budget (- org-reference-contraction-max-length  ; how many non-separator chars we can use
                                 (1- (length words))))
         (word-length-budget (/ total-length-budget                      ; max length of each word to keep within budget
                                org-reference-contraction-max-words))
         (num-overlong (-count (lambda (word)                            ; how many words exceed that budget
                                 (> (length word) word-length-budget))
                               words))
         (total-short-length (-sum (mapcar (lambda (word)                ; total length of words under that budget
                                             (if (<= (length word) word-length-budget)
                                                 (length word) 0))
                                           words)))
         (max-length (/ (- total-length-budget total-short-length)       ; max(max-length) that we can have to fit within the budget
                        num-overlong)))
    (mapcar (lambda (word)
              (if (<= (length word) max-length)
                  word
                (substring word 0 max-length)))
            words)))

(defun org-reference-contraction (reference-string)
  "Give a contracted form of REFERENCE-STRING that is only contains alphanumeric characters.
Strips 'joining' words present in `org-reference-contraction-stripped-words',
and then limits the result to the first `org-reference-contraction-max-words' words.
If the total length is > `org-reference-contraction-max-length' then individual words are
truncated to fit within the limit using `org-reference-contraction-truncate-words'."
  (let ((reference-words
         (-filter (lambda (word)
                    (not (member word org-reference-contraction-stripped-words)))
                  (split-string
                   (->> reference-string
                        downcase
                        (replace-regexp-in-string "\\[\\[[^]]+\\]\\[\\([^]]+\\)\\]\\]" "\\1") ; get description from org-link
                        (replace-regexp-in-string "[-/ ]+" " ") ; replace seperator-type chars with space
                        puny-encode-string
                        (replace-regexp-in-string "^xn--\\(.*?\\) ?-?\\([a-z0-9]+\\)$" "\\2 \\1") ; rearrange punycode
                        (replace-regexp-in-string "[^A-Za-z0-9 ]" "") ; strip chars which need %-encoding in a uri
                        ) " +"))))
    (when (> (length reference-words)
             org-reference-contraction-max-words)
      (setq reference-words
            (cl-subseq reference-words 0 org-reference-contraction-max-words)))

    (when (> (apply #'+ (1- (length reference-words))
                    (mapcar #'length reference-words))
             org-reference-contraction-max-length)
      (setq reference-words (org-reference-contraction-truncate-words reference-words)))

    (string-join reference-words org-reference-contraction-joining-char)))
#+end_src

Now here's alphapapa's subtly tweaked mode.
#+begin_src emacs-lisp
(define-minor-mode unpackaged/org-export-html-with-useful-ids-mode
  "Attempt to export Org as HTML with useful link IDs.
Instead of random IDs like \"#orga1b2c3\", use heading titles,
made unique when necessary."
  :global t
  (if unpackaged/org-export-html-with-useful-ids-mode
      (advice-add #'org-export-get-reference :override #'unpackaged/org-export-get-reference)
    (advice-remove #'org-export-get-reference #'unpackaged/org-export-get-reference)))
(unpackaged/org-export-html-with-useful-ids-mode 1) ; ensure enabled, and advice run

(defun unpackaged/org-export-get-reference (datum info)
  "Like `org-export-get-reference', except uses heading titles instead of random numbers."
  (let ((cache (plist-get info :internal-references)))
    (or (car (rassq datum cache))
        (let* ((crossrefs (plist-get info :crossrefs))
               (cells (org-export-search-cells datum))
               ;; Preserve any pre-existing association between
               ;; a search cell and a reference, i.e., when some
               ;; previously published document referenced a location
               ;; within current file (see
               ;; `org-publish-resolve-external-link').
               ;;
               ;; However, there is no guarantee that search cells are
               ;; unique, e.g., there might be duplicate custom ID or
               ;; two headings with the same title in the file.
               ;;
               ;; As a consequence, before re-using any reference to
               ;; an element or object, we check that it doesn't refer
               ;; to a previous element or object.
               (new (or (cl-some
                         (lambda (cell)
                           (let ((stored (cdr (assoc cell crossrefs))))
                             (when stored
                               (let ((old (org-export-format-reference stored)))
                                 (and (not (assoc old cache)) stored)))))
                         cells)
                        (when (org-element-property :raw-value datum)
                          ;; Heading with a title
                          (unpackaged/org-export-new-named-reference datum cache))
                        (when (member (car datum) '(src-block table example fixed-width property-drawer))
                          ;; Nameable elements
                          (unpackaged/org-export-new-named-reference datum cache))
                        ;; NOTE: This probably breaks some Org Export
                        ;; feature, but if it does what I need, fine.
                        (org-export-format-reference
                         (org-export-new-reference cache))))
               (reference-string new))
          ;; Cache contains both data already associated to
          ;; a reference and in-use internal references, so as to make
          ;; unique references.
          (dolist (cell cells) (push (cons cell new) cache))
          ;; Retain a direct association between reference string and
          ;; DATUM since (1) not every object or element can be given
          ;; a search cell (2) it permits quick lookup.
          (push (cons reference-string datum) cache)
          (plist-put info :internal-references cache)
          reference-string))))

(defun unpackaged/org-export-new-named-reference (datum cache)
  "Return new reference for DATUM that is unique in CACHE."
  (cl-macrolet ((inc-suffixf (place)
                             `(progn
                                (string-match (rx bos
                                                  (minimal-match (group (1+ anything)))
                                                  (optional "--" (group (1+ digit)))
                                                  eos)
                                              ,place)
                                ;; HACK: `s1' instead of a gensym.
                                (-let* (((s1 suffix) (list (match-string 1 ,place)
                                                           (match-string 2 ,place)))
                                        (suffix (if suffix
                                                    (string-to-number suffix)
                                                  0)))
                                  (setf ,place (format "%s--%s" s1 (cl-incf suffix)))))))
    (let* ((headline-p (eq (car datum) 'headline))
           (title (if headline-p
                      (org-element-property :raw-value datum)
                    (or (org-element-property :name datum)
                        (concat (org-element-property :raw-value
                                                      (org-element-property :parent
                                                                            (org-element-property :parent datum)))))))
           ;; get ascii-only form of title without needing percent-encoding
           (ref (concat (org-reference-contraction (substring-no-properties title))
                        (unless (or headline-p (org-element-property :name datum))
                          (concat ","
                                  (pcase (car datum)
                                    ('src-block "code")
                                    ('example "example")
                                    ('fixed-width "mono")
                                    ('property-drawer "properties")
                                    (_ (symbol-name (car datum))))
                                  "--1"))))
           (parent (when headline-p (org-element-property :parent datum))))
      (while (--any (equal ref (car it))
                    cache)
        ;; Title not unique: make it so.
        (if parent
            ;; Append ancestor title.
            (setf title (concat (org-element-property :raw-value parent)
                                "--" title)
                  ;; get ascii-only form of title without needing percent-encoding
                  ref (org-reference-contraction (substring-no-properties title))
                  parent (when headline-p (org-element-property :parent parent)))
          ;; No more ancestors: add and increment a number.
          (inc-suffixf ref)))
      ref)))

(add-hook 'org-load-hook #'unpackaged/org-export-html-with-useful-ids-mode)
#+end_src
We also need to redefine src_elisp{(org-export-format-reference)} as it now may
be passed a string as well as a number.
#+begin_src emacs-lisp
(defadvice! org-export-format-reference-a (reference)
  "Format REFERENCE into a string.

REFERENCE is a either a number or a string representing a reference,
as returned by `org-export-new-reference'."
  :override #'org-export-format-reference
  (if (stringp reference) reference (format "org%07x" reference)))
#+end_src
***** Nicer ~org-return~
Once again, from [[https://github.com/alphapapa/unpackaged.el#org-return-dwim][unpackaged.el]]
#+begin_src emacs-lisp
(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  ;; MAYBE: Use `org-element-lineage'.
  (when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
        (unpackaged/org-element-descendant-of type parent))))

;;;###autoload
(defun unpackaged/org-return-dwim (&optional default)
  "A helpful replacement for `org-return-indent'.  With prefix, call `org-return-indent'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return t)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ;; ((eq 'link (car (org-element-context)))
     ;;  ;; Link: Open it.
     ;;  (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
        (goto-char (org-entry-end-position))
        (cond ((and (org-at-heading-p)
                    (= heading-start (org-entry-beginning-position)))
               ;; Entry ends on its heading; add newline after
               (end-of-line)
               (insert "\n\n"))
              (t
               ;; Entry ends after its heading; back up
               (forward-line -1)
               (end-of-line)
               (when (org-at-heading-p)
                 ;; At the same heading
                 (forward-line)
                 (insert "\n")
                 (forward-line -1))
               (while (not (looking-back "\\(?:[[:blank:]]?\n\\)\\{3\\}" nil))
                 (insert "\n"))
               (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
        (if (or (eq 'plain-list (car context))  ; First item in list
                (and (eq 'item (car context))
                     (not (eq (org-element-property :contents-begin context)
                              (org-element-property :contents-end context))))
                (unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
            ;; Non-empty item: Add new item.
            (org-insert-item)
          ;; Empty item: Close the list.
          ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
          (delete-region (line-beginning-position) (line-end-position))
          (insert "\n"))))

     ((when (fboundp 'org-inlinetask-in-task-p)
        (org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return t))

     ((org-at-table-p)
      (cond ((save-excursion
               (beginning-of-line)
               ;; See `org-table-next-field'.
               (cl-loop with end = (line-end-position)
                        for cell = (org-element-table-cell-parser)
                        always (equal (org-element-property :contents-begin cell)
                                      (org-element-property :contents-end cell))
                        while (re-search-forward "|" end t)))
             ;; Empty row: end the table.
             (delete-region (line-beginning-position) (line-end-position))
             (org-return t))
            (t
             ;; Non-empty row: call `org-return-indent'.
             (org-return t))))
     (t
      ;; All other cases: call `org-return-indent'.
      (org-return t)))))

(map!
 :after evil-org
 :map evil-org-mode-map
 :i [return] #'unpackaged/org-return-dwim)
#+end_src
***** Snippet Helpers
****** Structure Templates

#+begin_src emacs-lisp :tangle no

  ;; This is needed as of Org 9.2
  (require 'org-tempo)

  (add-to-list 'org-structure-template-alist '("sh" . "src shell"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))

#+end_src
I often want to set =src-block= headers, and it's a pain to
+ type them out
+ remember what the accepted values are
+ oh, and specifying the same language again and again

We can solve this in three steps
+ having one-letter snippets, conditioned on ~(point)~ being within a src header
+ creating a nice prompt showing accepted values and the current default
+ pre-filling the =src-block= language with the last language used

For header args, the keys I'll use are
+ =r= for =:results=
+ =e= for =:exports=
+ =v= for =:eval=
+ =s= for =:session=
+ =d= for =:dir=

#+begin_src emacs-lisp
(defun +yas/org-src-header-p ()
  "Determine whether `point' is within a src-block header or header-args."
  (pcase (org-element-type (org-element-context))
    ('src-block (< (point) ; before code part of the src-block
                   (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                   (forward-line 1)
                                   (point))))
    ('inline-src-block (< (point) ; before code part of the inline-src-block
                          (save-excursion (goto-char (org-element-property :begin (org-element-context)))
                                          (search-forward "]{")
                                          (point))))
    ('keyword (string-match-p "^header-args" (org-element-property :value (org-element-context))))))
#+end_src

#+RESULTS:
: +yas/org-src-header-p

Now let's write a function we can reference in yasnippets to produce a nice
interactive way to specify header args.

#+begin_src emacs-lisp
(defun +yas/org-prompt-header-arg (arg question values)
  "Prompt the user to set ARG header property to one of VALUES with QUESTION.
The default value is identified and indicated. If either default is selected,
or no selection is made: nil is returned."
  (let* ((src-block-p (not (looking-back "^#\\+property:[ \t]+header-args:.*" (line-beginning-position))))
         (default
           (or
            (cdr (assoc arg
                        (if src-block-p
                            (nth 2 (org-babel-get-src-block-info t))
                          (org-babel-merge-params
                           org-babel-default-header-args
                           (let ((lang-headers
                                  (intern (concat "org-babel-default-header-args:"
                                                  (+yas/org-src-lang)))))
                             (when (boundp lang-headers) (eval lang-headers t)))))))
            ""))
         default-value)
    (setq values (mapcar
                  (lambda (value)
                    (if (string-match-p (regexp-quote value) default)
                        (setq default-value
                              (concat value " "
                                      (propertize "(default)" 'face 'font-lock-doc-face)))
                      value))
                  values))
    (let ((selection (consult--read values :prompt question :default default-value)))
      (unless (or (string-match-p "(default)$" selection)
                  (string= "" selection))
        selection))))
#+end_src

Finally, we fetch the language information for new source blocks.

Since we're getting this info, we might as well go a step further and also
provide the ability to determine the most popular language in the buffer that
doesn't have any =header-args= set for it (with =#+properties=).

#+begin_src emacs-lisp
(defun +yas/org-src-lang ()
  "Try to find the current language of the src/header at `point'.
Return nil otherwise."
  (let ((context (org-element-context)))
    (pcase (org-element-type context)
      ('src-block (org-element-property :language context))
      ('inline-src-block (org-element-property :language context))
      ('keyword (when (string-match "^header-args:\\([^ ]+\\)" (org-element-property :value context))
                  (match-string 1 (org-element-property :value context)))))))

(defun +yas/org-last-src-lang ()
  "Return the language of the last src-block, if it exists."
  (save-excursion
    (beginning-of-line)
    (when (re-search-backward "^[ \t]*#\\+begin_src" nil t)
      (org-element-property :language (org-element-context)))))

(defun +yas/org-most-common-no-property-lang ()
  "Find the lang with the most source blocks that has no global header-args, else nil."
  (let (src-langs header-langs)
    (save-excursion
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+begin_src" nil t)
        (push (+yas/org-src-lang) src-langs))
      (goto-char (point-min))
      (while (re-search-forward "^[ \t]*#\\+property: +header-args" nil t)
        (push (+yas/org-src-lang) header-langs)))

    (setq src-langs
          (mapcar #'car
                  ;; sort alist by frequency (desc.)
                  (sort
                   ;; generate alist with form (value . frequency)
                   (cl-loop for (n . m) in (seq-group-by #'identity src-langs)
                            collect (cons n (length m)))
                   (lambda (a b) (> (cdr a) (cdr b))))))

    (car (cl-set-difference src-langs header-langs :test #'string=))))
#+end_src

#+RESULTS:
: +yas/org-most-common-no-property-lang

***** Translate capital keywords (old) to lower case (new)
Everyone used to use ~#+CAPITAL~ keywords. Then people realised that ~#+lowercase~
is actually both marginally easier and visually nicer, so now the capital
version is just used in the manual.
#+begin_quote
Org is standardized on lower case. Uppercase is used in the manual as a poor
man's bold, and supported for historical reasons. --- [[https://orgmode.org/list/87tuuw3n15.fsf@nicolasgoaziou.fr][Nicolas Goaziou on the Org ML]]
#+end_quote

To avoid sometimes having to choose between the hassle out of updating old
documents and using mixed syntax, I'll whip up a basic transcode-y function.
It likely misses some edge cases, but should mostly work.

#+begin_src emacs-lisp
(defun org-syntax-convert-keyword-case-to-lower ()
  "Convert all #+KEYWORDS to #+keywords."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((count 0)
          (case-fold-search nil))
      (while (re-search-forward "^[ \t]*#\\+[A-Z_]+" nil t)
        (unless (s-matches-p "RESULTS" (match-string 0))
          (replace-match (downcase (match-string 0)) t)
          (setq count (1+ count))))
      (message "Replaced %d occurances" count))))
#+end_src

#+RESULTS:
: org-syntax-convert-keyword-case-to-lower

***** Extra links
****** xkcd
Because xkcd is cool, let's make it as easy and fun as possible to insert them.
Saving seconds adds up after all! (but only so much)

[[xkcd:1205]]

#+begin_src emacs-lisp
(org-link-set-parameters "xkcd"
                         :image-data-fun #'+org-xkcd-image-fn
                         :follow #'+org-xkcd-open-fn
                         :export #'+org-xkcd-export
                         :complete #'+org-xkcd-complete)

(defun +org-xkcd-open-fn (link)
  (+org-xkcd-image-fn nil link nil))

(defun +org-xkcd-image-fn (protocol link description)
  "Get image data for xkcd num LINK"
  (let* ((xkcd-info (+xkcd-fetch-info (string-to-number link)))
         (img (plist-get xkcd-info :img))
         (alt (plist-get xkcd-info :alt)))
    (message alt)
    (+org-image-file-data-fn protocol (xkcd-download img (string-to-number link)) description)))

(defun +org-xkcd-export (num desc backend _com)
  "Convert xkcd to html/LaTeX form"
  (let* ((xkcd-info (+xkcd-fetch-info (string-to-number num)))
         (img (plist-get xkcd-info :img))
         (alt (plist-get xkcd-info :alt))
         (title (plist-get xkcd-info :title))
         (file (xkcd-download img (string-to-number num))))
    (cond ((org-export-derived-backend-p backend 'html)
           (format "<img class='invertible' src='%s' title=\"%s\" alt='%s'>" img (subst-char-in-string ?\" ?“ alt) title))
          ((org-export-derived-backend-p backend 'latex)
           (format "\\begin{figure}[!htb]
  \\centering
  \\includegraphics[scale=0.4]{%s}%s
\\end{figure}" file (if (equal desc (format "xkcd:%s" num)) ""
                      (format "\n  \\caption*{\\label{xkcd:%s} %s}"
                              num
                              (or desc
                                  (format "\\textbf{%s} %s" title alt))))))
          (t (format "https://xkcd.com/%s" num)))))

(defun +org-xkcd-complete (&optional arg)
  "Complete xkcd using `+xkcd-stored-info'"
  (format "xkcd:%d" (+xkcd-select)))
#+end_src

#+RESULTS:
: +org-xkcd-complete

****** YouTube
The ~[[yt:...]]~ links preview nicely, but don't export nicely. Thankfully, we can
fix that.
#+begin_src emacs-lisp
(org-link-set-parameters "yt" :export #'+org-export-yt)
(defun +org-export-yt (path desc backend _com)
  (cond ((org-export-derived-backend-p backend 'html)
         (format "<iframe width='440' \
height='335' \
src='https://www.youtube.com/embed/%s' \
frameborder='0' \
allowfullscreen>%s</iframe>" path (or "" desc)))
        ((org-export-derived-backend-p backend 'latex)
         (format "\\href{https://youtu.be/%s}{%s}" path (or desc "youtube")))
        (t (format "https://youtu.be/%s" path))))
#+end_src

#+RESULTS:
: +org-export-yt

***** Fix problematic hooks
When one of the src_elisp{org-mode-hook} functions errors, it halts the hook
execution. This is problematic, and there are two hooks in particular which
cause issues. Let's make their failure less eventful.

#+begin_src emacs-lisp
(defadvice! shut-up-org-problematic-hooks (orig-fn &rest args)
  :around #'org-fancy-priorities-mode
  :around #'org-superstar-mode
  (ignore-errors (apply orig-fn args)))
#+end_src

#+RESULTS:

***** Flycheck with org-lint


Org may be simple, but that doesn't mean there's no such thing as malformed Org.
Thankfully, malformed Org is a much less annoying affair than malformed zipped
XML (looks at DOCX/ODT...), particularly because there's a rather helpful little
tool called ~org-lint~ bundled with Org that can tell you about your mistakes.


Flycheck doesn't currently support Org, and there's aren't any packages to do so
☹. However, in an issue on ~org-lint~ there is [[https://github.com/flycheck/flycheck/issues/1757#issuecomment-759546940][some code]] which apparently works.
Surely this is what the clipboard was invented for? With that said, let's
regurgitate the code, cross our fingers, and hope it works.

#+begin_src emacs-lisp :tangle no
(defconst flycheck-org-lint-form
  (flycheck-prepare-emacs-lisp-form
    (require 'org)
    (require 'org-attach)
    (let ((source (car command-line-args-left))
          (process-default-directory default-directory))
      (with-temp-buffer
        (insert-file-contents source 'visit)
        (setq buffer-file-name source)
        (setq default-directory process-default-directory)
        (delay-mode-hooks (org-mode))
        (setq delayed-mode-hooks nil)
        (dolist (err (org-lint))
          (let ((inf (cl-second err)))
            (princ (elt inf 0))
            (princ ": ")
            (princ (elt inf 2))
            (terpri)))))))

(defconst flycheck-org-lint-variables
  '(org-directory
    org-id-locations
    org-id-locations-file
    org-attach-id-dir
    org-attach-use-inheritance
    org-attach-id-to-path-function-list
    org-link-parameters)
  "Variables inherited by the org-lint subprocess.")

(defun flycheck-org-lint-variables-form ()
  (require 'org-attach)  ; Needed to make variables available
  `(progn
     ,@(seq-map (lambda (opt) `(setq-default ,opt ',(symbol-value opt)))
                (seq-filter #'boundp flycheck-org-lint-variables))))

(eval ; To preveant eager macro expansion form loading flycheck early.
 '(flycheck-define-checker org-lint
   "Org buffer checker using `org-lint'."
   :command ("emacs" (eval flycheck-emacs-args)
             "--eval" (eval (concat "(add-to-list 'load-path \""
                                    (file-name-directory (locate-library "org"))
                                    "\")"))
             "--eval" (eval (flycheck-sexp-to-string
                             (flycheck-org-lint-variables-form)))
             "--eval" (eval (flycheck-sexp-to-string
                             (flycheck-org-lint-customisations-form)))
             "--eval" (eval flycheck-org-lint-form)
             "--" source)
   :error-patterns
   ((error line-start line ": " (message) line-end))
   :modes org-mode))
#+end_src

#+RESULTS:

Turns out it almost works. Running =M-x flycheck-verify-setup= after running that
snippet produces the following:
#+begin_example
The following syntax checkers are not registered:
  - org-lint
Try adding these syntax checkers to `flycheck-checkers'.
#+end_example

Well that's very nice and helpful. We'll just do that 🙂.
#+begin_src emacs-lisp :tangle no
(add-to-list 'flycheck-checkers 'org-lint)
#+end_src

It was missing custom link types, but that's easily fixed just by adding
~org-link-parameters~ to ~flycheck-org-lint-variables~.

One remaining little annoyance is that it reports extra =#+options= that I've
added to Org as errors. So we need to tell ~org-lint~ about them without having it
load my whole config. Code duplication isn't great, but at least this isn't
much.

#+name: org-syntax-modifications
#+begin_src emacs-lisp :tangle no
(defun flycheck-org-lint-customisations-form ()
  `(progn
     (require 'ox)
     (cl-pushnew '(:latex-cover-page nil "coverpage" nil)
                 (org-export-backend-options (org-export-get-backend 'latex)))
     (cl-pushnew '(:latex-font-set nil "fontset" nil)
                 (org-export-backend-options (org-export-get-backend 'latex)))))
#+end_src
***** org refile
#+begin_src emacs-lisp
(setq org-refile-targets (quote ((nil :maxlevel . 9)
                                 (org-agenda-files :maxlevel . 9))))
(setq org-refile-use-outline-path 'file)
(setq org-refile-active-region-within-subtree t)
(setq org-outline-path-complete-in-steps nil)
(setq org-refile-allow-creating-parent-nodes (quote confirm))

#+end_src
***** org-vid-minor-mode
  #+begin_src emacs-lisp
   (define-minor-mode org-vid-minor-mode
      "Toggle video minor mode for video note taking in org-mode"
      :lighter " Video"
      :keymap
      `(
        (,(kbd "<up>")    . (lambda () (interactive) (mpv-speed-increase 1)))
        (,(kbd "<down>")  . (lambda () (interactive) (mpv-speed-decrease 1)))
        (,(kbd "<right>") . (lambda () (interactive) (mpv-seek-forward 1)))
        (,(kbd "<left>")  . (lambda () (interactive) (mpv-seek-backward 1)))
        (,(kbd "M-p")     . mpv-pause)
        (,(kbd "M-SPC")   . mpv-pause)
        (,(kbd "M-k")     . mpv-kill)
        (,(kbd "M--")     . (lambda () (interactive) (mpv-insert-playback-position t)))
        (,(kbd "M-s")     . (lambda () mpv-seek))
        (,(kbd "M-0")     . (lambda () (interactive) (mpv-speed-set 1)))
        (,(kbd "M-S")     . (lambda () (interactive) (mpv-seek-to-position-at-point)))
        ))
  #+end_src
**** DONE Visuals
CLOSED: [2022-04-01 Fri 18:12]

Here I try to do two things: improve the styling of the various documents, via
font changes etc, and also propagate colours from the current theme.

***** Font Display
Mixed pitch is great. As is ~+org-pretty-mode~, let's use them.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook #'+org-pretty-mode)
#+end_src


#+begin_src emacs-lisp :tangle no
(after! org
(custom-set-faces!
  '((org-block) :background nil)
  )
  (defface redd
    '((((class color) (min-colors 88) (background light))
      :foreground "red"))
    "Red."
    :group 'basic-faces)
  (custom-set-faces!
    ;'(org-document-title :height 1.6 :weight bold)
    '(org-level-1 :height 1.3 :weight extrabold :slant normal)
    '(org-level-2 :height 1.2 :weight bold :slant normal)
    '(org-level-3 :height 1.1 :weight regular :slant normal)
    ;'(org-document-info  :inherit 'nano-face-faded)
    '(org-document-title   ;:foreground ,(doom-color 'black)
                           :family "Roboto"
                           :height 250
                           :weight medium)))
#+end_src

#+RESULTS:
| doom--customize-themes-h-9 | doom--customize-themes-h-16 | doom--customize-themes-h-17 |

You can set the Org heading levels to be different font sizes.  So I choose to have level 1 headings to be 140% in height, level 2 to be 130%, etc.  Other interesting things you could play with include adding :foreground color and/or :background color if you want to override the theme colors.
Let's make headings a bit bigger

#+begin_src emacs-lisp :tangle yes
;; (after! org
  (custom-set-faces!
    '(org-level-1 :inherit outline-1 :weight extra-bold :height 1.35)
    '(org-level-2 :inherit outline-2 :weight bold :height 1.25)
    '(org-level-3 :inherit outline-3 :weight bold :height 1.22)
    '(org-level-4 :inherit outline-4 :weight bold :height 1.19)
    '(org-level-5 :inherit outline-5 :weight semi-bold :height 1.16)
    '(org-level-6 :inherit outline-6 :weight semi-bold :height 1.13)
    '(org-level-7 :inherit outline-7 :weight semi-bold)
    '(org-level-8 :inherit outline-8 :weight semi-bold)
    ;; Ensure that anything that should be fixed-pitch in org buffers appears that
    ;; way
    '(org-block nil :foreground nil :inherit 'fixed-pitch)
    '(org-code nil   :inherit '(shadow fixed-pitch))
    '(org-table nil   :inherit '(shadow fixed-pitch))
    '(org-verbatim nil :inherit '(shadow fixed-pitch))
    '(org-special-keyword nil :inherit '(font-lock-comment-face fixed-pitch))
    '(org-meta-line nil :inherit '(font-lock-comment-face fixed-pitch))
    '(org-checkbox nil :inherit 'fixed-pitch))
#+end_src

#+RESULTS:
| doom--customize-themes-h-1854 | doom--customize-themes-h-1855 | doom--customize-themes-h-1875 | doom--customize-themes-h-1876 | doom--customize-themes-h-1878 | doom--customize-themes-h-1885 |


And the same with the title.
#+begin_src emacs-lisp
(custom-set-faces!
  '(org-document-title :height 1.2))
#+end_src

#+RESULTS:
| doom--customize-themes-h-13 | doom--customize-themes-h-14 | doom--customize-themes-h-33 | doom--customize-themes-h-34 | doom--customize-themes-h-35 | doom--customize-themes-h-36 |

It seems reasonable to have deadlines in the error face when they're passed.
#+begin_src emacs-lisp
(setq org-agenda-deadline-faces
      '((1.001 . error)
        (1.0 . org-warning)
        (0.5 . org-upcoming-deadline)
        (0.0 . org-upcoming-distant-deadline)))
#+end_src

We can then have quote blocks stand out a bit more by making them /italic/.
#+begin_src emacs-lisp
(setq org-fontify-quote-and-verse-blocks t)
#+end_src

Org files can be rather nice to look at, particularly with some of the
customisations here. This comes at a cost however, expensive font-lock.
Feeling like you're typing through molasses in large files is no fun, but there
is a way I can defer font-locking when typing to make the experience more
responsive.
#+begin_src emacs-lisp
(defun locally-defer-font-lock ()
  "Set jit-lock defer and stealth, when buffer is over a certain size."
  ;; (when (> (buffer-size) 50000)
  (when (> (buffer-size) 5000);;as my laptop barely runs without graphics card
    (setq-local jit-lock-defer-time 0.05
                jit-lock-stealth-time 1)))

(add-hook 'org-mode-hook #'locally-defer-font-lock)
#+end_src


Apparently this causes issues with some people, but I haven't noticed anything
problematic beyond the expected slight delay in some fontification, so until I
do I'll use the above.
***** Reduced text indent

Thanks to the various bits and bobs of setup we have here, the non-heading lines
tend to appear over-indented in ~org-indent-mode~. We can adjust this by modifying
the generated text prefixes.

There's another issue we can have when using mixed-pitch mode, where the line
height is set by the indent prefix displayed with the fixed-pitch font. This
means that on 0-indent lines the line spacing can be different, which doesn't
look very good. We can also solve this problem by modifying the generated text
prefixes to but a fixed-pitch zero width space at the start of 0-indent lines
instead of nothing.

#+begin_src emacs-lisp
(defadvice! +org-indent--reduced-text-prefixes ()
  :after #'org-indent--compute-prefixes
  (setq org-indent--text-line-prefixes
        (make-vector org-indent--deepest-level nil))
  (when (> org-indent-indentation-per-level 0)
    (dotimes (n org-indent--deepest-level)
      (aset org-indent--text-line-prefixes
            n
            (org-add-props
                (concat (make-string (* n (1- org-indent-indentation-per-level))
                                     ?\s)
                        (if (> n 0)
                             (char-to-string org-indent-boundary-char)
                          "\u200b"))
                nil 'face 'org-indent)))))
#+end_src

***** Fontifying inline src blocks
Org does lovely things with =#+begin_src= blocks, like using font-lock for
language's major-mode behind the scenes and pulling out the lovely colourful
results. By contrast, inline =src_= blocks are somewhat neglected.

I am not the first person to feel this way, thankfully others have [[https://stackoverflow.com/questions/20309842/how-to-syntax-highlight-for-org-mode-inline-source-code-src-lang/28059832][taken to
stackexchange]] to voice their desire for inline src fontification. I was going to
steal their work, but unfortunately they didn't perform /true/ source code
fontification, but simply applied the =org-code= face to the content.

We can do better than that, and we shall! Using ~org-src-font-lock-fontify-block~
we can apply language-appropriate syntax highlighting. Then, continuing on to
={{{results(...)}}}= , it can have the =org-block= face applied to match, and then
the value-surrounding constructs hidden by mimicking the behaviour of
~prettify-symbols-mode~.

#+begin_warning
This currently only highlights a single inline src block per line.
I have no idea why it stops, but I'd rather it didn't.
If you have any idea what's going on or how to fix this /please/ get in touch.
#+end_warning

#+begin_src emacs-lisp
(setq org-inline-src-prettify-results '("⟨" . "⟩"))
#+end_src

Doom theme's extra fontification is more problematic than helpful.
#+begin_src emacs-lisp
(setq doom-themes-org-fontify-special-tags nil)
#+end_src

***** LaTeX Fragments
****** Prettier highlighting

First off, we want those fragments to look good.
#+begin_src emacs-lisp :tangle yes
(setq org-highlight-latex-and-related '(native script entities))
#+end_src

#+RESULTS:
| native | script | entities |

However, by using =native= highlighting the =org-block= face is added, and that
doesn't look too great --- particularly when the fragments are previewed.

Ideally ~org-src-font-lock-fontify-block~ wouldn't add the =org-block= face, but we
can avoid advising that entire function by just adding another face with
=:inherit default= which will override the background colour.

Inspecting ~org-do-latex-and-related~ shows that ="latex"= is the language argument
passed, and so we can override the background as discussed above.
#+begin_src emacs-lisp :tangle yes
(require 'org-src)
(add-to-list 'org-src-block-faces '("latex" (:inherit default :extend t)))
#+end_src

#+RESULTS:
| latex | (:inherit default :extend t) |

****** More eager rendering


What's better than syntax-highlighted LaTeX is /rendered/ LaTeX though, and we can
have this be performed automatically with =org-fragtog=.

#+begin_src emacs-lisp :tangle packages.el
(package! org-fragtog :pin "c675563af3f9ab5558cfd5ea460e2a07477b0cfd")
#+end_src

#+RESULTS:
| org-fragtog | :modules | ((:user) (:user . modules)) | :pin | 680606189d5d28039e6f9301b55ec80517a24005 |

#+begin_src emacs-lisp :tangle yes
(use-package! org-fragtog
  :hook (org-mode . org-fragtog-mode))
#+end_src

#+RESULTS:
| org-fragtog-mode | locally-defer-font-lock | +org-pretty-mode | org-ref-org-menu | er/add-org-mode-expansions | turn-on-org-cdlatex | org-appear-mode | elpher-org-mode-integration | auto-revert-mode | #[0 \301\211\207 [imenu-create-index-function org-imenu-get-tree] 2] | beginend-org-mode | +lookup--init-org-mode-handlers-h | (closure ((hook . org-mode-hook) (--dolist-tail--) t) (&rest _) (add-hook 'before-save-hook 'org-encrypt-entries nil t)) | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-fold-show-all append local] 5] | #[0 \300\301\302\303\304$\207 [add-hook change-major-mode-hook org-babel-show-result-all append local] 5] | org-babel-result-hide-spec | org-babel-hide-all-hashes | doom-disable-show-paren-mode-h | doom-disable-show-trailing-whitespace-h | +org-enable-auto-reformat-tables-h | +org-enable-auto-update-cookies-h | +org-make-last-point-visible-h | org-fancy-priorities-mode | org-superstar-mode | evil-org-mode | toc-org-enable | embrace-org-mode-hook | org-eldoc-load | +literate-enable-recompile-h |

****** Prettier rendering

It's nice to customise the look of LaTeX fragments so they fit better in the
text --- like this \(\sqrt{\beta^2+3}-\sum_{\phi=1}^\infty \frac{x^\phi-1}{\Gamma(a)}\).
Let's start by adding a sans font. I'd also like to use some of the
functionality from =bmc-maths=, so we'll load that too.

#+begin_src emacs-lisp :tangle yes
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{xcolor}

\\usepackage[T1]{fontenc}

\\usepackage{booktabs}

\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
% my custom stuff
\\usepackage[nofont,plaindd]{bmc-maths}
\\usepackage{arev}
")
#+end_src

#+RESULTS:
#+begin_example
\documentclass{article}
\usepackage[usenames]{xcolor}

\usepackage[T1]{fontenc}

\usepackage{booktabs}

\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\setlength{\textwidth}{\paperwidth}
\addtolength{\textwidth}{-3cm}
\setlength{\oddsidemargin}{1.5cm}
\addtolength{\oddsidemargin}{-2.54cm}
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textheight}{\paperheight}
\addtolength{\textheight}{-\headheight}
\addtolength{\textheight}{-\headsep}
\addtolength{\textheight}{-\footskip}
\addtolength{\textheight}{-3cm}
\setlength{\topmargin}{1.5cm}
\addtolength{\topmargin}{-2.54cm}
% my custom stuff
\usepackage[nofont,plaindd]{bmc-maths}
\usepackage{arev}
#+end_example

Since we can, instead of making the background colour match the =default= face,
let's make it transparent.
#+begin_src emacs-lisp :tangle yes
(setq org-format-latex-options
      (plist-put org-format-latex-options :background "Transparent"))
#+end_src

#+RESULTS:
| :foreground | default | :background | Transparent | :scale | 1.5 | :html-foreground | Black | :html-background | Transparent | :html-scale | 1.0 | :matchers | (begin $1 $ $$ \( \[) |

With the background taken care of, we just need to make sure we're using the
theme-appropriate foreground.

# TODO check that this is still needed.

#+begin_src emacs-lisp :tangle no
(add-hook! 'doom-load-theme-hook
  (setq org-preview-latex-image-directory
        (concat doom-cache-dir "org-latex/" (symbol-name doom-theme) "/"))
  (dolist (buffer (doom-buffers-in-mode 'org-mode (buffer-list)))
    (with-current-buffer buffer
      (+org--toggle-inline-images-in-subtree (point-min) (point-max) 'refresh)
      (org-clear-latex-preview (point-min) (point-max))
      (org--latex-preview-region (point-min) (point-max)))))
#+end_src

#+RESULTS:

****** Rendering speed tests

We can either render from a ~dvi~ or ~pdf~ file, so let's benchmark ~latex~ and
~pdflatex~.
| ~latex~ time | ~pdflatex~ time |
|------------+---------------|
| 135 \pm 2 ms | 215 \pm 3 ms    |

On the rendering side, there are two ~.dvi~-to-image converters which I am
interested in: ~dvipng~ and ~dvisvgm~. Then with the a ~.pdf~ we have ~pdf2svg~.
For inline preview we care about speed, while for exporting we care about file
size and prefer a vector graphic.

Using the above latex expression and benchmarking lead to the following results:
| ~dvipng~ time | ~dvisvgm~ time | ~pdf2svg~ time |
|-------------+--------------+--------------|
| 89 \pm 2 ms   | 178 \pm 2 ms   | 12 \pm 2 ms    |

Now let's combine this to see what's best
| Tool chain         | Total time | Resultant file size |
|--------------------+------------+---------------------|
| ~latex~ + ~dvipng~     | 226 \pm 2 ms | 7 KiB               |
| ~latex~ + ~dvisvgm~    | 392 \pm 4 ms | 8 KiB               |
| ~pdflatex~ + ~pdf2svg~ | 230 \pm 2 ms | 16 KiB              |

So, let's use ~dvipng~ for previewing LaTeX fragments in-Emacs, but ~dvisvgm~ for [[LaTeX Rendering]].

#+begin_warning
Unfortunately, it seems that SVG sizing is annoying ATM, so let's actually not do this right now.
#+end_warning

***** Stolen from [[https://github.com/jkitchin/scimax][scimax]] (semi-working right now)

I want fragment justification
#+begin_src emacs-lisp
(defun scimax-org-latex-fragment-justify (justification)
  "Justify the latex fragment at point with JUSTIFICATION.
JUSTIFICATION is a symbol for 'left, 'center or 'right."
  (interactive
   (list (intern-soft
          (completing-read "Justification (left): " '(left center right)
                           nil t nil nil 'left))))
  (let* ((ov (ov-at))
         (beg (ov-beg ov))
         (end (ov-end ov))
         (shift (- beg (line-beginning-position)))
         (img (overlay-get ov 'display))
         (img (and (and img (consp img) (eq (car img) 'image)
                        (image-type-available-p (plist-get (cdr img) :type)))
                   img))
         space-left offset)
    (when (and img
               ;; This means the equation is at the start of the line
               (= beg (line-beginning-position))
               (or
                (string= "" (s-trim (buffer-substring end (line-end-position))))
                (eq 'latex-environment (car (org-element-context)))))
      (setq space-left (- (window-max-chars-per-line) (car (image-size img)))
            offset (floor (cond
                           ((eq justification 'center)
                            (- (/ space-left 2) shift))
                           ((eq justification 'right)
                            (- space-left shift))
                           (t
                            0))))
      (when (>= offset 0)
        (overlay-put ov 'before-string (make-string offset ?\ ))))))

(defun scimax-org-latex-fragment-justify-advice (beg end image imagetype)
  "After advice function to justify fragments."
  (scimax-org-latex-fragment-justify (or (plist-get org-format-latex-options :justify) 'left)))


(defun scimax-toggle-latex-fragment-justification ()
  "Toggle if LaTeX fragment justification options can be used."
  (interactive)
  (if (not (get 'scimax-org-latex-fragment-justify-advice 'enabled))
      (progn
        (advice-add 'org--format-latex-make-overlay :after 'scimax-org-latex-fragment-justify-advice)
        (put 'scimax-org-latex-fragment-justify-advice 'enabled t)
        (message "Latex fragment justification enabled"))
    (advice-remove 'org--format-latex-make-overlay 'scimax-org-latex-fragment-justify-advice)
    (put 'scimax-org-latex-fragment-justify-advice 'enabled nil)
    (message "Latex fragment justification disabled")))
#+end_src
There's also this lovely equation numbering stuff I'll nick
#+begin_src emacs-lisp
;; Numbered equations all have (1) as the number for fragments with vanilla
;; org-mode. This code injects the correct numbers into the previews so they
;; look good.
(defun scimax-org-renumber-environment (orig-func &rest args)
  "A function to inject numbers in LaTeX fragment previews."
  (let ((results '())
        (counter -1)
        (numberp))
    (setq results (cl-loop for (begin . env) in
                           (org-element-map (org-element-parse-buffer) 'latex-environment
                             (lambda (env)
                               (cons
                                (org-element-property :begin env)
                                (org-element-property :value env))))
                           collect
                           (cond
                            ((and (string-match "\\\\begin{equation}" env)
                                  (not (string-match "\\\\tag{" env)))
                             (cl-incf counter)
                             (cons begin counter))
                            ((string-match "\\\\begin{align}" env)
                             (prog2
                                 (cl-incf counter)
                                 (cons begin counter)
                               (with-temp-buffer
                                 (insert env)
                                 (goto-char (point-min))
                                 ;; \\ is used for a new line. Each one leads to a number
                                 (cl-incf counter (count-matches "\\\\$"))
                                 ;; unless there are nonumbers.
                                 (goto-char (point-min))
                                 (cl-decf counter (count-matches "\\nonumber")))))
                            (t
                             (cons begin nil)))))

    (when (setq numberp (cdr (assoc (point) results)))
      (setf (car args)
            (concat
             (format "\\setcounter{equation}{%s}\n" numberp)
             (car args)))))

  (apply orig-func args))


(defun scimax-toggle-latex-equation-numbering ()
  "Toggle whether LaTeX fragments are numbered."
  (interactive)
  (if (not (get 'scimax-org-renumber-environment 'enabled))
      (progn
        (advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
        (put 'scimax-org-renumber-environment 'enabled t)
        (message "Latex numbering enabled"))
    (advice-remove 'org-create-formula-image #'scimax-org-renumber-environment)
    (put 'scimax-org-renumber-environment 'enabled nil)
    (message "Latex numbering disabled.")))

(advice-add 'org-create-formula-image :around #'scimax-org-renumber-environment)
(put 'scimax-org-renumber-environment 'enabled t)
#+end_src


***** Symbols

It's also nice to change the character used for collapsed items (by default ~…~),
I think ~▾~ is better for indicating 'collapsed section'.
and add an extra ~org-bullet~ to the default list of four.
I've also added some fun alternatives, just commented out.
#+begin_src emacs-lisp
(after! org-superstar
  (setq org-superstar-headline-bullets-list '("◉" "○" "✸" "✿" "✤" "✜" "◆" "▶")
        org-superstar-prettify-item-bullets t ))

        ;; org-superstar-headline-bullets-list '("◉" "●" "○" "◆" "●" "○" "◆")
        ;; org-superstar-item-bullet-alist '((?+ . ?➤) (?- . ?✦)) ; changes +/- symbols in item lists

(setq org-ellipsis " ▾ "
      org-hide-leading-stars t
      org-priority-highest ?A
      org-priority-lowest ?E
      org-priority-faces
      '((?A . 'all-the-icons-red)
        (?B . 'all-the-icons-orange)
        (?C . 'all-the-icons-yellow)
        (?D . 'all-the-icons-green)
        (?E . 'all-the-icons-blue)))
#+end_src

#+RESULTS:
| 65 | quote | all-the-icons-red    |
| 66 | quote | all-the-icons-orange |
| 67 | quote | all-the-icons-yellow |
| 68 | quote | all-the-icons-green  |
| 69 | quote | all-the-icons-blue   |

It's also nice to make use of the Unicode characters for check boxes, and other commands.
#+begin_src emacs-lisp
(appendq! +ligatures-extra-symbols
          `(:checkbox      "☐"
            :pending       "◼"
            :checkedbox    "☑"
            :list_property "∷"
            :em_dash       "—"
            :ellipses      "…"
            :arrow_right   "→"
            :arrow_left    "←"
            :title         "𝙏"
            :subtitle      "𝙩"
            :author        "𝘼"
            :date          "𝘿"
            :property      "☸"
            :options       "⌥"
            :startup       "⏻"
            :macro         "𝓜"
            :html_head     "🅷"
            :html          "🅗"
            :latex_class   "🄻"
            :latex_header  "🅻"
            :beamer_header "🅑"
            :latex         "🅛"
            :attr_latex    "🄛"
            :attr_html     "🄗"
            :attr_org      "⒪"
            :begin_quote   "❝"
            :end_quote     "❞"
            :caption       "☰"
            :header        "›"
            :results       "🠶"
            :begin_export  "⏩"
            :end_export    "⏪"
            :properties    "⚙"
            :end           "∎"
            :priority_a   ,(propertize "⚑" 'face 'all-the-icons-red)
            :priority_b   ,(propertize "⬆" 'face 'all-the-icons-orange)
            :priority_c   ,(propertize "■" 'face 'all-the-icons-yellow)
            :priority_d   ,(propertize "⬇" 'face 'all-the-icons-green)
            :priority_e   ,(propertize "❓" 'face 'all-the-icons-blue)))
(set-ligatures! 'org-mode
  :merge t
  :checkbox      "[ ]"
  :pending       "[-]"
  :checkedbox    "[X]"
  :list_property "::"
  :em_dash       "---"
  :ellipsis      "..."
  :arrow_right   "->"
  :arrow_left    "<-"
  :title         "#+title:"
  :subtitle      "#+subtitle:"
  :author        "#+author:"
  :date          "#+date:"
  :property      "#+property:"
  :options       "#+options:"
  :startup       "#+startup:"
  :macro         "#+macro:"
  :html_head     "#+html_head:"
  :html          "#+html:"
  :latex_class   "#+latex_class:"
  :latex_header  "#+latex_header:"
  :beamer_header "#+beamer_header:"
  :latex         "#+latex:"
  :attr_latex    "#+attr_latex:"
  :attr_html     "#+attr_html:"
  :attr_org      "#+attr_org:"
  :begin_quote   "#+begin_quote"
  :end_quote     "#+end_quote"
  :caption       "#+caption:"
  :header        "#+header:"
  :begin_export  "#+begin_export"
  :end_export    "#+end_export"
  :results       "#+RESULTS:"
  :property      ":PROPERTIES:"
  :end           ":END:"
  :priority_a    "[#A]"
  :priority_b    "[#B]"
  :priority_c    "[#C]"
  :priority_d    "[#D]"
  :priority_e    "[#E]"
  :roam_tags     "#+roam_tags:"
  :filetags      "#+filetags:")
(plist-put +ligatures-extra-symbols :name "⁍")

;; (with-eval-after-load 'org
;;   (plist-put org-format-latex-options :background 'default))
#+end_src

#+RESULTS:
| :name | ⁍  | :src_block | » | :src_block_end | « | :quote | “ | :quote_end | ” | :lambda | λ | :def | ƒ | :composition | ∘ | :map | ↦ | :null | ∅ | :true | 𝕋 | :false | 𝔽 | :int | ℤ | :float | ℝ | :str | 𝕊  | :bool | 𝔹 | :list | 𝕃 | :not | ￢ | :in | ∈ | :not-in | ∉ | :and | ∧ | :or | ∨ | :for | ∀ | :some | ∃ | :return | ⟼ | :yield | ⟻ | :union | ⋃ | :intersect | ∩ | :diff | ∖  | :tuple | ⨂ | :pipe |  | :dot | • | :checkbox | ☐ | :pending | ◼  | :checkedbox | ☑ | :list_property | ∷ | :em_dash | — | :ellipses | … | :arrow_right | → | :arrow_left | ← | :title | 𝙏  | :subtitle | 𝙩  | :author | 𝘼 | :date | 𝘿 | :property | ☸ | :options | ⌥ | :startup | ⏻ | :macro | 𝓜 | :html_head | 🅷 | :html | 🅗 | :latex_class | 🄻 | :latex_header | 🅻 | :beamer_header | 🅑 | :latex | 🅛 | :attr_latex | 🄛 | :attr_html | 🄗 | :attr_org | ⒪ | :begin_quote | ❝ | :end_quote | ❞ | :caption | ☰ | :header | › | :results | 🠶 | :begin_export | ⏩ | :end_export | ⏪ | :properties | ⚙ | :end | ∎ | :priority_a | ⚑  | :priority_b | ⬆ | :priority_c | ■ | :priority_d | ⬇ | :priority_e | ❓ | :checkbox | ☐ | :pending | ◼  | :checkedbox | ☑ | :list_property | ∷ | :em_dash | — | :ellipses | … | :arrow_right | → | :arrow_left | ← | :title | 𝙏  | :subtitle | 𝙩  | :author | 𝘼 | :date | 𝘿 | :property | ☸ | :options | ⌥ | :startup | ⏻ | :macro | 𝓜 | :html_head | 🅷 | :html | 🅗 | :latex_class | 🄻 | :latex_header | 🅻 | :beamer_header | 🅑 | :latex | 🅛 | :attr_latex | 🄛 | :attr_html | 🄗 | :attr_org | ⒪ | :begin_quote | ❝ | :end_quote | ❞ | :caption | ☰ | :header | › | :results | 🠶 | :begin_export | ⏩ | :end_export | ⏪ | :properties | ⚙ | :end | ∎ | :priority_a | ⚑  | :priority_b | ⬆ | :priority_c | ■ | :priority_d | ⬇ | :priority_e | ❓ |

~org-superstar-mode~ is great. While we're at it we may as well make tags prettier as well 🙂
#+begin_src emacs-lisp :tangle packages.el
;; (package! org-pretty-tags :pin "5c7521651b35ae9a7d3add4a66ae8cc176ae1c76")
#+end_src

#+begin_src emacs-lisp
;; (use-package! org-pretty-tags
;; :config
;;  (setq org-pretty-tags-surrogate-strings
;;        `(("uni"        . ,(all-the-icons-faicon   "graduation-cap" :face 'all-the-icons-purple  :v-adjust 0.01))
;;          ("ucc"        . ,(all-the-icons-material "computer"       :face 'all-the-icons-silver  :v-adjust 0.01))
;;          ("assignment" . ,(all-the-icons-material "library_books"  :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("test"       . ,(all-the-icons-material "timer"          :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("lecture"    . ,(all-the-icons-fileicon "keynote"        :face 'all-the-icons-orange  :v-adjust 0.01))
;;          ("email"      . ,(all-the-icons-faicon   "envelope"       :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("read"       . ,(all-the-icons-octicon  "book"           :face 'all-the-icons-lblue   :v-adjust 0.01))
;;          ("article"    . ,(all-the-icons-octicon  "file-text"      :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("web"        . ,(all-the-icons-faicon   "globe"          :face 'all-the-icons-green   :v-adjust 0.01))
;;          ("info"       . ,(all-the-icons-faicon   "info-circle"    :face 'all-the-icons-blue    :v-adjust 0.01))
;;          ("issue"      . ,(all-the-icons-faicon   "bug"            :face 'all-the-icons-red     :v-adjust 0.01))
;;          ("someday"    . ,(all-the-icons-faicon   "calendar-o"     :face 'all-the-icons-cyan    :v-adjust 0.01))
;;          ("idea"       . ,(all-the-icons-octicon  "light-bulb"     :face 'all-the-icons-yellow  :v-adjust 0.01))
;;          ("emacs"      . ,(all-the-icons-fileicon "emacs"          :face 'all-the-icons-lpurple :v-adjust 0.01))))
;;  (org-pretty-tags-global-mode))
#+end_src
***** Org Plot
We can use some of the variables in =org-plot= to use the current doom theme
colours.
#+begin_src emacs-lisp
(defvar +org-plot-term-size '(1050 . 650)
  "The size of the GNUPlot terminal, in the form (WIDTH . HEIGHT).")

(after! org-plot
  (defun +org-plot-generate-theme (_type)
    "Use the current Doom theme colours to generate a GnuPlot preamble."
    (format "
fgt = \"textcolor rgb '%s'\" # foreground text
fgat = \"textcolor rgb '%s'\" # foreground alt text
fgl = \"linecolor rgb '%s'\" # foreground line
fgal = \"linecolor rgb '%s'\" # foreground alt line

# foreground colors
set border lc rgb '%s'
# change text colors of  tics
set xtics @fgt
set ytics @fgt
# change text colors of labels
set title @fgt
set xlabel @fgt
set ylabel @fgt
# change a text color of key
set key @fgt

# line styles
set linetype 1 lw 2 lc rgb '%s' # red
set linetype 2 lw 2 lc rgb '%s' # blue
set linetype 3 lw 2 lc rgb '%s' # green
set linetype 4 lw 2 lc rgb '%s' # magenta
set linetype 5 lw 2 lc rgb '%s' # orange
set linetype 6 lw 2 lc rgb '%s' # yellow
set linetype 7 lw 2 lc rgb '%s' # teal
set linetype 8 lw 2 lc rgb '%s' # violet

# border styles
set tics out nomirror
set border 3

# palette
set palette maxcolors 8
set palette defined ( 0 '%s',\
1 '%s',\
2 '%s',\
3 '%s',\
4 '%s',\
5 '%s',\
6 '%s',\
7 '%s' )
"
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            (doom-color 'fg-alt)
            (doom-color 'fg)
            ;; colours
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)
            ;; duplicated
            (doom-color 'red)
            (doom-color 'blue)
            (doom-color 'green)
            (doom-color 'magenta)
            (doom-color 'orange)
            (doom-color 'yellow)
            (doom-color 'teal)
            (doom-color 'violet)))

  (defun +org-plot-gnuplot-term-properties (_type)
    (format "background rgb '%s' size %s,%s"
            (doom-color 'bg) (car +org-plot-term-size) (cdr +org-plot-term-size)))

  (setq org-plot/gnuplot-script-preamble #'+org-plot-generate-theme)
  (setq org-plot/gnuplot-term-extra #'+org-plot-gnuplot-term-properties))
#+end_src

#+RESULTS:
***** custom minor mode

   Stolen from =Prot=

#+begin_src emacs-lisp :tangle yes
;;;;;


;;
;;    Custom Minor Modes
;;
;;;;;

(define-minor-mode prot/scroll-center-cursor-mode
  "Toggle centred cursor scrolling behavior"
  :init-value nil
  :lighter " S="
  :global nil
  (if prot/scroll-center-cursor-mode
      (setq-local scroll-margin (* (frame-height) 2)
                  scroll-conservatively 0
                  maximum-scroll-margin 0.5)
    (dolist (local '(scroll-preserve-screen-position
                     scroll-conservatively
                     maximum-scroll-margin
                     scroll-margin))
      (kill-local-variable `,local)))
  )


#+end_src

#+RESULTS:


Make everything variable pitch, who the hell likes reading fixed-pitch?

#+begin_src emacs-lisp :tangle yes
(define-minor-mode prot/variable-pitch-mode
  "Toggle 'mixed-pitch-modei, except for programming modes"
  :init-value nil
  :global nil
  (if prot/variable-pitch-mode
      (unless (derived-mode-p 'prog-mode)
        (variable-pitch-mode 1))
    (variable-pitch-mode -1)))
#+end_src

NO line numbers.

#+begin_src emacs-lisp :tangle yes

(define-minor-mode prot/display-line-number-mode
  "Disable line numbers, except for programming modes."
  :init-value nil
  :global nil
  (if prot/display-line-number-mode
      (unless (derived-mode-p 'prog-mode)
        (display-line-numbers-mode -1))
    (display-line-numbers-mode 1)))
#+end_src

**** Exporting
***** General settings

By default Org only exports the first three levels of headings as ... headings.
This is rather unfortunate as my documents frequently stray far beyond three
levels of depth. The two main formats I care about exporting to are LaTeX and
HTML. When using an =article= class, LaTeX headlines go from =\section=,
=\subsection=, =\subsubsection=, and =\paragraph= to =\subgraph= --- /five/ levels.
HTML5 has six levels of headings (=<h1>= to =<h6>=), but first level Org headings
get exported as =<h2>= elements --- leaving /five/ usable levels.

As such, it would seem to make sense to recognise the first /five/ levels of Org
headings when exporting.

#+begin_src emacs-lisp
(setq org-export-headline-levels 5) ; I like nesting
#+end_src

I'm also going to make use of an item in =ox-extra= so that I can add an =:ignore:=
tag to headings for the content to be kept, but the heading itself ignored
(unlike =:noexport:= which ignored both heading and content). This is useful when
I want to use headings to provide a structure for writing that doesn't appear in
the final documents.
#+begin_src emacs-lisp
(require 'ox-extra)
(ox-extras-activate '(ignore-headlines))
#+end_src

Since I (roughly) track Org ~HEAD~, it makes sense to include the git version in
the creator string.
#+begin_src emacs-lisp
(setq org-export-creator-string
      (format "Emacs %s (Org mode %s–%s)" emacs-version (org-release) (org-git-version)))
#+end_src

***** Acronym formatting

I like automatically using spaced small caps for acronyms. For strings I want to
be unaffected let's use ~;~ as a prefix to prevent the transformation --- i.e.
~;JFK~ (as one would want for two-letter geographic locations and names).

This has to be implemented on a per-format basis, currently HTML and LaTeX
exports are supported.

#+begin_src emacs-lisp
(defun org-export-filter-text-acronym (text backend _info)
  "Wrap suspected acronyms in acronyms-specific formatting.
Treat sequences of 2+ capital letters (optionally succeeded by \"s\") as an acronym.
Ignore if preceeded by \";\" (for manual prevention) or \"\\\" (for LaTeX commands).

TODO abstract backend implementations."
  (let ((base-backend
         (cond
          ((org-export-derived-backend-p backend 'latex) 'latex)
          ;; Markdown is derived from HTML, but we don't want to format it
          ((org-export-derived-backend-p backend 'md) nil)
          ((org-export-derived-backend-p backend 'html) 'html)))
        (case-fold-search nil))
    (when base-backend
      (replace-regexp-in-string
       "[;\\\\]?\\b[A-Z][A-Z]+s?\\(?:[^A-Za-z]\\|\\b\\)"
       (lambda (all-caps-str)
         (cond ((equal (aref all-caps-str 0) ?\\) all-caps-str)                ; don't format LaTeX commands
               ((equal (aref all-caps-str 0) ?\;) (substring all-caps-str 1))  ; just remove not-acronym indicator char ";"
               (t (let* ((final-char (if (string-match-p "[^A-Za-z]" (substring all-caps-str -1 (length all-caps-str)))
                                         (substring all-caps-str -1 (length all-caps-str))
                                       nil)) ; needed to re-insert the [^A-Za-z] at the end
                         (trailing-s (equal (aref all-caps-str (- (length all-caps-str) (if final-char 2 1))) ?s))
                         (acr (if final-char
                                  (substring all-caps-str 0 (if trailing-s -2 -1))
                                (substring all-caps-str 0 (+ (if trailing-s -1 (length all-caps-str)))))))
                    (pcase base-backend
                      ('latex (concat "\\acr{" (s-downcase acr) "}" (when trailing-s "\\acrs{}") final-char))
                      ('html (concat "<span class='acr'>" acr "</span>" (when trailing-s "<small>s</small>") final-char)))))))
       text t t))))

(add-to-list 'org-export-filter-plain-text-functions
             #'org-export-filter-text-acronym)

;; We won't use `org-export-filter-headline-functions' because it
;; passes (and formats) the entire section contents. That's no good.

(defun org-html-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-html-format-headline-default-function', but with acronym formatting."
  (org-html-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'html info) tags info))
(setq org-html-format-headline-function #'org-html-format-headline-acronymised)

(defun org-latex-format-headline-acronymised (todo todo-type priority text tags info)
  "Like `org-latex-format-headline-default-function', but with acronym formatting."
  (org-latex-format-headline-default-function
   todo todo-type priority (org-export-filter-text-acronym text 'latex info) tags info))
(setq org-latex-format-headline-function #'org-latex-format-headline-acronymised)
#+end_src

***** Exporting Org code

With all our Org config and hooks, exporting an Org code block when using
a font-lock based method can produce undesirable results. To address this, we
can tweak ~+org-babel-mode-alist~ when exporting.

#+begin_src emacs-lisp
(defun +org-mode--fontlock-only-mode ()
  "Just apply org-mode's font-lock once."
  (let (org-mode-hook
        org-hide-leading-stars
        org-hide-emphasis-markers)
    (org-set-font-lock-defaults)
    (font-lock-ensure))
  (setq-local major-mode #'fundamental-mode))

(defun +org-export-babel-mask-org-config (_backend)
  "Use `+org-mode--fontlock-only-mode' instead of `org-mode'."
  (setq-local org-src-lang-modes
              (append org-src-lang-modes
                      (list (cons "org" #'+org-mode--fontlock-only)))))

(add-hook 'org-export-before-processing-hook #'+org-export-babel-mask-org-config)
#+end_src

**** HTML Export


I want to tweak a whole bunch of things. While I'll want my tweaks almost all
the time, occasionally I may want to test how something turns out using a more
default config. With that in mind, a global minor mode seems like the most
appropriate architecture to use.

#+begin_src emacs-lisp
(define-minor-mode org-fancy-html-export-mode
  "Toggle my fabulous org export tweaks. While this mode itself does a little bit,
the vast majority of the change in behaviour comes from switch statements in:
 - `org-html-template-fancier'
 - `org-html--build-meta-info-extended'
 - `org-html-src-block-collapsable'
 - `org-html-block-collapsable'
 - `org-html-table-wrapped'
 - `org-html--format-toc-headline-colapseable'
 - `org-html--toc-text-stripped-leaves'
 - `org-export-html-headline-anchor'"
  :global t
  :init-value t
  (if org-fancy-html-export-mode
      (setq org-html-style-default org-html-style-fancy
            org-html-meta-tags #'org-html-meta-tags-fancy
            org-html-checkbox-type 'html-span)
    (setq org-html-style-default org-html-style-plain
          org-html-meta-tags #'org-html-meta-tags-default
          org-html-checkbox-type 'html)))
#+end_src

***** Htmlize command

Why not have a command to htmlize files? This is basically a little test of my
engrave-faces package because it somehow seems to work without a GUI, while the
htmlize package doesn't.

#+begin_src emacs-lisp :tangle cli.el :noweb-ref none
(defcli! htmlize (file)
  "Export a FILE buffer to HTML."

  (print! "Htmlizing %s" file)

  (doom-initialize)
  (require 'highlight-numbers)
  (require 'highlight-quoted)
  (require 'rainbow-delimiters)
  (require 'engrave-faces-html)

  ;; Lighten org-mode
  (when (string= "org" (file-name-extension file))
    (setcdr (assoc 'org after-load-alist) nil)
    (setq org-load-hook nil)
    (require 'org)
    (setq org-mode-hook nil)
    (add-hook 'engrave-faces-before-hook
              (lambda () (if (eq major-mode 'org-mode)
                        (org-show-all)))))

  (engrave-faces-html-file file))
#+end_src
***** Extra header content

We want to tack on a few more bits to the start of the body. Unfortunately, there
doesn't seem to be any nice variable or hook, so we'll just override the
relevant function.

This is done to allow me to add the date and author to the page header,
implement a CSS-only light/dark theme toggle, and a sprinkle of [[https://ogp.me/][Open Graph]]
metadata.
#+begin_src emacs-lisp
(defadvice! org-html-template-fancier (orig-fn contents info)
  "Return complete document string after HTML conversion.
CONTENTS is the transcoded contents string.  INFO is a plist
holding export options. Adds a few extra things to the body
compared to the default implementation."
  :around #'org-html-template
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn contents info)
    (concat
     (when (and (not (org-html-html5-p info)) (org-html-xhtml-p info))
       (let* ((xml-declaration (plist-get info :html-xml-declaration))
              (decl (or (and (stringp xml-declaration) xml-declaration)
                        (cdr (assoc (plist-get info :html-extension)
                                    xml-declaration))
                        (cdr (assoc "html" xml-declaration))
                        "")))
         (when (not (or (not decl) (string= "" decl)))
           (format "%s\n"
                   (format decl
                           (or (and org-html-coding-system
                                    (fboundp 'coding-system-get)
                                    (coding-system-get org-html-coding-system 'mime-charset))
                               "iso-8859-1"))))))
     (org-html-doctype info)
     "\n"
     (concat "<html"
             (cond ((org-html-xhtml-p info)
                    (format
                     " xmlns=\"http://www.w3.org/1999/xhtml\" lang=\"%s\" xml:lang=\"%s\""
                     (plist-get info :language) (plist-get info :language)))
                   ((org-html-html5-p info)
                    (format " lang=\"%s\"" (plist-get info :language))))
             ">\n")
     "<head>\n"
     (org-html--build-meta-info info)
     (org-html--build-head info)
     (org-html--build-mathjax-config info)
     "</head>\n"
     "<body>\n<input type='checkbox' id='theme-switch'><div id='page'><label id='switch-label' for='theme-switch'></label>"
     (let ((link-up (org-trim (plist-get info :html-link-up)))
           (link-home (org-trim (plist-get info :html-link-home))))
       (unless (and (string= link-up "") (string= link-home ""))
         (format (plist-get info :html-home/up-format)
                 (or link-up link-home)
                 (or link-home link-up))))
     ;; Preamble.
     (org-html--build-pre/postamble 'preamble info)
     ;; Document contents.
     (let ((div (assq 'content (plist-get info :html-divs))))
       (format "<%s id=\"%s\">\n" (nth 1 div) (nth 2 div)))
     ;; Document title.
     (when (plist-get info :with-title)
       (let ((title (and (plist-get info :with-title)
                         (plist-get info :title)))
             (subtitle (plist-get info :subtitle))
             (html5-fancy (org-html--html5-fancy-p info)))
         (when title
           (format
            (if html5-fancy
                "<header class=\"page-header\">%s\n<h1 class=\"title\">%s</h1>\n%s</header>"
              "<h1 class=\"title\">%s%s</h1>\n")
            (if (or (plist-get info :with-date)
                    (plist-get info :with-author))
                (concat "<div class=\"page-meta\">"
                        (when (plist-get info :with-date)
                          (org-export-data (plist-get info :date) info))
                        (when (and (plist-get info :with-date) (plist-get info :with-author)) ", ")
                        (when (plist-get info :with-author)
                          (org-export-data (plist-get info :author) info))
                        "</div>\n")
              "")
            (org-export-data title info)
            (if subtitle
                (format
                 (if html5-fancy
                     "<p class=\"subtitle\" role=\"doc-subtitle\">%s</p>\n"
                   (concat "\n" (org-html-close-tag "br" nil info) "\n"
                           "<span class=\"subtitle\">%s</span>\n"))
                 (org-export-data subtitle info))
              "")))))
     contents
     (format "</%s>\n" (nth 1 (assq 'content (plist-get info :html-divs))))
     ;; Postamble.
     (org-html--build-pre/postamble 'postamble info)
     ;; Possibly use the Klipse library live code blocks.
     (when (plist-get info :html-klipsify-src)
       (concat "<script>" (plist-get info :html-klipse-selection-script)
               "</script><script src=\""
               org-html-klipse-js
               "\"></script><link rel=\"stylesheet\" type=\"text/css\" href=\""
               org-html-klipse-css "\"/>"))
     ;; Closing document.
     "</div>\n</body>\n</html>")))
#+end_src

I think it would be nice if "Table of Contents" brought you back to the top of
the page. Well, since we've done this much advising already...
#+begin_src emacs-lisp
(defadvice! org-html-toc-linked (depth info &optional scope)
  "Build a table of contents.

Just like `org-html-toc', except the header is a link to \"#\".

DEPTH is an integer specifying the depth of the table.  INFO is
a plist used as a communication channel.  Optional argument SCOPE
is an element defining the scope of the table.  Return the table
of contents as a string, or nil if it is empty."
  :override #'org-html-toc
  (let ((toc-entries
         (mapcar (lambda (headline)
                   (cons (org-html--format-toc-headline headline info)
                         (org-export-get-relative-level headline info)))
                 (org-export-collect-headlines info depth scope))))
    (when toc-entries
      (let ((toc (concat "<div id=\"text-table-of-contents\">"
                         (org-html--toc-text toc-entries)
                         "</div>\n")))
        (if scope toc
          (let ((outer-tag (if (org-html--html5-fancy-p info)
                               "nav"
                             "div")))
            (concat (format "<%s id=\"table-of-contents\">\n" outer-tag)
                    (let ((top-level (plist-get info :html-toplevel-hlevel)))
                      (format "<h%d><a href=\"#\" style=\"color:inherit; text-decoration: none;\">%s</a></h%d>\n"
                              top-level
                              (org-html--translate "Table of Contents" info)
                              top-level))
                    toc
                    (format "</%s>\n" outer-tag))))))))
#+end_src

Lastly, let's pile on some metadata. This gives my pages nice embeds.
#+begin_src emacs-lisp
(defvar org-html-meta-tags-opengraph-image
  '(:image "https://tecosaur.com/resources/org/nib.png"
    :type "image/png"
    :width "200"
    :height "200"
    :alt "Green fountain pen nib")
  "Plist of og:image:PROP properties and their value, for use in `org-html-meta-tags-fancy'.")

(defun org-html-meta-tags-fancy (info)
  "Use the INFO plist to construct the meta tags, as described in `org-html-meta-tags'."
  (let ((title (org-html-plain-text
                (org-element-interpret-data (plist-get info :title)) info))
        (author (and (plist-get info :with-author)
                     (let ((auth (plist-get info :author)))
                       ;; Return raw Org syntax.
                       (and auth (org-html-plain-text
                                  (org-element-interpret-data auth) info))))))
    (append
     (list
      (when (org-string-nw-p author)
        (list "name" "author" author))
      (when (org-string-nw-p (plist-get info :description))
        (list "name" "description"
              (plist-get info :description)))
      '("name" "generator" "org mode")
      '("name" "theme-color" "#77aa99")
      '("property" "og:type" "article")
      (list "property" "og:title" title)
      (let ((subtitle (org-export-data (plist-get info :subtitle) info)))
        (when (org-string-nw-p subtitle)
          (list "property" "og:description" subtitle))))
     (when org-html-meta-tags-opengraph-image
       (list (list "property" "og:image" (plist-get org-html-meta-tags-opengraph-image :image))
             (list "property" "og:image:type" (plist-get org-html-meta-tags-opengraph-image :type))
             (list "property" "og:image:width" (plist-get org-html-meta-tags-opengraph-image :width))
             (list "property" "og:image:height" (plist-get org-html-meta-tags-opengraph-image :height))
             (list "property" "og:image:alt" (plist-get org-html-meta-tags-opengraph-image :alt))))
     (list
      (when (org-string-nw-p author)
        (list "property" "og:article:author:first_name" (car (s-split-up-to " " author 2))))
      (when (and (org-string-nw-p author) (s-contains-p " " author))
        (list "property" "og:article:author:last_name" (cadr (s-split-up-to " " author 2))))
      (list "property" "og:article:published_time"
            (format-time-string
             "%FT%T%z"
             (or
              (when-let ((date-str (cadar (org-collect-keywords '("DATE")))))
                (unless (string= date-str (format-time-string "%F"))
                  (ignore-errors (encode-time (org-parse-time-string date-str)))))
              (if buffer-file-name
                  (file-attribute-modification-time (file-attributes buffer-file-name))
                (current-time)))))
      (when buffer-file-name
        (list "property" "og:article:modified_time"
              (format-time-string "%FT%T%z" (file-attribute-modification-time (file-attributes buffer-file-name)))))))))

(unless (functionp #'org-html-meta-tags-default)
  (defalias 'org-html-meta-tags-default #'ignore))
(setq org-html-meta-tags #'org-html-meta-tags-fancy)
#+end_src

***** Custom CSS/JS

The default org HTML export is ... alright, but we can really jazz it up.
[[https://lepisma.xyz][lepisma.xyz]] has a really nice style, and from and org export too!
Suffice to say I've snatched it, with a few of my own tweaks applied.

#+begin_src html :tangle misc/org-export-header.html :comments no
<link rel="icon" href="https://tecosaur.com/resources/org/nib.ico" type="image/ico" />

<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-roman-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/etbookot-italic-webfont.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextRegular.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextItalic.woff2">
<link rel="preload" as="font" crossorigin="anonymous" type="font/woff2" href="https://tecosaur.com/resources/org/Merriweather-TextBold.woff2">
#+end_src

#+begin_src emacs-lisp
(setq org-html-style-plain org-html-style-default
      org-html-htmlize-output-type 'css
      org-html-doctype "html5"
      org-html-html5-fancy t)

(defun org-html-reload-fancy-style ()
  (interactive)
  (setq org-html-style-fancy
        (concat (f-read-text (expand-file-name "misc/org-export-header.html" doom-user-dir))
                "<script>\n"
                (f-read-text (expand-file-name "misc/org-css/main.js" doom-user-dir))
                "</script>\n<style>\n"
                (f-read-text (expand-file-name "misc/org-css/main.min.css" doom-user-dir))
                "</style>"))
  (when org-fancy-html-export-mode
    (setq org-html-style-default org-html-style-fancy)))
(org-html-reload-fancy-style)
#+end_src

***** Collapsable src and example blocks

By wrapping the ~<pre>~ element in a ~<details>~ block, we can obtain collapsable
blocks with no CSS, though we will toss a little in anyway to have this looking
somewhat spiffy.

Since this collapsability seems useful to have on by default for certain chunks
of code, it would be nice if you could set it with =#+attr_html: :collapsed t=.

It would be nice to also have a corresponding global / session-local way of
setting this, but I haven't quite been able to get that working (yet).

#+begin_src emacs-lisp
(defvar org-html-export-collapsed nil)
(eval '(cl-pushnew '(:collapsed "COLLAPSED" "collapsed" org-html-export-collapsed t)
                   (org-export-backend-options (org-export-get-backend 'html))))
(add-to-list 'org-default-properties "EXPORT_COLLAPSED")
#+end_src

We can take our src block modification a step further, and add a gutter on the
side of the src block containing both an anchor referencing the current block,
and a button to copy the content of the block.

#+name: Src blocks
#+begin_src emacs-lisp
(defadvice! org-html-src-block-collapsable (orig-fn src-block contents info)
  "Wrap the usual <pre> block in a <details>"
  :around #'org-html-src-block
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn src-block contents info)
    (let* ((properties (cadr src-block))
           (lang (mode-name-to-lang-name
                  (plist-get properties :language)))
           (name (plist-get properties :name))
           (ref (org-export-get-reference src-block info))
           (collapsed-p (member (or (org-export-read-attribute :attr_html src-block :collapsed)
                                    (plist-get info :collapsed))
                                '("y" "yes" "t" t "true" "all"))))
      (format
       "<details id='%s' class='code'%s><summary%s>%s</summary>
<div class='gutter'>
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>⎘</button>\
</div>
%s
</details>"
       ref
       (if collapsed-p "" " open")
       (if name " class='named'" "")
       (concat
        (when name (concat "<span class=\"name\">" name "</span>"))
        "<span class=\"lang\">" lang "</span>")
       ref
       (if name
           (replace-regexp-in-string (format "<pre\\( class=\"[^\"]+\"\\)? id=\"%s\">" ref) "<pre\\1>"
                                     (funcall orig-fn src-block contents info))
         (funcall orig-fn src-block contents info))))))

(defun mode-name-to-lang-name (mode)
  (or (cadr (assoc mode
                   '(("asymptote" "Asymptote")
                     ("awk" "Awk")
                     ("C" "C")
                     ("clojure" "Clojure")
                     ("css" "CSS")
                     ("D" "D")
                     ("ditaa" "ditaa")
                     ("dot" "Graphviz")
                     ("calc" "Emacs Calc")
                     ("emacs-lisp" "Emacs Lisp")
                     ("fortran" "Fortran")
                     ("gnuplot" "gnuplot")
                     ("haskell" "Haskell")
                     ("hledger" "hledger")
                     ("java" "Java")
                     ("js" "Javascript")
                     ("latex" "LaTeX")
                     ("ledger" "Ledger")
                     ("lisp" "Lisp")
                     ("lilypond" "Lilypond")
                     ("lua" "Lua")
                     ("matlab" "MATLAB")
                     ("mscgen" "Mscgen")
                     ("ocaml" "Objective Caml")
                     ("octave" "Octave")
                     ("org" "Org mode")
                     ("oz" "OZ")
                     ("plantuml" "Plantuml")
                     ("processing" "Processing.js")
                     ("python" "Python")
                     ("R" "R")
                     ("ruby" "Ruby")
                     ("sass" "Sass")
                     ("scheme" "Scheme")
                     ("screen" "Gnu Screen")
                     ("sed" "Sed")
                     ("sh" "shell")
                     ("sql" "SQL")
                     ("sqlite" "SQLite")
                     ("forth" "Forth")
                     ("io" "IO")
                     ("J" "J")
                     ("makefile" "Makefile")
                     ("maxima" "Maxima")
                     ("perl" "Perl")
                     ("picolisp" "Pico Lisp")
                     ("scala" "Scala")
                     ("shell" "Shell Script")
                     ("ebnf2ps" "ebfn2ps")
                     ("cpp" "C++")
                     ("abc" "ABC")
                     ("coq" "Coq")
                     ("groovy" "Groovy")
                     ("bash" "bash")
                     ("csh" "csh")
                     ("ash" "ash")
                     ("dash" "dash")
                     ("ksh" "ksh")
                     ("mksh" "mksh")
                     ("posh" "posh")
                     ("ada" "Ada")
                     ("asm" "Assembler")
                     ("caml" "Caml")
                     ("delphi" "Delphi")
                     ("html" "HTML")
                     ("idl" "IDL")
                     ("mercury" "Mercury")
                     ("metapost" "MetaPost")
                     ("modula-2" "Modula-2")
                     ("pascal" "Pascal")
                     ("ps" "PostScript")
                     ("prolog" "Prolog")
                     ("simula" "Simula")
                     ("tcl" "tcl")
                     ("tex" "LaTeX")
                     ("plain-tex" "TeX")
                     ("verilog" "Verilog")
                     ("vhdl" "VHDL")
                     ("xml" "XML")
                     ("nxml" "XML")
                     ("conf" "Configuration File"))))
      mode))
#+end_src

#+name: Example, fixed width, and property blocks
#+begin_src emacs-lisp
(defun org-html-block-collapsable (orig-fn block contents info)
  "Wrap the usual block in a <details>"
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn block contents info)
    (let ((ref (org-export-get-reference block info))
          (type (pcase (car block)
                  ('property-drawer "Properties")))
          (collapsed-default (pcase (car block)
                               ('property-drawer t)
                               (_ nil)))
          (collapsed-value (org-export-read-attribute :attr_html block :collapsed))
          (collapsed-p (or (member (org-export-read-attribute :attr_html block :collapsed)
                                   '("y" "yes" "t" t "true"))
                           (member (plist-get info :collapsed) '("all")))))
      (format
       "<details id='%s' class='code'%s>
<summary%s>%s</summary>
<div class='gutter'>\
<a href='#%s'>#</a>
<button title='Copy to clipboard' onclick='copyPreToClipbord(this)'>⎘</button>\
</div>
%s\n
</details>"
       ref
       (if (or collapsed-p collapsed-default) "" " open")
       (if type " class='named'" "")
       (if type (format "<span class='type'>%s</span>" type) "")
       ref
       (funcall orig-fn block contents info)))))

(advice-add 'org-html-example-block   :around #'org-html-block-collapsable)
(advice-add 'org-html-fixed-width     :around #'org-html-block-collapsable)
(advice-add 'org-html-property-drawer :around #'org-html-block-collapsable)
#+end_src

***** Include extra font-locking in htmlize

Org uses [[https://github.com/hniksic/emacs-htmlize][htmlize.el]] to export buffers with syntax highlighting.

The works fantastically, for the most part. Minor modes that provide
font-locking are /not/ loaded, and so do not impact the result.

By enabling these modes in ~htmlize-before-hook~ we can correct this behaviour.

#+begin_src emacs-lisp
(autoload #'highlight-numbers--turn-on "highlight-numbers")
(add-hook 'htmlize-before-hook #'highlight-numbers--turn-on)
#+end_src

***** Handle table overflow

In order to accommodate wide tables ---particularly on mobile devices--- we want
to set a maximum width and scroll overflow. Unfortunately, this cannot be applied
directly to the ~table~ element, so we have to wrap it in a ~div~.

While we're at it, we can a link gutter, as we did with src blocks, and show the
~#+name~, if one is given.

#+begin_src emacs-lisp
(defadvice! org-html-table-wrapped (orig-fn table contents info)
  "Wrap the usual <table> in a <div>"
  :around #'org-html-table
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn table contents info)
    (let* ((name (plist-get (cadr table) :name))
           (ref (org-export-get-reference table info)))
      (format "<div id='%s' class='table'>
<div class='gutter'><a href='#%s'>#</a></div>
<div class='tabular'>
%s
</div>\
</div>"
              ref ref
              (if name
                  (replace-regexp-in-string (format "<table id=\"%s\"" ref) "<table"
                                            (funcall orig-fn table contents info))
                (funcall orig-fn table contents info))))))
#+end_src

***** TOC as a collapsable tree

The TOC is much nicer to navigate as a collapsable tree. Unfortunately we cannot
achieve this with CSS alone. Thankfully we can avoid JS though, by adapting the
TOC generation code to use a ~label~ for each item, and a hidden ~checkbox~ to keep
track of state.

To add this, we need to change one line in [[file:~/.emacs.d/.local/straight/repos/org/lisp/ox-html.el::(format "<a href=\"#%s\">%s</a>"][org-html--format-toc-headline]].

Since we can actually accomplish the desired effect by adding advice /around/ the
function, without overriding it --- let's do that to reduce the bug surface of
this config a tad.
#+begin_src emacs-lisp
(defadvice! org-html--format-toc-headline-colapseable (orig-fn headline info)
  "Add a label and checkbox to `org-html--format-toc-headline's usual output,
to allow the TOC to be a collapseable tree."
  :around #'org-html--format-toc-headline
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn headline info)
    (let ((id (or (org-element-property :CUSTOM_ID headline)
                  (org-export-get-reference headline info))))
      (format "<input type='checkbox' id='toc--%s'/><label for='toc--%s'>%s</label>"
              id id (funcall orig-fn headline info)))))
#+end_src

Now, leaves (headings with no children) shouldn't have the ~label~ item. The
obvious way to achieve this is by including some /if no children.../ logic in
~org-html--format-toc-headline-colapseable~. Unfortunately, I can't my elisp isn't
up to par to extract the number of child headings from the mountain of info that
org provides.
#+begin_src emacs-lisp
(defadvice! org-html--toc-text-stripped-leaves (orig-fn toc-entries)
  "Remove label"
  :around #'org-html--toc-text
  (if (or (not org-fancy-html-export-mode) (bound-and-true-p org-msg-export-in-progress))
      (funcall orig-fn toc-entries)
    (replace-regexp-in-string "<input [^>]+><label [^>]+>\\(.+?\\)</label></li>" "\\1</li>"
                              (funcall orig-fn toc-entries))))
#+end_src

***** Make verbatim different to code

Since we have =verbatim= and ~code~, let's make use of the difference.

We can use ~code~ exclusively for code snippets and commands like: "calling
src_elisp{(message "Hello")} in batch-mode Emacs prints to stdout like ~echo~".
Then we can use =verbatim= for miscellaneous 'other monospace' like keyboard
shortcuts: "either =C-c C-c= or =C-g= is likely the most useful keybinding in Emacs",
or file names: "I keep my configuration in =~/.config/doom/=", among other things.

Then, styling these two cases differently can help improve clarity in a document.

#+begin_src emacs-lisp
(setq org-html-text-markup-alist
      '((bold . "<b>%s</b>")
        (code . "<code>%s</code>")
        (italic . "<i>%s</i>")
        (strike-through . "<del>%s</del>")
        (underline . "<span class=\"underline\">%s</span>")
        (verbatim . "<kbd>%s</kbd>")))
#+end_src

***** Change checkbox type

We also want to use HTML checkboxes, however we want to get a bit fancier than default
#+begin_src emacs-lisp
(appendq! org-html-checkbox-types
          '((html-span
             (on . "<span class='checkbox'></span>")
             (off . "<span class='checkbox'></span>")
             (trans . "<span class='checkbox'></span>"))))
(setq org-html-checkbox-type 'html-span)
#+end_src
- [ ] I'm yet to do this
- [-] Work in progress
- [X] This is done

***** Extra special strings

The ~org-html-special-string-regexps~ variable defines substitutions for:
+ =\-=, a shy hyphen
+ =---=, an em dash
+ =--=, an en dash
+ =...=, (horizontal) ellipses

However I think it would be nice if there was also a substitution for left/right
arrows (=->= and =<-=). This is a ~defconst~, but as you may tell from the amount of
advice in this config, I'm not above messing with things I'm not 'supposed' to.

The only minor complication is that =<= and =>= are converted to =&lt;= and =&gt;=
before this stage of output processing.

#+begin_src emacs-lisp
(pushnew! org-html-special-string-regexps
          '("-&gt;" . "&#8594;")
          '("&lt;-" . "&#8592;"))
#+end_src

***** Header anchors

I want to add GitHub-style links on hover for headings.
#+begin_src emacs-lisp
(defun org-export-html-headline-anchor (text backend info)
  (when (and (org-export-derived-backend-p backend 'html)
             (not (org-export-derived-backend-p backend 're-reveal))
             org-fancy-html-export-mode)
    (unless (bound-and-true-p org-msg-export-in-progress)
      (replace-regexp-in-string
       "<h\\([0-9]\\) id=\"\\([a-z0-9-]+\\)\">\\(.*[^ ]\\)<\\/h[0-9]>" ; this is quite restrictive, but due to `org-reference-contraction' I can do this
       "<h\\1 id=\"\\2\">\\3<a aria-hidden=\"true\" href=\"#\\2\">#</a> </h\\1>"
       text))))

(add-to-list 'org-export-filter-headline-functions
             'org-export-html-headline-anchor)
#+end_src

***** Link previews

Sometimes it's nice to make a link particularly prominent, an embed/preview like
Twitter does would be nice I think.

We can do this without too much trouble by adding a new link type ever so
slightly different from =https= --- =Https=.

#+begin_src emacs-lisp
(org-link-set-parameters "Https"
                         :follow (lambda (url arg) (browse-url (concat "https:" url) arg))
                         :export #'org-url-fancy-export)
#+end_src

Then, if we can fetch a plist of the form src_elisp{(:title "..." :description
"..." :image "...")} for such links via a function ~org-url-unfurl-metadata~, we
can make a fancy export.

#+begin_src emacs-lisp
(defun org-url-fancy-export (url _desc backend)
  (let ((metadata (org-url-unfurl-metadata (concat "https:" url))))
    (cond
     ((org-export-derived-backend-p backend 'html)
      (concat
       "<div class=\"link-preview\">"
       (format "<a href=\"%s\">" (concat "https:" url))
       (when (plist-get metadata :image)
         (format "<img src=\"%s\"/>" (plist-get metadata :image)))
       "<small>"
       (replace-regexp-in-string "//\\(?:www\\.\\)?\\([^/]+\\)/?.*" "\\1" url)
       "</small><p>"
       (when (plist-get metadata :title)
         (concat "<b>" (org-html-encode-plain-text (plist-get metadata :title)) "</b></br>"))
       (when (plist-get metadata :description)
         (org-html-encode-plain-text (plist-get metadata :description)))
       "</p></a></div>"))
     (t url))))
#+end_src

Now we just need to actually implement that metadata extraction function.
#+begin_src emacs-lisp
(setq org-url-unfurl-metadata--cache nil)
(defun org-url-unfurl-metadata (url)
  (cdr (or (assoc url org-url-unfurl-metadata--cache)
           (car (push
                 (cons
                  url
                  (let* ((head-data
                          (-filter #'listp
                                   (cdaddr
                                    (with-current-buffer (progn (message "Fetching metadata from %s" url)
                                                                (url-retrieve-synchronously url t t 5))
                                      (goto-char (point-min))
                                      (delete-region (point-min) (- (search-forward "<head") 6))
                                      (delete-region (search-forward "</head>") (point-max))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<script[^\u2800]+?</script>" nil t)
                                        (replace-match ""))
                                      (goto-char (point-min))
                                      (while (re-search-forward "<style[^\u2800]+?</style>" nil t)
                                        (replace-match ""))
                                      (libxml-parse-html-region (point-min) (point-max))))))
                         (meta (delq nil
                                     (mapcar
                                      (lambda (tag)
                                        (when (eq 'meta (car tag))
                                          (cons (or (cdr (assoc 'name (cadr tag)))
                                                    (cdr (assoc 'property (cadr tag))))
                                                (cdr (assoc 'content (cadr tag))))))
                                      head-data))))
                    (let ((title (or (cdr (assoc "og:title" meta))
                                     (cdr (assoc "twitter:title" meta))
                                     (nth 2 (assq 'title head-data))))
                          (description (or (cdr (assoc "og:description" meta))
                                           (cdr (assoc "twitter:description" meta))
                                           (cdr (assoc "description" meta))))
                          (image (or (cdr (assoc "og:image" meta))
                                     (cdr (assoc "twitter:image" meta)))))
                      (when image
                        (setq image (replace-regexp-in-string
                                     "^/" (concat "https://" (replace-regexp-in-string "//\\([^/]+\\)/?.*" "\\1" url) "/")
                                     (replace-regexp-in-string
                                      "^//" "https://"
                                      image))))
                      (list :title title :description description :image image))))
                 org-url-unfurl-metadata--cache)))))
#+end_src

***** LaTeX Rendering
****** Pre-rendered

I consider ~dvisvgm~ to be a rather compelling option. However this isn't scaled
very well at the moment.
#+begin_src emacs-lisp
;; (setq-default org-html-with-latex `dvisvgm)
#+end_src

****** MathJax

If MathJax is used, we want to use version 3 instead of the default version 2.
Looking at a [[https://www.intmath.com/cg5/katex-mathjax-comparison.php][comparison]] we seem to find that it is ~5 times as fast, uses a
single file instead of multiple, but seems to be a bit bigger unfortunately.
Thankfully this can be mitigated my adding the ~async~ attribute to defer loading.

#+begin_src emacs-lisp
(setq org-html-mathjax-options
      '((path "https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" )
        (scale "1")
        (autonumber "ams")
        (multlinewidth "85%")
        (tagindent ".8em")
        (tagside "right")))

(setq org-html-mathjax-template
      "<script>
MathJax = {
  chtml: {
    scale: %SCALE
  },
  svg: {
    scale: %SCALE,
    fontCache: \"global\"
  },
  tex: {
    tags: \"%AUTONUMBER\",
    multlineWidth: \"%MULTLINEWIDTH\",
    tagSide: \"%TAGSIDE\",
    tagIndent: \"%TAGINDENT\"
  }
};
</script>
<script id=\"MathJax-script\" async
        src=\"%PATH\"></script>")
#+end_src

**** Reveal export
By default reveal is rather nice, there are just a few tweaks that I consider a
good idea.

#+begin_src emacs-lisp
(setq org-re-reveal-theme "white"
      org-re-reveal-transition "slide"
      org-re-reveal-plugins '(markdown notes math search zoom))
#+end_src

**** Babel


Doom lazy-loads babel languages, with is lovely.
It also pulls in [[https://github.com/astahlman/ob-async][ob-async]], which is nice, but it would be even better if it was
used by default.

There are two caveats to =ob-async=:
1. It does not support =:session=
   + So, we don't want =:async= used when =:session= is set
2. It adds a fixed delay to execution
   + This is undesirable in a number of cases, for example it's generally
     unwanted with =emacs-lisp= code
   + As such, I also introduce a async language blacklist to control when it's
     automatically enabled

Due to the nuance in the desired behaviour, instead of just adding =:async= to
~org-babel-default-header-args~, I advice ~org-babel-get-src-block-info~ to add
=:async= intelligently. As an escape hatch, it also recognises =:sync= as an
indication that =:async= should not be added.

I did originally have this enabled for everything except for =emacs-lisp= and
=LaTeX= (there were weird issues), but this added  a ~3s "startup" cost to every
src block evaluation, which was a bit of a pain. Since =:async= can be added
easily with =#+properties=, I've turned this behaviour from a blacklist to a
whitelist.

#+begin_src emacs-lisp
(add-transient-hook! #'org-babel-execute-src-block
  (require 'ob-async))

(defvar org-babel-auto-async-languages '()
  "Babel languages which should be executed asyncronously by default.")

(defadvice! org-babel-get-src-block-info-eager-async-a (orig-fn &optional light datum)
  "Eagarly add an :async parameter to the src information, unless it seems problematic.
This only acts o languages in `org-babel-auto-async-languages'.
Not added when either:
+ session is not \"none\"
+ :sync is set"
  :around #'org-babel-get-src-block-info
  (let ((result (funcall orig-fn light datum)))
    (when (and (string= "none" (cdr (assoc :session (caddr result))))
               (member (car result) org-babel-auto-async-languages)
               (not (assoc :async (caddr result))) ; don't duplicate
               (not (assoc :sync (caddr result))))
      (push '(:async) (caddr result)))
    result))
#+end_src

**** ESS


We don't want ~R~ evaluation to hang the editor, hence
#+begin_src emacs-lisp
(setq ess-eval-visibly 'nowait)
#+end_src

Syntax highlighting is nice, so let's turn all of that on
#+begin_src emacs-lisp
(setq ess-R-font-lock-keywords
      '((ess-R-fl-keyword:keywords . t)
        (ess-R-fl-keyword:constants . t)
        (ess-R-fl-keyword:modifiers . t)
        (ess-R-fl-keyword:fun-defs . t)
        (ess-R-fl-keyword:assign-ops . t)
        (ess-R-fl-keyword:%op% . t)
        (ess-fl-keyword:fun-calls . t)
        (ess-fl-keyword:numbers . t)
        (ess-fl-keyword:operators . t)
        (ess-fl-keyword:delimiters . t)
        (ess-fl-keyword:= . t)
        (ess-R-fl-keyword:F&T . t)))
#+end_src

Lastly, in the event that I use =JAGS=, it would be nice to be able to use =jags= as
the language identifier, not =ess-jags=.
#+begin_src emacs-lisp
(after! org
  (add-to-list '+org-babel-mode-alist '(jags . ess-jags)))
#+end_src

**** ASCII export


To start with, why settle for ASCII when UTF-8 exists?
#+begin_src emacs-lisp
(setq org-ascii-charset 'utf-8)
#+end_src

The ASCII export is generally fairly nice. I think the main aspect that could
benefit from improvement is the appearance of LaTeX fragments. There's a nice
utility we can use to create unicode representation, which are much nicer.
It's called ~latex2text~, and it's part of the =pylatexenc= package, and it's [[https://repology.org/project/python:pylatexenc/versions][not
really packaged]]. So, we'll resort to installing it with =pip=.

#+begin_src shell :tangle (if (executable-find "latex2text") "no" "setup.sh")
sudo python3 -m pip install pylatexenc
#+end_src

With that installed, we can override the *src_elisp* {(org-ascii-latex-fragment)} and
*src-elisp*  {(org-ascii-latex-environment)} functions, which are conveniently very
slim --- just extracting the content, and indenting. We'll only do something
different when =utf-8= is set.

#+begin_src emacs-lisp
(when (executable-find "latex2text")
  (after! ox-ascii
    (defvar org-ascii-convert-latex t
      "Use latex2text to convert LaTeX elements to unicode.")

    (defadvice! org-ascii-latex-environment-unicode-a (latex-environment _contents info)
      "Transcode a LATEX-ENVIRONMENT element from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
      :override #'org-ascii-latex-environment
      (when (plist-get info :with-latex)
        (org-ascii--justify-element
         (org-remove-indentation
          (let* ((latex (org-element-property :value latex-environment))
                 (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                               org-ascii-convert-latex
                               (doom-call-process "latex2text" "-q" "--code" latex))))
            (if (= (car unicode) 0) ; utf-8 set, and sucessfully ran latex2text
                (cdr unicode) latex)))
         latex-environment info)))

    (defadvice! org-ascii-latex-fragment-unicode-a (latex-fragment _contents info)
      "Transcode a LATEX-FRAGMENT object from Org to ASCII, converting to unicode.
CONTENTS is nil.  INFO is a plist holding contextual
information."
      :override #'org-ascii-latex-fragment
      (when (plist-get info :with-latex)
        (let* ((latex (org-element-property :value latex-fragment))
               (unicode (and (eq (plist-get info :ascii-charset) 'utf-8)
                             org-ascii-convert-latex
                             (doom-call-process "latex2text" "-q" "--code" latex))))
          (if (and unicode (= (car unicode) 0)) ; utf-8 set, and sucessfully ran latex2text
              (cdr unicode) latex))))))
#+end_src

**** Markdown Export
***** GFM


Because of the /[[https://github.com/commonmark/commonmark-spec/wiki/markdown-flavors][lovely variety in markdown implementations]]/ there isn't actually
such a thing a standard table spec ... or standard anything really. Because
~org-md~ is a goody-two-shoes, it just uses HTML for all these non-standardised
elements (a lot of them). So ~ox-gfm~ is handy for exporting markdown with all the
features that GitHub has.

#+begin_src emacs-lisp :noweb-ref none :tangle packages.el
(package! ox-gfm :pin "46faa67dbb3fb0cd7a76c3fe518f16e4195c22c7")
#+end_src

#+begin_src emacs-lisp
(use-package! ox-gfm
  :after ox)
#+end_src

***** Character substitutions

When I want to paste exported markdown somewhere (for example when using [[Emacs Everywhere][Emacs
Everywhere]]), it can be preferable to have unicode characters for =---= etc. instead
of =&#x2014;=.

To accomplish this, we just need to locally rebind the alist which provides
these substitution.

#+begin_src emacs-lisp
(defadvice! org-md-plain-text-unicode-a (orig-fn text info)
  "Locally rebind `org-html-special-string-regexps'"
  :around #'org-md-plain-text
  (let ((org-html-special-string-regexps
         '(("\\\\-" . "-")
           ("---\\([^-]\\|$\\)" . "—\\1")
           ("--\\([^-]\\|$\\)" . "–\\1")
           ("\\.\\.\\." . "…")
           ("<->" . "⟷")
           ("->" . "→")
           ("<-" . "←"))))
    (funcall orig-fn text (plist-put info :with-smart-quotes nil))))
#+end_src

In the future, I may want to check =info= to only have this active when =ox-gfm= is
being used.

Another worthwhile consideration is LaTeX formatting. It seems most Markdown
parsers are fixated on TeX-style syntax (=$= and =$$=). As unfortunate as this is,
it's probably best to accommodate them, for the sake of decent rendering.

=ox-md= doesn't provide any transcoders for this, so we'll have to whip up our own
and push them onto the =md= transcoders alist.

#+begin_src emacs-lisp
(after! ox-md
  (defun org-md-latex-fragment (latex-fragment _contents info)
    "Transcode a LATEX-FRAGMENT object from Org to Markdown."
    (let ((frag (org-element-property :value latex-fragment)))
      (cond
       ((string-match-p "^\\\\(" frag)
        (concat "$" (substring frag 2 -2) "$"))
       ((string-match-p "^\\\\\\[" frag)
        (concat "$$" (substring frag 2 -2) "$$"))
       (t (message "unrecognised fragment: %s" frag)
          frag))))

  (defun org-md-latex-environment (latex-environment contents info)
    "Transcode a LATEX-ENVIRONMENT object from Org to Markdown."
    (concat "$$\n"
            (org-html-latex-environment latex-environment contents info)
            "$$\n"))

  (defun org-utf8-entity (entity _contents _info)
    "Transcode an ENTITY object from Org to utf-8.
CONTENTS are the definition itself.  INFO is a plist holding
contextual information."
    (org-element-property :utf-8 entity))

  ;; We can't let this be immediately parsed and evaluated,
  ;; because eager macro-expansion tries to call as-of-yet
  ;; undefined functions.
  ;; NOTE in the near future this shouldn't be required
  (eval
   '(dolist (extra-transcoder
             '((latex-fragment . org-md-latex-fragment)
               (latex-environment . org-md-latex-environment)
               (entity . org-utf8-entity)))
      (unless (member extra-transcoder (org-export-backend-transcoders
                                        (org-export-get-backend 'md)))
        (push extra-transcoder (org-export-backend-transcoders
                                (org-export-get-backend 'md)))))))
#+end_src

**** ORB - Org-Roam Bibtex

The package that allows us to search through bibliography files and take notes on them. Makes Org-Roam work better as a zettlekasten for academic research.

#+begin_src emacs-lisp :tangle no

(use-package! org-roam-bibtex
  :after org-roam
  :hook (org-mode . org-roam-bibtex-mode)
  :config
  (require 'org-ref)
  (setq orb-preformat-keywords
   '("citekey" "title" "url" "file" "author-or-editor" "keywords" "pdf" "doi" "author" "tags" "year" "author-bbrev")))
;)
#+end_src

**** Org-journal
#+begin_src emacs-lisp
(use-package org-journal
      ;; :defer t
      :bind
      ("C-c n j" . org-journal-new-entry)
      :custom
      (org-journal-dir "~/org/journal")
      (org-journal-date-prefix "#+TITLE: ")
      (org-journal-time-prefix "** ")
      (org-journal-file-format "%Y-%m-%d.org")
      (org-journal-date-format "%A, %d %B %Y"))
(setq org-journal-enable-agenda-integration t)
#+end_src

#+RESULTS:
: t

**** Org-publish
#+begin_src emacs-lisp
(setq org-publish-use-timestamps-flag nil)
(setq org-export-with-broken-links t)
(setq org-publish-project-alist
      '(("my.site"
         :base-directory "~/org/mysite/"
         :base-extension "org"
         :publishing-directory "~/org/mysite/html/"
         :recursive t
         :exclude "org-html-themes/.*"
         :with-author nil           ;; Don't include author name
         :with-author nil           ;; Don't include author name
         :with-creator t            ;; Include Emacs and Org versions in footer
         :with-toc t                ;; Include a table of contents
         :section-numbers nil       ;; Don't include section numbers
         :time-stamp-file nil   ;; Don't include time stamp in file
         :publishing-function org-html-publish-to-html
         :headline-levels 4             ; Just the default for this project.
         :auto-preamble t)
         ("org-static"
         :base-directory "~/org/website"
         :base-extension "css\\|js\\|png\\|jpg\\|gif\\|pdf\\|mp3\\|ogg\\|swf"
         :publishing-directory "~/public_html/"
         :recursive t
         :exclude ".*/org-html-themes/.*"
         :publishing-function org-publish-attachment)
      ))
;; Generate the site output
;; (org-publish-all t)

;; (message "Build complete!")



#+end_src

#+RESULTS:
: Build complete!

**** Ox-Hugo
I have recently started using =ox-hugo= to help post on my Hugo based website. The following section sets up an org-capture to enable quick blogging.
#+BEGIN_SRC elisp :tangle no
(defun org-hugo-new-subtree-post-capture-template ()
  "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information."
  (let* (;; http://www.holgerschurig.de/en/emacs-blog-from-org-to-hugo/
         (date (format-time-string (org-time-stamp-format  :inactive) (org-current-time)))
         (title (read-from-minibuffer "Post Title: ")) ;Prompt to enter the post title
         (fname (org-hugo-slug title)))
    (mapconcat #'identity
               `(
                 ,(concat "* TODO " title)
                 ":PROPERTIES:"
                 ,(concat ":EXPORT_FILE_NAME: " fname)
                 ,(concat ":EXPORT_DATE: " date) ;Enter current date and time
                 ,(concat ":EXPORT_HUGO_CUSTOM_FRONT_MATTER: "  ":tags something :subtitle booyea :featured false :categories abc :highlight true ")
                 ":END:"
                 "%?\n")          ;Place the cursor here
               "\n")))
(defvar hugo-org-path "/home/cantos/Dropbox/blog/sunny-website/org-content/"
  "define the place where we put our org files for hugo")
;;(defvar org-capture-blog (concat hugo-org-path "blog.org"))

(setq org-capture-templates
      '(
        ("h" "Hugo Post"
         entry
         (file+olp "/home/cantos/Dropbox/blog/sunny-website/org-content/blog.org" "Posts")
         (function  org-hugo-new-subtree-post-capture-template))))
#+END_SRC
**** improving the html output-file

At this point have a decent basic output for our website, but what if we want to make it look a little bit nicer?
By setting a few more variables, we can use a nice stylesheet to give our site a more polished look:

#+begin_src emacs-lisp :tangle no


;; Customize the HTML output
(setq org-html-validation-link nil            ;; Don't show validation link
      org-html-head-include-scripts nil       ;; Use our own scripts
      org-html-head-include-default-style nil ;; Use our own styles
      org-html-head "<link rel=\"stylesheet\" href=\"https://cdn.simplecss.org/simple.min.css\" />")

#+end_src

#+RESULTS:
: <link rel="stylesheet" href="https://cdn.simplecss.org/simple.min.css" />

This will remove the default JavaScript and CSS code that gets injected into the HTML output by default and replace it with the link to a nice stylesheet called Simple.css (or a CSS file of your own!).

**** Org-ref settings

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-ref)

(setq reftex-default-bibliography '("~/Dropbox/Dissertation/library.bib"))
(setq org-ref-default-bibliography '("~/Dropbox/Dissertation/library.bib")
      org-ref-pdf-directory "~/Dropbox/Zotero/storage")
(setq org-ref-default-citation-link "citep")
(setq bibtex-dialect 'biblatex)
(defun my/org-ref-open-pdf-at-point ()
  "Open the pdf for bibtex key under point if it exists."
  (interactive)
  (let* ((results (org-ref-get-bibtex-key-and-file))
         (key (car results))
         (pdf-file (car (bibtex-completion-find-pdf key))))
    (if (file-exists-p pdf-file)
        (org-open-file pdf-file)
      (message "No PDF found for %s" key))))
(setq org-ref-open-pdf-function 'my/org-ref-open-pdf-at-point)
(setq bibtex-completion-pdf-field "file")
(setq bibtex-autokey-year-length 4
      bibtex-autokey-name-year-separator ""
      bibtex-autokey-year-title-separator ""
      bibtex-autokey-titleword-separator ""
      bibtex-autokey-titlewords 0
      bibtex-autokey-titlewords-stretch 0
      bibtex-autokey-titleword-length 0)
(setq org-ref-notes-function 'orb-edit-notes)
(setq org-ref-note-title-format
  "* TODO %y -%t
 :PROPERTIES:
  :Custom_ID: %k
  :AUTHOR: %9a
  :JOURNAL: %j
  :VOLUME: %v
  :DOI: %D
  :URL: %U
 :END:

")
#+END_SRC

**** Bibtex-completion

#+BEGIN_SRC emacs-lisp :tangle no
(setq-default bibtex-completion-bibliography "~/Dropbox/Dissertation/library.bib")
(setq bibtex-completion-pdf-field "File")
(setq bibtex-completion-notes-path "~/Dropbox/org")
(setq bibtex-completion-notes-template-multiple-files
 (concat
  " ${title}\n"
  "#+ROAM_KEY: cite:${=key=}\n\n\n"
  "- tags ::\n"
  "- keywords :: ${keywords}\n\n"
  "* Meta information\n"
  ":PROPERTIES:\n"
  ":Custom_ID: ${=key=}\n"
  ":INTERLEAVE_PDF: %(orb-process-file-field \"${=key=}\")\n"
  ":AUTHOR: ${author-abbrev}\n"
  ":JOURNAL: ${journaltitle}\n"
  ":DATE: ${date}\n"
  ":YEAR: ${year}\n"
  ":DOI: ${doi}\n"
  ":URL: ${url}\n"
  ":END:\n\n"
  ))
#+END_SRC

**** Org-appt settings

#+BEGIN_SRC emacs-lisp :tangle no
(require 'appt)

(setq-default appt-display-mode-line t)
(appt-activate 1)
(org-agenda-to-appt 1)
(appt-check 1)
(setq appt-message-warning-time 60)
(setq appt-display-interval 900)
#+END_SRC

**** Org-roam-bibtex

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-roam-bibtex
  :after (org-roam)
  :hook (org-roam-mode . org-roam-bibtex-mode)
  :config
  (setq orb-preformat-keywords
    '("=key=" "title" "url" "file" "author-or-editor" "keywords"))
  (setq orb-autokey-format "%A%y")
  (setq orb-pdf-scrapper-export-fields
    '("author" "editor" "title" "journal" "date"))
  (setq orb-templates
        '(("r" "ref" plain (function org-roam-capture--get-point)
           ""
           :file-name "${=key=}"
           :head "#+TITLE: ${title}\n
                  #+ROAM_KEY: ${ref}

- tags ::
- keywords :: ${keywords}\n

 * Meta information\n
        :PROPERTIES:\n
        :Custom_ID: ${=key=}\n
        :URL: ${url}\n
        :AUTHOR: ${author-or-editor}\n
        :INTERLEAVE_PDF: %(orb-process-file-field \"${=key=}\")\n
        :INTERLEAVE_PAGE_NOTE: \n
        :END:\n\n"

        :unnarrowed t)))
  :bind (:map org-mode-map
         (("C-c n a" . orb-note-actions))))
#+END_SRC

#+RESULTS:
: orb-note-actions

**** Org-roam-server

#+BEGIN_SRC emacs-lisp :tangle no
(use-package org-roam-server
  :config
  (setq org-roam-server-host "127.0.0.1"
        org-roam-server-port 8080
        org-roam-server-authenticate nil
        org-roam-server-export-inline-images t
        org-roam-server-serve-files nil
        org-roam-server-served-file-extensions '("pdf" "mp4" "ogv")
        org-roam-server-network-poll t
        org-roam-server-network-arrows nil
        org-roam-server-network-label-truncate t
        org-roam-server-network-label-truncate-length 60
        org-roam-server-network-label-wrap-length 20)
  (defun org-roam-server-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (org-roam-server-mode 1)
    (browse-url-xdg-open (format "http://localhost:%d" org-roam-server-port))))
#+END_SRC
** Latex

*** To-be-implemented ideas

- Paste image from clipboard
  + Determine first folder in ~graphicspath~ if applicable
  + Ask for file name
  + Use ~xclip~ to save file to graphics folder, or current directory (whichever applies)
  #+begin_src shell :eval no :tangle no
command -v xclip >/dev/null 2>&1 || { echo >&1 "no xclip"; exit 1; }

if
    xclip -selection clipboard -target image/png -o >/dev/null 2>&1
then
    xclip -selection clipboard -target image/png -o >$1 2>/dev/null
    echo $1
else
    echo "no image"
fi
  #+end_src
  + Insert figure, with filled in details as a result (activate =yasnippet= with
    filename as variable maybe?)

*** Compilation

#+begin_src emacs-lisp
(setq TeX-save-query nil
      TeX-show-compilation t
      TeX-command-extra-options "-shell-escape")
(after! latex
  (add-to-list 'TeX-command-list '("XeLaTeX" "%`xelatex%(mode)%' %t" TeX-run-TeX nil t)))
#+end_src

For viewing the PDF, I rather like the pdf-tools viewer. While auctex is trying
to be nice in recognising that I have some PDF viewing apps installed, I'd
rather not have it default to using them, so let's re-order the preferences.
#+begin_src emacs-lisp
(setq +latex-viewers '(pdf-tools evince zathura okular skim sumatrapdf))
#+end_src

*** Snippet helpers
**** Template

For use in the new-file template, let's set out a nice preamble we may want to use.
#+name: latex-nice-preamble
#+begin_src latex :tangle no
\\usepackage[pdfa,unicode=true,hidelinks]{hyperref}

\\usepackage[dvipsnames,svgnames,table,hyperref]{xcolor}
\\renewcommand{\\UrlFont}{\\ttfamily\\small}

\\usepackage[a-2b]{pdfx} % why not be archival

\\usepackage[T1]{fontenc}
\\usepackage[osf]{newpxtext}  % Palatino
\\usepackage{gillius}
\\usepackage[scale=0.9]{sourcecodepro}

\\usepackage[varbb]{newpxmath}
\\usepackage{mathtools}
\\usepackage{amssymb}

\\usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=2000]{microtype}
% microtype makes text look nicer

\\usepackage{graphicx} % include graphics

\\usepackage{booktabs} % nice table rules
#+end_src
Then let's bind the content to a function, and define some nice helpers.
#+begin_src emacs-lisp :noweb no-export
(setq tec/yas-latex-template-preamble "
<<latex-nice-preamble>>
")

(defun tec/yas-latex-get-class-choice ()
  "Prompt user for LaTeX class choice"
  (setq tec/yas-latex-class-choice (completing-read "Select document class: " '("article" "scrartcl" "bmc"))))

(defun tec/yas-latex-preamble-if ()
  "Based on class choice prompt for insertion of default preamble"
  (if (equal tec/yas-latex-class-choice "bmc") 'nil
    (eq (read-char-choice "Include default preamble? [Type y/n]" '(?y ?n)) ?y)))
#+end_src

**** Deliminators

#+begin_src emacs-lisp
(after! tex
  (defvar tec/tex-last-delim-char nil
    "Last open delim expanded in a tex document")
  (defvar tec/tex-delim-dot-second t
    "When the `tec/tex-last-delim-char' is . a second character (this) is prompted for")
  (defun tec/get-open-delim-char ()
    "Exclusivly read next char to tec/tex-last-delim-char"
    (setq tec/tex-delim-dot-second nil)
    (setq tec/tex-last-delim-char (read-char-exclusive "Opening deliminator, recognises: 9 ( [ { < | ."))
    (when (eql ?. tec/tex-last-delim-char)
      (setq tec/tex-delim-dot-second (read-char-exclusive "Other deliminator, recognises: 0 9 (  ) [ ] { } < > |"))))
  (defun tec/tex-open-delim-from-char (&optional open-char)
    "Find the associated opening delim as string"
    (unless open-char (setq open-char (if (eql ?. tec/tex-last-delim-char)
                                          tec/tex-delim-dot-second
                                        tec/tex-last-delim-char)))
    (pcase open-char
      (?\( "(")
      (?9  "(")
      (?\[ "[")
      (?\{ "\\{")
      (?<  "<")
      (?|  (if tec/tex-delim-dot-second "." "|"))
      (_   ".")))
  (defun tec/tex-close-delim-from-char (&optional open-char)
    "Find the associated closing delim as string"
    (if tec/tex-delim-dot-second
        (pcase tec/tex-delim-dot-second
          (?\) ")")
          (?0  ")")
          (?\] "]")
          (?\} "\\}")
          (?\> ">")
          (?|  "|")
          (_   "."))
      (pcase (or open-char tec/tex-last-delim-char)
        (?\( ")")
        (?9  ")")
        (?\[ "]")
        (?\{ "\\}")
        (?<  ">")
        (?\) ")")
        (?0  ")")
        (?\] "]")
        (?\} "\\}")
        (?\> ">")
        (?|  "|")
        (_   "."))))
  (defun tec/tex-next-char-smart-close-delim (&optional open-char)
    (and (bound-and-true-p smartparens-mode)
         (eql (char-after) (pcase (or open-char tec/tex-last-delim-char)
                             (?\( ?\))
                             (?\[ ?\])
                             (?{ ?})
                             (?< ?>)))))
  (defun tec/tex-delim-yas-expand (&optional open-char)
    (yas-expand-snippet (yas-lookup-snippet "_deliminators" 'latex-mode) (point) (+ (point) (if (tec/tex-next-char-smart-close-delim open-char) 2 1)))))
#+end_src

*** Editor visuals

Let's enhance ~TeX-fold-math~ a bit
#+begin_src emacs-lisp
(after! latex
  (setcar (assoc "⋆" LaTeX-fold-math-spec-list) "★")) ;; make \star bigger

(setq TeX-fold-math-spec-list
      `(;; missing/better symbols
        ("≤" ("le"))
        ("≥" ("ge"))
        ("≠" ("ne"))
        ;; convenience shorts -- these don't work nicely ATM
        ;; ("‹" ("left"))
        ;; ("›" ("right"))
        ;; private macros
        ("ℝ" ("RR"))
        ("ℕ" ("NN"))
        ("ℤ" ("ZZ"))
        ("ℚ" ("QQ"))
        ("ℂ" ("CC"))
        ("ℙ" ("PP"))
        ("ℍ" ("HH"))
        ("𝔼" ("EE"))
        ("𝑑" ("dd"))
        ;; known commands
        ("" ("phantom"))
        (,(lambda (num den) (if (and (TeX-string-single-token-p num) (TeX-string-single-token-p den))
                                (concat num "／" den)
                              (concat "❪" num "／" den "❫"))) ("frac"))
        (,(lambda (arg) (concat "√" (TeX-fold-parenthesize-as-necessary arg))) ("sqrt"))
        (,(lambda (arg) (concat "⭡" (TeX-fold-parenthesize-as-necessary arg))) ("vec"))
        ("‘{1}’" ("text"))
        ;; private commands
        ("|{1}|" ("abs"))
        ("‖{1}‖" ("norm"))
        ("⌊{1}⌋" ("floor"))
        ("⌈{1}⌉" ("ceil"))
        ("⌊{1}⌉" ("round"))
        ("𝑑{1}/𝑑{2}" ("dv"))
        ("∂{1}/∂{2}" ("pdv"))
        ;; fancification
        ("{1}" ("mathrm"))
        (,(lambda (word) (string-offset-roman-chars 119743 word)) ("mathbf"))
        (,(lambda (word) (string-offset-roman-chars 119951 word)) ("mathcal"))
        (,(lambda (word) (string-offset-roman-chars 120003 word)) ("mathfrak"))
        (,(lambda (word) (string-offset-roman-chars 120055 word)) ("mathbb"))
        (,(lambda (word) (string-offset-roman-chars 120159 word)) ("mathsf"))
        (,(lambda (word) (string-offset-roman-chars 120367 word)) ("mathtt"))
        )
      TeX-fold-macro-spec-list
      '(
        ;; as the defaults
        ("[f]" ("footnote" "marginpar"))
        ("[c]" ("cite"))
        ("[l]" ("label"))
        ("[r]" ("ref" "pageref" "eqref"))
        ("[i]" ("index" "glossary"))
        ("..." ("dots"))
        ("{1}" ("emph" "textit" "textsl" "textmd" "textrm" "textsf" "texttt"
                "textbf" "textsc" "textup"))
        ;; tweaked defaults
        ("©" ("copyright"))
        ("®" ("textregistered"))
        ("™"  ("texttrademark"))
        ("[1]:||►" ("item"))
        ("❡❡ {1}" ("part" "part*"))
        ("❡ {1}" ("chapter" "chapter*"))
        ("§ {1}" ("section" "section*"))
        ("§§ {1}" ("subsection" "subsection*"))
        ("§§§ {1}" ("subsubsection" "subsubsection*"))
        ("¶ {1}" ("paragraph" "paragraph*"))
        ("¶¶ {1}" ("subparagraph" "subparagraph*"))
        ;; extra
        ("⬖ {1}" ("begin"))
        ("⬗ {1}" ("end"))
        ))

(defun string-offset-roman-chars (offset word)
  "Shift the codepoint of each character in WORD by OFFSET with an extra -6 shift if the letter is lowercase"
  (apply 'string
         (mapcar (lambda (c)
                   (string-offset-apply-roman-char-exceptions
                    (+ (if (>= c 97) (- c 6) c) offset)))
                 word)))

(defvar string-offset-roman-char-exceptions
  '(;; lowercase serif
    (119892 .  8462) ; ℎ
    ;; lowercase caligraphic
    (119994 . 8495) ; ℯ
    (119996 . 8458) ; ℊ
    (120004 . 8500) ; ℴ
    ;; caligraphic
    (119965 . 8492) ; ℬ
    (119968 . 8496) ; ℰ
    (119969 . 8497) ; ℱ
    (119971 . 8459) ; ℋ
    (119972 . 8464) ; ℐ
    (119975 . 8466) ; ℒ
    (119976 . 8499) ; ℳ
    (119981 . 8475) ; ℛ
    ;; fraktur
    (120070 . 8493) ; ℭ
    (120075 . 8460) ; ℌ
    (120076 . 8465) ; ℑ
    (120085 . 8476) ; ℜ
    (120092 . 8488) ; ℨ
    ;; blackboard
    (120122 . 8450) ; ℂ
    (120127 . 8461) ; ℍ
    (120133 . 8469) ; ℕ
    (120135 . 8473) ; ℙ
    (120136 . 8474) ; ℚ
    (120137 . 8477) ; ℝ
    (120145 . 8484) ; ℤ
    )
  "An alist of deceptive codepoints, and then where the glyph actually resides.")

(defun string-offset-apply-roman-char-exceptions (char)
  "Sometimes the codepoint doesn't contain the char you expect.
Such special cases should be remapped to another value, as given in `string-offset-roman-char-exceptions'."
  (if (assoc char string-offset-roman-char-exceptions)
      (cdr (assoc char string-offset-roman-char-exceptions))
    char))

(defun TeX-fold-parenthesize-as-necessary (tokens &optional suppress-left suppress-right)
  "Add ❪ ❫ parenthesis as if multiple LaTeX tokens appear to be present"
  (if (TeX-string-single-token-p tokens) tokens
    (concat (if suppress-left "" "❪")
            tokens
            (if suppress-right "" "❫"))))

(defun TeX-string-single-token-p (teststring)
  "Return t if TESTSTRING appears to be a single token, nil otherwise"
  (if (string-match-p "^\\\\?\\w+$" teststring) t nil))
#+end_src

Some local keybindings to make life a bit easier
#+begin_src emacs-lisp
(after! tex
  (map!
   :map LaTeX-mode-map
   :ei [C-return] #'LaTeX-insert-item)
  (setq TeX-electric-math '("\\(" . "")))
#+end_src

Maths deliminators can be de-emphasised a bit
#+begin_src emacs-lisp
;; Making \( \) less visible
(defface unimportant-latex-face
  '((t :inherit font-lock-comment-face :weight extra-light))
  "Face used to make \\(\\), \\[\\] less visible."
  :group 'LaTeX-math)

(font-lock-add-keywords
 'latex-mode
 `(("\\\\[]()[]" 0 'unimportant-latex-face prepend))
 'end)

;; (font-lock-add-keywords
;;  'latex-mode
;;  '(("\\\\[[:word:]]+" 0 'font-lock-keyword-face prepend))
;;  'end)
#+end_src

And enable shell escape for the preview
#+begin_src emacs-lisp
(setq preview-LaTeX-command '("%`%l \"\\nonstopmode\\nofiles\
\\PassOptionsToPackage{" ("," . preview-required-option-list) "}{preview}\
\\AtBeginDocument{\\ifx\\ifPreview\\undefined"
preview-default-preamble "\\fi}\"%' \"\\detokenize{\" %t \"}\""))
#+end_src

*** Math input
**** CDLaTeX

The symbols and modifies are very nice by default, but could do with a bit of
fleshing out. Let's change the prefix to a key which is similarly rarely used,
but more convenient, like =;=.
#+begin_src emacs-lisp
(after! cdlatex
  (setq cdlatex-env-alist
        '(("bmatrix" "\\begin{bmatrix}\n?\n\\end{bmatrix}" nil)
          ("equation*" "\\begin{equation*}\n?\n\\end{equation*}" nil)))
  (setq ;; cdlatex-math-symbol-prefix ?\; ;; doesn't work at the moment :(
   cdlatex-math-symbol-alist
   '( ;; adding missing functions to 3rd level symbols
     (?_    ("\\downarrow"  ""           "\\inf"))
     (?2    ("^2"           "\\sqrt{?}"     ""     ))
     (?3    ("^3"           "\\sqrt[3]{?}"  ""     ))
     (?^    ("\\uparrow"    ""           "\\sup"))
     (?k    ("\\kappa"      ""           "\\ker"))
     (?m    ("\\mu"         ""           "\\lim"))
     (?c    (""             "\\circ"     "\\cos"))
     (?d    ("\\delta"      "\\partial"  "\\dim"))
     (?D    ("\\Delta"      "\\nabla"    "\\deg"))
     ;; no idea why \Phi isnt on 'F' in first place, \phi is on 'f'.
     (?F    ("\\Phi"))
     ;; now just convenience
     (?.    ("\\cdot" "\\dots"))
     (?:    ("\\vdots" "\\ddots"))
     (?*    ("\\times" "\\star" "\\ast")))
   cdlatex-math-modify-alist
   '( ;; my own stuff
     (?B    "\\mathbb"        nil          t    nil  nil)
     (?a    "\\abs"           nil          t    nil  nil))))
#+end_src

**** LAAS


This makes use of =aas= (/Auto Activating Snippets/) for CDLaTeX-like symbol input.

#+begin_src emacs-lisp :tangle no
(package! laas :recipe (:host github :repo "tecosaur/LaTeX-auto-activating-snippets"))

#+end_src

#+begin_src emacs-lisp :tangle no
(use-package! laas
  :hook (LaTeX-mode . laas-mode)
  :config
  (aas-set-snippets 'laas-mode
                    ;; set condition!
                    :cond #'texmathp ; expand only while in math
                    "supp" "\\supp"
                    "On" "O(n)"
                    "O1" "O(1)"
                    "Olog" "O(\\log n)"
                    "Olon" "O(n \\log n)"
                    ;; bind to functions!
                    "Sum" (lambda () (interactive)
                            (yas-expand-snippet "\\sum_{$1}^{$2} $0"))
                    "Span" (lambda () (interactive)
                             (yas-expand-snippet "\\Span($1)$0"))
                    ;; add accent snippets
                    :cond #'laas-object-on-left-condition
                    "qq" (lambda () (interactive) (laas-wrap-previous-object "sqrt")))
  (defun laas-tex-fold-maybe ()
    (unless (equal "/" aas-transient-snippet-key)
      (+latex-fold-last-macro-a)))
  (add-hook 'aas-post-snippet-expand-hook #'laas-tex-fold-maybe))
#+end_src

#+RESULTS:
| preview-mode-setup | er/add-latex-mode-expansions | mixed-pitch-mode | laas-mode | beginend-LaTeX-mode | reftex-mode | evil-tex-mode | adaptive-wrap-prefix-mode | +evil-embrace-latex-mode-hook-h | embrace-LaTeX-mode-hook |

*** SyncTeX

#+begin_src emacs-lisp
(after! tex
  (add-to-list 'TeX-view-program-list '("Evince" "evince %o"))
  (add-to-list 'TeX-view-program-selection '(output-pdf "Evince")))
#+end_src

*** Fixes

In case of Emacs28,
#+begin_src emacs-lisp
(when EMACS28+
  (add-hook 'latex-mode-hook #'TeX-latex-mode))
#+end_src

** Python

Since I'm using =mypyls=, as suggested in [[file:~/.emacs.d/modules/lang/python/README.org::*Language Server Protocol Support][:lang python LSP support]] I'll tweak the
priority of =mypyls=

#+begin_src emacs-lisp
(after! lsp-python-ms
  (set-lsp-priority! 'mspyls 1))
#+end_src

** Markdown

Most of the time when I write markdown, it's going into some app/website which
will do it's own line wrapping, hence we /only/ want to use visual line wrapping. No hard stuff.
#+begin_src emacs-lisp
(add-hook! (gfm-mode markdown-mode) #'visual-line-mode #'turn-off-auto-fill)
#+end_src

Since markdown is often seen as rendered HTML, let's try to somewhat mirror the
style or markdown renderers.

Most markdown renders seem to make the first three headings levels larger than
normal text, the first two much so. Then the fourth level tends to be the same
as body text, while the fifth and sixth are (increasingly) smaller, with the
sixth greyed out. Since the sixth level is so small, I'll turn up the boldness a notch.
#+begin_src emacs-lisp
 (add-to-list 'auto-mode-alist '("\\.mdx\\'" . markdown-mode))

(custom-set-faces!
  '(markdown-header-face-1 :height 1.25 :weight extra-bold :inherit markdown-header-face)
  '(markdown-header-face-2 :height 1.15 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-3 :height 1.08 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-4 :height 1.00 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-5 :height 0.90 :weight bold       :inherit markdown-header-face)
  '(markdown-header-face-6 :height 0.75 :weight extra-bold :inherit markdown-header-face))
#+end_src

** Julia


As mentioned in [[https://github.com/non-Jedi/lsp-julia/issues/35][lsp-julia#35]], =lsp-mode= seems to serve an invalid response to the
Julia server. The pseudo-fix is rather simple at least
#+begin_src emacs-lisp
(add-hook 'julia-mode-hook #'rainbow-delimiters-mode-enable)
(add-hook! 'julia-mode-hook
  (setq-local lsp-enable-folding t
              lsp-folding-range-limit 100))
#+end_src

Julia is also missing a mime type, but that's not too hard to fix.

#+begin_src xml :tangle ~/.local/share/mime/packages/julia.xml :mkdirp yes :comments no
<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>
  <mime-type type="text/julia">
    <comment>Julia source sode</comment>
    <glob pattern="*.jl"/>
    <alias type="text/julia"/>
  </mime-type>
</mime-info>
#+end_src

#+begin_src shell :tangle (if (string= (shell-command-to-string "xdg-mime query default text/julia") "") "setup.sh" "no")
update-mime-database ~/.local/share/mime
#+end_src

** PDF
***** Terminal viewing

Sometimes I'm in a terminal and I still want to see the content. Additionally,
sometimes I'd like to act on the textual content and so would like a plaintext version.
Thanks to src_shell{pdftotext} we have a convenient way of performing this conversion.
I've integrated this into a little package, =pdftotext.el=.
#+begin_src emacs-lisp :tangle packages.el
(package! pdftotext :recipe (:host github :repo "tecosaur/pdftotext.el"))
#+end_src

The output can be slightly nicer without spelling errors, and with prettier page
feeds (=^L= by default).


This is very nice, now we just need to associate it with =.pdf= files, and make
sure =pdf-tools= doesn't take priority.

Lastly, whenever Emacs is non-graphical (i.e. a TUI), we want to use this by default.

#+begin_src emacs-lisp :tangle (if (executable-find "pdftotext") "yes" "no")
(use-package! pdftotext
  :init
  (unless (display-graphic-p)
    (add-to-list 'auto-mode-alist '("\\.[pP][dD][fF]\\'" . pdftotext-mode))
    (add-to-list 'magic-mode-alist '("%PDF" . pdftotext-mode)))
  :config
  (unless (display-graphic-p) (after! pdf-tools (pdftotext-install)))
  ;; For prettyness
  (add-hook 'pdftotext-mode-hook #'spell-fu-mode-disable)
  (add-hook 'pdftotext-mode-hook (lambda () (page-break-lines-mode 1)))
  ;; I have no idea why this is needed
  (map! :map pdftotext-mode-map
        "<mouse-4>" (cmd! (scroll-down mouse-wheel-scroll-amount-horizontal))
        "<mouse-5>" (cmd! (scroll-up mouse-wheel-scroll-amount-horizontal))))

#+end_src

** Graph viz

Graphviz is a nice method of visualising simple graphs, based on plaintext
=.dot= / =.gv= files.
#+begin_src emacs-lisp :tangle packages.el
(package! graphviz-dot-mode :pin "a1b7d66f5c20404a1e59c2ee5e841022622535b8")
#+end_src

#+begin_src emacs-lisp
(use-package! graphviz-dot-mode
  :commands graphviz-dot-mode
  :mode ("\\.dot\\'" "\\.gz\\'")
  :init
  (after! org
    (setcdr (assoc "dot" org-src-lang-modes)
            'graphviz-dot)))

(use-package! company-graphviz-dot
  :after graphviz-dot-mode)
#+end_src
** Beancount
There are a number of rather compelling advantages to [[https://plaintextaccounting.org/][plain text accounting]],
with [[https://www.ledger-cli.org/][ledger]] being the most obvious example. However, [[https://github.com/beancount/beancount][beancount]], a more recent
implementation of the idea is ledger-compatible (meaning I can switch easily if
I change my mind) and has a gorgeous front-end --- [[https://beancount.github.io/fava/][fava]].

Of course, there's an Emacs mode for this.

#+begin_src emacs-lisp :tangle packages.el
(package! beancount :recipe (:host github :repo "beancount/beancount-mode")
  :pin "e8a5bce28c796320fa0c83f169d518aba330fd3d")
#+end_src

#+begin_src emacs-lisp
(use-package! beancount
  :mode ("\\.beancount\\'" . beancount-mode)
  :init
  (after! all-the-icons
    (add-to-list 'all-the-icons-icon-alist
                 '("\\.beancount\\'" all-the-icons-material "attach_money" :face all-the-icons-lblue))
    (add-to-list 'all-the-icons-mode-icon-alist
                 '(beancount-mode all-the-icons-material "attach_money" :face all-the-icons-lblue)))
  :config
  (setq beancount-electric-currency t)
  (defun beancount-bal ()
    "Run bean-report bal."
    (interactive)
    (let ((compilation-read-command nil))
      (beancount--run "bean-report"
                      (file-relative-name buffer-file-name) "bal")))
  (map! :map beancount-mode-map
        :n "TAB" #'beancount-align-to-previous-number
        :i "RET" (cmd! (newline-and-indent) (beancount-align-to-previous-number))))
#+end_src
** R
***** Editor Visuals
#+begin_src emacs-lisp
(after! ess-r-mode
  (appendq! +ligatures-extra-symbols
            '(:assign "⟵"
              :multiply "×"))
  (set-ligatures! 'ess-r-mode
    ;; Functional
    :def "function"
    ;; Types
    :null "NULL"
    :true "TRUE"
    :false "FALSE"
    :int "int"
    :floar "float"
    :bool "bool"
    ;; Flow
    :not "!"
    :and "&&" :or "||"
    :for "for"
    :in "%in%"
    :return "return"
    ;; Other
    :assign "<-"
    :multiply "%*%"))
#+end_src
** latex
#+begin_src emacs-lisp :tangle yes

(with-eval-after-load 'ox-latex
(add-to-list 'org-latex-classes
             '("org-plain-latex"
               "\\documentclass{article}
           [NO-DEFAULT-PACKAGES]
           [PACKAGES]
           [EXTRA]"
               ("\\section{%s}" . "\\section*{%s}")
               ("\\subsection{%s}" . "\\subsection*{%s}")
               ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
               ("\\paragraph{%s}" . "\\paragraph*{%s}")
               ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))))

#+end_src
* Keyboard shortcuts (org -roam)

Everything is mapped to SPC-R because doom is not using it and R stands for roam.
#+begin_src elisp :tangle yes
(map! :leader
      (:prefix-map ("R" . "regular")
       :desc "find file"            "f"   #'org-roam-node-find
       :desc "find ref"             "F"   #'org-roam-ref-find
       :desc "center scroll"        "s"   #'prot/scroll-center-cursor-mode
       :desc "start taking notes"   "S"   #'org-noter
       :desc "toggle buffer"        "b"   #'org-roam-buffer-toggle
       :desc "insert note"          "i"   #'org-roam-node-insert
       :desc "server"               "g"   #'org-roam-server
       :desc "quit notes"           "q"   #'org-noter-kill-session
       :desc "tag (roam)"           "t"   #'org-roam-tag-add
       :desc "tag (org)"            "T"   #'org-set-tags-command
       :desc "pomodoro"             "p"   #'org-pomodoro
       :desc "rebuid db"            "d"   #'org-roam-db-build-cache
       :desc "cite"                 "c"   #'helm-bibtex
       :desc "thesaurus this word"  "w"  #'powerthesaurus-lookup-word-at-point
       :desc "thesaurus lookup word" "W"   #'powerthesaurus-lookup-word
       :desc "outline"              "o"   #'org-ol-tree
       (:prefix  ("r" . "orui")
                :desc "orui-mode" "r" #'org-roam-ui-mode
                :desc "zoom" "z" #'orui-node-zoom
                :desc "open" "o" #'orui-open
                :desc "local" "l" #'orui-node-local
                :desc "sync theme" "t" #'orui-sync-theme
                :desc "follow" "f" #'orui-follow-mode)
       (:prefix ("m" . "transclusion")
                :desc "make link"            "m"   #'org-transclusion-make-from-link
                :desc "transclusion mode"    "t"   #'org-transclusion-mode
                :desc "add at point"         "a"   #'org-transclusion-add-at-point
                :desc "add all in buffer"    "A"   #'org-transclusion-add-all-in-buffer
                :desc "remove at point"      "r"   #'org-transclusion-remove-at-point
                :desc "remove all in buffer" "R"   #'org-transclusion-remove-all-in-buffer
                :desc "start live edit"      "s"   #'org-transclusion-live-sync-start-at-point
                :desc "stop live edit"       "S"   #'org-transclusion-live-sync-exit-at-point)
       )
      (:prefix ("d" . "GTD")
       :desc  "process inbox" "p"#'org-gtd-process-inbox
       :desc  "agenda list" "a"#'org-agenda-list
       :desc  "capture" "c"#'org-gtd-capture
       :desc  "show next" "n" #'org-gtd-show-all-next
       :desc  "show stuck project" "s" #'org-gtd-show-stuck-projects)
      )
#+end_src

#+RESULTS:
: org-gtd-show-stuck-projects

** getting things done

   Getting things done package to make my life work.

  #+begin_src emacs-lisp :tangle no
(use-package! org-gtd
  :after org
  :config
  ;; where org-gtd will put its files. This value is also the default one.
  (setq org-gtd-directory "~/org/Daily/")
  ;; package: https://github.com/Malabarba/org-agenda-property
  ;; this is so you can see who an item was delegated to in the agenda
  (setq org-agenda-property-list '("DELEGATED_TO"))
  ;; I think this makes the agenda easier to read
  (setq org-agenda-property-position 'next-line)
  ;; package: https://www.nongnu.org/org-edna-el/
  ;; org-edna is used to make sure that when a project task gets DONE,
  ;; the next TODO is automatically changed to NEXT.
  (setq org-edna-use-inheritance t)
  (org-edna-load)
  :bind
  (("C-c d c" . org-gtd-capture) ;; add item to inbox
  ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
  ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
  ("C-c d s" . org-gtd-show-stuck-projects)) ;; see projects that don't have a NEXT item
  :init
  (bind-key "C-c c" 'org-gtd-clarify-finalize)) ;; the keybinding to hit when you're done editing an item in the processing phase
#+end_src

#+RESULTS:
: org-gtd-show-stuck-projects

* Denote
#+begin_src emacs-lisp :tangle packages.el

(package! denote
  :recipe (:host github
           :repo "protesilaos/denote"))
#+end_src

#+RESULTS:
| denote | :modules | ((:user) (:user . modules)) | :recipe | (:host github :repo protesilaos/denote) |

#+begin_src emacs-lisp

;;; Denote (simple note-taking)
;; Read the manual: <https://protesilaos.com/emacs/denote>.
(use-package! denote
  :config
  ;; Remember to check the doc strings of those variables.
  (setq denote-directory (expand-file-name "~/org/Denotes/"))
  (setq denote-known-keywords '("emacs" "philosophy" "politics" "economics"))
  (setq denote-infer-keywords t)
  (setq denote-sort-keywords t)
  (setq denote-file-type 'text) ; Org is the default, set others here like I do

  ;; We allow multi-word keywords by default.  The author's personal
  ;; preference is for single-word keywords for a more disciplined
  ;; workflow.
  (setq denote-allow-multi-word-keywords nil)

  (setq denote-date-format nil) ; read its doc string

  ;; By default, we fontify backlinks in their bespoke buffer.
  (setq denote-link-fontify-backlinks t)

  ;; Also see `denote-link-backlinks-display-buffer-action' which is a bit
  ;; advanced.

  ;; If you use Markdown or plain text files you want to buttonise
  ;; existing buttons upon visiting the file (Org renders links as
  ;; buttons right away).
  (add-hook 'find-file-hook #'denote-link-buttonize-buffer)

  ;; We use different ways to specify a path for demo purposes.
  (setq denote-dired-directories
        (list denote-directory
              (thread-last denote-directory (expand-file-name "attachments"))
              (expand-file-name "~/Documents/books")))

  ;; Generic (great if you rename files Denote-style in lots of places):
  (add-hook 'dired-mode-hook #'denote-dired-mode)
  ;;
  ;; OR if only want it in `denote-dired-directories':
  ;; (add-hook 'dired-mode-hook #'denote-dired-mode-in-directories)

  ;; Here is a custom, user-level command from one of the examples we
  ;; show in this manual.  We define it here and add it to a key binding
  ;; below.  The manual: <https://protesilaos.com/emacs/denote>.
  (defun prot/denote-journal ()
    "Create an entry tagged 'journal', while prompting for a title."
    (interactive)
    (denote
     (denote--title-prompt)
     '("journal")))

  ;; Denote DOES NOT define any key bindings.  This is for the user to
  ;; decide.  For example:
  (let ((map global-map))
    (define-key map (kbd "C-c n j") #'prot/denote-journal)
    (define-key map (kbd "C-c n n") #'denote)
    (define-key map (kbd "C-c n N") #'denote-type)
    (define-key map (kbd "C-c n d") #'denote-date)
    (define-key map (kbd "C-c n s") #'denote-subdirectory)
    ;; If you intend to use Denote with a variety of file types, it is
    ;; easier to bind the link-related commands to the `global-map', as
    ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
    ;; `markdown-mode-map', and/or `text-mode-map'.
    (define-key map (kbd "C-c n i") #'denote-link) ; "insert" mnemonic
    (define-key map (kbd "C-c n I") #'denote-link-add-links)
    (define-key map (kbd "C-c n l") #'denote-link-find-file) ; "list" links
    (define-key map (kbd "C-c n b") #'denote-link-backlinks)
    ;; Note that `denote-rename-file' can work from any context, not
    ;; just Dired buffers.  That is why we bind it here to the
    ;; `global-map'.
    (define-key map (kbd "C-c n r") #'denote-rename-file))

  ;; Key bindings specifically for Dired.
  (let ((map dired-mode-map))
    (define-key map (kbd "C-c C-d C-i") #'denote-link-dired-marked-notes)
    (define-key map (kbd "C-c C-d C-r") #'denote-dired-rename-marked-files))

  (with-eval-after-load 'org-capture
    (setq denote-org-capture-specifiers "%l\n%i\n%?")
    (add-to-list 'org-capture-templates
                 '("n" "New note (with denote.el)" plain
                   (file denote-last-path)
                   #'denote-org-capture
                   :no-save t
                   :immediate-finish nil
                   :kill-buffer t
                   :jump-to-captured t))))

;;; Custom extensions for "focus mode" (logos.el)
;; Read the manual: <https://protesilaos.com/emacs/logos>.
(use-package! olivetti
  :config
  (setq olivetti-body-width 0.7)
  (setq olivetti-minimum-body-width 80)
  (setq olivetti-recall-visual-line-mode-entry-state t))

(use-package! logos
  :config
  (setq logos-outlines-are-pages t)
  (setq logos-outline-regexp-alist
        `((emacs-lisp-mode . ,(format "\\(^;;;+ \\|%s\\)" logos--page-delimiter))
          (org-mode . ,(format "\\(^\\*+ +\\|^-\\{5\\}$\\|%s\\)" logos--page-delimiter))
          (markdown-mode . ,(format "\\(^\\#+ +\\|^[*-]\\{5\\}$\\|^\\* \\* \\*$\\|%s\\)" logos--page-delimiter))
          (conf-toml-mode . "^\\[")
          (t . ,(or outline-regexp logos--page-delimiter))))

  ;; These apply when `logos-focus-mode' is enabled.  Their value is
  ;; buffer-local.
  (setq-default logos-hide-mode-line t)
  (setq-default logos-hide-buffer-boundaries t)
  (setq-default logos-hide-fringe t)
  (setq-default logos-variable-pitch t) ; see my `fontaine' configurations
  (setq-default logos-buffer-read-only nil)
  (setq-default logos-scroll-lock nil)
  (setq-default logos-olivetti t)

  ;; I don't need to do `with-eval-after-load' for the `modus-themes' as
  ;; I always load them before other relevant potentially packages.
  (add-hook 'modus-themes-after-load-theme-hook #'logos-update-fringe-in-buffers)

  (let ((map global-map))
    (define-key map [remap narrow-to-region] #'logos-narrow-dwim)
    (define-key map [remap forward-page] #'logos-forward-page-dwim)
    (define-key map [remap backward-page] #'logos-backward-page-dwim)
    ;; I don't think I ever saw a package bind M-] or M-[...
    (define-key map (kbd "M-]") #'logos-forward-page-dwim)
    (define-key map (kbd "M-[") #'logos-backward-page-dwim)
    (define-key map (kbd "<f9>") #'logos-focus-mode))

;;;; Extra tweaks
  ;; place point at the top when changing pages, but not in `prog-mode'
  (defun prot/logos--recenter-top ()
    "Use `recenter' to reposition the view at the top."
    (unless (derived-mode-p 'prog-mode)
      (recenter 1))) ; Use 0 for the absolute top

  (add-hook 'logos-page-motion-hook #'prot/logos--recenter-top))

;;; Emoji input
;; (use-package! emoji
;;   :config
;;   (defun prot/emoji-insert (&optional transient)
;;     "Thin wrapper for `emoji-insert' and `emoji-search'.
;; When called with optional TRANSIENT as a prefix argument, use the
;; transient interface (transient.el), else pick an emoji with
;; minibuffer completion."
;;     (interactive "P")
;;     (let ((cmd (if transient 'emoji-insert 'emoji-search)))
;;       (call-interactively cmd)))

  ;; The default key bindings for Emoji are behind the C-x 8 e prefix.
  ;; (define-key global-map (kbd "C-.") #'prot/emoji-insert))

(provide 'prot-emacs-write)

#+end_src

#+RESULTS:
: prot-emacs-write

* Some helper macros

 There are a few handy macros added by doom, namely
 - ~load!~ for loading external ~.el~ files relative to this one
 - ~use-package!~ for configuring packages
 - ~add-load-path!~ for adding directories to the ~load-path~ where ~Emacs~ looks when
   you load packages

#+begin_src emacs-lisp :tangle no

    (setq prettify-symbols-alist '(("lambda" . ?λ)
                                    ("->" . ?→)
                                    ("->>" . ?↠)
                                    ("=>" . ?⇒)
                                    ("/=" . ?≠)
                                    ("!=" . ?≠)
                                    ("==" . ?≡)
                                    ("<=" . ?≤)
                                    (">=" . ?≥)))
#+end_src

* deft
#+begin_src emacs-lisp :tangle no
(use-package deft
  :commands deft
  :init
  (setq deft-default-extension "org"
        ;; de-couples filename and note title:
        deft-use-filename-as-title nil
        deft-use-filter-string-for-filename t
        ;; disable auto-save
        deft-auto-save-interval -1.0
        ;; converts the filter string into a readable file-name using kebab-case:
        deft-file-naming-rules
        '((noslash . "-")
          (nospace . "-")
          (case-fn . downcase)))
  :config
  (add-to-list 'deft-extensions "tex")
  )

#+end_src
